(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.OakStreaming = require('./OakStreaming');
window.http = require('http');
window.WebTorrent = require('webtorrent');


document.body = document.createElement("body");

var para = document.createElement("video");
para.id = "myVideo";
para.style.display = "none";
document.body.appendChild(para);

para = document.createElement("p");
para.id = "WebTorrent-received";
para.style.display = "none";
document.body.appendChild(para);

window.myStreamingA = new OakStreaming("myStreamingA");
window.myStreamingB = new OakStreaming("myStreamingB");
window.myStreamingC = new OakStreaming("myStreamingC");
},{"./OakStreaming":2,"http":99,"webtorrent":130}],2:[function(require,module,exports){
var http = require('http');
var MultiStream = require('multistream');
var util = require('util');
var readableStream = require('readable-stream');
var Videostream = require('videostream');
var ut_pex = require('ut_pex');
var WebTorrent = require('webtorrent');
var SimplePeer = require('simple-peer');
var parseTorrent = require('parse-torrent');


 /**
 * @module FVSL
 */
module.exports = FVSL;


 /**
 * Creates a new FVSL instance which has the methods streamVideo, loadVideo, createSignalingData, createSignalingDataResponse, processSignalingResponse and several simple get methods  
 * @constructor
 */ 
function FVSL(OakName){
   var self = this;
   (function(){
      var peerId = Math.floor(Math.random() * Math.pow(10,300) + 1);   
      console.log("Version: Headhunter   In OakStreaming constructor. this.name: " + OakName);
      var OakName = OakName || "NoName FVSL instance";
      
      // Only methods should be part of the API, i.e. only methods should be publically accessible.
      // Every method should have access to these variables. Therefore they are definied at this high scope.
      var simplePeerCreationCounter = 0;
      var connectionsWaitingForSignalingData = [];
      var theTorrent = null;
      var peersToAdd = [];
      var bytesReceivedFromServer = 0;
      var notificationsBecauseNewWires = 0;
      var SIZE_OF_VIDEO_FILE = -42;
      
      self.streamVideo = streamVideo;
      self.loadVideo = loadVideo;
      self.forTesting_connectedToNewWebTorrentPeer = null;
                
      self.getNumberOfBytesDownloadedFromServer = function(){
         return bytesReceivedFromServer;
      };
      
      self.getNumberOfBystesDownloadedP2P = function(){
         if(theTorrent){
            return theTorrent.downloaded;
         } else {
            return 0;
         }
      };
      
      self.getNumberOfBytesUploadedP2P = function(){
         if(theTorrent){
            return theTorrent.uploaded;
         } else {
            return 0;
         }
      };
      
      self.getPercentageDownloadedTorrent = function(){
         if(theTorrent){
            return theTorrent.progress;
         } else {
            return 0;
         }
      };
      
      self.getFileSize = function(){
         return SIZE_OF_VIDEO_FILE;
      };
      
      self.createSignalingData = function (callback){
         var alreadyCalledCallback = false;
         var oakNumber = simplePeerCreationCounter;
         console.log("In createSignalingData for oakNumber: " + oakNumber);
         connectionsWaitingForSignalingData[oakNumber] = new SimplePeer({initiator: true, tickle: false});
         simplePeerCreationCounter++;
         
         connectionsWaitingForSignalingData[oakNumber].on('signal', function (signalingData){
            if(!alreadyCalledCallback){
               alreadyCalledCallback = true;
               signalingData.oakNumber = oakNumber;
               callback(signalingData);
            }
         });
      };
      
      self.createSignalingDataResponse = function (signalingData, callback){
         var oakNumber = signalingData.oakNumber;
         console.log("In createSignalingDataResponse. In the beginning oakNumber: " + oakNumber);
         delete signalingData.oakNumber;
         
         var myPeer = new SimplePeer({initiator: false, tickle: false});
         var index = simplePeerCreationCounter;
         connectionsWaitingForSignalingData[index] = myPeer;
         simplePeerCreationCounter++;
         
         myPeer.on('signal', function (answerSignalingData){
            console.log("In createSignalingDataResponse, after onSignal oakNumber: " + oakNumber);
            answerSignalingData.oakNumber = oakNumber;
            console.log("In createSignalingDataResponse,  object that is returned with callback: " + JSON.stringify(answerSignalingData));
            callback(answerSignalingData);
         });
         myPeer.signal(signalingData);
         
         var self = this;
         myPeer.on('connect', function(){
            self.addSimplePeerInstance(connectionsWaitingForSignalingData[index], {}, function(){console.log("addSimplePeerInstance ended");});
         });
      };
      
      self.processSignalingResponse = function (signalingData, callback){
         console.log("In processSignalingResponse,  signalingData paramter: " + JSON.stringify(signalingData));
         var oakNumber = signalingData.oakNumber;
         delete signalingData.oakNumber;
         console.log("In processSignalingResponse,  oakNumber: " + oakNumber);
         console.log("connectionsWaitingForSignalingData: " + connectionsWaitingForSignalingData);
         var self = this;
         (connectionsWaitingForSignalingData[oakNumber]).on('connect', function (){
            console.log('Established a simple-peer connection');
            self.addSimplePeerInstance(connectionsWaitingForSignalingData[oakNumber]);
            connectionsWaitingForSignalingData[oakNumber] = undefined;
            callback();
         });
         console.log("In processSignalingResponse,  object that is passed to .signal(): " + JSON.stringify(signalingData));
         connectionsWaitingForSignalingData[oakNumber].signal(signalingData);
      };
       
       /**
       * @typedef StreamInformationObject
       * @type {object}
       * @property {number} video_file_size - The size in byte of the video file that was passed as an argument.
       */
       
      /**
       * @callback OakStreaming~streamVideoFinished
       * @param {StreamInformationObject} streamInformationObject - An object that other clients/peers can pass as an argument to their loadVideo method to download the video from other clients/peers and/or a Web Server.
       */ 

      /**
       * Streams a video file to all other clients/peers.
       * @param {object} video_file - The video file that should be streamed to the other clients/peers. This paramter can either be a {@link https://developer.mozilla.org/en-US/docs/Web/API/File |W3C File object}, a {@link https://developer.mozilla.org/en-US/docs/Web/API/FileList |W3C FileList}, a {@link https://nodejs.org/api/buffer.html |Node Buffer object} or a {@link https://nodejs.org/api/stream.html#stream_class_stream_readable |Readable stream object}.
       * @param {object} [options] - Options for the creation of the StreamInformationObject, that after its creation gets passed as an argument to the callback function.
       * @param {string} options.path_to_file_on_XHR_server - The path that will be used for the XML HTTP Request (XHR). A valid path would be, for example, "/videos/aVideoFile.mp4". It is not necessary to set both the pathToFileOnXHRServer and the hashValue paramter for successfull XHR requests. If this property and the hashValue property is undefined, no video data will be requested from the server.
       * @param {string} options.hash_value - Hash value of the video file that should by requested from the SVSL WebServer. It is not necessary to set both the pathToFileOnXHRServer and the hashValue paramter for successfull XHR requests. If this property and the hashValue property is undefined, no video data will be requested from the server. 
       * @param {string} options.XHR_server_URL - URL of a XHR server that can serve the video file. If this property is not set, XHR will be send to the Web server that served the Web page.
       * @param {number} options.XHR_port - Port that will be used when communicating with the XHR server that was specified in the XHRServerURL property. This property should only be set when the XHRServerURL property is set too. The default value is 80.
       * @param {number} options.download_from_p2p_time_range - How many seconds of video playback must be buffered in advance such that no more data streams are requested from the WebTorrent network. The default value is 20 (seconds).
       * @param {number} options.create_readStream_request_size - The size of the byte range requests to the WebTorrent network. The default value is 5000000 (bytes).
       * @param {number} options.download_from_server_time_range - How many seconds of video playback must be buffered in advance such that no more data is requested from the XHR server. The default value is 5 (seconds).
       * @param {number} options.peer_upload_limit_multiplier - The FVSL client will severly throttle the video data upload to other peers when (bytes_uploaded_to_other_peers * peer_upload_limit_multiplier + peer_upload_limit_addition >=  bytes_downloaded_from_other_peers) and stop the throtting as soon as this inequality is no longer true. The default value for peer_upload_limit_multiplier is 2.
       * @param {number} options.peer_upload_limit_addition - The FVSL client will severly throttle the video data upload to other peers when (bytes_uploaded_to_other_peers * peer_upload_limit_multiplier + peer_upload_limit_addition >=  bytes_downloaded_from_other_peers) and stop the throtting as soon as this inequality is no longer true. the default value for peer_upload_limit_addition is 500000 (byte).
       * @param {OakStreaming~streamVideoFinished} callback - This callback function gets called with the generated StreamInformationObject at the end of the execution of streamVideo.
       */
      function streamVideo(video_file, options, callback, returnTorrent, destroyTorrent){ 
         var webTorrentClient = new WebTorrent();
         //console.log("streamVideo is executed");
         //console.log("videoFile: " + videoFile);
         //console.log("options: " + options);
         //console.log("callback: " + callback);         
          
         var streamInformationObject = options
             
         if(video_file){
            var seedingOptions = {};
            seedingOptions.announceList = options.webTorrentTrackers;

            var self = this; 
            webTorrentClient.seed(video_file, seedingOptions, function(torrent){
               console.log("torrent file is seeded");
               
               /* K42 Maybe I will need this later
               var torrentFileAsBlobURL = torrent.torrentFileBlobURL;
               var xhr = new XMLHttpRequest();
               var XHROrMethodEndHappend = false;
               xhr.open('GET', torrentFileAsBlobURL, true);
               xhr.responseType = 'blob';
               xhr.onload = function(e) {
                 if (this.status == 200) {
                   streamInformationObject.torrentAsBlob = this.response;
                   if(XHROrMethodEndHappend){
                      callback(streamInformationObject);
                   } else {
                      XHROrMethodEndHappend = true;
                   }
                 }
               };
               xhr.send();
               */
               
               streamInformationObject.size_of_video_file = torrent.files[0].length;
               streamInformationObject.magnetURI = torrent.magnetURI;
               streamInformationObject.infoHash = torrent.infoHash;
               // streamInformationObject.parsedTorrent =  parseTorrent(torrent.torrentFile); // K42
               // var bufferTorrent = parseTorrent(streamInformationObject.parsedTorrent); K42
              
               
               console.log("In streamVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
               // This function calls the callback function when this FVSL instance already connected to another peer or as soon as it connects to another peer.
               self.forTesting_connectedToNewWebTorrentPeer = function(callback){
                  console.log("In streamVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets executed");
                  if(notificationsBecauseNewWires <= 0){
                     notificationsBecauseNewWires--;
                     var callbackCalled = false;
                     
                     torrent.on('wire', function(wire){
                        if(!callbackCalled){
                           callback();
                           callbackCalled = true;
                        }
                     });
                  } else {
                     notificationsBecauseNewWires--;            
                     callback();
                  }
               };
               
               // This is necessary such that the forTesting_connectedToNewWebTorrentPeer function knows how many peers already connected to this FVSL instance.
               torrent.on('wire', function (wire){
                  notificationsBecauseNewWires++;  
               });          
                        
               console.log("Creaded streamInformationObject:\n" + JSON.stringify(streamInformationObject));
               
               // For some Jasmine tests it is appropriate that the torrent gets destroyed immediately after the streamInformationObject has been created. The destruction of the torrent stops the seeding.
               if(returnTorrent === "It's a test"){
                  if(destroyTorrent){
                     notificationsBecauseNewWires = 0;
                     torrent.destroy();
                     delete webTorrentClient;
                  }
                  callback(streamInformationObject, torrent);
               } else {
                  callback(streamInformationObject);
                  return streamInformationObject;
               }
            });
         } else {
            callback(streamInformationObject);
            /* K42
            if(XHROrMethodEndHappend){
               callback(streamInformationObject);
            } else {
                XHROrMethodEndHappend = true;
            }
            */
         }  
      }


      /**
       * @callback OakStreaming~loadedVideoFinished
       */ 
       
      /**
       * Streams a video file to all other clients/peers.
       * @param {StreamInformationObject} streamInformationObject - This object contains all data that is needed to initiate loading the video from other peers and/or a Web server. StreamInformationObjects can be created by the {@link streamVideo|streamVideo} method.
       * @param {OakStreaming~loadedVideoFinished} callback - This callback gets called when the video has been loaded entirely into the buffer of the video player.
       */
      function loadVideo(streamInformationObject, callback, endIfVideoLoaded){         
         console.log("loadVideo is called");
         //////console.log("option paramter:\n" + JSON.stringify(streamInformationObject));
         var deliveryByServer = (streamInformationObject.pathToFileOnXHRServer || streamInformationObject.hashValue) ? true : false;
         var deliveryByWebtorrent = streamInformationObject.parsedTorrent ? true : false;
         var XHRServerURL = streamInformationObject.XHRServerURL || false;
         //console.log("streamInformationObject.XHRServerURL: " + streamInformationObject.XHRServerURL);
         var XHR_PORT = streamInformationObject.XHRPort || 80;
         var pathToFileOnXHRServer = streamInformationObject.pathToFileOnXHRServer;       
         var hashValue = streamInformationObject.hashValue;
         var webTorrentTrackers = streamInformationObject.webTorrentTrackers;
         //var deliveryByWebtorrent = streamInformationObject.magnetURI ? true : false;
         var MAGNET_URI = streamInformationObject.magnetURI;
         //console.log("Buffer.isBuffer(streamInformationObject.torrentFile.data): " + Buffer.isBuffer(streamInformationObject.torrentFile.data));
         //console.log("streamInformationObject.torrentFile:\n" + JSON.stringify(streamInformationObject.torrentFile));
         var THE_RECEIVED_TORRENT_FILE = streamInformationObject.parsedTorrent;
         
         //console.log("THE_RECEIVED_TORRENT_FILE:\n" + JSON.stringify(THE_RECEIVED_TORRENT_FILE));
         //console.log("Buffer.isBuffer(THE_RECEIVED_TORRENT_FILE): " + Buffer.isBuffer(THE_RECEIVED_TORRENT_FILE));
         
         //console.log("THE_RECEIVED_TORRENT_FILE\n" + parseTorrent(THE_RECEIVED_TORRENT_FILE));
         //var SIZE_OF_VIDEO_FILE = streamInformationObject.sizeOfVideoFile;
         var SIZE_OF_VIDEO_FILE = streamInformationObject.sizeOfVideoFile;

         var DOWNLOAD_FROM_P2P_TIME_RANGE = streamInformationObject.downloadFromP2PTimeRange || 20; // how much seconds must be buffered in advance such that no more data streams are requested from the P2P network                  Old Describtion: This is the minomum byte range that the WebTorrent client will download in advance (regarding the current playback position) with a sequential chunk selection strategy. This means the video buffer size in byte
         var CREATE_READSTREAM_REQUEST_SIZE = streamInformationObject.createReadstreamRequestSize || 50000000; // The size of the createReadstream WebTorrent requests in bytes. 
         
         var DOWNLOAD_FROM_SERVER_TIME_RANGE = streamInformationObject.downloadFromServerTimeRange || 5; // in seconds
         var UPLOAD_LIMIT = streamInformationObject.uploadLimit || 2; // multiplied by number of downloaded bytes
         var ADDITION_TO_UPLOAD_LIMIT = streamInformationObject.additionToUploadLimit || 500000; // amount of byte added to upload limit
         
         
         var XHR_REQUEST_SIZE = streamInformationObject.xhrRequestSize || 50000; // in byte
         var THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM = streamInformationObject.thresholdForReturningAnswerStream || 50000; // in byte

         var CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL = streamInformationObject.checkIfBufferFullEnoughInterval || 300; // in miliseconds
         var CHECK_IF_ANSWERSTREAM_READY_INTERVAL = streamInformationObject.checkIfAnswerstreamReadyInterval || 200; // in miliseconds
         var UPDATE_CHART_INTERVAL = streamInformationObject.updateChartInterval || 1000; // in miliseconds
         var CHOKE_IF_NECESSARY_INTERVAL = streamInformationObject.chokeIfNecessaryInterval || 500; // in miliseconds
         var CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL = streamInformationObject.checkIfNewCreateReadstreamInterval || 500 ;
         
         var self = this;
         var endStreaming = false;
         var webTorrentClient = null;
         var wires = [];
         var consoleCounter = 0;
         var globalvideostreamRequestNumber = 0;
         bytesReceivedFromServer = 0;
         var webTorrentFile;
         var videostreamRequestHandlers = [];
         var inCritical = true;
         var videoCompletelyLoaded = false;
         var bytesTakenFromWebTorrent = 0;
         var bytesTakenFromServer = 0;   
         
         
         var myVideo = document.querySelector('video');
         myVideo.addEventListener('error', function (err){
            console.error(myVideo.error);
         });
         
         function MyReadableStream(options){
            readableStream.Readable.call(this, options);
         }
         util.inherits(MyReadableStream, readableStream.Readable);
         MyReadableStream.prototype._read = function(size){};
         
        
         if(deliveryByWebtorrent){
            console.log("entered if(deliveryByWebtorrent)");
            webTorrentClient = new WebTorrent();
                
            //THE_RECEIVED_TORRENT_FILE 
           
            var webTorrentOptions = {};
            /* Weiß nicht mehr warum das hier steht
            if(streamInformationObject.pathToFileToSeed){
               webTorrentOptions.path = streamInformationObject.pathToFileToSeed;
            }
            */
            var url = URL.createObjectURL(streamInformationObject.torrentAsBlob);
            
            webTorrentClient.add(url, webTorrentOptions, function (torrent){              
               console.log("webTorrentClient.add   torrent meta data ready");         
               theTorrent = torrent;
               webTorrentFile = torrent.files[0];
               
               for(var j=0; j< peersToAdd.length; j++){
                  theTorrent.addPeer(peersToAdd[j][0]);
                  if(peersToAdd[j][1]){
                     (peersToAdd[j][1])();
                  }
               } 
                            
               //console.log("In loadVideo typeof webTorrentFile after assignment: " + typeof webTorrentFile);

               console.log("In loadVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
               self.forTesting_connectedToNewWebTorrentPeer = function(callback){
                  console.log("In loadVideo     " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer   gets called");
                  if(notificationsBecauseNewWires <= 0){
                     notificationsBecauseNewWires--;
                     var callbackCalled = false;
                     
                     torrent.on('wire', function(wire){
                        if(!callbackCalled){
                           callback();
                           callbackCalled = true;
                        }
                     });
                  } else {
                     notificationsBecauseNewWires--;            
                     callback();
                  }
               };
               
               torrent.on('wire', function (wire){
                  console.log("torrent.on('wire', ..) is fired");
                  wires.push(wire);
                  if(!window.firstWire){
                     window.firstWire = wire;
                  }
                  notificationsBecauseNewWires++;
                  
                  
                  wire.use(ut_pex());
                  //wire.ut_pex.start();
                  
                  /*
                  wire.ut_pex.on('peer', function (peer){
                     theTorrent.addPeer(peer);
                     // got a peer
                     // probably add it to peer connections queue
                  });
                  */
               });

               for(var i=0, length=videostreamRequestHandlers.length; i<length; i++){
                  var thisRequest = videostreamRequestHandlers[i];
                  if(thisRequest.currentCB !== null){
                     //console.log("In onTorrent nachträglich webtorrent stream erzeugen  thisRequest.start: " + thisRequest.start);
                     //console.log("In onTorrent  webTorrentFile.length: " + webTorrentFile.length);
                                 
                     var endCreateReadStream;
                     if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE > webTorrentFile.length-1){
                        endCreateReadStream = webTorrentFile.length-1;
                     } else {
                        endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                     }
                         
                     thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                     /*
                     thisRequest.on('end', function(){
                        if(thisRequest.currentCB !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < thisRequest.videoFileSize){
                           var endCreateReadStream;
                           if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                              endCreateReadStream = webTorrentFile.length-1;
                           } else {
                              endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                           }                
                           thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                           thisRequest.oldStartWebTorrent = thisRequest.start;
                           thisRequest.webTorrentStream.unpipe();
                           thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                        }             
                     });
                     */
                     thisRequest.oldStartWebTorrent = thisRequest.start;
                     thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                  }
               }
            });
         }
         
         
         
         var fileLikeObject = function (pathToFileOnXHRServer){
            this.pathToFileOnXHRServer = pathToFileOnXHRServer;
         };
         fileLikeObject.prototype.createReadStream = function (opts){
            if(opts.start > SIZE_OF_VIDEO_FILE){
               //console.log("opts.start > SIZE_OF_VIDEO_FILE there cb(null,null) every time");
               return (new MultiStream(function (cb){cb(null, null);}));
            }
            inCritical = true;
            //console.log(consoleCounter++ + " called createreadStream ");
            //console.log(consoleCounter++ + " opts.start: " + opts.start);
            //console.log(consoleCounter++ + " opts.end: " + opts.end);

            var thisRequest = new VideostreamRequestHandler(++globalvideostreamRequestNumber, opts, this);
           
            if(opts.end && !isNaN(opts.end)){
               thisRequest.end = opts.end + 1;
            } else {
               thisRequest.end = SIZE_OF_VIDEO_FILE;
            }
            
            var MyWriteableStream = function(highWaterMark){
               readableStream.Writable.call(this, highWaterMark);
            };
            util.inherits(MyWriteableStream, readableStream.Writable);
            MyWriteableStream.prototype._write = function(chunk, encoding, done){
               //console.log("MyWriteableStream _write is called");       
               if(thisRequest.start-thisRequest.oldStartWebTorrent < chunk.length){
                  ////////console.log("MyWriteableStream _write: pushing received data in answerStream")
                  bytesTakenFromWebTorrent += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
                  var streamHasMemoryLeft = thisRequest.answerStream.push(chunk.slice(thisRequest.start-thisRequest.oldStartWebTorrent, chunk.length));
                  thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
                  
                  if(streamHasMemoryLeft){            
                     if(thisRequest.currentCB !== null && thisRequest.start >= thisRequest.end){
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res);
                     }
                  } else {
                     if(thisRequest.currentCB === null){
                        if(thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                        thisRequest.noMoreData = true;
                     } else {
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res);
                     }
                  }
                     thisRequest.start += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
               }
               //ceckIfAnswerStreamReady(thisRequest);
               thisRequest.oldStartWebTorrent += chunk.length;
               done();
            };
            thisRequest.collectorStreamForWebtorrent = new MyWriteableStream({highWaterMark: 50000000});
            videostreamRequestHandlers.push(thisRequest);

            if(webTorrentFile && theTorrent.uploaded <= UPLOAD_LIMIT * theTorrent.downloaded + ADDITION_TO_UPLOAD_LIMIT){
               ////////console.log("after new videostreamRequest creating a corresponding webtorrent stream");
               ////console.log("opts.start: " + opts.start);
               ////console.log("webTorrentFile.length: " + webTorrentFile.length);
                
               var endCreateReadStream;
               if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                  endCreateReadStream = webTorrentFile.length-1;
               } else {
                  endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
               }
               thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
               thisRequest.lastEndCreateReadStream = endCreateReadStream;
               thisRequest.oldStartWebTorrent = thisRequest.start;
               
               thisRequest.webTorrentStream.unpipe();
               thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
            }

            var multi = new MultiStream(function (cb){
               //console.log("ReadableStream request number " + thisRequest.readStreamNumber + "    does a cb request");
              
               if(thisRequest.end >= 0 && thisRequest.start >= thisRequest.end){
                  //console.log("called cb(null,null) from " + thisRequest.readStreamNumber); 
                  thisRequest.req = null;
                  return cb(null, null);
               }
              
               thisRequest.CBNumber++;
               if(consoleCounter<20){
                  //////console.log(consoleCounter++ + "    " + thisRequest.CBNumber + ". call of function(cb) from " + videostreamRequestNumber);
                  ////////console.log(consoleCounter++ + "    start: " + thisRequest.start);
               }
               thisRequest.currentCB = cb;
               thisRequest.noMoreData = false;
            
               if(!ceckIfAnswerStreamReady(thisRequest)){
                  if(thisRequest.webTorrentStream){
                     thisRequest.webTorrentStream.resume();
                  } else if(webTorrentFile){
                     ////////console.log("New cb function was called and I subsequently create a new torrentStream for it because non existed before for this videostreamRequest");
                     ////console.log("After new Multistream. thisRequest.start: " + thisRequest.start);
                     ////console.log("webTorrentFile.length: " + webTorrentFile.length);
                     var endCreateReadStream;
                     if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                        endCreateReadStream = webTorrentFile.length-1;
                     } else {
                        endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                     }
                     thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                     thisRequest.lastEndCreateReadStream = endCreateReadStream;
                     thisRequest.oldStartWebTorrent = thisRequest.start;
                     
                     thisRequest.webTorrentStream.unpipe();
                     thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                  }

                  if(deliveryByServer && inCritical && !thisRequest.XHRConducted){
                     conductXHR(thisRequest);
                  }
               }
            });
            ////////console.log(consoleCounter++ + " terminate createReadStream");
            var destroy = multi.destroy;
            multi.destroy = function(){
               if (thisRequest.req) {
                  thisRequest.req.destroy();
               }
               destroy.call(multi);
            };
            return multi;
         };
        
         
            
         function frequentlyCheckIfNewCreateReadStreamNecessary(){
               if(videoCompletelyLoaded){
                  return;
               }        
               if(myVideo.duration){
                  var timeRanges = myVideo.buffered;          
                  for (var i = 0, length = timeRanges.length; i < length; i++){
                     if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)+3) {
                        if (timeRanges.end(i) - myVideo.currentTime <= DOWNLOAD_FROM_P2P_TIME_RANGE) {
                           for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
                              var thisRequest = videostreamRequestHandlers[i];
                              
                              if(thisRequest.currentCB !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < thisRequest.videoFileSize){
                                 var endCreateReadStream;
                                 if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                                    endCreateReadStream = webTorrentFile.length-1;
                                 } else {
                                    endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                                 }                
                                 thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                                 thisRequest.oldStartWebTorrent = thisRequest.start;
                                 thisRequest.webTorrentStream.unpipe();
                                 thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                              }
                           }
                        }
                     }
                  }
                  setTimeout(frequentlyCheckIfNewCreateReadStreamNecessary, CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL);
               }
            }   
         
         
         function ceckIfAnswerStreamReady(thisRequest){
            ////////console.log("At the beginning of thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream);
            ////////console.log("In ceckIfAnswerStreamReady of videostreamRequest number " + thisRequest.readStreamNumber +  ". thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream + "     thisRequest.currentCB: " + thisRequest.currentCB);
            if (thisRequest.currentCB && ((thisRequest.bytesInAnswerStream >= THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM) || (thisRequest.start >= SIZE_OF_VIDEO_FILE))){
               ////////console.log("answerStream from videostream Request number " + thisRequest.readStreamNumber + " and CB number " + thisRequest.CBNumber + " gets returned");
               // //////console.log("Returing answerStream out of ceckIfAnswerStreamReady()");
               var theCallbackFunction = thisRequest.currentCB;
               thisRequest.currentCB = null;
               thisRequest.answerStream.push(null);
               if (thisRequest.webTorrentStream){
                  thisRequest.webTorrentStream.pause();
               }
               thisRequest.bytesInAnswerStream = 0;
               var res = thisRequest.answerStream;
               thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
               //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
               theCallbackFunction(null, res);
               return true;
            }
            return false;
         }

         function chokeIfNecessary(){
               if (theTorrent && theTorrent.uploaded >= theTorrent.downloaded * UPLOAD_LIMIT + ADDITION_TO_UPLOAD_LIMIT) {
                  /* mache ich schon in einer anderen frequent methode
                  if(videoCompletelyLoaded){
                     theTorrent.destroy();
                     delete webTorrentClient;
                     endStreaming = true;
                     return;
                  }
                  */
                  for (var i = 0, length = wires.length; i < length; i++){
                     //console.log("I choked a peer");
                     wires[i].choke();
                  }
               }
               setTimeout(chokeIfNecessary, CHOKE_IF_NECESSARY_INTERVAL);
            }

         function updateChart(){
               if(endStreaming){
                  return;
               }
               if(theTorrent && webTorrentFile){
                  document.getElementById("WebTorrent-received").innerHTML = "webTorrentFile.length: " + webTorrentFile.length + "\n torrent.downloaded: " + theTorrent.downloaded + "\n torrent.uploaded: " + theTorrent.uploaded + "\n torrent.progress: " + theTorrent.progress + "\n Bytes received from server: " + bytesReceivedFromServer + "\n Bytes taken from server delivery: " + bytesTakenFromServer + "\n Bytes taken from WebTorrent delivery: " + bytesTakenFromWebTorrent;
               }
               setTimeout(updateChart, UPDATE_CHART_INTERVAL);
         }
          
         function VideostreamRequestHandler(readStreamNumber, opts, self) {
            this.readStreamNumber = readStreamNumber;
            this.opts = opts;
            this.start = opts.start || 0;
            this.oldStartWebTorrent = -42;
            this.oldStartServer = -42;
            this.currentCB = null;
            this.CBNumber = 0;
            this.webTorrentStream = null;
            this.answerStream = new MyReadableStream({highWaterMark: 5000000});
            this.bytesInAnswerStream = 0;
            this.collectorStreamForWebtorrent = null;
            this.XHRConducted = false;
            this.end = -42;
            this.self = self;
            this.bytesTakenFromWebTorrent = 0;
            this.bytesTakenFromServer = 0;
            this.noMoreData = false;
            this.req = null;
            this.lastEndCreateReadStream = -42;
         }

         function frequentlyCeckIfAnswerStreamReady(){
               if(videoCompletelyLoaded){
                  return;
               }
               for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
                  ceckIfAnswerStreamReady(videostreamRequestHandlers[i]);
               }
               setTimeout(frequentlyCeckIfAnswerStreamReady, CHECK_IF_ANSWERSTREAM_READY_INTERVAL);
         }

         function checkIfBufferFullEnough(){
               //console.log("checkIfBufferFullEnough is called");
               if(videoCompletelyLoaded){
                  return;
               }
               //console.log("video.duration: " + myVideo.duration);
               if(myVideo.duration){
                  var timeRanges = myVideo.buffered;
                  if(timeRanges.length >= 1){
                     //console.log("timeRanges.start(0): " + timeRanges.start(0));
                     //console.log("timeRanges.end(0): " + timeRanges.end(0));
                     
                     if(timeRanges.start(0) == 0 && timeRanges.end(0) == myVideo.duration){
                       // console.log("In checkIfBufferFullEnough: callback should be called");
                        videoCompletelyLoaded = true;
                        if(callback){
                           if(endIfVideoLoaded){
                              callback();
                           } else {
                              callback(theTorrent);
                           }
                        }
                        if(endIfVideoLoaded){
                           if(theTorrent){
                              theTorrent.destroy();
                              delete webTorrentClient;
                           }
                           endStreaming = true;
                           return;                 
                        } 
                     }
                  }
                  inCritical = true;              
                  for (var i = 0, length = timeRanges.length; i < length; i++) {
                     ////////console.log("Time range number " + i + ": start(" + timeRanges.start(i) + ") end(" + timeRanges.end(i) + ")");
                     if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)) {
                        if (timeRanges.end(i) - myVideo.currentTime >= DOWNLOAD_FROM_SERVER_TIME_RANGE) {
                           inCritical = false;
                           ////////console.log("I set inCritical to false");
                        }
                     }
                  }
                  if (deliveryByServer && inCritical) {
                     for (var j = 0, length = videostreamRequestHandlers.length; j < length; j++) {
                        if (videostreamRequestHandlers[j].currentCB !== null && videostreamRequestHandlers[j].XHRConducted === false) {
                           conductXHR(videostreamRequestHandlers[j]);
                        }
                     }
                  }
               }
               setTimeout(checkIfBufferFullEnough, CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL);
            }

         function conductXHR(thisRequest) {
            if(thisRequest.currentCB === null){
               return;
            }
            thisRequest.XHRConducted = true;
            var reqStart = thisRequest.start;
            var reqEnd = reqStart + XHR_REQUEST_SIZE;

            if (thisRequest.end >= 0 && reqEnd > thisRequest.end) {
               reqEnd = thisRequest.end;
            }
            if (reqStart >= reqEnd) {
               thisRequest.req = null;
               //console.log("called cb(null,null)");
               return thisRequest.currentCB(null, null);
            }

            /* glaube ich unnötiger und/oder gefährlicher müll
            if (reqStart >= reqEnd) {
            req = null;
            return thisRequest.currentCB(null, null);
            }
            */
            if (consoleCounter < 10000000) {
               //////////console.log(consoleCounter++ + "  videoStream " + thisRequest.readStreamNumber + "  CB number " + thisRequest.CBNumber + "    reqStart: " + reqStart);
               //////////console.log(consoleCounter++ + "  Multistream " + thisRequest.readStreamNumber + "   CB number " + thisRequest.CBNumber + "    reqEnd: " + reqEnd);
            }

            var XHRDataHandler = function (chunk){
               bytesReceivedFromServer += chunk.length;
               //console.log("ReadableStream request number " + thisRequest.readStreamNumber + " received a chunk of length " + chunk.length);
               if(thisRequest.noMoreData){
                  thisRequest.oldStartServer += chunk.length;
                  return;
               }
               if (thisRequest.start - thisRequest.oldStartServer < chunk.length){         
                  bytesTakenFromServer += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
                  thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
                  var myBuffer = chunk.slice(thisRequest.start - thisRequest.oldStartServer, chunk.length);
                  //console.log("In XHRDataHandler   myBuffer.length: " + myBuffer.length);
                  var StreamHasMemoryLeft = thisRequest.answerStream.push(myBuffer);         
                  if(!StreamHasMemoryLeft){
                     if(thisRequest.currentCB !== null){
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res); 
                     } else {
                        thisRequest.noMoreData = true;
                        if(thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                     }
                  } else {
                     if (thisRequest.start >= SIZE_OF_VIDEO_FILE && thisRequest.currentCB !== null){
                        var theCallbackFunction = thisRequest.currentCB;
                        thisRequest.currentCB = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                        theCallbackFunction(null, res);
                     }
                  } 
                  thisRequest.start += chunk.length - (thisRequest.start - thisRequest.oldStartServer);            
               }
               thisRequest.oldStartServer += chunk.length;
            }

            var XHREnd = function (){
               //console.log("ReadableStream request number " + thisRequest.readStreamNumber + " XHREnd");
               if (consoleCounter < 1000000000000){
                  //////////console.log("XHREnd from videostreamRequest number " + thisRequest.readStreamNumber);
               }
               if(thisRequest.bytesInAnswerStream > 0 && thisRequest.currentCB !== null){
                  thisRequest.answerStream.push(null);
                  thisRequest.bytesInAnswerStream = 0;
                  var res = thisRequest.answerStream;
                  thisRequest.answerStream = new MyReadableStream({highWaterMark: 5000000});
                  var theCallbackFunction = thisRequest.currentCB;
                  thisRequest.currentCB = null;
                  //console.log("XHREnd: called CB with data out of answerStream from videostreamRequest number " + thisRequest.readStreamNumber);
                  theCallbackFunction(null, res);
               }
               thisRequest.XHRConducted = false;
            }  
            
            thisRequest.oldStartServer = reqStart;
            
            //console.log("At htto.get   reqStart: " + reqStart + "     reqEnd: " + reqEnd);

                  
            var XHROptionObject = {
               path: thisRequest.self.pathToFileOnXHRServer,
               headers: {
                  range: 'bytes=' + reqStart + '-' + (reqEnd-1)
               }
            };
            if(XHRServerURL){
               XHROptionObject.hostname = XHRServerURL;
               XHROptionObject.port = XHR_PORT;
            }
            
            thisRequest.req = http.get(XHROptionObject, function (res){
                  var contentRange = res.headers['content-range'];
                  if (contentRange) {
                     thisRequest.fileSize = parseInt(contentRange.split('/')[1], 10);
                  }
                  //////////console.log("I return currentCB with http response stream");
                  ////////////console.log("function(res) is executed from readstream number " + createReadStreamCounter + " and CB number " + thisCBNumber);
                  res.on('end', XHREnd);
                  res.on('data', XHRDataHandler);
               }
            );
         }
         frequentlyCheckIfNewCreateReadStreamNecessary();
         chokeIfNecessary();
         updateChart();
         frequentlyCeckIfAnswerStreamReady();
         checkIfBufferFullEnough();

         //////console.log("I call Videostream constructor");
         if(hashValue){
            Videostream(new fileLikeObject(hashValue), myVideo);
         } else {
            Videostream(new fileLikeObject(pathToFileOnXHRServer), myVideo);
         }
      }


      function addSimplePeerInstance(simplePeerInstance, options, callback){
         // The method add a simplePeer to the WebTorrent swarm instance
         if(theTorrent){
            if(theTorrent.infoHash){
               theTorrent.addPeer(simplePeerInstance);
               if(callback){
                  callback();
               }
            } else {
               theTorrent.on('infoHash', function() {theTorrent.addPeer(simplePeerInstance); if(callback){callback()}});
            }
         } else {
            var pair = [];
            pair.push(simplePeerInstance);
            pair.push(callback);
            peersToAdd.push(pair);
         }
      }
   })();
}
},{"http":99,"multistream":61,"parse-torrent":69,"readable-stream":86,"simple-peer":95,"ut_pex":120,"util":127,"videostream":129,"webtorrent":130}],3:[function(require,module,exports){
var ADDR_RE = /^\[?([^\]]+)\]?:(\d+)$/ // ipv4/ipv6/hostname + port

var cache = {}

// reset cache when it gets to 100,000 elements (~ 600KB of ipv4 addresses)
// so it will not grow to consume all memory in long-running processes
var size = 0

module.exports = function addrToIPPort (addr) {
  if (size === 100000) module.exports.reset()
  if (!cache[addr]) {
    var m = ADDR_RE.exec(addr)
    if (!m) throw new Error('invalid addr: ' + addr)
    cache[addr] = [ m[1], Number(m[2]) ]
    size += 1
  }
  return cache[addr]
}

module.exports.reset = function reset () {
  cache = {}
  size = 0
}

},{}],4:[function(require,module,exports){
'use strict'

exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(require,module,exports){
(function (Buffer){
/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode (data, start, end, encoding) {
  if (typeof start !== 'number' && encoding == null) {
    encoding = start
    start = undefined
  }

  if (typeof end !== 'number' && encoding == null) {
    encoding = end
    end = undefined
  }

  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !(Buffer.isBuffer(data))
    ? new Buffer(data)
    : data.slice(start, end)

  decode.bytes = decode.data.length

  return decode.next()
}

decode.bytes = 0
decode.position = 0
decode.data = null
decode.encoding = null

decode.next = function () {
  switch (decode.data[decode.position]) {
    case 0x64:
      return decode.dictionary()
    case 0x6C:
      return decode.list()
    case 0x69:
      return decode.integer()
    default:
      return decode.buffer()
  }
}

decode.find = function (chr) {
  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while (i < c) {
    if (d[i] === chr) return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode(chr) + '" [0x' +
    chr.toString(16) + ']'
  )
}

decode.dictionary = function () {
  decode.position++

  var dict = {}

  while (decode.data[decode.position] !== 0x65) {
    dict[decode.buffer()] = decode.next()
  }

  decode.position++

  return dict
}

decode.list = function () {
  decode.position++

  var lst = []

  while (decode.data[decode.position] !== 0x65) {
    lst.push(decode.next())
  }

  decode.position++

  return lst
}

decode.integer = function () {
  var end = decode.find(0x65)
  var number = decode.data.toString('ascii', decode.position + 1, end)

  decode.position += end + 1 - decode.position

  return parseInt(number, 10)
}

decode.buffer = function () {
  var sep = decode.find(0x3A)
  var length = parseInt(decode.data.toString('ascii', decode.position, sep), 10)
  var end = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString(decode.encoding, sep, end)
    : decode.data.slice(sep, end)
}

module.exports = decode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],6:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode (data, buffer, offset) {
  var buffers = []
  var result = null

  encode._encode(buffers, data)
  result = Buffer.concat(buffers)
  encode.bytes = result.length

  if (Buffer.isBuffer(buffer)) {
    result.copy(buffer, offset)
    return buffer
  }

  return result
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function (buffers, data) {
  if (Buffer.isBuffer(data)) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return
  }

  switch (typeof data) {
    case 'string':
      encode.buffer(buffers, data)
      break
    case 'number':
      encode.number(buffers, data)
      break
    case 'object':
      data.constructor === Array
        ? encode.list(buffers, data)
        : encode.dict(buffers, data)
      break
    case 'boolean':
      encode.number(buffers, data ? 1 : 0)
      break
  }
}

var buffE = new Buffer('e')
var buffD = new Buffer('d')
var buffL = new Buffer('l')

encode.buffer = function (buffers, data) {
  buffers.push(new Buffer(Buffer.byteLength(data) + ':' + data))
}

encode.number = function (buffers, data) {
  var maxLo = 0x80000000
  var hi = (data / maxLo) << 0
  var lo = (data % maxLo) << 0
  var val = hi * maxLo + lo

  buffers.push(new Buffer('i' + val + 'e'))

  if (val !== data && !encode._floatConversionDetected) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "' + data + '":',
      'Bencoding only defines support for integers, value was converted to "' + val + '"'
    )
    console.trace()
  }
}

encode.dict = function (buffers, data) {
  buffers.push(buffD)

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys(data).sort()
  var kl = keys.length

  for (; j < kl; j++) {
    k = keys[j]
    encode.buffer(buffers, k)
    encode._encode(buffers, data[k])
  }

  buffers.push(buffE)
}

encode.list = function (buffers, data) {
  var i = 0
  var c = data.length
  buffers.push(buffL)

  for (; i < c; i++) {
    encode._encode(buffers, data[i])
  }

  buffers.push(buffE)
}

module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],7:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require('./encode')
bencode.decode = require('./decode')

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function (value) {
  return bencode.encode(value).length
}

},{"./decode":5,"./encode":6}],8:[function(require,module,exports){
module.exports = function(haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low < 0 || low >= haystack.length)
      throw new RangeError("invalid lower bound");
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high < low || high >= haystack.length)
      throw new RangeError("invalid upper bound");
  }

  while(low <= high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle, mid, haystack);

    /* Too low. */
    if(cmp < 0.0)
      low  = mid + 1;

    /* Too high. */
    else if(cmp > 0.0)
      high = mid - 1;

    /* Key found. */
    else
      return mid;
  }

  /* Key not found. */
  return ~low;
}

},{}],9:[function(require,module,exports){
(function (Buffer){
var Container = typeof Buffer !== "undefined" ? Buffer //in node, use buffers
		: typeof Int8Array !== "undefined" ? Int8Array //in newer browsers, use webgl int8arrays
		: function(l){ var a = new Array(l); for(var i = 0; i < l; i++) a[i]=0; }; //else, do something similar

function BitField(data, opts){
	if(!(this instanceof BitField)) {
		return new BitField(data, opts);
	}

	if(arguments.length === 0){
		data = 0;
	}

	this.grow = opts && (isFinite(opts.grow) && getByteSize(opts.grow) || opts.grow) || 0;

	if(typeof data === "number" || data === undefined){
		data = new Container(getByteSize(data));
		if(data.fill && !data._isBuffer) data.fill(0); // clear node buffers of garbage
	}
	this.buffer = data;
}

function getByteSize(num){
	var out = num >> 3;
	if(num % 8 !== 0) out++;
	return out;
}

BitField.prototype.get = function(i){
	var j = i >> 3;
	return (j < this.buffer.length) &&
		!!(this.buffer[j] & (128 >> (i % 8)));
};

BitField.prototype.set = function(i, b){
	var j = i >> 3;
	if (b || arguments.length === 1){
		if (this.buffer.length < j + 1) this._grow(Math.max(j + 1, Math.min(2 * this.buffer.length, this.grow)));
		// Set
		this.buffer[j] |= 128 >> (i % 8);
	} else if (j < this.buffer.length) {
		/// Clear
		this.buffer[j] &= ~(128 >> (i % 8));
	}
};

BitField.prototype._grow = function(length) {
	if (this.buffer.length < length && length <= this.grow) {
		var newBuffer = new Container(length);
		if (newBuffer.fill) newBuffer.fill(0);
		if (this.buffer.copy) this.buffer.copy(newBuffer, 0);
		else {
			for(var i = 0; i < this.buffer.length; i++) {
				newBuffer[i] = this.buffer[i];
			}
		}
		this.buffer = newBuffer;
	}
};

if(typeof module !== "undefined") module.exports = BitField;

}).call(this,require("buffer").Buffer)

},{"buffer":20}],10:[function(require,module,exports){
module.exports = Wire

var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-protocol')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var speedometer = require('speedometer')
var stream = require('readable-stream')

var BITFIELD_GROW = 400000
var KEEP_ALIVE_TIMEOUT = 55000

var MESSAGE_PROTOCOL = Buffer.from('\u0013BitTorrent protocol')
var MESSAGE_KEEP_ALIVE = Buffer.from([0x00, 0x00, 0x00, 0x00])
var MESSAGE_CHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x00])
var MESSAGE_UNCHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x01])
var MESSAGE_INTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x02])
var MESSAGE_UNINTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x03])

var MESSAGE_RESERVED = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
var MESSAGE_PORT = [0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00]

function Request (piece, offset, length, callback) {
  this.piece = piece
  this.offset = offset
  this.length = length
  this.callback = callback
}

inherits(Wire, stream.Duplex)

function Wire () {
  if (!(this instanceof Wire)) return new Wire()
  stream.Duplex.call(this)

  this._debugId = hat(32)
  this._debug('new wire')

  this.peerId = null // remote peer id (hex string)
  this.peerIdBuffer = null // remote peer id (buffer)
  this.type = null // connection type ('webrtc', 'tcpIncoming', 'tcpOutgoing', 'webSeed')

  this.amChoking = true // are we choking the peer?
  this.amInterested = false // are we interested in the peer?

  this.peerChoking = true // is the peer choking us?
  this.peerInterested = false // is the peer interested in us?

  // The largest torrent that I know of (the Geocities archive) is ~641 GB and has
  // ~41,000 pieces. Therefore, cap bitfield to 10x larger (400,000 bits) to support all
  // possible torrents but prevent malicious peers from growing bitfield to fill memory.
  this.peerPieces = new BitField(0, { grow: BITFIELD_GROW })

  this.peerExtensions = {}

  this.requests = [] // outgoing
  this.peerRequests = [] // incoming

  this.extendedMapping = {} // number -> string, ex: 1 -> 'ut_metadata'
  this.peerExtendedMapping = {} // string -> number, ex: 9 -> 'ut_metadata'

  // The extended handshake to send, minus the "m" field, which gets automatically
  // filled from `this.extendedMapping`
  this.extendedHandshake = {}

  this.peerExtendedHandshake = {} // remote peer's extended handshake

  this._ext = {}  // string -> function, ex 'ut_metadata' -> ut_metadata()
  this._nextExt = 1

  this.uploaded = 0
  this.downloaded = 0
  this.uploadSpeed = speedometer()
  this.downloadSpeed = speedometer()

  this._keepAliveInterval = null
  this._timeout = null
  this._timeoutMs = 0

  this.destroyed = false // was the wire ended by calling `destroy`?
  this._finished = false

  this._parserSize = 0 // number of needed bytes to parse next message from remote peer
  this._parser = null // function to call once `this._parserSize` bytes are available

  this._buffer = [] // incomplete message data
  this._bufferSize = 0 // cached total length of buffers in `this._buffer`

  this.on('finish', this._onFinish)

  this._parseHandshake()
}

/**
 * Set whether to send a "keep-alive" ping (sent every 55s)
 * @param {boolean} enable
 */
Wire.prototype.setKeepAlive = function (enable) {
  var self = this
  self._debug('setKeepAlive %s', enable)
  clearInterval(self._keepAliveInterval)
  if (enable === false) return
  self._keepAliveInterval = setInterval(function () {
    self.keepAlive()
  }, KEEP_ALIVE_TIMEOUT)
}

/**
 * Set the amount of time to wait before considering a request to be "timed out"
 * @param {number} ms
 * @param {boolean=} unref (should the timer be unref'd? default: false)
 */
Wire.prototype.setTimeout = function (ms, unref) {
  this._debug('setTimeout ms=%d unref=%s', ms, unref)
  this._clearTimeout()
  this._timeoutMs = ms
  this._timeoutUnref = !!unref
  this._updateTimeout()
}

Wire.prototype.destroy = function () {
  if (this.destroyed) return
  this.destroyed = true
  this._debug('destroy')
  this.emit('close')
  this.end()
}

Wire.prototype.end = function () {
  this._debug('end')
  this._onUninterested()
  this._onChoke()
  stream.Duplex.prototype.end.apply(this, arguments)
}

/**
 * Use the specified protocol extension.
 * @param  {function} Extension
 */
Wire.prototype.use = function (Extension) {
  var name = Extension.prototype.name
  if (!name) {
    throw new Error('Extension class requires a "name" property on the prototype')
  }
  this._debug('use extension.name=%s', name)

  var ext = this._nextExt
  var handler = new Extension(this)

  function noop () {}

  if (typeof handler.onHandshake !== 'function') {
    handler.onHandshake = noop
  }
  if (typeof handler.onExtendedHandshake !== 'function') {
    handler.onExtendedHandshake = noop
  }
  if (typeof handler.onMessage !== 'function') {
    handler.onMessage = noop
  }

  this.extendedMapping[ext] = name
  this._ext[name] = handler
  this[name] = handler

  this._nextExt += 1
}

//
// OUTGOING MESSAGES
//

/**
 * Message "keep-alive": <len=0000>
 */
Wire.prototype.keepAlive = function () {
  this._debug('keep-alive')
  this._push(MESSAGE_KEEP_ALIVE)
}

/**
 * Message: "handshake" <pstrlen><pstr><reserved><info_hash><peer_id>
 * @param  {Buffer|string} infoHash (as Buffer or *hex* string)
 * @param  {Buffer|string} peerId
 * @param  {Object} extensions
 */
Wire.prototype.handshake = function (infoHash, peerId, extensions) {
  var infoHashBuffer, peerIdBuffer
  if (typeof infoHash === 'string') {
    infoHashBuffer = Buffer.from(infoHash, 'hex')
  } else {
    infoHashBuffer = infoHash
    infoHash = infoHashBuffer.toString('hex')
  }
  if (typeof peerId === 'string') {
    peerIdBuffer = Buffer.from(peerId, 'hex')
  } else {
    peerIdBuffer = peerId
    peerId = peerIdBuffer.toString('hex')
  }

  if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
    throw new Error('infoHash and peerId MUST have length 20')
  }

  this._debug('handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  var reserved = Buffer.from(MESSAGE_RESERVED)

  // enable extended message
  reserved[5] |= 0x10

  if (extensions && extensions.dht) reserved[7] |= 1

  this._push(Buffer.concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]))
  this._handshakeSent = true

  if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
    // Peer's handshake indicated support already
    // (incoming connection)
    this._sendExtendedHandshake()
  }
}

/* Peer supports BEP-0010, send extended handshake.
 *
 * This comes after the 'handshake' event to give the user a chance to populate
 * `this.extendedHandshake` and `this.extendedMapping` before the extended handshake
 * is sent to the remote peer.
 */
Wire.prototype._sendExtendedHandshake = function () {
  // Create extended message object from registered extensions
  var msg = extend(this.extendedHandshake)
  msg.m = {}
  for (var ext in this.extendedMapping) {
    var name = this.extendedMapping[ext]
    msg.m[name] = Number(ext)
  }

  // Send extended handshake
  this.extended(0, bencode.encode(msg))
  this._extendedHandshakeSent = true
}

/**
 * Message "choke": <len=0001><id=0>
 */
Wire.prototype.choke = function () {
  if (this.amChoking) return
  this.amChoking = true
  this._debug('choke')
  this.peerRequests.splice(0, this.peerRequests.length)
  this._push(MESSAGE_CHOKE)
}

/**
 * Message "unchoke": <len=0001><id=1>
 */
Wire.prototype.unchoke = function () {
  if (!this.amChoking) return
  this.amChoking = false
  this._debug('unchoke')
  this._push(MESSAGE_UNCHOKE)
}

/**
 * Message "interested": <len=0001><id=2>
 */
Wire.prototype.interested = function () {
  if (this.amInterested) return
  this.amInterested = true
  this._debug('interested')
  this._push(MESSAGE_INTERESTED)
}

/**
 * Message "uninterested": <len=0001><id=3>
 */
Wire.prototype.uninterested = function () {
  if (!this.amInterested) return
  this.amInterested = false
  this._debug('uninterested')
  this._push(MESSAGE_UNINTERESTED)
}

/**
 * Message "have": <len=0005><id=4><piece index>
 * @param  {number} index
 */
Wire.prototype.have = function (index) {
  this._debug('have %d', index)
  this._message(4, [index], null)
}

/**
 * Message "bitfield": <len=0001+X><id=5><bitfield>
 * @param  {BitField|Buffer} bitfield
 */
Wire.prototype.bitfield = function (bitfield) {
  this._debug('bitfield')
  if (!Buffer.isBuffer(bitfield)) bitfield = bitfield.buffer
  this._message(5, [], bitfield)
}

/**
 * Message "request": <len=0013><id=6><index><begin><length>
 * @param  {number}   index
 * @param  {number}   offset
 * @param  {number}   length
 * @param  {function} cb
 */
Wire.prototype.request = function (index, offset, length, cb) {
  if (!cb) cb = function () {}
  if (this._finished) return cb(new Error('wire is closed'))
  if (this.peerChoking) return cb(new Error('peer is choking'))

  this._debug('request index=%d offset=%d length=%d', index, offset, length)

  this.requests.push(new Request(index, offset, length, cb))
  this._updateTimeout()
  this._message(6, [index, offset, length], null)
}

/**
 * Message "piece": <len=0009+X><id=7><index><begin><block>
 * @param  {number} index
 * @param  {number} offset
 * @param  {Buffer} buffer
 */
Wire.prototype.piece = function (index, offset, buffer) {
  this._debug('piece index=%d offset=%d', index, offset)
  this.uploaded += buffer.length
  this.uploadSpeed(buffer.length)
  this.emit('upload', buffer.length)
  this._message(7, [index, offset], buffer)
}

/**
 * Message "cancel": <len=0013><id=8><index><begin><length>
 * @param  {number} index
 * @param  {number} offset
 * @param  {number} length
 */
Wire.prototype.cancel = function (index, offset, length) {
  this._debug('cancel index=%d offset=%d length=%d', index, offset, length)
  this._callback(
    pull(this.requests, index, offset, length),
    new Error('request was cancelled'),
    null
  )
  this._message(8, [index, offset, length], null)
}

/**
 * Message: "port" <len=0003><id=9><listen-port>
 * @param {Number} port
 */
Wire.prototype.port = function (port) {
  this._debug('port %d', port)
  var message = Buffer.from(MESSAGE_PORT)
  message.writeUInt16BE(port, 5)
  this._push(message)
}

/**
 * Message: "extended" <len=0005+X><id=20><ext-number><payload>
 * @param  {number|string} ext
 * @param  {Object} obj
 */
Wire.prototype.extended = function (ext, obj) {
  this._debug('extended ext=%s', ext)
  if (typeof ext === 'string' && this.peerExtendedMapping[ext]) {
    ext = this.peerExtendedMapping[ext]
  }
  if (typeof ext === 'number') {
    var extId = Buffer.from([ext])
    var buf = Buffer.isBuffer(obj) ? obj : bencode.encode(obj)

    this._message(20, [], Buffer.concat([extId, buf]))
  } else {
    throw new Error('Unrecognized extension: ' + ext)
  }
}

/**
 * Duplex stream method. Called whenever the remote peer stream wants data. No-op
 * since we'll just push data whenever we get it.
 */
Wire.prototype._read = function () {}

/**
 * Send a message to the remote peer.
 */
Wire.prototype._message = function (id, numbers, data) {
  var dataLength = data ? data.length : 0
  var buffer = Buffer.allocUnsafe(5 + 4 * numbers.length)

  buffer.writeUInt32BE(buffer.length + dataLength - 4, 0)
  buffer[4] = id
  for (var i = 0; i < numbers.length; i++) {
    buffer.writeUInt32BE(numbers[i], 5 + 4 * i)
  }

  this._push(buffer)
  if (data) this._push(data)
}

Wire.prototype._push = function (data) {
  if (this._finished) return
  return this.push(data)
}

//
// INCOMING MESSAGES
//

Wire.prototype._onKeepAlive = function () {
  this._debug('got keep-alive')
  this.emit('keep-alive')
}

Wire.prototype._onHandshake = function (infoHashBuffer, peerIdBuffer, extensions) {
  var infoHash = infoHashBuffer.toString('hex')
  var peerId = peerIdBuffer.toString('hex')

  this._debug('got handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  this.peerId = peerId
  this.peerIdBuffer = peerIdBuffer
  this.peerExtensions = extensions

  this.emit('handshake', infoHash, peerId, extensions)

  var name
  for (name in this._ext) {
    this._ext[name].onHandshake(infoHash, peerId, extensions)
  }

  if (extensions.extended && this._handshakeSent &&
      !this._extendedHandshakeSent) {
    // outgoing connection
    this._sendExtendedHandshake()
  }
}

Wire.prototype._onChoke = function () {
  this.peerChoking = true
  this._debug('got choke')
  this.emit('choke')
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('peer is choking'), null)
  }
}

Wire.prototype._onUnchoke = function () {
  this.peerChoking = false
  this._debug('got unchoke')
  this.emit('unchoke')
}

Wire.prototype._onInterested = function () {
  this.peerInterested = true
  this._debug('got interested')
  this.emit('interested')
}

Wire.prototype._onUninterested = function () {
  this.peerInterested = false
  this._debug('got uninterested')
  this.emit('uninterested')
}

Wire.prototype._onHave = function (index) {
  if (this.peerPieces.get(index)) return
  this._debug('got have %d', index)

  this.peerPieces.set(index, true)
  this.emit('have', index)
}

Wire.prototype._onBitField = function (buffer) {
  this.peerPieces = new BitField(buffer)
  this._debug('got bitfield')
  this.emit('bitfield', this.peerPieces)
}

Wire.prototype._onRequest = function (index, offset, length) {
  var self = this
  if (self.amChoking) return
  self._debug('got request index=%d offset=%d length=%d', index, offset, length)

  var respond = function (err, buffer) {
    if (request !== pull(self.peerRequests, index, offset, length)) return
    if (err) return self._debug('error satisfying request index=%d offset=%d length=%d (%s)', index, offset, length, err.message)
    self.piece(index, offset, buffer)
  }

  var request = new Request(index, offset, length, respond)
  self.peerRequests.push(request)
  self.emit('request', index, offset, length, respond)
}

Wire.prototype._onPiece = function (index, offset, buffer) {
  this._debug('got piece index=%d offset=%d', index, offset)
  this._callback(pull(this.requests, index, offset, buffer.length), null, buffer)
  this.downloaded += buffer.length
  this.downloadSpeed(buffer.length)
  this.emit('download', buffer.length)
  this.emit('piece', index, offset, buffer)
}

Wire.prototype._onCancel = function (index, offset, length) {
  this._debug('got cancel index=%d offset=%d length=%d', index, offset, length)
  pull(this.peerRequests, index, offset, length)
  this.emit('cancel', index, offset, length)
}

Wire.prototype._onPort = function (port) {
  this._debug('got port %d', port)
  this.emit('port', port)
}

Wire.prototype._onExtended = function (ext, buf) {
  if (ext === 0) {
    var info
    try {
      info = bencode.decode(buf)
    } catch (err) {
      this._debug('ignoring invalid extended handshake: %s', err.message || err)
    }

    if (!info) return
    this.peerExtendedHandshake = info

    var name
    if (typeof info.m === 'object') {
      for (name in info.m) {
        this.peerExtendedMapping[name] = Number(info.m[name].toString())
      }
    }
    for (name in this._ext) {
      if (this.peerExtendedMapping[name]) {
        this._ext[name].onExtendedHandshake(this.peerExtendedHandshake)
      }
    }
    this._debug('got extended handshake')
    this.emit('extended', 'handshake', this.peerExtendedHandshake)
  } else {
    if (this.extendedMapping[ext]) {
      ext = this.extendedMapping[ext] // friendly name for extension
      if (this._ext[ext]) {
        // there is an registered extension handler, so call it
        this._ext[ext].onMessage(buf)
      }
    }
    this._debug('got extended message ext=%s', ext)
    this.emit('extended', ext, buf)
  }
}

Wire.prototype._onTimeout = function () {
  this._debug('request timed out')
  this._callback(this.requests.shift(), new Error('request has timed out'), null)
  this.emit('timeout')
}

/**
 * Duplex stream method. Called whenever the remote peer has data for us. Data that the
 * remote peer sends gets buffered (i.e. not actually processed) until the right number
 * of bytes have arrived, determined by the last call to `this._parse(number, callback)`.
 * Once enough bytes have arrived to process the message, the callback function
 * (i.e. `this._parser`) gets called with the full buffer of data.
 * @param  {Buffer} data
 * @param  {string} encoding
 * @param  {function} cb
 */
Wire.prototype._write = function (data, encoding, cb) {
  this._bufferSize += data.length
  this._buffer.push(data)

  while (this._bufferSize >= this._parserSize) {
    var buffer = (this._buffer.length === 1)
      ? this._buffer[0]
      : Buffer.concat(this._buffer)
    this._bufferSize -= this._parserSize
    this._buffer = this._bufferSize
      ? [buffer.slice(this._parserSize)]
      : []
    this._parser(buffer.slice(0, this._parserSize))
  }

  cb(null) // Signal that we're ready for more data
}

Wire.prototype._callback = function (request, err, buffer) {
  if (!request) return

  this._clearTimeout()

  if (!this.peerChoking && !this._finished) this._updateTimeout()
  request.callback(err, buffer)
}

Wire.prototype._clearTimeout = function () {
  if (!this._timeout) return

  clearTimeout(this._timeout)
  this._timeout = null
}

Wire.prototype._updateTimeout = function () {
  var self = this
  if (!self._timeoutMs || !self.requests.length || self._timeout) return

  self._timeout = setTimeout(function () {
    self._onTimeout()
  }, self._timeoutMs)
  if (self._timeoutUnref && self._timeout.unref) self._timeout.unref()
}

/**
 * Takes a number of bytes that the local peer is waiting to receive from the remote peer
 * in order to parse a complete message, and a callback function to be called once enough
 * bytes have arrived.
 * @param  {number} size
 * @param  {function} parser
 */
Wire.prototype._parse = function (size, parser) {
  this._parserSize = size
  this._parser = parser
}

/**
 * Handle the first 4 bytes of a message, to determine the length of bytes that must be
 * waited for in order to have the whole message.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessageLength = function (buffer) {
  var length = buffer.readUInt32BE(0)
  if (length > 0) {
    this._parse(length, this._onMessage)
  } else {
    this._onKeepAlive()
    this._parse(4, this._onMessageLength)
  }
}

/**
 * Handle a message from the remote peer.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessage = function (buffer) {
  this._parse(4, this._onMessageLength)
  switch (buffer[0]) {
    case 0:
      return this._onChoke()
    case 1:
      return this._onUnchoke()
    case 2:
      return this._onInterested()
    case 3:
      return this._onUninterested()
    case 4:
      return this._onHave(buffer.readUInt32BE(1))
    case 5:
      return this._onBitField(buffer.slice(1))
    case 6:
      return this._onRequest(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 7:
      return this._onPiece(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.slice(9))
    case 8:
      return this._onCancel(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 9:
      return this._onPort(buffer.readUInt16BE(1))
    case 20:
      return this._onExtended(buffer.readUInt8(1), buffer.slice(2))
    default:
      this._debug('got unknown message')
      return this.emit('unknownmessage', buffer)
  }
}

Wire.prototype._parseHandshake = function () {
  var self = this
  self._parse(1, function (buffer) {
    var pstrlen = buffer.readUInt8(0)
    self._parse(pstrlen + 48, function (handshake) {
      var protocol = handshake.slice(0, pstrlen)
      if (protocol.toString() !== 'BitTorrent protocol') {
        self._debug('Error: wire not speaking BitTorrent protocol (%s)', protocol.toString())
        self.end()
        return
      }
      handshake = handshake.slice(pstrlen)
      self._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
        dht: !!(handshake[7] & 0x01), // see bep_0005
        extended: !!(handshake[5] & 0x10) // see bep_0010
      })
      self._parse(4, self._onMessageLength)
    })
  })
}

Wire.prototype._onFinish = function () {
  this._finished = true

  this.push(null) // stream cannot be half open, so signal the end of it
  while (this.read()) {} // consume and discard the rest of the stream data

  clearInterval(this._keepAliveInterval)
  this._parse(Number.MAX_VALUE, function () {})
  this.peerRequests = []
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('wire was closed'), null)
  }
}

Wire.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

function pull (requests, piece, offset, length) {
  for (var i = 0; i < requests.length; i++) {
    var req = requests[i]
    if (req.piece !== piece || req.offset !== offset || req.length !== length) continue

    if (i === 0) requests.shift()
    else requests.splice(i, 1)

    return req
  }
  return null
}

},{"bencode":7,"bitfield":9,"debug":31,"hat":39,"inherits":43,"readable-stream":86,"safe-buffer":92,"speedometer":98,"xtend":139}],11:[function(require,module,exports){
(function (process){
module.exports = Client

var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-tracker')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var once = require('once')
var parallel = require('run-parallel')
var Peer = require('simple-peer')
var uniq = require('uniq')
var url = require('url')

var common = require('./lib/common')
var HTTPTracker = require('./lib/client/http-tracker') // empty object in browser
var UDPTracker = require('./lib/client/udp-tracker') // empty object in browser
var WebSocketTracker = require('./lib/client/websocket-tracker')

inherits(Client, EventEmitter)

/**
 * BitTorrent tracker client.
 *
 * Find torrent peers, to help a torrent client participate in a torrent swarm.
 *
 * @param {Object} opts                          options object
 * @param {string|Buffer} opts.infoHash          torrent info hash
 * @param {string|Buffer} opts.peerId            peer id
 * @param {string|Array.<string>} opts.announce  announce
 * @param {number} opts.port                     torrent client listening port
 * @param {function} opts.getAnnounceOpts        callback to provide data to tracker
 * @param {number} opts.rtcConfig                RTCPeerConnection configuration object
 * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)
 */
function Client (opts) {
  var self = this
  if (!(self instanceof Client)) return new Client(opts)
  EventEmitter.call(self)
  if (!opts) opts = {}

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  // required
  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self._peerIdBuffer = Buffer.from(self.peerId, 'hex')
  self._peerIdBinary = self._peerIdBuffer.toString('binary')

  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._infoHashBuffer = Buffer.from(self.infoHash, 'hex')
  self._infoHashBinary = self._infoHashBuffer.toString('binary')

  self._port = opts.port

  self.destroyed = false

  self._rtcConfig = opts.rtcConfig
  self._wrtc = opts.wrtc
  self._getAnnounceOpts = opts.getAnnounceOpts

  debug('new client %s', self.infoHash)

  var webrtcSupport = self._wrtc !== false && (!!self._wrtc || Peer.WEBRTC_SUPPORT)

  var announce = (typeof opts.announce === 'string')
    ? [ opts.announce ]
    : opts.announce == null
      ? []
      : opts.announce

  announce = announce.map(function (announceUrl) {
    announceUrl = announceUrl.toString()
    if (announceUrl[announceUrl.length - 1] === '/') {
      // remove trailing slash from trackers to catch duplicates
      announceUrl = announceUrl.substring(0, announceUrl.length - 1)
    }
    return announceUrl
  })

  announce = uniq(announce)

  self._trackers = announce
    .map(function (announceUrl) {
      var protocol = url.parse(announceUrl).protocol
      if ((protocol === 'http:' || protocol === 'https:') &&
          typeof HTTPTracker === 'function') {
        return new HTTPTracker(self, announceUrl)
      } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {
        return new UDPTracker(self, announceUrl)
      } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {
        // Skip ws:// trackers on https:// sites because they throw SecurityError
        if (protocol === 'ws:' && typeof window !== 'undefined' &&
            window.location.protocol === 'https:') {
          nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
          return null
        }
        return new WebSocketTracker(self, announceUrl)
      } else {
        nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
        return null
      }
    })
    .filter(Boolean)

  function nextTickWarn (err) {
    process.nextTick(function () {
      self.emit('warning', err)
    })
  }
}

/**
 * Simple convenience function to scrape a tracker for an info hash without needing to
 * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple
 * torrents at the same time.
 * @params {Object} opts
 * @param  {string|Array.<string>} opts.infoHash
 * @param  {string} opts.announce
 * @param  {function} cb
 */
Client.scrape = function (opts, cb) {
  cb = once(cb)

  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')

  var clientOpts = extend(opts, {
    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,
    peerId: Buffer.from('01234567890123456789'), // dummy value
    port: 6881 // dummy value
  })

  var client = new Client(clientOpts)
  client.once('error', cb)

  var len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1
  var results = {}
  client.on('scrape', function (data) {
    len -= 1
    results[data.infoHash] = data
    if (len === 0) {
      client.destroy()
      var keys = Object.keys(results)
      if (keys.length === 1) {
        cb(null, results[keys[0]])
      } else {
        cb(null, results)
      }
    }
  })

  opts.infoHash = Array.isArray(opts.infoHash)
    ? opts.infoHash.map(function (infoHash) {
      return Buffer.from(infoHash, 'hex')
    })
    : Buffer.from(opts.infoHash, 'hex')
  client.scrape({ infoHash: opts.infoHash })
  return client
}

/**
 * Send a `start` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.start = function (opts) {
  var self = this
  debug('send `start`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'started'
  self._announce(opts)

  // start announcing on intervals
  self._trackers.forEach(function (tracker) {
    tracker.setInterval()
  })
}

/**
 * Send a `stop` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.stop = function (opts) {
  var self = this
  debug('send `stop`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'stopped'
  self._announce(opts)
}

/**
 * Send a `complete` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.complete = function (opts) {
  var self = this
  debug('send `complete`')
  if (!opts) opts = {}
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'completed'
  self._announce(opts)
}

/**
 * Send a `update` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.update = function (opts) {
  var self = this
  debug('send `update`')
  opts = self._defaultAnnounceOpts(opts)
  if (opts.event) delete opts.event
  self._announce(opts)
}

Client.prototype._announce = function (opts) {
  var self = this
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.announce(opts)
  })
}

/**
 * Send a scrape request to the trackers.
 * @param {Object} opts
 */
Client.prototype.scrape = function (opts) {
  var self = this
  debug('send `scrape`')
  if (!opts) opts = {}
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.scrape(opts)
  })
}

Client.prototype.setInterval = function (intervalMs) {
  var self = this
  debug('setInterval %d', intervalMs)
  self._trackers.forEach(function (tracker) {
    tracker.setInterval(intervalMs)
  })
}

Client.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  debug('destroy')

  var tasks = self._trackers.map(function (tracker) {
    return function (cb) {
      tracker.destroy(cb)
    }
  })

  parallel(tasks, cb)

  self._trackers = []
  self._getAnnounceOpts = null
}

Client.prototype._defaultAnnounceOpts = function (opts) {
  var self = this
  if (!opts) opts = {}

  if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS

  if (opts.uploaded == null) opts.uploaded = 0
  if (opts.downloaded == null) opts.downloaded = 0

  if (self._getAnnounceOpts) opts = extend(opts, self._getAnnounceOpts())
  return opts
}

}).call(this,require('_process'))

},{"./lib/client/http-tracker":17,"./lib/client/udp-tracker":17,"./lib/client/websocket-tracker":13,"./lib/common":14,"_process":73,"debug":31,"events":35,"inherits":43,"once":63,"run-parallel":90,"safe-buffer":92,"simple-peer":95,"uniq":115,"url":117,"xtend":139}],12:[function(require,module,exports){
module.exports = Tracker

var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

inherits(Tracker, EventEmitter)

function Tracker (client, announceUrl) {
  var self = this
  EventEmitter.call(self)
  self.client = client
  self.announceUrl = announceUrl

  self.interval = null
  self.destroyed = false
}

Tracker.prototype.setInterval = function (intervalMs) {
  var self = this
  if (intervalMs == null) intervalMs = self.DEFAULT_ANNOUNCE_INTERVAL

  clearInterval(self.interval)

  if (intervalMs) {
    self.interval = setInterval(function () {
      self.announce(self.client._defaultAnnounceOpts())
    }, intervalMs)
    if (self.interval.unref) self.interval.unref()
  }
}

},{"events":35,"inherits":43}],13:[function(require,module,exports){
module.exports = WebSocketTracker

var debug = require('debug')('bittorrent-tracker:websocket-tracker')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var Peer = require('simple-peer')
var Socket = require('simple-websocket')

var common = require('../common')
var Tracker = require('./tracker')

// Use a socket pool, so tracker clients share WebSocket objects for the same server.
// In practice, WebSockets are pretty slow to establish, so this gives a nice performance
// boost, and saves browser resources.
var socketPool = {}

var RECONNECT_MINIMUM = 15 * 1000
var RECONNECT_MAXIMUM = 30 * 60 * 1000
var RECONNECT_VARIANCE = 30 * 1000
var OFFER_TIMEOUT = 50 * 1000

inherits(WebSocketTracker, Tracker)

function WebSocketTracker (client, announceUrl, opts) {
  var self = this
  Tracker.call(self, client, announceUrl)
  debug('new websocket tracker %s', announceUrl)

  self.peers = {} // peers (offer id -> peer)
  self.socket = null

  self.reconnecting = false
  self.retries = 0
  self.reconnectTimer = null

  self._openSocket()
}

WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1000 // 30 seconds

WebSocketTracker.prototype.announce = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.announce(opts)
    })
    return
  }

  var params = extend(opts, {
    action: 'announce',
    info_hash: self.client._infoHashBinary,
    peer_id: self.client._peerIdBinary
  })
  if (self._trackerId) params.trackerid = self._trackerId

  if (opts.event === 'stopped') {
    // Don't include offers with 'stopped' event
    self._send(params)
  } else {
    // Limit the number of offers that are generated, since it can be slow
    var numwant = Math.min(opts.numwant, 5)

    self._generateOffers(numwant, function (offers) {
      params.numwant = numwant
      params.offers = offers
      self._send(params)
    })
  }
}

WebSocketTracker.prototype.scrape = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.scrape(opts)
    })
    return
  }

  var infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)
    ? opts.infoHash.map(function (infoHash) {
      return infoHash.toString('binary')
    })
    : (opts.infoHash && opts.infoHash.toString('binary')) || self.client._infoHashBinary
  var params = {
    action: 'scrape',
    info_hash: infoHashes
  }

  self._send(params)
}

WebSocketTracker.prototype.destroy = function (cb) {
  var self = this
  if (!cb) cb = noop
  if (self.destroyed) return cb(null)

  self.destroyed = true

  clearInterval(self.interval)
  clearTimeout(self.reconnectTimer)

  if (self.socket) {
    self.socket.removeListener('connect', self._onSocketConnectBound)
    self.socket.removeListener('data', self._onSocketDataBound)
    self.socket.removeListener('close', self._onSocketCloseBound)
    self.socket.removeListener('error', self._onSocketErrorBound)
  }

  self._onSocketConnectBound = null
  self._onSocketErrorBound = null
  self._onSocketDataBound = null
  self._onSocketCloseBound = null

  // Destroy peers
  for (var peerId in self.peers) {
    var peer = self.peers[peerId]
    clearTimeout(peer.trackerTimeout)
    peer.destroy()
  }
  self.peers = null

  if (socketPool[self.announceUrl]) {
    socketPool[self.announceUrl].consumers -= 1
  }

  if (socketPool[self.announceUrl].consumers === 0) {
    delete socketPool[self.announceUrl]

    try {
      self.socket.on('error', noop) // ignore all future errors
      self.socket.destroy(cb)
    } catch (err) {
      cb(null)
    }
  } else {
    cb(null)
  }

  self.socket = null
}

WebSocketTracker.prototype._openSocket = function () {
  var self = this
  self.destroyed = false

  if (!self.peers) self.peers = {}

  self._onSocketConnectBound = function () {
    self._onSocketConnect()
  }
  self._onSocketErrorBound = function (err) {
    self._onSocketError(err)
  }
  self._onSocketDataBound = function (data) {
    self._onSocketData(data)
  }
  self._onSocketCloseBound = function () {
    self._onSocketClose()
  }

  self.socket = socketPool[self.announceUrl]
  if (self.socket) {
    socketPool[self.announceUrl].consumers += 1
  } else {
    self.socket = socketPool[self.announceUrl] = new Socket(self.announceUrl)
    self.socket.consumers = 1
    self.socket.on('connect', self._onSocketConnectBound)
  }

  self.socket.on('data', self._onSocketDataBound)
  self.socket.on('close', self._onSocketCloseBound)
  self.socket.on('error', self._onSocketErrorBound)
}

WebSocketTracker.prototype._onSocketConnect = function () {
  var self = this
  if (self.destroyed) return

  if (self.reconnecting) {
    self.reconnecting = false
    self.retries = 0
    self.announce(self.client._defaultAnnounceOpts())
  }
}

WebSocketTracker.prototype._onSocketData = function (data) {
  var self = this
  if (self.destroyed) return

  try {
    data = JSON.parse(data)
  } catch (err) {
    self.client.emit('warning', new Error('Invalid tracker response'))
    return
  }

  if (data.action === 'announce') {
    self._onAnnounceResponse(data)
  } else if (data.action === 'scrape') {
    self._onScrapeResponse(data)
  } else {
    self._onSocketError(new Error('invalid action in WS response: ' + data.action))
  }
}

WebSocketTracker.prototype._onAnnounceResponse = function (data) {
  var self = this

  if (data.info_hash !== self.client._infoHashBinary) {
    debug(
      'ignoring websocket data from %s for %s (looking for %s: reused socket)',
      self.announceUrl, common.binaryToHex(data.info_hash), self.client.infoHash
    )
    return
  }

  if (data.peer_id && data.peer_id === self.client._peerIdBinary) {
    // ignore offers/answers from this client
    return
  }

  debug(
    'received %s from %s for %s',
    JSON.stringify(data), self.announceUrl, self.client.infoHash
  )

  var failure = data['failure reason']
  if (failure) return self.client.emit('warning', new Error(failure))

  var warning = data['warning message']
  if (warning) self.client.emit('warning', new Error(warning))

  var interval = data.interval || data['min interval']
  if (interval) self.setInterval(interval * 1000)

  var trackerId = data['tracker id']
  if (trackerId) {
    // If absent, do not discard previous trackerId value
    self._trackerId = trackerId
  }

  if (data.complete != null) {
    self.client.emit('update', {
      announce: self.announceUrl,
      complete: data.complete,
      incomplete: data.incomplete
    })
  }

  var peer
  if (data.offer && data.peer_id) {
    debug('creating peer (from remote offer)')
    peer = new Peer({
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.id = common.binaryToHex(data.peer_id)
    peer.once('signal', function (answer) {
      var params = {
        action: 'announce',
        info_hash: self.client._infoHashBinary,
        peer_id: self.client._peerIdBinary,
        to_peer_id: data.peer_id,
        answer: answer,
        offer_id: data.offer_id
      }
      if (self._trackerId) params.trackerid = self._trackerId
      self._send(params)
    })
    peer.signal(data.offer)
    self.client.emit('peer', peer)
  }

  if (data.answer && data.peer_id) {
    var offerId = common.binaryToHex(data.offer_id)
    peer = self.peers[offerId]
    if (peer) {
      peer.id = common.binaryToHex(data.peer_id)
      peer.signal(data.answer)
      self.client.emit('peer', peer)

      clearTimeout(peer.trackerTimeout)
      peer.trackerTimeout = null
      delete self.peers[offerId]
    } else {
      debug('got unexpected answer: ' + JSON.stringify(data.answer))
    }
  }
}

WebSocketTracker.prototype._onScrapeResponse = function (data) {
  var self = this
  data = data.files || {}

  var keys = Object.keys(data)
  if (keys.length === 0) {
    self.client.emit('warning', new Error('invalid scrape response'))
    return
  }

  keys.forEach(function (infoHash) {
    var response = data[infoHash]
    // TODO: optionally handle data.flags.min_request_interval
    // (separate from announce interval)
    self.client.emit('scrape', {
      announce: self.announceUrl,
      infoHash: common.binaryToHex(infoHash),
      complete: response.complete,
      incomplete: response.incomplete,
      downloaded: response.downloaded
    })
  })
}

WebSocketTracker.prototype._onSocketClose = function () {
  var self = this
  if (self.destroyed) return
  self.destroy()
  self._startReconnectTimer()
}

WebSocketTracker.prototype._onSocketError = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroy()
  // errors will often happen if a tracker is offline, so don't treat it as fatal
  self.client.emit('warning', err)
  self._startReconnectTimer()
}

WebSocketTracker.prototype._startReconnectTimer = function () {
  var self = this
  var ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, self.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)

  self.reconnecting = true
  clearTimeout(self.reconnectTimer)
  self.reconnectTimer = setTimeout(function () {
    self.retries++
    self._openSocket()
  }, ms)
  if (self.reconnectTimer.unref) self.reconnectTimer.unref()

  debug('reconnecting socket in %s ms', ms)
}

WebSocketTracker.prototype._send = function (params) {
  var self = this
  if (self.destroyed) return

  var message = JSON.stringify(params)
  debug('send %s', message)
  self.socket.send(message)
}

WebSocketTracker.prototype._generateOffers = function (numwant, cb) {
  var self = this
  var offers = []
  debug('generating %s offers', numwant)

  for (var i = 0; i < numwant; ++i) {
    generateOffer()
  }
  checkDone()

  function generateOffer () {
    var offerId = hat(160)
    debug('creating peer (from _generateOffers)')
    var peer = self.peers[offerId] = new Peer({
      initiator: true,
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.once('signal', function (offer) {
      offers.push({
        offer: offer,
        offer_id: common.hexToBinary(offerId)
      })
      checkDone()
    })
    peer.trackerTimeout = setTimeout(function () {
      debug('tracker timeout: destroying peer')
      peer.trackerTimeout = null
      delete self.peers[offerId]
      peer.destroy()
    }, OFFER_TIMEOUT)
    if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()
  }

  function checkDone () {
    if (offers.length === numwant) {
      debug('generated %s offers', numwant)
      cb(offers)
    }
  }
}

function noop () {}

},{"../common":14,"./tracker":12,"debug":31,"hat":39,"inherits":43,"simple-peer":95,"simple-websocket":97,"xtend":139}],14:[function(require,module,exports){
/**
 * Functions/constants needed by both the client and server.
 */

var Buffer = require('safe-buffer').Buffer
var extend = require('xtend/mutable')

exports.DEFAULT_ANNOUNCE_PEERS = 50
exports.MAX_ANNOUNCE_PEERS = 82

exports.binaryToHex = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'binary').toString('hex')
}

exports.hexToBinary = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'hex').toString('binary')
}

var config = require('./common-node')
extend(exports, config)

},{"./common-node":17,"safe-buffer":92,"xtend/mutable":140}],15:[function(require,module,exports){
(function (Buffer){
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  var reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, new Buffer(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],16:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits');
var Transform = require('readable-stream').Transform;
var defined = require('defined');

module.exports = Block;
inherits(Block, Transform);

function Block (size, opts) {
    if (!(this instanceof Block)) return new Block(size, opts);
    Transform.call(this);
    if (!opts) opts = {};
    if (typeof size === 'object') {
        opts = size;
        size = opts.size;
    }
    this.size = size || 512;
    
    if (opts.nopad) this._zeroPadding = false;
    else this._zeroPadding = defined(opts.zeroPadding, true);
    
    this._buffered = [];
    this._bufferedBytes = 0;
}

Block.prototype._transform = function (buf, enc, next) {
    this._bufferedBytes += buf.length;
    this._buffered.push(buf);
    
    while (this._bufferedBytes >= this.size) {
        var b = Buffer.concat(this._buffered);
        this._bufferedBytes -= this.size;
        this.push(b.slice(0, this.size));
        this._buffered = [ b.slice(this.size, b.length) ];
    }
    next();
};

Block.prototype._flush = function () {
    if (this._bufferedBytes && this._zeroPadding) {
        var zeroes = new Buffer(this.size - this._bufferedBytes);
        zeroes.fill(0);
        this._buffered.push(zeroes);
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    else if (this._bufferedBytes) {
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    this.push(null);
};

}).call(this,require("buffer").Buffer)

},{"buffer":20,"defined":33,"inherits":43,"readable-stream":86}],17:[function(require,module,exports){

},{}],18:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17}],19:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":20}],20:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; i++) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  that.write(string, encoding)
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

function arrayIndexOf (arr, val, byteOffset, encoding) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var foundIndex = -1
  for (var i = 0; byteOffset + i < arrLength; i++) {
    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
      if (foundIndex === -1) foundIndex = i
      if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize
    } else {
      if (foundIndex !== -1) i -= i - foundIndex
      foundIndex = -1
    }
  }
  return -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  if (Buffer.isBuffer(val)) {
    // special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(this, val, byteOffset, encoding)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset, encoding)
  }

  throw new TypeError('val must be string, number or Buffer')
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; i++) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; i++) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":4,"ieee754":41,"isarray":49}],21:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],22:[function(require,module,exports){
module.exports = ChunkStoreWriteStream

var BlockStream = require('block-stream2')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(ChunkStoreWriteStream, stream.Writable)

function ChunkStoreWriteStream (store, chunkLength, opts) {
  var self = this
  if (!(self instanceof ChunkStoreWriteStream)) {
    return new ChunkStoreWriteStream(store, chunkLength, opts)
  }
  stream.Writable.call(self, opts)
  if (!opts) opts = {}

  if (!store || !store.put || !store.get) {
    throw new Error('First argument must be an abstract-chunk-store compliant store')
  }
  chunkLength = Number(chunkLength)
  if (!chunkLength) throw new Error('Second argument must be a chunk length')

  self._blockstream = new BlockStream(chunkLength, { zeroPadding: false })

  self._blockstream
    .on('data', onData)
    .on('error', function (err) { self.destroy(err) })

  var index = 0
  function onData (chunk) {
    if (self.destroyed) return
    store.put(index, chunk)
    index += 1
  }

  self.on('finish', function () { this._blockstream.end() })
}

ChunkStoreWriteStream.prototype._write = function (chunk, encoding, callback) {
  this._blockstream.write(chunk, encoding, callback)
}

ChunkStoreWriteStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
}

},{"block-stream2":16,"inherits":43,"readable-stream":86}],23:[function(require,module,exports){
module.exports = function(target, numbers) {
  var closest = Infinity
  var difference = 0
  var winner = null

  numbers.sort(function(a, b) {
    return a - b
  })

  for (var i = 0, l = numbers.length; i < l; i++) {  
    difference = Math.abs(target - numbers[i])
    if (difference >= closest) {
      break
    }
    closest = difference
    winner = numbers[i]
  }

  return winner
}

},{}],24:[function(require,module,exports){
var ipaddr = require('ipaddr.js');

module.exports = compact2string = function (buf) {
  switch(buf.length) {
  case 6:
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3] + ":" + buf.readUInt16BE(4);
    break;
  case 18:
    var hexGroups = [];
    for(var i = 0; i < 8; i++) {
      hexGroups.push(buf.readUInt16BE(i * 2).toString(16));
    }
    var host = ipaddr.parse(hexGroups.join(":")).toString();
    return "[" + host + "]:" + buf.readUInt16BE(16);
  default:
    throw new Error("Invalid Compact IP/PORT, It should contain 6 or 18 bytes");
  }
};

compact2string.multi = function (buf) {
  if(buf.length % 6 !== 0)
    throw new Error("buf length isn't multiple of compact IP/PORTs (6 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 6) {
    output.push(compact2string(buf.slice(i, i + 6)));
  }

  return output;
};

compact2string.multi6 = function (buf) {
  if(buf.length % 18 !== 0)
    throw new Error("buf length isn't multiple of compact IP6/PORTs (18 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 18) {
    output.push(compact2string(buf.slice(i, i + 18)));
  }

  return output;
};

},{"ipaddr.js":44}],25:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":46}],26:[function(require,module,exports){
(function (process,global,Buffer){
module.exports = createTorrent
module.exports.parseInput = parseInput

module.exports.announceList = [
  [ 'udp://tracker.openbittorrent.com:80' ],
  [ 'udp://tracker.internetwarriors.net:1337' ],
  [ 'udp://tracker.leechers-paradise.org:6969' ],
  [ 'udp://tracker.coppersurfer.tk:6969' ],
  [ 'udp://exodus.desync.com:6969' ],
  [ 'wss://tracker.webtorrent.io' ],
  [ 'wss://tracker.btorrent.xyz' ],
  [ 'wss://tracker.openwebtorrent.com' ],
  [ 'wss://tracker.fastcast.nz' ]
]

var bencode = require('bencode')
var BlockStream = require('block-stream2')
var calcPieceLength = require('piece-length')
var corePath = require('path')
var extend = require('xtend')
var FileReadStream = require('filestream/read')
var flatten = require('flatten')
var fs = require('fs')
var isFile = require('is-file')
var junk = require('junk')
var MultiStream = require('multistream')
var once = require('once')
var parallel = require('run-parallel')
var sha1 = require('simple-sha1')
var stream = require('readable-stream')

/**
 * Create a torrent.
 * @param  {string|File|FileList|Buffer|Stream|Array.<string|File|Buffer|Stream>} input
 * @param  {Object} opts
 * @param  {string=} opts.name
 * @param  {Date=} opts.creationDate
 * @param  {string=} opts.comment
 * @param  {string=} opts.createdBy
 * @param  {boolean|number=} opts.private
 * @param  {number=} opts.pieceLength
 * @param  {Array.<Array.<string>>=} opts.announceList
 * @param  {Array.<string>=} opts.urlList
 * @param  {function} cb
 * @return {Buffer} buffer of .torrent file data
 */
function createTorrent (input, opts, cb) {
  if (typeof opts === 'function') return createTorrent(input, null, opts)
  opts = opts ? extend(opts) : {}

  _parseInput(input, opts, function (err, files, singleFileTorrent) {
    if (err) return cb(err)
    opts.singleFileTorrent = singleFileTorrent
    onFiles(files, opts, cb)
  })
}

function parseInput (input, opts, cb) {
  if (typeof opts === 'function') return parseInput(input, null, opts)
  opts = opts ? extend(opts) : {}
  _parseInput(input, opts, cb)
}

/**
 * Parse input file and return file information.
 */
function _parseInput (input, opts, cb) {
  if (Array.isArray(input) && input.length === 0) throw new Error('invalid input type')

  if (isFileList(input)) input = Array.prototype.slice.call(input)
  if (!Array.isArray(input)) input = [ input ]

  // In Electron, use the true file path
  input = input.map(function (item) {
    if (isBlob(item) && typeof item.path === 'string') return item.path
    return item
  })

  // If there's just one file, allow the name to be set by `opts.name`
  if (input.length === 1 && typeof input[0] !== 'string' && !input[0].name) input[0].name = opts.name

  var commonPrefix = null
  input.forEach(function (item, i) {
    if (typeof item === 'string') {
      return
    }

    var path = item.fullPath || item.name
    if (!path) {
      path = 'Unknown File ' + (i + 1)
      item.unknownName = true
    }

    item.path = path.split('/')

    // Remove initial slash
    if (!item.path[0]) {
      item.path.shift()
    }

    if (item.path.length < 2) { // No real prefix
      commonPrefix = null
    } else if (i === 0 && input.length > 1) { // The first file has a prefix
      commonPrefix = item.path[0]
    } else if (item.path[0] !== commonPrefix) { // The prefix doesn't match
      commonPrefix = null
    }
  })

  // remove junk files
  input = input.filter(function (item) {
    if (typeof item === 'string') {
      return true
    }
    var filename = item.path[item.path.length - 1]
    return notHidden(filename) && junk.not(filename)
  })

  if (commonPrefix) {
    input.forEach(function (item) {
      var pathless = (Buffer.isBuffer(item) || isReadable(item)) && !item.path
      if (typeof item === 'string' || pathless) return
      item.path.shift()
    })
  }

  if (!opts.name && commonPrefix) {
    opts.name = commonPrefix
  }

  if (!opts.name) {
    // use first user-set file name
    input.some(function (item) {
      if (typeof item === 'string') {
        opts.name = corePath.basename(item)
        return true
      } else if (!item.unknownName) {
        opts.name = item.path[item.path.length - 1]
        return true
      }
    })
  }

  if (!opts.name) {
    opts.name = 'Unnamed Torrent ' + Date.now()
  }

  var numPaths = input.reduce(function (sum, item) {
    return sum + Number(typeof item === 'string')
  }, 0)

  var isSingleFileTorrent = (input.length === 1)

  if (input.length === 1 && typeof input[0] === 'string') {
    if (typeof fs.stat !== 'function') {
      throw new Error('filesystem paths do not work in the browser')
    }
    // If there's a single path, verify it's a file before deciding this is a single
    // file torrent
    isFile(input[0], function (err, pathIsFile) {
      if (err) return cb(err)
      isSingleFileTorrent = pathIsFile
      processInput()
    })
  } else {
    process.nextTick(function () {
      processInput()
    })
  }

  function processInput () {
    parallel(input.map(function (item) {
      return function (cb) {
        var file = {}

        if (isBlob(item)) {
          file.getStream = getBlobStream(item)
          file.length = item.size
        } else if (Buffer.isBuffer(item)) {
          file.getStream = getBufferStream(item)
          file.length = item.length
        } else if (isReadable(item)) {
          file.getStream = getStreamStream(item, file)
          file.length = 0
        } else if (typeof item === 'string') {
          if (typeof fs.stat !== 'function') {
            throw new Error('filesystem paths do not work in the browser')
          }
          var keepRoot = numPaths > 1 || isSingleFileTorrent
          getFiles(item, keepRoot, cb)
          return // early return!
        } else {
          throw new Error('invalid input type')
        }
        file.path = item.path
        cb(null, file)
      }
    }), function (err, files) {
      if (err) return cb(err)
      files = flatten(files)
      cb(null, files, isSingleFileTorrent)
    })
  }
}

function getFiles (path, keepRoot, cb) {
  traversePath(path, getFileInfo, function (err, files) {
    if (err) return cb(err)

    if (Array.isArray(files)) files = flatten(files)
    else files = [ files ]

    path = corePath.normalize(path)
    if (keepRoot) {
      path = path.slice(0, path.lastIndexOf(corePath.sep) + 1)
    }
    if (path[path.length - 1] !== corePath.sep) path += corePath.sep

    files.forEach(function (file) {
      file.getStream = getFilePathStream(file.path)
      file.path = file.path.replace(path, '').split(corePath.sep)
    })
    cb(null, files)
  })
}

function getFileInfo (path, cb) {
  cb = once(cb)
  fs.stat(path, function (err, stat) {
    if (err) return cb(err)
    var info = {
      length: stat.size,
      path: path
    }
    cb(null, info)
  })
}

function traversePath (path, fn, cb) {
  fs.readdir(path, function (err, entries) {
    if (err && err.code === 'ENOTDIR') {
      // this is a file
      fn(path, cb)
    } else if (err) {
      // real error
      cb(err)
    } else {
      // this is a folder
      parallel(entries.filter(notHidden).filter(junk.not).map(function (entry) {
        return function (cb) {
          traversePath(corePath.join(path, entry), fn, cb)
        }
      }), cb)
    }
  })
}

function notHidden (file) {
  return file[0] !== '.'
}

function getPieceList (files, pieceLength, cb) {
  cb = once(cb)
  var pieces = []
  var length = 0

  var streams = files.map(function (file) {
    return file.getStream
  })

  var remainingHashes = 0
  var pieceNum = 0
  var ended = false

  var multistream = new MultiStream(streams)
  var blockstream = new BlockStream(pieceLength, { zeroPadding: false })

  multistream.on('error', onError)

  multistream
    .pipe(blockstream)
    .on('data', onData)
    .on('end', onEnd)
    .on('error', onError)

  function onData (chunk) {
    length += chunk.length

    var i = pieceNum
    sha1(chunk, function (hash) {
      pieces[i] = hash
      remainingHashes -= 1
      maybeDone()
    })
    remainingHashes += 1
    pieceNum += 1
  }

  function onEnd () {
    ended = true
    maybeDone()
  }

  function onError (err) {
    cleanup()
    cb(err)
  }

  function cleanup () {
    multistream.removeListener('error', onError)
    blockstream.removeListener('data', onData)
    blockstream.removeListener('end', onEnd)
    blockstream.removeListener('error', onError)
  }

  function maybeDone () {
    if (ended && remainingHashes === 0) {
      cleanup()
      cb(null, new Buffer(pieces.join(''), 'hex'), length)
    }
  }
}

function onFiles (files, opts, cb) {
  var announceList = opts.announceList

  if (!announceList) {
    if (typeof opts.announce === 'string') announceList = [ [ opts.announce ] ]
    else if (Array.isArray(opts.announce)) {
      announceList = opts.announce.map(function (u) { return [ u ] })
    }
  }

  if (!announceList) announceList = []

  if (global.WEBTORRENT_ANNOUNCE) {
    if (typeof global.WEBTORRENT_ANNOUNCE === 'string') {
      announceList.push([ [ global.WEBTORRENT_ANNOUNCE ] ])
    } else if (Array.isArray(global.WEBTORRENT_ANNOUNCE)) {
      announceList = announceList.concat(global.WEBTORRENT_ANNOUNCE.map(function (u) {
        return [ u ]
      }))
    }
  }

  // When no trackers specified, use some reasonable defaults
  if (opts.announce === undefined && opts.announceList === undefined) {
    announceList = announceList.concat(module.exports.announceList)
  }

  if (typeof opts.urlList === 'string') opts.urlList = [ opts.urlList ]

  var torrent = {
    info: {
      name: opts.name
    },
    'creation date': Math.ceil((Number(opts.creationDate) || Date.now()) / 1000),
    encoding: 'UTF-8'
  }

  if (announceList.length !== 0) {
    torrent.announce = announceList[0][0]
    torrent['announce-list'] = announceList
  }

  if (opts.comment !== undefined) torrent.comment = opts.comment

  if (opts.createdBy !== undefined) torrent['created by'] = opts.createdBy

  if (opts.private !== undefined) torrent.info.private = Number(opts.private)

  // "ssl-cert" key is for SSL torrents, see:
  //   - http://blog.libtorrent.org/2012/01/bittorrent-over-ssl/
  //   - http://www.libtorrent.org/manual-ref.html#ssl-torrents
  //   - http://www.libtorrent.org/reference-Create_Torrents.html
  if (opts.sslCert !== undefined) torrent.info['ssl-cert'] = opts.sslCert

  if (opts.urlList !== undefined) torrent['url-list'] = opts.urlList

  var pieceLength = opts.pieceLength || calcPieceLength(files.reduce(sumLength, 0))
  torrent.info['piece length'] = pieceLength

  getPieceList(files, pieceLength, function (err, pieces, torrentLength) {
    if (err) return cb(err)
    torrent.info.pieces = pieces

    files.forEach(function (file) {
      delete file.getStream
    })

    if (opts.singleFileTorrent) {
      torrent.info.length = torrentLength
    } else {
      torrent.info.files = files
    }

    cb(null, bencode.encode(torrent))
  })
}

/**
 * Accumulator to sum file lengths
 * @param  {number} sum
 * @param  {Object} file
 * @return {number}
 */
function sumLength (sum, file) {
  return sum + file.length
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

/**
 * Check if `obj` is a W3C `FileList` object
 * @param  {*} obj
 * @return {boolean}
 */
function isFileList (obj) {
  return typeof FileList === 'function' && obj instanceof FileList
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

/**
 * Convert a `File` to a lazy readable stream.
 * @param  {File|Blob} file
 * @return {function}
 */
function getBlobStream (file) {
  return function () {
    return new FileReadStream(file)
  }
}

/**
 * Convert a `Buffer` to a lazy readable stream.
 * @param  {Buffer} buffer
 * @return {function}
 */
function getBufferStream (buffer) {
  return function () {
    var s = new stream.PassThrough()
    s.end(buffer)
    return s
  }
}

/**
 * Convert a file path to a lazy readable stream.
 * @param  {string} path
 * @return {function}
 */
function getFilePathStream (path) {
  return function () {
    return fs.createReadStream(path)
  }
}

/**
 * Convert a readable stream to a lazy readable stream. Adds instrumentation to track
 * the number of bytes in the stream and set `file.length`.
 *
 * @param  {Stream} stream
 * @param  {Object} file
 * @return {function}
 */
function getStreamStream (readable, file) {
  return function () {
    var counter = new stream.Transform()
    counter._transform = function (buf, enc, done) {
      file.length += buf.length
      this.push(buf)
      done()
    }
    readable.pipe(counter)
    return counter
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":73,"bencode":27,"block-stream2":16,"buffer":20,"filestream/read":36,"flatten":37,"fs":18,"is-file":47,"junk":50,"multistream":61,"once":63,"path":70,"piece-length":71,"readable-stream":86,"run-parallel":90,"simple-sha1":96,"xtend":139}],27:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require( './lib/encode' )
bencode.decode = require( './lib/decode' )

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function( value ) {
  return bencode.encode( value ).length
}

},{"./lib/decode":28,"./lib/encode":30}],28:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":29,"buffer":20}],29:[function(require,module,exports){
var Dict = module.exports = function Dict() {
  Object.defineProperty(this, "_keys", {
    enumerable: false,
    value: [],
  })
}

Dict.prototype.binaryKeys = function binaryKeys() {
  return this._keys.slice()
}

Dict.prototype.binarySet = function binarySet(key, value) {
  this._keys.push(key)

  this[key] = value
}

},{}],30:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],31:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":32}],32:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":60}],33:[function(require,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],34:[function(require,module,exports){
var once = require('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback();
	};

	var onend = function() {
		readable = false;
		if (!writable) callback();
	};

	var onexit = function(exitCode) {
		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;
},{"once":63}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],36:[function(require,module,exports){
var Readable = require('readable-stream').Readable;
var inherits = require('inherits');
var reExtension = /^.*\.(\w+)$/;
var toBuffer = require('typedarray-to-buffer');

function FileReadStream(file, opts) {
  var readStream = this;
  if (! (this instanceof FileReadStream)) {
    return new FileReadStream(file, opts);
  }
  opts = opts || {};

  // inherit readable
  Readable.call(this, opts);

  // save the read offset
  this._offset = 0;
  this._ready = false;
  this._file = file;
  this._size = file.size;
  this._chunkSize = opts.chunkSize || Math.max(this._size / 1000, 200 * 1024);

  // create the reader
  this.reader = new FileReader();

  // generate the header blocks that we will send as part of the initial payload
  this._generateHeaderBlocks(file, opts, function(err, blocks) {
    // if we encountered an error, emit it
    if (err) {
      return readStream.emit('error', err);
    }

    // push the header blocks out to the stream
    if (Array.isArray(blocks)) {
      blocks.forEach(function (block) {
        readStream.push(block);
      });
    }

    readStream._ready = true;
    readStream.emit('_ready');
  });
}

inherits(FileReadStream, Readable);
module.exports = FileReadStream;

FileReadStream.prototype._generateHeaderBlocks = function(file, opts, callback) {
  callback(null, []);
};

FileReadStream.prototype._read = function() {
  if (!this._ready) {
    this.once('_ready', this._read.bind(this));
    return;
  }
  var readStream = this;
  var reader = this.reader;

  var startOffset = this._offset;
  var endOffset = this._offset + this._chunkSize;
  if (endOffset > this._size) endOffset = this._size;

  if (startOffset === this._size) {
    this.destroy();
    this.push(null);
    return;
  }

  reader.onload = function() {
    // update the stream offset
    readStream._offset = endOffset;

    // get the data chunk
    readStream.push(toBuffer(reader.result));
  }
  reader.onerror = function() {
    readStream.emit('error', reader.error);
  }

  reader.readAsArrayBuffer(this._file.slice(startOffset, endOffset));
};

FileReadStream.prototype.destroy = function() {
  this._file = null;
  if (this.reader) {
    this.reader.onload = null;
    this.reader.onerror = null;
    try { this.reader.abort(); } catch (e) {};
  }
  this.reader = null;
}

},{"inherits":43,"readable-stream":86,"typedarray-to-buffer":113}],37:[function(require,module,exports){
module.exports = function flatten(list, depth) {
  depth = (typeof depth == 'number') ? depth : Infinity;

  if (!depth) {
    if (Array.isArray(list)) {
      return list.map(function(i) { return i; });
    }
    return list;
  }

  return _flatten(list, 1);

  function _flatten(list, d) {
    return list.reduce(function (acc, item) {
      if (Array.isArray(item) && d < depth) {
        return acc.concat(_flatten(item, d + 1));
      }
      else {
        return acc.concat(item);
      }
    }, []);
  }
};

},{}],38:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof window === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||
      window.webkitRTCPeerConnection,
    RTCSessionDescription: window.RTCSessionDescription ||
      window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
    RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||
      window.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],39:[function(require,module,exports){
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};

},{}],40:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":99}],41:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],42:[function(require,module,exports){
(function (process){
module.exports = ImmediateStore

function ImmediateStore (store) {
  if (!(this instanceof ImmediateStore)) return new ImmediateStore(store)

  this.store = store
  this.chunkLength = store.chunkLength

  if (!this.store || !this.store.get || !this.store.put) {
    throw new Error('First argument must be abstract-chunk-store compliant')
  }

  this.mem = []
}

ImmediateStore.prototype.put = function (index, buf, cb) {
  var self = this
  self.mem[index] = buf
  self.store.put(index, buf, function (err) {
    self.mem[index] = null
    if (cb) cb(err)
  })
}

ImmediateStore.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)

  var start = (opts && opts.offset) || 0
  var end = opts && opts.length && (start + opts.length)

  var buf = this.mem[index]
  if (buf) return nextTick(cb, null, opts ? buf.slice(start, end) : buf)

  this.store.get(index, opts, cb)
}

ImmediateStore.prototype.close = function (cb) {
  this.store.close(cb)
}

ImmediateStore.prototype.destroy = function (cb) {
  this.store.destroy(cb)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":73}],43:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],44:[function(require,module,exports){
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

  ipaddr = {};

  root = this;

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var rangeName, rangeSubnets, subnet, _i, _len;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
        subnet = rangeSubnets[_i];
        if (address.match.apply(address, subnet)) {
          return rangeName;
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var octet, _i, _len;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (_i = 0, _len = octets.length; _i < _len; _i++) {
        octet = octets[_i];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, octet, stop, zeros, zerotable, _i;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = _i = 3; _i >= 0; i = _i += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var _i, _len, _ref, _results;
        _ref = match.slice(1, 6);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(parseIntAuto(part));
        }
        return _results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var _i, _results;
        _results = [];
        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
          _results.push((value >> shift) & 0xff);
        }
        return _results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts) {
      var i, part, _i, _j, _len, _ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = _i = 0; _i <= 14; i = _i += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      _ref = this.parts;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        part = _ref[_j];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
      stringParts = (function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this);
      compactStringParts = [];
      pushPart = function(part) {
        return compactStringParts.push(part);
      };
      state = 0;
      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
        part = stringParts[_i];
        switch (state) {
          case 0:
            if (part === '0') {
              pushPart('');
            } else {
              pushPart(part);
            }
            state = 1;
            break;
          case 1:
            if (part === '0') {
              state = 2;
            } else {
              pushPart(part);
            }
            break;
          case 2:
            if (part !== '0') {
              pushPart('');
              pushPart(part);
              state = 3;
            }
            break;
          case 3:
            pushPart(part);
        }
      }
      if (state === 2) {
        pushPart('');
        pushPart('');
      }
      return compactStringParts.join(":");
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, part, _i, _len, _ref;
      bytes = [];
      _ref = this.parts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var part;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this)).join(":");
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, _ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  ipv6Regexes = {
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    return (function() {
      var _i, _len, _ref, _results;
      _ref = string.split(":");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        _results.push(parseInt(part, 16));
      }
      return _results;
    })();
  };

  ipaddr.IPv6.parser = function(string) {
    var match, octet, octets, parts, _i, _len;
    if (string.match(ipv6Regexes['native'])) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      parts = expandIPv6(match[1].slice(0, -1), 6);
      if (parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (_i = 0, _len = octets.length; _i < _len; _i++) {
          octet = octets[_i];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        parts.push(octets[0] << 8 | octets[1]);
        parts.push(octets[2] << 8 | octets[3]);
        return parts;
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (_error) {
      e = _error;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (_error) {
        e = _error;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);

},{}],45:[function(require,module,exports){
/* (c) 2016 Ari Porad (@ariporad) <http://ariporad.com>. License: ariporad.mit-license.org */

// Partially from http://stackoverflow.com/a/94049/1928484, and from another SO answer, which told me that the highest
// char code that's ascii is 127, but I can't find the link for. Sorry.

var MAX_ASCII_CHAR_CODE = 127;

module.exports = function isAscii(str) {
  for (var i = 0, strLen = str.length; i < strLen; ++i) {
    if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE) return false;
  }
  return true;
};

},{}],46:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],47:[function(require,module,exports){
'use strict';

var fs = require('fs');

module.exports = function isFile(path, cb){
  if(!cb)return isFileSync(path);

  fs.stat(path, function(err, stats){
    if(err)return cb(err);
    return cb(null, stats.isFile());
  });
};

module.exports.sync = isFileSync;

function isFileSync(path){
  return fs.existsSync(path) && fs.statSync(path).isFile();
}

},{"fs":18}],48:[function(require,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],49:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],50:[function(require,module,exports){
'use strict';

// // All
// /^npm-debug\.log$/,   // npm error log
// /^\..*\.swp$/,        // vim state
// // OS X
// /^\.DS_Store$/,       // stores custom folder attributes
// /^\.AppleDouble$/,    // stores additional file resources
// /^\.LSOverride$/,     // contains the absolute path to the app to be used
// /^Icon[\r\?]?/,       // custom Finder icon
// /^\._.*/,             // thumbnail
// /^\.Spotlight-V100$/,  // file that might appear on external disk
// /\.Trashes/,          // file that might appear on external disk
// /^__MACOSX$/,         // resource fork
// // Linux
// /~$/,                 // backup file
// // Windows
// /^Thumbs\.db$/,       // image file cache
// /^ehthumbs\.db$/,     // folder config file
// /^Desktop\.ini$/      // stores custom folder attributes

exports.re = /^npm-debug\.log$|^\..*\.swp$|^\.DS_Store$|^\.AppleDouble$|^\.LSOverride$|^Icon[\r\?]?|^\._.*|^\.Spotlight-V100$|\.Trashes|^__MACOSX$|~$|^Thumbs\.db$|^ehthumbs\.db$|^Desktop\.ini$/;

exports.is = function (filename) {
	return exports.re.test(filename);
};

exports.not = exports.isnt = function (filename) {
	return !exports.is(filename);
};

},{}],51:[function(require,module,exports){
(function (Buffer){
module.exports = magnetURIDecode
module.exports.decode = magnetURIDecode
module.exports.encode = magnetURIEncode

var base32 = require('thirty-two')
var extend = require('xtend')
var uniq = require('uniq')

/**
 * Parse a magnet URI and return an object of keys/values
 *
 * @param  {string} uri
 * @return {Object} parsed uri
 */
function magnetURIDecode (uri) {
  var result = {}

  // Support 'magnet:' and 'stream-magnet:' uris
  var data = uri.split('magnet:?')[1]

  var params = (data && data.length >= 0)
    ? data.split('&')
    : []

  params.forEach(function (param) {
    var keyval = param.split('=')

    // This keyval is invalid, skip it
    if (keyval.length !== 2) return

    var key = keyval[0]
    var val = keyval[1]

    // Clean up torrent name
    if (key === 'dn') val = decodeURIComponent(val).replace(/\+/g, ' ')

    // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded
    // URIs, so decode them
    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
      val = decodeURIComponent(val)
    }

    // Return keywords as an array
    if (key === 'kt') val = decodeURIComponent(val).split('+')

    // If there are repeated parameters, return an array of values
    if (result[key]) {
      if (Array.isArray(result[key])) {
        result[key].push(val)
      } else {
        var old = result[key]
        result[key] = [old, val]
      }
    } else {
      result[key] = val
    }
  })

  // Convenience properties for parity with `parse-torrent-file` module
  var m
  if (result.xt) {
    var xts = Array.isArray(result.xt) ? result.xt : [ result.xt ]
    xts.forEach(function (xt) {
      if ((m = xt.match(/^urn:btih:(.{40})/))) {
        result.infoHash = m[1].toLowerCase()
      } else if ((m = xt.match(/^urn:btih:(.{32})/))) {
        var decodedStr = base32.decode(m[1])
        result.infoHash = new Buffer(decodedStr, 'binary').toString('hex')
      }
    })
  }
  if (result.infoHash) result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  if (result.dn) result.name = result.dn
  if (result.kt) result.keywords = result.kt

  if (typeof result.tr === 'string') result.announce = [ result.tr ]
  else if (Array.isArray(result.tr)) result.announce = result.tr
  else result.announce = []

  result.urlList = []
  if (typeof result.as === 'string' || Array.isArray(result.as)) {
    result.urlList = result.urlList.concat(result.as)
  }
  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {
    result.urlList = result.urlList.concat(result.ws)
  }

  uniq(result.announce)
  uniq(result.urlList)

  return result
}

function magnetURIEncode (obj) {
  obj = extend(obj) // clone obj, so we can mutate it

  // support using convenience names, in addition to spec names
  // (example: `infoHash` for `xt`, `name` for `dn`)
  if (obj.infoHashBuffer) obj.xt = 'urn:btih:' + obj.infoHashBuffer.toString('hex')
  if (obj.infoHash) obj.xt = 'urn:btih:' + obj.infoHash
  if (obj.name) obj.dn = obj.name
  if (obj.keywords) obj.kt = obj.keywords
  if (obj.announce) obj.tr = obj.announce
  if (obj.urlList) {
    obj.ws = obj.urlList
    delete obj.as
  }

  var result = 'magnet:?'
  Object.keys(obj)
    .filter(function (key) {
      return key.length === 2
    })
    .forEach(function (key, i) {
      var values = Array.isArray(obj[key]) ? obj[key] : [ obj[key] ]
      values.forEach(function (val, j) {
        if ((i > 0 || j > 0) && (key !== 'kt' || j === 0)) result += '&'

        if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+')
        if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
          val = encodeURIComponent(val)
        }
        if (key === 'kt') val = encodeURIComponent(val)

        if (key === 'kt' && j > 0) result += '+' + val
        else result += key + '=' + val
      })
    })

  return result
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"thirty-two":108,"uniq":115,"xtend":139}],52:[function(require,module,exports){
module.exports = MediaElementWrapper

var inherits = require('inherits')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var MediaSource = typeof window !== 'undefined' && window.MediaSource

var DEFAULT_BUFFER_DURATION = 60 // seconds

function MediaElementWrapper (elem, opts) {
  var self = this
  if (!(self instanceof MediaElementWrapper)) return new MediaElementWrapper(elem, opts)

  if (!MediaSource) throw new Error('web browser lacks MediaSource support')

  if (!opts) opts = {}
  self._bufferDuration = opts.bufferDuration || DEFAULT_BUFFER_DURATION
  self._elem = elem
  self._mediaSource = new MediaSource()
  self._streams = []
  self.detailedError = null

  self._errorHandler = function () {
    self._elem.removeEventListener('error', self._errorHandler)
    var streams = self._streams.slice()
    streams.forEach(function (stream) {
      stream.destroy(self._elem.error)
    })
  }
  self._elem.addEventListener('error', self._errorHandler)

  self._elem.src = window.URL.createObjectURL(self._mediaSource)
}

/*
 * `obj` can be a previous value returned by this function
 * or a string
 */
MediaElementWrapper.prototype.createWriteStream = function (obj) {
  var self = this

  return new MediaSourceStream(self, obj)
}

/*
 * Use to trigger an error on the underlying media element
 */
MediaElementWrapper.prototype.error = function (err) {
  var self = this

  // be careful not to overwrite any existing detailedError values
  if (!self.detailedError) {
    self.detailedError = err
  }
  try {
    self._mediaSource.endOfStream('decode')
  } catch (err) {}
}

inherits(MediaSourceStream, stream.Writable)

function MediaSourceStream (wrapper, obj) {
  var self = this
  stream.Writable.call(self)

  self._wrapper = wrapper
  self._elem = wrapper._elem
  self._mediaSource = wrapper._mediaSource
  self._allStreams = wrapper._streams
  self._allStreams.push(self)
  self._bufferDuration = wrapper._bufferDuration
  self._sourceBuffer = null

  self._openHandler = function () {
    self._onSourceOpen()
  }
  self._flowHandler = function () {
    self._flow()
  }

  if (typeof obj === 'string') {
    self._type = obj
    // Need to create a new sourceBuffer
    if (self._mediaSource.readyState === 'open') {
      self._createSourceBuffer()
    } else {
      self._mediaSource.addEventListener('sourceopen', self._openHandler)
    }
  } else if (obj._sourceBuffer === null) {
    obj.destroy()
    self._type = obj._type // The old stream was created but hasn't finished initializing
    self._mediaSource.addEventListener('sourceopen', self._openHandler)
  } else if (obj._sourceBuffer) {
    obj.destroy()
    self._type = obj._type
    self._sourceBuffer = obj._sourceBuffer // Copy over the old sourceBuffer
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
  } else {
    throw new Error('The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function')
  }

  self._elem.addEventListener('timeupdate', self._flowHandler)

  self.on('error', function (err) {
    self._wrapper.error(err)
  })

  self.on('finish', function () {
    if (self.destroyed) return
    self._finished = true
    if (self._allStreams.every(function (other) { return other._finished })) {
      try {
        self._mediaSource.endOfStream()
      } catch (err) {}
    }
  })
}

MediaSourceStream.prototype._onSourceOpen = function () {
  var self = this
  if (self.destroyed) return

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._createSourceBuffer()
}

MediaSourceStream.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  // Remove from allStreams
  self._allStreams.splice(self._allStreams.indexOf(self), 1)

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._elem.removeEventListener('timeupdate', self._flowHandler)
  if (self._sourceBuffer) {
    self._sourceBuffer.removeEventListener('updateend', self._flowHandler)
    if (self._mediaSource.readyState === 'open') {
      self._sourceBuffer.abort()
    }
  }

  if (err) self.emit('error', err)
  self.emit('close')
}

MediaSourceStream.prototype._createSourceBuffer = function () {
  var self = this
  if (self.destroyed) return

  if (MediaSource.isTypeSupported(self._type)) {
    self._sourceBuffer = self._mediaSource.addSourceBuffer(self._type)
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
    if (self._cb) {
      var cb = self._cb
      self._cb = null
      cb()
    }
  } else {
    self.destroy(new Error('The provided type is not supported'))
  }
}

MediaSourceStream.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return
  if (!self._sourceBuffer) {
    self._cb = function (err) {
      if (err) return cb(err)
      self._write(chunk, encoding, cb)
    }
    return
  }

  if (self._sourceBuffer.updating) {
    return cb(new Error('Cannot append buffer while source buffer updating'))
  }

  try {
    self._sourceBuffer.appendBuffer(toArrayBuffer(chunk))
  } catch (err) {
    // appendBuffer can throw for a number of reasons, most notably when the data
    // being appended is invalid or if appendBuffer is called after another error
    // already occurred on the media element. In Chrome, there may be useful debugging
    // info in chrome://media-internals
    self.destroy(err)
    return
  }
  self._cb = cb
}

MediaSourceStream.prototype._flow = function () {
  var self = this

  if (self.destroyed || !self._sourceBuffer || self._sourceBuffer.updating) {
    return
  }

  if (self._mediaSource.readyState === 'open') {
    // check buffer size
    if (self._getBufferDuration() > self._bufferDuration) {
      return
    }
  }

  if (self._cb) {
    var cb = self._cb
    self._cb = null
    cb()
  }
}

// TODO: if zero actually works in all browsers, remove the logic associated with this below
var EPSILON = 0

MediaSourceStream.prototype._getBufferDuration = function () {
  var self = this

  var buffered = self._sourceBuffer.buffered
  var currentTime = self._elem.currentTime
  var bufferEnd = -1 // end of the buffer
  // This is a little over complex because some browsers seem to separate the
  // buffered region into multiple sections with slight gaps.
  for (var i = 0; i < buffered.length; i++) {
    var start = buffered.start(i)
    var end = buffered.end(i) + EPSILON

    if (start > currentTime) {
      // Reached past the joined buffer
      break
    } else if (bufferEnd >= 0 || currentTime <= end) {
      // Found the start/continuation of the joined buffer
      bufferEnd = end
    }
  }

  var bufferedTime = bufferEnd - currentTime
  if (bufferedTime < 0) {
    bufferedTime = 0
  }

  return bufferedTime
}

},{"inherits":43,"readable-stream":86,"to-arraybuffer":110}],53:[function(require,module,exports){
(function (process){
module.exports = Storage

function Storage (chunkLength, opts) {
  if (!(this instanceof Storage)) return new Storage(chunkLength, opts)
  if (!opts) opts = {}

  this.chunkLength = Number(chunkLength)
  if (!this.chunkLength) throw new Error('First argument must be a chunk length')

  this.chunks = []
  this.closed = false
  this.length = Number(opts.length) || Infinity

  if (this.length !== Infinity) {
    this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength
    this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1
  }
}

Storage.prototype.put = function (index, buf, cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))

  var isLastChunk = (index === this.lastChunkIndex)
  if (isLastChunk && buf.length !== this.lastChunkLength) {
    return nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))
  }
  if (!isLastChunk && buf.length !== this.chunkLength) {
    return nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))
  }
  this.chunks[index] = buf
  nextTick(cb, null)
}

Storage.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  var buf = this.chunks[index]
  if (!buf) return nextTick(cb, new Error('Chunk not found'))
  if (!opts) return nextTick(cb, null, buf)
  var offset = opts.offset || 0
  var len = opts.length || (buf.length - offset)
  nextTick(cb, null, buf.slice(offset, len + offset))
}

Storage.prototype.close = Storage.prototype.destroy = function (cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  this.closed = true
  this.chunks = null
  nextTick(cb, null)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":73}],54:[function(require,module,exports){
(function (Buffer){
// This is an intentionally recursive require. I don't like it either.
var Box = require('./index')
var Descriptor = require('./descriptor')

var TIME_OFFSET = 2082844800000

/*
TODO:
test these
add new box versions
*/

// These have 'version' and 'flags' fields in the headers
exports.fullBoxes = {}
var fullBoxes = [
  'mvhd',
  'tkhd',
  'mdhd',
  'vmhd',
  'smhd',
  'stsd',
  'esds',
  'stsz',
  'stco',
  'stss',
  'stts',
  'ctts',
  'stsc',
  'dref',
  'elst',
  'hdlr',
  'mehd',
  'trex',
  'mfhd',
  'tfhd',
  'tfdt',
  'trun'
]
fullBoxes.forEach(function (type) {
  exports.fullBoxes[type] = true
})

exports.ftyp = {}
exports.ftyp.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.ftyp.encodingLength(box))
  var brands = box.compatibleBrands || []
  buf.write(box.brand, 0, 4, 'ascii')
  buf.writeUInt32BE(box.brandVersion, 4)
  for (var i = 0; i < brands.length; i++) buf.write(brands[i], 8 + (i * 4), 4, 'ascii')
  exports.ftyp.encode.bytes = 8 + brands.length * 4
  return buf
}
exports.ftyp.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var brand = buf.toString('ascii', 0, 4)
  var version = buf.readUInt32BE(4)
  var compatibleBrands = []
  for (var i = 8; i < buf.length; i += 4) compatibleBrands.push(buf.toString('ascii', i, i + 4))
  return {
    brand: brand,
    brandVersion: version,
    compatibleBrands: compatibleBrands
  }
}
exports.ftyp.encodingLength = function (box) {
  return 8 + (box.compatibleBrands || []).length * 4
}

exports.mvhd = {}
exports.mvhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(96)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  writeFixed32(box.preferredRate || 0, buf, 16)
  writeFixed16(box.preferredVolume || 0, buf, 20)
  writeReserved(buf, 22, 32)
  writeMatrix(box.matrix, buf, 32)
  buf.writeUInt32BE(box.previewTime || 0, 68)
  buf.writeUInt32BE(box.previewDuration || 0, 72)
  buf.writeUInt32BE(box.posterTime || 0, 76)
  buf.writeUInt32BE(box.selectionTime || 0, 80)
  buf.writeUInt32BE(box.selectionDuration || 0, 84)
  buf.writeUInt32BE(box.currentTime || 0, 88)
  buf.writeUInt32BE(box.nextTrackId || 0, 92)
  exports.mvhd.encode.bytes = 96
  return buf
}
exports.mvhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    preferredRate: readFixed32(buf, 16),
    preferredVolume: readFixed16(buf, 20),
    matrix: readMatrix(buf.slice(32, 68)),
    previewTime: buf.readUInt32BE(68),
    previewDuration: buf.readUInt32BE(72),
    posterTime: buf.readUInt32BE(76),
    selectionTime: buf.readUInt32BE(80),
    selectionDuration: buf.readUInt32BE(84),
    currentTime: buf.readUInt32BE(88),
    nextTrackId: buf.readUInt32BE(92)
  }
}
exports.mvhd.encodingLength = function (box) {
  return 96
}

exports.tkhd = {}
exports.tkhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(80)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.trackId || 0, 8)
  writeReserved(buf, 12, 16)
  buf.writeUInt32BE(box.duration || 0, 16)
  writeReserved(buf, 20, 28)
  buf.writeUInt16BE(box.layer || 0, 28)
  buf.writeUInt16BE(box.alternateGroup || 0, 30)
  buf.writeUInt16BE(box.volume || 0, 32)
  writeMatrix(box.matrix, buf, 36)
  buf.writeUInt32BE(box.trackWidth || 0, 72)
  buf.writeUInt32BE(box.trackHeight || 0, 76)
  exports.tkhd.encode.bytes = 80
  return buf
}
exports.tkhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    trackId: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(16),
    layer: buf.readUInt16BE(28),
    alternateGroup: buf.readUInt16BE(30),
    volume: buf.readUInt16BE(32),
    matrix: readMatrix(buf.slice(36, 72)),
    trackWidth: buf.readUInt32BE(72),
    trackHeight: buf.readUInt32BE(76)
  }
}
exports.tkhd.encodingLength = function (box) {
  return 80
}

exports.mdhd = {}
exports.mdhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  buf.writeUInt16BE(box.language || 0, 16)
  buf.writeUInt16BE(box.quality || 0, 18)
  exports.mdhd.encode.bytes = 20
  return buf
}
exports.mdhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    language: buf.readUInt16BE(16),
    quality: buf.readUInt16BE(18)
  }
}
exports.mdhd.encodingLength = function (box) {
  return 20
}

exports.vmhd = {}
exports.vmhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8)
  buf.writeUInt16BE(box.graphicsMode || 0, 0)
  var opcolor = box.opcolor || [0, 0, 0]
  buf.writeUInt16BE(opcolor[0], 2)
  buf.writeUInt16BE(opcolor[1], 4)
  buf.writeUInt16BE(opcolor[2], 6)
  exports.vmhd.encode.bytes = 8
  return buf
}
exports.vmhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    graphicsMode: buf.readUInt16BE(0),
    opcolor: [buf.readUInt16BE(2), buf.readUInt16BE(4), buf.readUInt16BE(6)]
  }
}
exports.vmhd.encodingLength = function (box) {
  return 8
}

exports.smhd = {}
exports.smhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt16BE(box.balance || 0, 0)
  writeReserved(buf, 2, 4)
  exports.smhd.encode.bytes = 4
  return buf
}
exports.smhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    balance: buf.readUInt16BE(0)
  }
}
exports.smhd.encodingLength = function (box) {
  return 4
}

exports.stsd = {}
exports.stsd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsd.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    Box.encode(entry, buf, ptr)
    ptr += Box.encode.bytes
  }

  exports.stsd.encode.bytes = ptr
  return buf
}
exports.stsd.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var entry = Box.decode(buf, ptr, end)
    entries[i] = entry
    ptr += entry.length
  }

  return {
    entries: entries
  }
}
exports.stsd.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    totalSize += Box.encodingLength(box.entries[i])
  }
  return totalSize
}

exports.avc1 = exports.VisualSampleEntry = {}
exports.VisualSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.VisualSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 24)
  buf.writeUInt16BE(box.width || 0, 24)
  buf.writeUInt16BE(box.height || 0, 26)
  buf.writeUInt32BE(box.hResolution || 0x480000, 28)
  buf.writeUInt32BE(box.vResolution || 0x480000, 32)
  writeReserved(buf, 36, 40)
  buf.writeUInt16BE(box.frameCount || 1, 40)
  var compressorName = box.compressorName || ''
  var nameLen = Math.min(compressorName.length, 31)
  buf.writeUInt8(nameLen, 42)
  buf.write(compressorName, 43, nameLen, 'utf8')
  buf.writeUInt16BE(box.depth || 0x18, 74)
  buf.writeInt16BE(-1, 76)

  var ptr = 78
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.VisualSampleEntry.encode.bytes = ptr
}
exports.VisualSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var length = end - offset
  var nameLen = Math.min(buf.readUInt8(42), 31)
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    width: buf.readUInt16BE(24),
    height: buf.readUInt16BE(26),
    hResolution: buf.readUInt32BE(28),
    vResolution: buf.readUInt32BE(32),
    frameCount: buf.readUInt16BE(40),
    compressorName: buf.toString('utf8', 43, 43 + nameLen),
    depth: buf.readUInt16BE(74),
    children: []
  }

  var ptr = 78
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.VisualSampleEntry.encodingLength = function (box) {
  var len = 78
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.avcC = {}
exports.avcC.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf)
  exports.avcC.encode.bytes = box.buffer.length
}
exports.avcC.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  return {
    mimeCodec: buf.toString('hex', 1, 4),
    buffer: new Buffer(buf)
  }
}
exports.avcC.encodingLength = function (box) {
  return box.buffer.length
}

exports.mp4a = exports.AudioSampleEntry = {}
exports.AudioSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.AudioSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 16)
  buf.writeUInt16BE(box.channelCount || 2, 16)
  buf.writeUInt16BE(box.sampleSize || 16, 18)
  writeReserved(buf, 20, 24)
  buf.writeUInt32BE(box.sampleRate || 0, 24)

  var ptr = 28
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.AudioSampleEntry.encode.bytes = ptr
}
exports.AudioSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)
  var length = end - offset
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    channelCount: buf.readUInt16BE(16),
    sampleSize: buf.readUInt16BE(18),
    sampleRate: buf.readUInt32BE(24),
    children: []
  }

  var ptr = 28
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.AudioSampleEntry.encodingLength = function (box) {
  var len = 28
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.esds = {}
exports.esds.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf, 0)
  exports.esds.encode.bytes = box.buffer.length
}
exports.esds.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  var desc = Descriptor.Descriptor.decode(buf, 0, buf.length)
  var esd = (desc.tagName === 'ESDescriptor') ? desc : {}
  var dcd = esd.DecoderConfigDescriptor || {}
  var oti = dcd.oti || 0
  var dsi = dcd.DecoderSpecificInfo
  var audioConfig = dsi ? (dsi.buffer.readUInt8(0) & 0xf8) >> 3 : 0

  var mimeCodec = null
  if (oti) {
    mimeCodec = oti.toString(16)
    if (audioConfig) {
      mimeCodec += '.' + audioConfig
    }
  }

  return {
    mimeCodec: mimeCodec,
    buffer: new Buffer(buf.slice(0))
  }
}
exports.esds.encodingLength = function (box) {
  return box.buffer.length
}

// TODO: integrate the two versions in a saner way
exports.stsz = {}
exports.stsz.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : Buffer(exports.stsz.encodingLength(box))

  buf.writeUInt32BE(0, 0)
  buf.writeUInt32BE(entries.length, 4)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 8)
  }

  exports.stsz.encode.bytes = 8 + entries.length * 4
  return buf
}
exports.stsz.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var size = buf.readUInt32BE(0)
  var num = buf.readUInt32BE(4)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    if (size === 0) {
      entries[i] = buf.readUInt32BE(i * 4 + 8)
    } else {
      entries[i] = size
    }
  }

  return {
    entries: entries
  }
}
exports.stsz.encodingLength = function (box) {
  return 8 + box.entries.length * 4
}

exports.stss =
exports.stco = {}
exports.stco.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stco.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 4)
  }

  exports.stco.encode.bytes = 4 + entries.length * 4
  return buf
}
exports.stco.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    entries[i] = buf.readUInt32BE(i * 4 + 4)
  }

  return {
    entries: entries
  }
}
exports.stco.encodingLength = function (box) {
  return 4 + box.entries.length * 4
}

exports.stts = {}
exports.stts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].duration || 0, ptr + 4)
  }

  exports.stts.encode.bytes = 4 + box.entries.length * 8
  return buf
}
exports.stts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      duration: buf.readUInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.stts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.ctts = {}
exports.ctts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.ctts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].compositionOffset || 0, ptr + 4)
  }

  exports.ctts.encode.bytes = 4 + entries.length * 8
  return buf
}
exports.ctts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      compositionOffset: buf.readInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.ctts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.stsc = {}
exports.stsc.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsc.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].firstChunk || 0, ptr)
    buf.writeUInt32BE(entries[i].samplesPerChunk || 0, ptr + 4)
    buf.writeUInt32BE(entries[i].sampleDescriptionId || 0, ptr + 8)
  }

  exports.stsc.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.stsc.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      firstChunk: buf.readUInt32BE(ptr),
      samplesPerChunk: buf.readUInt32BE(ptr + 4),
      sampleDescriptionId: buf.readUInt32BE(ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.stsc.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.dref = {}
exports.dref.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.dref.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    var size = (entry.buf ? entry.buf.length : 0) + 4 + 4

    buf.writeUInt32BE(size, ptr)
    ptr += 4

    buf.write(entry.type, ptr, 4, 'ascii')
    ptr += 4

    if (entry.buf) {
      entry.buf.copy(buf, ptr)
      ptr += entry.buf.length
    }
  }

  exports.dref.encode.bytes = ptr
  return buf
}
exports.dref.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var size = buf.readUInt32BE(ptr)
    var type = buf.toString('ascii', ptr + 4, ptr + 8)
    var tmp = buf.slice(ptr + 8, ptr + size)
    ptr += size

    entries[i] = {
      type: type,
      buf: tmp
    }
  }

  return {
    entries: entries
  }
}
exports.dref.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    var buf = box.entries[i].buf
    totalSize += (buf ? buf.length : 0) + 4 + 4
  }
  return totalSize
}

exports.elst = {}
exports.elst.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.elst.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].trackDuration || 0, ptr)
    buf.writeUInt32BE(entries[i].mediaTime || 0, ptr + 4)
    writeFixed32(entries[i].mediaRate || 0, buf, ptr + 8)
  }

  exports.elst.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.elst.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      trackDuration: buf.readUInt32BE(ptr),
      mediaTime: buf.readInt32BE(ptr + 4),
      mediaRate: readFixed32(buf, ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.elst.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.hdlr = {}
exports.hdlr.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.hdlr.encodingLength(box))

  var len = 21 + (box.name || '').length
  buf.fill(0, 0, len)

  buf.write(box.handlerType || '', 4, 4, 'ascii')
  writeString(box.name || '', buf, 20)

  exports.hdlr.encode.bytes = len
  return buf
}
exports.hdlr.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  return {
    handlerType: buf.toString('ascii', 4, 8),
    name: readString(buf, 20, end)
  }
}
exports.hdlr.encodingLength = function (box) {
  return 21 + (box.name || '').length
}

exports.mehd = {}
exports.mehd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.fragmentDuration || 0, 0)
  exports.mehd.encode.bytes = 4
  return buf
}
exports.mehd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    fragmentDuration: buf.readUInt32BE(0)
  }
}
exports.mehd.encodingLength = function (box) {
  return 4
}

exports.trex = {}
exports.trex.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)

  buf.writeUInt32BE(box.trackId || 0, 0)
  buf.writeUInt32BE(box.defaultSampleDescriptionIndex || 0, 4)
  buf.writeUInt32BE(box.defaultSampleDuration || 0, 8)
  buf.writeUInt32BE(box.defaultSampleSize || 0, 12)
  buf.writeUInt32BE(box.defaultSampleFlags || 0, 16)
  exports.trex.encode.bytes = 20
  return buf
}
exports.trex.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    trackId: buf.readUInt32BE(0),
    defaultSampleDescriptionIndex: buf.readUInt32BE(4),
    defaultSampleDuration: buf.readUInt32BE(8),
    defaultSampleSize: buf.readUInt32BE(12),
    defaultSampleFlags: buf.readUInt32BE(16)
  }
}
exports.trex.encodingLength = function (box) {
  return 20
}

exports.mfhd = {}
exports.mfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.sequenceNumber || 0, 0)
  exports.mfhd.encode.bytes = 4
  return buf
}
exports.mfhd.decode = function (buf, offset) {
  return {
    sequenceNumber: buf.readUint32BE(0)
  }
}
exports.mfhd.encodingLength = function (box) {
  return 4
}

exports.tfhd = {}
exports.tfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt32BE(box.trackId, 0)
  exports.tfhd.encode.bytes = 4
  return buf
}
exports.tfhd.decode = function (buf, offset) {
  // TODO: this
}
exports.tfhd.encodingLength = function (box) {
  // TODO: this is wrong!
  return 4
}

exports.tfdt = {}
exports.tfdt.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.baseMediaDecodeTime || 0, 0)
  exports.tfdt.encode.bytes = 4
  return buf
}
exports.tfdt.decode = function (buf, offset) {
  // TODO: this
}
exports.tfdt.encodingLength = function (box) {
  return 4
}

exports.trun = {}
exports.trun.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8 + box.entries.length * 16)

  // TODO: this is wrong
  buf.writeUInt32BE(box.entries.length, 0)
  buf.writeInt32BE(box.dataOffset, 4)
  var ptr = 8
  for (var i = 0; i < box.entries.length; i++) {
    var entry = box.entries[i]
    buf.writeUInt32BE(entry.sampleDuration, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleSize, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleFlags, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleCompositionTimeOffset, ptr)
    ptr += 4
  }
  exports.trun.encode.bytes = ptr
}
exports.trun.decode = function (buf, offset) {
  // TODO: this
}
exports.trun.encodingLength = function (box) {
  // TODO: this is wrong
  return 8 + box.entries.length * 16
}

exports.mdat = {}
exports.mdat.encode = function (box, buf, offset) {
  if (box.buffer) {
    box.buffer.copy(buf, offset)
    exports.mdat.encode.bytes = box.buffer.length
  } else {
    exports.mdat.encode.bytes = exports.mdat.encodingLength(box)
  }
}
exports.mdat.decode = function (buf, start, end) {
  return {
    buffer: new Buffer(buf.slice(start, end))
  }
}
exports.mdat.encodingLength = function (box) {
  return box.buffer ? box.buffer.length : box.contentLength
}

function writeReserved (buf, offset, end) {
  for (var i = offset; i < end; i++) buf[i] = 0
}

function writeDate (date, buf, offset) {
  buf.writeUInt32BE(Math.floor((date.getTime() + TIME_OFFSET) / 1000), offset)
}

// TODO: think something is wrong here
function writeFixed32 (num, buf, offset) {
  buf.writeUInt16BE(Math.floor(num) % (256 * 256), offset)
  buf.writeUInt16BE(Math.floor(num * 256 * 256) % (256 * 256), offset + 2)
}

function writeFixed16 (num, buf, offset) {
  buf[offset] = Math.floor(num) % 256
  buf[offset + 1] = Math.floor(num * 256) % 256
}

function writeMatrix (list, buf, offset) {
  if (!list) list = [0, 0, 0, 0, 0, 0, 0, 0, 0]
  for (var i = 0; i < list.length; i++) {
    writeFixed32(list[i], buf, offset + i * 4)
  }
}

function writeString (str, buf, offset) {
  var strBuffer = new Buffer(str, 'utf8')
  strBuffer.copy(buf, offset)
  buf[offset + strBuffer.length] = 0
}

function readMatrix (buf) {
  var list = new Array(buf.length / 4)
  for (var i = 0; i < list.length; i++) list[i] = readFixed32(buf, i * 4)
  return list
}

function readDate (buf, offset) {
  return new Date(buf.readUInt32BE(offset) * 1000 - TIME_OFFSET)
}

function readFixed32 (buf, offset) {
  return buf.readUInt16BE(offset) + buf.readUInt16BE(offset + 2) / (256 * 256)
}

function readFixed16 (buf, offset) {
  return buf[offset] + buf[offset + 1] / 256
}

function readString (buf, offset, length) {
  var i
  for (i = 0; i < length; i++) {
    if (buf[offset + i] === 0) {
      break
    }
  }
  return buf.toString('utf8', offset, offset + i)
}

}).call(this,require("buffer").Buffer)

},{"./descriptor":55,"./index":56,"buffer":20}],55:[function(require,module,exports){
(function (Buffer){
var tagToName = {
  0x03: 'ESDescriptor',
  0x04: 'DecoderConfigDescriptor',
  0x05: 'DecoderSpecificInfo',
  0x06: 'SLConfigDescriptor'
}

exports.Descriptor = {}
exports.Descriptor.decode = function (buf, start, end) {
  var tag = buf.readUInt8(start)
  var ptr = start + 1
  var lenByte
  var len = 0
  do {
    lenByte = buf.readUInt8(ptr++)
    len = (len << 7) | (lenByte & 0x7f)
  } while (lenByte & 0x80)

  var obj
  var tagName = tagToName[tag] // May be undefined; that's ok
  if (exports[tagName]) {
    obj = exports[tagName].decode(buf, ptr, end)
  } else {
    obj = {
      buffer: new Buffer(buf.slice(ptr, ptr + len))
    }
  }

  obj.tag = tag
  obj.tagName = tagName
  obj.length = (ptr - start) + len
  obj.contentsLen = len
  return obj
}

exports.DescriptorArray = {}
exports.DescriptorArray.decode = function (buf, start, end) {
  var ptr = start
  var obj = {}
  while (ptr + 2 <= end) {
    var descriptor = exports.Descriptor.decode(buf, ptr, end)
    ptr += descriptor.length
    var tagName = tagToName[descriptor.tag] || ('Descriptor' + descriptor.tag)
    obj[tagName] = descriptor
  }
  return obj
}

exports.ESDescriptor = {}
exports.ESDescriptor.decode = function (buf, start, end) {
  var flags = buf.readUInt8(start + 2)
  var ptr = start + 3
  if (flags & 0x80) {
    ptr += 2
  }
  if (flags & 0x40) {
    var len = buf.readUInt8(ptr)
    ptr += len + 1
  }
  if (flags & 0x20) {
    ptr += 2
  }
  return exports.DescriptorArray.decode(buf, ptr, end)
}

exports.DecoderConfigDescriptor = {}
exports.DecoderConfigDescriptor.decode = function (buf, start, end) {
  var oti = buf.readUInt8(start)
  var obj = exports.DescriptorArray.decode(buf, start + 13, end)
  obj.oti = oti
  return obj
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],56:[function(require,module,exports){
(function (Buffer){
// var assert = require('assert')
var uint64be = require('uint64be')

var boxes = require('./boxes')

var UINT32_MAX = 4294967295

var Box = exports

/*
 * Lists the proper order for boxes inside containers.
 * Five-character names ending in 's' indicate arrays instead of single elements.
 */
var containers = exports.containers = {
  'moov': ['mvhd', 'meta', 'traks', 'mvex'],
  'trak': ['tkhd', 'tref', 'trgr', 'edts', 'meta', 'mdia', 'udta'],
  'edts': ['elst'],
  'mdia': ['mdhd', 'hdlr', 'elng', 'minf'],
  'minf': ['vmhd', 'smhd', 'hmhd', 'sthd', 'nmhd', 'dinf', 'stbl'],
  'dinf': ['dref'],
  'stbl': ['stsd', 'stts', 'ctts', 'cslg', 'stsc', 'stsz', 'stz2', 'stco', 'co64', 'stss', 'stsh', 'padb', 'stdp', 'sdtp', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios'],
  'mvex': ['mehd', 'trexs', 'leva'],
  'moof': ['mfhd', 'meta', 'trafs'],
  'traf': ['tfhd', 'trun', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios', 'tfdt', 'meta']
}

Box.encode = function (obj, buffer, offset) {
  Box.encodingLength(obj) // sets every level appropriately
  offset = offset || 0
  buffer = buffer || new Buffer(obj.length)
  return Box._encode(obj, buffer, offset)
}

Box._encode = function (obj, buffer, offset) {
  var type = obj.type
  var len = obj.length
  if (len > UINT32_MAX) {
    len = 1
  }
  buffer.writeUInt32BE(len, offset)
  buffer.write(obj.type, offset + 4, 4, 'ascii')
  var ptr = offset + 8
  if (len === 1) {
    uint64be.encode(obj.length, buffer, ptr)
    ptr += 8
  }
  if (boxes.fullBoxes[type]) {
    buffer.writeUInt32BE(obj.flags || 0, ptr)
    buffer.writeUInt8(obj.version || 0, ptr)
    ptr += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          Box._encode(child, buffer, ptr)
          ptr += Box.encode.bytes
        })
      } else if (obj[childType]) {
        Box._encode(obj[childType], buffer, ptr)
        ptr += Box.encode.bytes
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        Box._encode(child, buffer, ptr)
        ptr += Box.encode.bytes
      })
    }
  } else if (boxes[type]) {
    var encode = boxes[type].encode
    encode(obj, buffer, ptr)
    ptr += encode.bytes
  } else if (obj.buffer) {
    var buf = obj.buffer
    buf.copy(buffer, ptr)
    ptr += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  Box.encode.bytes = ptr - offset
  // assert.equal(ptr - offset, obj.length, 'Error encoding \'' + type + '\': wrote ' + ptr - offset + ' bytes, expecting ' + obj.length)
  return buffer
}

/*
 * Returns an object with `type` and `size` fields,
 * or if there isn't enough data, returns the total
 * number of bytes needed to read the headers
 */
Box.readHeaders = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  if (end - start < 8) {
    return 8
  }

  var len = buffer.readUInt32BE(start)
  var type = buffer.toString('ascii', start + 4, start + 8)
  var ptr = start + 8

  if (len === 1) {
    if (end - start < 16) {
      return 16
    }

    len = uint64be.decode(buffer, ptr)
    ptr += 8
  }

  var version
  var flags
  if (boxes.fullBoxes[type]) {
    version = buffer.readUInt8(ptr)
    flags = buffer.readUInt32BE(ptr) & 0xffffff
    ptr += 4
  }

  return {
    length: len,
    headersLen: ptr - start,
    contentLen: len - (ptr - start),
    type: type,
    version: version,
    flags: flags
  }
}

Box.decode = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var headers = Box.readHeaders(buffer, start, end)
  if (!headers || headers.length > end - start) {
    throw new Error('Data too short')
  }

  return Box.decodeWithoutHeaders(headers, buffer, start + headers.headersLen, start + headers.length)
}

Box.decodeWithoutHeaders = function (headers, buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var type = headers.type
  var obj = {}
  if (containers[type]) {
    obj.otherBoxes = []
    var contents = containers[type]
    var ptr = start
    while (end - ptr >= 8) {
      var child = Box.decode(buffer, ptr, end)
      ptr += child.length
      if (contents.indexOf(child.type) >= 0) {
        obj[child.type] = child
      } else if (contents.indexOf(child.type + 's') >= 0) {
        var childType = child.type + 's'
        var entry = obj[childType] = obj[childType] || []
        entry.push(child)
      } else {
        obj.otherBoxes.push(child)
      }
    }
  } else if (boxes[type]) {
    var decode = boxes[type].decode
    obj = decode(buffer, start, end)
  } else {
    obj.buffer = new Buffer(buffer.slice(start, end))
  }

  obj.length = headers.length
  obj.contentLen = headers.contentLen
  obj.type = headers.type
  obj.version = headers.version
  obj.flags = headers.flags
  return obj
}

Box.encodingLength = function (obj) {
  var type = obj.type

  var len = 8
  if (boxes.fullBoxes[type]) {
    len += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          child.type = childType
          len += Box.encodingLength(child)
        })
      } else if (obj[childType]) {
        var child = obj[childType]
        child.type = childType
        len += Box.encodingLength(child)
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        len += Box.encodingLength(child)
      })
    }
  } else if (boxes[type]) {
    len += boxes[type].encodingLength(obj)
  } else if (obj.buffer) {
    len += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  if (len > UINT32_MAX) {
    len += 8
  }

  obj.length = len
  return len
}

}).call(this,require("buffer").Buffer)

},{"./boxes":54,"buffer":20,"uint64be":114}],57:[function(require,module,exports){
(function (Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var nextEvent = require('next-event')
var Box = require('mp4-box-encoding')

var EMPTY = new Buffer(0)

module.exports = Decoder

function Decoder () {
  if (!(this instanceof Decoder)) return new Decoder()
  stream.Writable.call(this)

  this.destroyed = false

  this._pending = 0
  this._missing = 0
  this._buf = null
  this._str = null
  this._cb = null
  this._ondrain = null
  this._writeBuffer = null
  this._writeCb = null

  this._ondrain = null
  this._kick()
}

inherits(Decoder, stream.Writable)

Decoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (err) this.emit('error', err)
  this.emit('close')
}

Decoder.prototype._write = function (data, enc, next) {
  if (this.destroyed) return
  var drained = !this._str || !this._str._writableState.needDrain

  while (data.length && !this.destroyed) {
    if (!this._missing) {
      this._writeBuffer = data
      this._writeCb = next
      return
    }

    var consumed = data.length < this._missing ? data.length : this._missing
    if (this._buf) data.copy(this._buf, this._buf.length - this._missing)
    else if (this._str) drained = this._str.write(consumed === data.length ? data : data.slice(0, consumed))

    this._missing -= consumed

    if (!this._missing) {
      var buf = this._buf
      var cb = this._cb
      var stream = this._str

      this._buf = this._cb = this._str = this._ondrain = null
      drained = true

      if (stream) stream.end()
      if (cb) cb(buf)
    }

    data = consumed === data.length ? EMPTY : data.slice(consumed)
  }

  if (this._pending && !this._missing) {
    this._writeBuffer = data
    this._writeCb = next
    return
  }

  if (drained) next()
  else this._ondrain(next)
}

Decoder.prototype._buffer = function (size, cb) {
  this._missing = size
  this._buf = new Buffer(size)
  this._cb = cb
}

Decoder.prototype._stream = function (size, cb) {
  var self = this
  this._missing = size
  this._str = new MediaData(this)
  this._ondrain = nextEvent(this._str, 'drain')
  this._pending++
  this._str.on('end', function () {
    self._pending--
    self._kick()
  })
  this._cb = cb
  return this._str
}

Decoder.prototype._readBox = function () {
  var self = this
  bufferHeaders(8)

  function bufferHeaders (len, buf) {
    self._buffer(len, function (additionalBuf) {
      if (buf) {
        buf = Buffer.concat(buf, additionalBuf)
      } else {
        buf = additionalBuf
      }
      var headers = Box.readHeaders(buf)
      if (typeof headers === 'number') {
        bufferHeaders(headers - buf.length, buf)
      } else {
        self._pending++
        self._headers = headers
        self.emit('box', headers)
      }
    })
  }
}

Decoder.prototype.stream = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  return self._stream(headers.contentLen, null)
}

Decoder.prototype.decode = function (cb) {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  self._buffer(headers.contentLen, function (buf) {
    var box = Box.decodeWithoutHeaders(headers, buf)
    cb(box)
    self._pending--
    self._kick()
  })
}

Decoder.prototype.ignore = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  this._missing = headers.contentLen
  this._cb = function () {
    self._pending--
    self._kick()
  }
}

Decoder.prototype._kick = function () {
  if (this._pending) return
  if (!this._buf && !this._str) this._readBox()
  if (this._writeBuffer) {
    var next = this._writeCb
    var buffer = this._writeBuffer
    this._writeBuffer = null
    this._writeCb = null
    this._write(buffer, null, next)
  }
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"inherits":43,"mp4-box-encoding":56,"next-event":62,"readable-stream":86}],58:[function(require,module,exports){
(function (process,Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var Box = require('mp4-box-encoding')

module.exports = Encoder

function noop () {}

function Encoder () {
  if (!(this instanceof Encoder)) return new Encoder()
  stream.Readable.call(this)

  this.destroyed = false

  this._reading = false
  this._stream = null
  this._drain = null
  this._want = false
  this._onreadable = onreadable
  this._onend = onend

  var self = this

  function onreadable () {
    if (!self._want) return
    self._want = false
    self._read()
  }

  function onend () {
    self._stream = null
  }
}

inherits(Encoder, stream.Readable)

Encoder.prototype.mediaData =
Encoder.prototype.mdat = function (size, cb) {
  var stream = new MediaData(this)
  this.box({type: 'mdat', contentLength: size, encodeBufferLen: 8, stream: stream}, cb)
  return stream
}

Encoder.prototype.box = function (box, cb) {
  if (!cb) cb = noop
  if (this.destroyed) return cb(new Error('Encoder is destroyed'))

  var buf
  if (box.encodeBufferLen) {
    buf = new Buffer(box.encodeBufferLen)
  }
  if (box.stream) {
    box.buffer = null
    buf = Box.encode(box, buf)
    this.push(buf)
    this._stream = box.stream
    this._stream.on('readable', this._onreadable)
    this._stream.on('end', this._onend)
    this._stream.on('end', cb)
    this._forward()
  } else {
    buf = Box.encode(box, buf)
    var drained = this.push(buf)
    if (drained) return process.nextTick(cb)
    this._drain = cb
  }
}

Encoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (this._stream && this._stream.destroy) this._stream.destroy()
  this._stream = null
  if (this._drain) {
    var cb = this._drain
    this._drain = null
    cb(err)
  }
  if (err) this.emit('error', err)
  this.emit('close')
}

Encoder.prototype.finalize = function () {
  this.push(null)
}

Encoder.prototype._forward = function () {
  if (!this._stream) return

  while (!this.destroyed) {
    var buf = this._stream.read()

    if (!buf) {
      this._want = !!this._stream
      return
    }

    if (!this.push(buf)) return
  }
}

Encoder.prototype._read = function () {
  if (this._reading || this.destroyed) return
  this._reading = true

  if (this._stream) this._forward()
  if (this._drain) {
    var drain = this._drain
    this._drain = null
    drain()
  }

  this._reading = false
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":73,"buffer":20,"inherits":43,"mp4-box-encoding":56,"readable-stream":86}],59:[function(require,module,exports){
exports.decode = require('./decode')
exports.encode = require('./encode')

},{"./decode":57,"./encode":58}],60:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],61:[function(require,module,exports){
module.exports = MultiStream

var inherits = require('inherits')
var stream = require('readable-stream')

inherits(MultiStream, stream.Readable)

function MultiStream (streams, opts) {
  if (!(this instanceof MultiStream)) return new MultiStream(streams, opts)
  stream.Readable.call(this, opts)

  this.destroyed = false

  this._drained = false
  this._forwarding = false
  this._current = null
  this._queue = (typeof streams === 'function' ? streams : streams.map(toStreams2))

  this._next()
}

MultiStream.obj = function (streams) {
  return new MultiStream(streams, { objectMode: true, highWaterMark: 16 })
}

MultiStream.prototype._read = function () {
  this._drained = true
  this._forward()
}

MultiStream.prototype._forward = function () {
  if (this._forwarding || !this._drained || !this._current) return
  this._forwarding = true

  var chunk
  while ((chunk = this._current.read()) !== null) {
    this._drained = this.push(chunk)
  }

  this._forwarding = false
}

MultiStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (this._current && this._current.destroy) this._current.destroy()
  if (typeof this._queue !== 'function') {
    this._queue.forEach(function (stream) {
      if (stream.destroy) stream.destroy()
    })
  }

  if (err) this.emit('error', err)
  this.emit('close')
}

MultiStream.prototype._next = function () {
  var self = this
  self._current = null

  if (typeof self._queue === 'function') {
    self._queue(function (err, stream) {
      if (err) return self.destroy(err)
      self._gotNextStream(toStreams2(stream))
    })
  } else {
    var stream = self._queue.shift()
    if (typeof stream === 'function') stream = toStreams2(stream())
    self._gotNextStream(stream)
  }
}

MultiStream.prototype._gotNextStream = function (stream) {
  var self = this

  if (!stream) {
    self.push(null)
    self.destroy()
    return
  }

  self._current = stream
  self._forward()

  stream.on('readable', onReadable)
  stream.on('end', onEnd)
  stream.on('error', onError)
  stream.on('close', onClose)

  function onReadable () {
    self._forward()
  }

  function onClose () {
    if (!stream._readableState.ended) {
      self.destroy()
    }
  }

  function onEnd () {
    self._current = null
    stream.removeListener('readable', onReadable)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onError)
    stream.removeListener('close', onClose)
    self._next()
  }

  function onError (err) {
    self.destroy(err)
  }
}

function toStreams2 (s) {
  if (!s || typeof s === 'function' || s._readableState) return s

  var wrap = new stream.Readable().wrap(s)
  if (s.destroy) {
    wrap.destroy = s.destroy.bind(s)
  }
  return wrap
}

},{"inherits":43,"readable-stream":86}],62:[function(require,module,exports){
module.exports = nextEvent

function nextEvent (emitter, name) {
  var next = null
  emitter.on(name, function (data) {
    if (!next) return
    var fn = next
    next = null
    fn(data)
  })

  return function (once) {
    next = once
  }
}

},{}],63:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":138}],64:[function(require,module,exports){
(function (Buffer){
module.exports = decodeTorrentFile
module.exports.decode = decodeTorrentFile
module.exports.encode = encodeTorrentFile

var bencode = require('bencode')
var path = require('path')
var sha1 = require('simple-sha1')
var uniq = require('uniq')

/**
 * Parse a torrent. Throws an exception if the torrent is missing required fields.
 * @param  {Buffer|Object} torrent
 * @return {Object}        parsed torrent
 */
function decodeTorrentFile (torrent) {
  if (Buffer.isBuffer(torrent)) {
    torrent = bencode.decode(torrent)
  }

  // sanity check
  ensure(torrent.info, 'info')
  ensure(torrent.info['name.utf-8'] || torrent.info.name, 'info.name')
  ensure(torrent.info['piece length'], 'info[\'piece length\']')
  ensure(torrent.info.pieces, 'info.pieces')

  if (torrent.info.files) {
    torrent.info.files.forEach(function (file) {
      ensure(typeof file.length === 'number', 'info.files[0].length')
      ensure(file['path.utf-8'] || file.path, 'info.files[0].path')
    })
  } else {
    ensure(typeof torrent.info.length === 'number', 'info.length')
  }

  var result = {}
  result.info = torrent.info
  result.infoBuffer = bencode.encode(torrent.info)
  result.infoHash = sha1.sync(result.infoBuffer)
  result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  result.name = (torrent.info['name.utf-8'] || torrent.info.name).toString()

  if (torrent.info.private !== undefined) result.private = !!torrent.info.private

  if (torrent['creation date']) result.created = new Date(torrent['creation date'] * 1000)
  if (torrent['created by']) result.createdBy = torrent['created by'].toString()

  if (Buffer.isBuffer(torrent.comment)) result.comment = torrent.comment.toString()

  // announce and announce-list will be missing if metadata fetched via ut_metadata
  result.announce = []
  if (torrent['announce-list'] && torrent['announce-list'].length) {
    torrent['announce-list'].forEach(function (urls) {
      urls.forEach(function (url) {
        result.announce.push(url.toString())
      })
    })
  } else if (torrent.announce) {
    result.announce.push(torrent.announce.toString())
  }

  // handle url-list (BEP19 / web seeding)
  if (Buffer.isBuffer(torrent['url-list'])) {
    // some clients set url-list to empty string
    torrent['url-list'] = torrent['url-list'].length > 0
      ? [ torrent['url-list'] ]
      : []
  }
  result.urlList = (torrent['url-list'] || []).map(function (url) {
    return url.toString()
  })

  uniq(result.announce)
  uniq(result.urlList)

  var files = torrent.info.files || [ torrent.info ]
  result.files = files.map(function (file, i) {
    var parts = [].concat(result.name, file['path.utf-8'] || file.path || []).map(function (p) {
      return p.toString()
    })
    return {
      path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
      name: parts[parts.length - 1],
      length: file.length,
      offset: files.slice(0, i).reduce(sumLength, 0)
    }
  })

  result.length = files.reduce(sumLength, 0)

  var lastFile = result.files[result.files.length - 1]

  result.pieceLength = torrent.info['piece length']
  result.lastPieceLength = ((lastFile.offset + lastFile.length) % result.pieceLength) || result.pieceLength
  result.pieces = splitPieces(torrent.info.pieces)

  return result
}

/**
 * Convert a parsed torrent object back into a .torrent file buffer.
 * @param  {Object} parsed parsed torrent
 * @return {Buffer}
 */
function encodeTorrentFile (parsed) {
  var torrent = {
    info: parsed.info
  }

  torrent['announce-list'] = (parsed.announce || []).map(function (url) {
    if (!torrent.announce) torrent.announce = url
    url = new Buffer(url, 'utf8')
    return [ url ]
  })

  torrent['url-list'] = parsed.urlList || []

  if (parsed.created) {
    torrent['creation date'] = (parsed.created.getTime() / 1000) | 0
  }

  if (parsed.createdBy) {
    torrent['created by'] = parsed.createdBy
  }

  if (parsed.comment) {
    torrent.comment = parsed.comment
  }

  return bencode.encode(torrent)
}

function sumLength (sum, file) {
  return sum + file.length
}

function splitPieces (buf) {
  var pieces = []
  for (var i = 0; i < buf.length; i += 20) {
    pieces.push(buf.slice(i, i + 20).toString('hex'))
  }
  return pieces
}

function ensure (bool, fieldName) {
  if (!bool) throw new Error('Torrent is missing required field: ' + fieldName)
}

}).call(this,require("buffer").Buffer)

},{"bencode":65,"buffer":20,"path":70,"simple-sha1":96,"uniq":115}],65:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./lib/decode":66,"./lib/encode":68,"dup":27}],66:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":67,"buffer":20}],67:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],68:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],69:[function(require,module,exports){
(function (process,Buffer){
/* global Blob */

module.exports = parseTorrent
module.exports.remote = parseTorrentRemote

var blobToBuffer = require('blob-to-buffer')
var fs = require('fs') // browser exclude
var get = require('simple-get')
var magnet = require('magnet-uri')
var parseTorrentFile = require('parse-torrent-file')

module.exports.toMagnetURI = magnet.encode
module.exports.toTorrentFile = parseTorrentFile.encode

/**
 * Parse a torrent identifier (magnet uri, .torrent file, info hash)
 * @param  {string|Buffer|Object} torrentId
 * @return {Object}
 */
function parseTorrent (torrentId) {
  if (typeof torrentId === 'string' && /^(stream-)?magnet:/.test(torrentId)) {
    // magnet uri (string)
    return magnet(torrentId)
  } else if (typeof torrentId === 'string' && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
    // info hash (hex/base-32 string)
    return magnet('magnet:?xt=urn:btih:' + torrentId)
  } else if (Buffer.isBuffer(torrentId) && torrentId.length === 20) {
    // info hash (buffer)
    return magnet('magnet:?xt=urn:btih:' + torrentId.toString('hex'))
  } else if (Buffer.isBuffer(torrentId)) {
    // .torrent file (buffer)
    return parseTorrentFile(torrentId) // might throw
  } else if (torrentId && torrentId.infoHash) {
    // parsed torrent (from `parse-torrent`, `parse-torrent-file`, or `magnet-uri`)
    if (!torrentId.announce) torrentId.announce = []
    if (typeof torrentId.announce === 'string') {
      torrentId.announce = [ torrentId.announce ]
    }
    if (!torrentId.urlList) torrentId.urlList = []
    return torrentId
  } else {
    throw new Error('Invalid torrent identifier')
  }
}

function parseTorrentRemote (torrentId, cb) {
  var parsedTorrent
  if (typeof cb !== 'function') throw new Error('second argument must be a Function')

  try {
    parsedTorrent = parseTorrent(torrentId)
  } catch (err) {
    // If torrent fails to parse, it could be a Blob, http/https URL or
    // filesystem path, so don't consider it an error yet.
  }

  if (parsedTorrent && parsedTorrent.infoHash) {
    process.nextTick(function () {
      cb(null, parsedTorrent)
    })
  } else if (isBlob(torrentId)) {
    blobToBuffer(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Error converting Blob: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof get === 'function' && /^https?:/.test(torrentId)) {
    // http, or https url to torrent file
    get.concat({
      url: torrentId,
      headers: { 'user-agent': 'WebTorrent (http://webtorrent.io)' }
    }, function (err, res, torrentBuf) {
      if (err) return cb(new Error('Error downloading torrent: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof fs.readFile === 'function' && typeof torrentId === 'string') {
    // assume it's a filesystem path
    fs.readFile(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Invalid torrent identifier'))
      parseOrThrow(torrentBuf)
    })
  } else {
    process.nextTick(function () {
      cb(new Error('Invalid torrent identifier'))
    })
  }

  function parseOrThrow (torrentBuf) {
    try {
      parsedTorrent = parseTorrent(torrentBuf)
    } catch (err) {
      return cb(err)
    }
    if (parsedTorrent && parsedTorrent.infoHash) cb(null, parsedTorrent)
    else cb(new Error('Invalid torrent identifier'))
  }
}

/**
 * Check if `obj` is a W3C `Blob` or `File` object
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

// Workaround Browserify v13 bug
// https://github.com/substack/node-browserify/issues/1483
;(function () { Buffer(0) })()

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":73,"blob-to-buffer":15,"buffer":20,"fs":18,"magnet-uri":51,"parse-torrent-file":64,"simple-get":94}],70:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":73}],71:[function(require,module,exports){
var closest = require('closest-to')

// Create a range from 16kb–4mb
var sizes = []
for (var i = 14; i <= 22; i++) {
  sizes.push(Math.pow(2, i))
}

module.exports = function(size) {
  return closest(
    size / Math.pow(2, 10), sizes 
  )
}

},{"closest-to":23}],72:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":73}],73:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],74:[function(require,module,exports){
var once = require('once')
var eos = require('end-of-stream')
var fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close() // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

},{"end-of-stream":34,"fs":18,"once":63}],75:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],77:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],78:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":76,"./encode":77}],79:[function(require,module,exports){
var iterate = function (list) {
  var offset = 0
  return function () {
    if (offset === list.length) return null

    var len = list.length - offset
    var i = (Math.random() * len) | 0
    var el = list[offset + i]

    var tmp = list[offset]
    list[offset] = el
    list[offset + i] = tmp
    offset++

    return el
  }
}

module.exports = iterate

},{}],80:[function(require,module,exports){
/*
Instance of writable stream.

call .get(length) or .discard(length) to get a stream (relative to the last end)

emits 'stalled' once everything is written


*/
var inherits = require('inherits')
var stream = require('readable-stream')

module.exports = RangeSliceStream

inherits(RangeSliceStream, stream.Writable)

function RangeSliceStream (offset) {
	var self = this
	if (!(self instanceof RangeSliceStream)) return new RangeSliceStream(offset)
	stream.Writable.call(self)

	self.destroyed = false
	self._queue = []
	self._position = offset || 0
	self._cb = null
	self._buffer = null
	self._out = null
}

RangeSliceStream.prototype._write = function (chunk, encoding, cb) {
	var self = this

	var drained = true

	while (true) {
		if (self.destroyed) {
			return
		}

		// Wait for more queue entries
		if (self._queue.length === 0) {
			self._buffer = chunk
			self._cb = cb
			return
		}

		self._buffer = null
		var currRange = self._queue[0]
		// Relative to the start of chunk, what data do we need?
		var writeStart = Math.max(currRange.start - self._position, 0)
		var writeEnd = currRange.end - self._position

		// Check if we need to throw it all away
		if (writeStart >= chunk.length) {
			self._position += chunk.length
			return cb(null)
		}

		// Check if we need to use it all
		var toWrite
		if (writeEnd > chunk.length) {
			self._position += chunk.length
			if (writeStart === 0) {
				toWrite = chunk
			} else {
				toWrite = chunk.slice(writeStart)
			}
			drained = currRange.stream.write(toWrite) && drained
			break
		}

		self._position += writeEnd
		if (writeStart === 0 && writeEnd === chunk.length) {
			toWrite = chunk
		} else {
			toWrite = chunk.slice(writeStart, writeEnd)
		}
		drained = currRange.stream.write(toWrite) && drained
		if (currRange.last) {
			currRange.stream.end()
		}
		chunk = chunk.slice(writeEnd)
		self._queue.shift()
	}

	if (drained) {
		cb(null)
	} else {
		currRange.stream.once('drain', cb.bind(null, null))
	}
}

RangeSliceStream.prototype.slice = function (ranges) {
	var self = this

	if (self.destroyed) return null

	if (!(ranges instanceof Array)) {
		ranges = [ranges]
	}

	var str = new stream.PassThrough()

	ranges.forEach(function (range, i) {
		self._queue.push({
			start: range.start,
			end: range.end,
			stream: str,
			last: i === (ranges.length - 1)
		})
	})
	if (self._buffer) {
		self._write(self._buffer, null, self._cb)
	}

	return str
}

RangeSliceStream.prototype.destroy = function (err) {
	var self = this
	if (self.destroyed) return
	self.destroyed = true

	if (err) self.emit('error', err)
}

},{"inherits":43,"readable-stream":86}],81:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":83,"./_stream_writable":85,"core-util-is":25,"inherits":43,"process-nextick-args":72}],82:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":84,"core-util-is":25,"inherits":43}],83:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var hasPrependListener = typeof EE.prototype.prependListener === 'function';

function prependListener(emitter, event, fn) {
  if (hasPrependListener) return emitter.prependListener(event, fn);

  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS. This is here
  // only because this code needs to continue to work with older versions
  // of Node.js that do not include the prependListener() method. The goal
  // is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var _buf = list[0];
        var cpy = Math.min(n - c, _buf.length);

        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);

        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":81,"_process":73,"buffer":20,"buffer-shims":19,"core-util-is":25,"events":35,"inherits":43,"isarray":49,"process-nextick-args":72,"string_decoder/":107,"util":17}],84:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":81,"core-util-is":25,"inherits":43}],85:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":81,"_process":73,"buffer":20,"buffer-shims":19,"core-util-is":25,"events":35,"inherits":43,"process-nextick-args":72,"util-deprecate":125}],86:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":81,"./lib/_stream_passthrough.js":82,"./lib/_stream_readable.js":83,"./lib/_stream_transform.js":84,"./lib/_stream_writable.js":85,"_process":73}],87:[function(require,module,exports){
exports.render = render
exports.append = append
var mime = exports.mime = require('./lib/mime.json')

var debug = require('debug')('render-media')
var isAscii = require('is-ascii')
var MediaElementWrapper = require('mediasource')
var path = require('path')
var streamToBlobURL = require('stream-to-blob-url')
var videostream = require('videostream')

var VIDEOSTREAM_EXTS = [ '.mp4', '.m4v', '.m4a' ]

var MEDIASOURCE_VIDEO_EXTS = [ '.mp4', '.m4v', '.webm', '.mkv' ]
var MEDIASOURCE_AUDIO_EXTS = [ '.m4a', '.mp3' ]
var MEDIASOURCE_EXTS = MEDIASOURCE_VIDEO_EXTS.concat(MEDIASOURCE_AUDIO_EXTS)

var AUDIO_EXTS = [ '.wav', '.aac', '.ogg', '.oga' ]
var IMAGE_EXTS = [ '.jpg', '.jpeg', '.png', '.gif', '.bmp' ]
var IFRAME_EXTS = [ '.css', '.html', '.js', '.md', '.pdf', '.txt' ]

var MediaSource = typeof window !== 'undefined' && window.MediaSource

function render (file, elem, cb) {
  validateFile(file)
  if (typeof elem === 'string') elem = document.querySelector(elem)

  renderMedia(file, function (tagName) {
    if (elem.nodeName !== tagName.toUpperCase()) {
      var extname = path.extname(file.name).toLowerCase()

      throw new Error(
        'Cannot render "' + extname + '" inside a "' +
        elem.nodeName.toLowerCase() + '" element, expected "' + tagName + '"'
      )
    }

    return elem
  }, cb)
}

function append (file, rootElem, cb) {
  if (!cb) cb = function () {}
  validateFile(file)
  if (typeof rootElem === 'string') rootElem = document.querySelector(rootElem)

  if (rootElem && (rootElem.nodeName === 'VIDEO' || rootElem.nodeName === 'AUDIO')) {
    throw new Error(
      'Invalid video/audio node argument. Argument must be root element that ' +
      'video/audio tag will be appended to.'
    )
  }

  renderMedia(file, function (tagName) {
    if (tagName === 'video' || tagName === 'audio') return createMedia(tagName)
    else return createElem(tagName)
  }, function (err, elem) {
    if (err && elem) elem.remove()
    cb(err, elem)
  })

  function createMedia (tagName) {
    var elem = createElem(tagName)
    elem.controls = true
    elem.autoplay = true
    rootElem.appendChild(elem)
    return elem
  }

  function createElem (tagName) {
    var elem = document.createElement(tagName)
    rootElem.appendChild(elem)
    return elem
  }
}

function renderMedia (file, getElem, cb) {
  if (!cb) cb = function () {}
  var extname = path.extname(file.name).toLowerCase()
  var currentTime = 0
  var elem

  if (MEDIASOURCE_EXTS.indexOf(extname) >= 0) {
    renderMediaSource()
  } else if (AUDIO_EXTS.indexOf(extname) >= 0) {
    renderAudio()
  } else if (IMAGE_EXTS.indexOf(extname) >= 0) {
    renderImage()
  } else if (IFRAME_EXTS.indexOf(extname) >= 0) {
    renderIframe()
  } else {
    tryRenderIframe()
  }

  function renderMediaSource () {
    var tagName = MEDIASOURCE_VIDEO_EXTS.indexOf(extname) >= 0 ? 'video' : 'audio'

    if (MediaSource) {
      if (VIDEOSTREAM_EXTS.indexOf(extname) >= 0) {
        useVideostream()
      } else {
        useMediaSource()
      }
    } else {
      useBlobURL()
    }

    function useVideostream () {
      debug('Use `videostream` package for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToMediaSource)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      videostream(file, elem)
    }

    function useMediaSource () {
      debug('Use MediaSource API for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToBlobURL)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)

      var wrapper = new MediaElementWrapper(elem)
      var writable = wrapper.createWriteStream(getCodec(file.name))
      file.createReadStream().pipe(writable)

      if (currentTime) elem.currentTime = currentTime
    }

    function useBlobURL () {
      debug('Use Blob URL for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      getBlobURL(file, function (err, url) {
        if (err) return fatalError(err)
        elem.src = url
        if (currentTime) elem.currentTime = currentTime
      })
    }

    function fallbackToMediaSource (err) {
      debug('videostream error: fallback to MediaSource API: %o', err.message || err)
      elem.removeEventListener('error', fallbackToMediaSource)
      elem.removeEventListener('canplay', onCanPlay)

      useMediaSource()
    }

    function fallbackToBlobURL (err) {
      debug('MediaSource API error: fallback to Blob URL: %o', err.message || err)
      elem.removeEventListener('error', fallbackToBlobURL)
      elem.removeEventListener('canplay', onCanPlay)

      useBlobURL()
    }

    function prepareElem () {
      if (!elem) {
        elem = getElem(tagName)

        elem.addEventListener('progress', function () {
          currentTime = elem.currentTime
        })
      }
    }
  }

  function renderAudio () {
    elem = getElem('audio')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      elem.src = url
    })
  }

  function onLoadStart () {
    elem.removeEventListener('loadstart', onLoadStart)
    elem.play()
  }

  function onCanPlay () {
    elem.removeEventListener('canplay', onCanPlay)
    cb(null, elem)
  }

  function renderImage () {
    elem = getElem('img')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      elem.alt = file.name
      cb(null, elem)
    })
  }

  function renderIframe () {
    elem = getElem('iframe')

    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      if (extname !== '.pdf') elem.sandbox = 'allow-forms allow-scripts'
      cb(null, elem)
    })
  }

  function tryRenderIframe () {
    debug('Unknown file extension "%s" - will attempt to render into iframe', extname)

    var str = ''
    file.createReadStream({ start: 0, end: 1000 })
      .setEncoding('utf8')
      .on('data', function (chunk) {
        str += chunk
      })
      .on('end', done)
      .on('error', cb)

    function done () {
      if (isAscii(str)) {
        debug('File extension "%s" appears ascii, so will render.', extname)
        renderIframe()
      } else {
        debug('File extension "%s" appears non-ascii, will not render.', extname)
        cb(new Error('Unsupported file type "' + extname + '": Cannot append to DOM'))
      }
    }
  }

  function fatalError (err) {
    err.message = 'Error rendering file "' + file.name + '": ' + err.message
    debug(err.message)
    cb(err)
  }
}

function getBlobURL (file, cb) {
  var extname = path.extname(file.name).toLowerCase()
  streamToBlobURL(file.createReadStream(), mime[extname], cb)
}

function validateFile (file) {
  if (file == null) {
    throw new Error('file cannot be null or undefined')
  }
  if (typeof file.name !== 'string') {
    throw new Error('missing or invalid file.name property')
  }
  if (typeof file.createReadStream !== 'function') {
    throw new Error('missing or invalid file.createReadStream property')
  }
}

function getCodec (name) {
  var extname = path.extname(name).toLowerCase()
  return {
    '.m4a': 'audio/mp4; codecs="mp4a.40.5"',
    '.m4v': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.mkv': 'video/webm; codecs="avc1.640029, mp4a.40.5"',
    '.mp3': 'audio/mpeg',
    '.mp4': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.webm': 'video/webm; codecs="vorbis, vp8"'
  }[extname]
}

},{"./lib/mime.json":88,"debug":31,"is-ascii":45,"mediasource":52,"path":70,"stream-to-blob-url":103,"videostream":129}],88:[function(require,module,exports){
module.exports={
  ".3gp": "video/3gpp",
  ".aac": "audio/aac",
  ".aif": "audio/x-aiff",
  ".aiff": "audio/x-aiff",
  ".atom": "application/atom+xml",
  ".avi": "video/x-msvideo",
  ".bmp": "image/bmp",
  ".bz2": "application/x-bzip2",
  ".conf": "text/plain",
  ".css": "text/css",
  ".csv": "text/csv",
  ".diff": "text/x-diff",
  ".doc": "application/msword",
  ".flv": "video/x-flv",
  ".gif": "image/gif",
  ".gz": "application/x-gzip",
  ".htm": "text/html",
  ".html": "text/html",
  ".ico": "image/vnd.microsoft.icon",
  ".ics": "text/calendar",
  ".iso": "application/octet-stream",
  ".jar": "application/java-archive",
  ".jpeg": "image/jpeg",
  ".jpg": "image/jpeg",
  ".js": "application/javascript",
  ".json": "application/json",
  ".less": "text/css",
  ".log": "text/plain",
  ".m3u": "audio/x-mpegurl",
  ".m4a": "audio/mp4",
  ".m4v": "video/mp4",
  ".manifest": "text/cache-manifest",
  ".markdown": "text/x-markdown",
  ".mathml": "application/mathml+xml",
  ".md": "text/x-markdown",
  ".mid": "audio/midi",
  ".midi": "audio/midi",
  ".mov": "video/quicktime",
  ".mp3": "audio/mpeg",
  ".mp4": "video/mp4",
  ".mp4v": "video/mp4",
  ".mpeg": "video/mpeg",
  ".mpg": "video/mpeg",
  ".odp": "application/vnd.oasis.opendocument.presentation",
  ".ods": "application/vnd.oasis.opendocument.spreadsheet",
  ".odt": "application/vnd.oasis.opendocument.text",
  ".oga": "audio/ogg",
  ".ogg": "application/ogg",
  ".pdf": "application/pdf",
  ".png": "image/png",
  ".pps": "application/vnd.ms-powerpoint",
  ".ppt": "application/vnd.ms-powerpoint",
  ".ps": "application/postscript",
  ".psd": "image/vnd.adobe.photoshop",
  ".qt": "video/quicktime",
  ".rar": "application/x-rar-compressed",
  ".rdf": "application/rdf+xml",
  ".rss": "application/rss+xml",
  ".rtf": "application/rtf",
  ".svg": "image/svg+xml",
  ".svgz": "image/svg+xml",
  ".swf": "application/x-shockwave-flash",
  ".tar": "application/x-tar",
  ".tbz": "application/x-bzip-compressed-tar",
  ".text": "text/plain",
  ".tif": "image/tiff",
  ".tiff": "image/tiff",
  ".torrent": "application/x-bittorrent",
  ".ttf": "application/x-font-ttf",
  ".txt": "text/plain",
  ".wav": "audio/wav",
  ".webm": "video/webm",
  ".wma": "audio/x-ms-wma",
  ".wmv": "video/x-ms-wmv",
  ".xls": "application/vnd.ms-excel",
  ".xml": "application/xml",
  ".yaml": "text/yaml",
  ".yml": "text/yaml",
  ".zip": "application/zip"
}

},{}],89:[function(require,module,exports){
(function (process){
module.exports = function (tasks, limit, cb) {
  if (typeof limit !== 'number') throw new Error('second argument must be a Number')
  var results, len, pending, keys, isErrored
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = len = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = len = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (err) isErrored = true
    if (--pending === 0 || err) {
      done(err)
    } else if (!isErrored && next < len) {
      var key
      if (keys) {
        key = keys[next]
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      } else {
        key = next
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      }
    }
  }

  var next = limit
  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.some(function (key, i) {
      tasks[key](function (err, result) { each(key, err, result) })
      if (i === limit - 1) return true // early return
    })
  } else {
    // array
    tasks.some(function (task, i) {
      task(function (err, result) { each(i, err, result) })
      if (i === limit - 1) return true // early return
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":73}],90:[function(require,module,exports){
(function (process){
module.exports = function (tasks, cb) {
  var results, pending, keys
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":73}],91:[function(require,module,exports){
(function (global){
/*
 * Rusha, a JavaScript implementation of the Secure Hash Algorithm, SHA-1,
 * as defined in FIPS PUB 180-1, tuned for high performance with large inputs.
 * (http://github.com/srijs/rusha)
 *
 * Inspired by Paul Johnstons implementation (http://pajhome.org.uk/crypt/md5).
 *
 * Copyright (c) 2013 Sam Rijs (http://awesam.de).
 * Released under the terms of the MIT license as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
(function () {
    var util = {
            getDataType: function (data) {
                if (typeof data === 'string') {
                    return 'string';
                }
                if (data instanceof Array) {
                    return 'array';
                }
                if (typeof global !== 'undefined' && global.Buffer && global.Buffer.isBuffer(data)) {
                    return 'buffer';
                }
                if (data instanceof ArrayBuffer) {
                    return 'arraybuffer';
                }
                if (data.buffer instanceof ArrayBuffer) {
                    return 'view';
                }
                if (data instanceof Blob) {
                    return 'blob';
                }
                throw new Error('Unsupported data type.');
            }
        };
    // The Rusha object is a wrapper around the low-level RushaCore.
    // It provides means of converting different inputs to the
    // format accepted by RushaCore as well as other utility methods.
    function Rusha(chunkSize) {
        'use strict';
        // Private object structure.
        var self$2 = { fill: 0 };
        // Calculate the length of buffer that the sha1 routine uses
        // including the padding.
        var padlen = function (len) {
            for (len += 9; len % 64 > 0; len += 1);
            return len;
        };
        var padZeroes = function (bin, len) {
            for (var i = len >> 2; i < bin.length; i++)
                bin[i] = 0;
        };
        var padData = function (bin, chunkLen, msgLen) {
            bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
            bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen >> 29;
            bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
        };
        // Convert a binary string and write it to the heap.
        // A binary string is expected to only contain char codes < 256.
        var convStr = function (H8, H32, start, len, off) {
            var str = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = str.charCodeAt(start);
                case 1:
                    H8[off + 2 | 0] = str.charCodeAt(start + 1);
                case 2:
                    H8[off + 1 | 0] = str.charCodeAt(start + 2);
                case 3:
                    H8[off | 0] = str.charCodeAt(start + 3);
                }
            }
            for (i = om; i < j; i = i + 4 | 0) {
                H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
            case 2:
                H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
            case 1:
                H8[off + j + 3 | 0] = str.charCodeAt(start + j);
            }
        };
        // Convert a buffer or array and write it to the heap.
        // The buffer or array is expected to only contain elements < 256.
        var convBuf = function (H8, H32, start, len, off) {
            var buf = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[start];
                case 1:
                    H8[off + 2 | 0] = buf[start + 1];
                case 2:
                    H8[off + 1 | 0] = buf[start + 2];
                case 3:
                    H8[off | 0] = buf[start + 3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[start + j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[start + j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[start + j];
            }
        };
        var convBlob = function (H8, H32, start, len, off) {
            var blob = this, i, om = off % 4, lm = len % 4, j = len - lm;
            var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[0];
                case 1:
                    H8[off + 2 | 0] = buf[1];
                case 2:
                    H8[off + 1 | 0] = buf[2];
                case 3:
                    H8[off | 0] = buf[3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[j];
            }
        };
        var convFn = function (data) {
            switch (util.getDataType(data)) {
            case 'string':
                return convStr.bind(data);
            case 'array':
                return convBuf.bind(data);
            case 'buffer':
                return convBuf.bind(data);
            case 'arraybuffer':
                return convBuf.bind(new Uint8Array(data));
            case 'view':
                return convBuf.bind(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            case 'blob':
                return convBlob.bind(data);
            }
        };
        var slice = function (data, offset) {
            switch (util.getDataType(data)) {
            case 'string':
                return data.slice(offset);
            case 'array':
                return data.slice(offset);
            case 'buffer':
                return data.slice(offset);
            case 'arraybuffer':
                return data.slice(offset);
            case 'view':
                return data.buffer.slice(offset);
            }
        };
        // Convert an ArrayBuffer into its hexadecimal string representation.
        var hex = function (arrayBuffer) {
            var i, x, hex_tab = '0123456789abcdef', res = [], binarray = new Uint8Array(arrayBuffer);
            for (i = 0; i < binarray.length; i++) {
                x = binarray[i];
                res[i] = hex_tab.charAt(x >> 4 & 15) + hex_tab.charAt(x >> 0 & 15);
            }
            return res.join('');
        };
        var ceilHeapSize = function (v) {
            // The asm.js spec says:
            // The heap object's byteLength must be either
            // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.
            // Also, byteLengths smaller than 2^16 are deprecated.
            var p;
            // If v is smaller than 2^16, the smallest possible solution
            // is 2^16.
            if (v <= 65536)
                return 65536;
            // If v < 2^24, we round up to 2^n,
            // otherwise we round up to 2^24 * n.
            if (v < 16777216) {
                for (p = 1; p < v; p = p << 1);
            } else {
                for (p = 16777216; p < v; p += 16777216);
            }
            return p;
        };
        // Initialize the internal data structures to a new capacity.
        var init = function (size) {
            if (size % 64 > 0) {
                throw new Error('Chunk size must be a multiple of 128 bit');
            }
            self$2.maxChunkLen = size;
            self$2.padMaxChunkLen = padlen(size);
            // The size of the heap is the sum of:
            // 1. The padded input message size
            // 2. The extended space the algorithm needs (320 byte)
            // 3. The 160 bit state the algoritm uses
            self$2.heap = new ArrayBuffer(ceilHeapSize(self$2.padMaxChunkLen + 320 + 20));
            self$2.h32 = new Int32Array(self$2.heap);
            self$2.h8 = new Int8Array(self$2.heap);
            self$2.core = new Rusha._core({
                Int32Array: Int32Array,
                DataView: DataView
            }, {}, self$2.heap);
            self$2.buffer = null;
        };
        // Iinitializethe datastructures according
        // to a chunk siyze.
        init(chunkSize || 64 * 1024);
        var initState = function (heap, padMsgLen) {
            var io = new Int32Array(heap, padMsgLen + 320, 5);
            io[0] = 1732584193;
            io[1] = -271733879;
            io[2] = -1732584194;
            io[3] = 271733878;
            io[4] = -1009589776;
        };
        var padChunk = function (chunkLen, msgLen) {
            var padChunkLen = padlen(chunkLen);
            var view = new Int32Array(self$2.heap, 0, padChunkLen >> 2);
            padZeroes(view, chunkLen);
            padData(view, chunkLen, msgLen);
            return padChunkLen;
        };
        // Write data to the heap.
        var write = function (data, chunkOffset, chunkLen) {
            convFn(data)(self$2.h8, self$2.h32, chunkOffset, chunkLen, 0);
        };
        // Initialize and call the RushaCore,
        // assuming an input buffer of length len * 4.
        var coreCall = function (data, chunkOffset, chunkLen, msgLen, finalize) {
            var padChunkLen = chunkLen;
            if (finalize) {
                padChunkLen = padChunk(chunkLen, msgLen);
            }
            write(data, chunkOffset, chunkLen);
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
        };
        var getRawDigest = function (heap, padMaxChunkLen) {
            var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
            var out = new Int32Array(5);
            var arr = new DataView(out.buffer);
            arr.setInt32(0, io[0], false);
            arr.setInt32(4, io[1], false);
            arr.setInt32(8, io[2], false);
            arr.setInt32(12, io[3], false);
            arr.setInt32(16, io[4], false);
            return out;
        };
        // Calculate the hash digest as an array of 5 32bit integers.
        var rawDigest = this.rawDigest = function (str) {
                var msgLen = str.byteLength || str.length || str.size || 0;
                initState(self$2.heap, self$2.padMaxChunkLen);
                var chunkOffset = 0, chunkLen = self$2.maxChunkLen, last;
                for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                    coreCall(str, chunkOffset, chunkLen, msgLen, false);
                }
                coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                return getRawDigest(self$2.heap, self$2.padMaxChunkLen);
            };
        // The digest and digestFrom* interface returns the hash digest
        // as a hex string.
        this.digest = this.digestFromString = this.digestFromBuffer = this.digestFromArrayBuffer = function (str) {
            return hex(rawDigest(str).buffer);
        };
    }
    ;
    // The low-level RushCore module provides the heart of Rusha,
    // a high-speed sha1 implementation working on an Int32Array heap.
    // At first glance, the implementation seems complicated, however
    // with the SHA1 spec at hand, it is obvious this almost a textbook
    // implementation that has a few functions hand-inlined and a few loops
    // hand-unrolled.
    Rusha._core = function RushaCore(stdlib, foreign, heap) {
        'use asm';
        var H = new stdlib.Int32Array(heap);
        function hash(k, x) {
            // k in bytes
            k = k | 0;
            x = x | 0;
            var i = 0, j = 0, y0 = 0, z0 = 0, y1 = 0, z1 = 0, y2 = 0, z2 = 0, y3 = 0, z3 = 0, y4 = 0, z4 = 0, t0 = 0, t1 = 0;
            y0 = H[x + 320 >> 2] | 0;
            y1 = H[x + 324 >> 2] | 0;
            y2 = H[x + 328 >> 2] | 0;
            y3 = H[x + 332 >> 2] | 0;
            y4 = H[x + 336 >> 2] | 0;
            for (i = 0; (i | 0) < (k | 0); i = i + 64 | 0) {
                z0 = y0;
                z1 = y1;
                z2 = y2;
                z3 = y3;
                z4 = y4;
                for (j = 0; (j | 0) < 64; j = j + 4 | 0) {
                    t1 = H[i + j >> 2] | 0;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[k + j >> 2] = t1;
                }
                for (j = k + 64 | 0; (j | 0) < (k + 80 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 80 | 0; (j | 0) < (k + 160 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) + 1859775393 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 160 | 0; (j | 0) < (k + 240 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | y1 & y3 | y2 & y3) | 0) + ((t1 + y4 | 0) - 1894007588 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 240 | 0; (j | 0) < (k + 320 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) - 899497514 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                y0 = y0 + z0 | 0;
                y1 = y1 + z1 | 0;
                y2 = y2 + z2 | 0;
                y3 = y3 + z3 | 0;
                y4 = y4 + z4 | 0;
            }
            H[x + 320 >> 2] = y0;
            H[x + 324 >> 2] = y1;
            H[x + 328 >> 2] = y2;
            H[x + 332 >> 2] = y3;
            H[x + 336 >> 2] = y4;
        }
        return { hash: hash };
    };
    // If we'e running in Node.JS, export a module.
    if (typeof module !== 'undefined') {
        module.exports = Rusha;
    } else if (typeof window !== 'undefined') {
        window.Rusha = Rusha;
    }
    // If we're running in a webworker, accept
    // messages containing a jobid and a buffer
    // or blob object, and return the hash result.
    if (typeof FileReaderSync !== 'undefined') {
        var reader = new FileReaderSync(), hasher = new Rusha(4 * 1024 * 1024);
        self.onmessage = function onMessage(event) {
            var hash, data = event.data.data;
            try {
                hash = hasher.digest(data);
                self.postMessage({
                    id: event.data.id,
                    hash: hash
                });
            } catch (e) {
                self.postMessage({
                    id: event.data.id,
                    error: e.name
                });
            }
        };
    }
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],92:[function(require,module,exports){
module.exports = require('buffer')

},{"buffer":20}],93:[function(require,module,exports){
(function (Buffer){
module.exports = function (stream, cb) {
  var chunks = []
  stream.on('data', function (chunk) {
    chunks.push(chunk)
  })
  stream.once('end', function () {
    if (cb) cb(null, Buffer.concat(chunks))
    cb = null
  })
  stream.once('error', function (err) {
    if (cb) cb(err)
    cb = null
  })
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],94:[function(require,module,exports){
(function (Buffer){
module.exports = simpleGet

var extend = require('xtend')
var http = require('http')
var https = require('https')
var once = require('once')
var unzipResponse = require('unzip-response') // excluded from browser build
var url = require('url')

function simpleGet (opts, cb) {
  opts = typeof opts === 'string' ? { url: opts } : extend(opts)
  cb = once(cb)

  if (opts.url) parseOptsUrl(opts)
  if (opts.headers == null) opts.headers = {}
  if (opts.maxRedirects == null) opts.maxRedirects = 10

  var body = opts.body
  opts.body = undefined
  if (body && !opts.method) opts.method = 'POST'

  // Request gzip/deflate
  var customAcceptEncoding = Object.keys(opts.headers).some(function (h) {
    return h.toLowerCase() === 'accept-encoding'
  })
  if (!customAcceptEncoding) opts.headers['accept-encoding'] = 'gzip, deflate'

  // Support http: and https: urls
  var protocol = opts.protocol === 'https:' ? https : http
  var req = protocol.request(opts, function (res) {
    // Follow 3xx redirects
    if (res.statusCode >= 300 && res.statusCode < 400 && 'location' in res.headers) {
      opts.url = res.headers.location
      parseOptsUrl(opts)
      res.resume() // Discard response

      opts.maxRedirects -= 1
      if (opts.maxRedirects > 0) simpleGet(opts, cb)
      else cb(new Error('too many redirects'))

      return
    }

    cb(null, typeof unzipResponse === 'function' ? unzipResponse(res) : res)
  })
  req.on('error', cb)
  req.end(body)
  return req
}

module.exports.concat = function (opts, cb) {
  return simpleGet(opts, function (err, res) {
    if (err) return cb(err)
    var chunks = []
    res.on('data', function (chunk) {
      chunks.push(chunk)
    })
    res.on('end', function () {
      cb(null, res, Buffer.concat(chunks))
    })
  })
}

;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(function (method) {
  module.exports[method] = function (opts, cb) {
    if (typeof opts === 'string') opts = { url: opts }
    opts.method = method.toUpperCase()
    return simpleGet(opts, cb)
  }
})

function parseOptsUrl (opts) {
  var loc = url.parse(opts.url)
  if (loc.hostname) opts.hostname = loc.hostname
  if (loc.port) opts.port = loc.port
  if (loc.protocol) opts.protocol = loc.protocol
  if (loc.auth) opts.auth = loc.auth
  opts.path = loc.path
  delete opts.url
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"http":99,"https":40,"once":63,"unzip-response":17,"url":117,"xtend":139}],95:[function(require,module,exports){
(function (Buffer){
module.exports = Peer

var debug = require('debug')('simple-peer')
var getBrowserRTC = require('get-browser-rtc')
var hat = require('hat')
var inherits = require('inherits')
var once = require('once')
var stream = require('readable-stream')

inherits(Peer, stream.Duplex)

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer (opts) {
  var self = this
  if (!(self instanceof Peer)) return new Peer(opts)
  self._debug('new peer %o', opts)

  if (!opts) opts = {}
  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.initiator = opts.initiator || false
  self.channelConfig = opts.channelConfig || Peer.channelConfig
  self.channelName = opts.initiator ? (opts.channelName || hat(160)) : null
  self.config = opts.config || Peer.config
  self.constraints = opts.constraints || Peer.constraints
  self.offerConstraints = opts.offerConstraints
  self.answerConstraints = opts.answerConstraints
  self.reconnectTimer = opts.reconnectTimer || false
  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
  self.stream = opts.stream || false
  self.trickle = opts.trickle !== undefined ? opts.trickle : true

  self.destroyed = false
  self.connected = false

  // so Peer object always has same shape (V8 optimization)
  self.remoteAddress = undefined
  self.remoteFamily = undefined
  self.remotePort = undefined
  self.localAddress = undefined
  self.localPort = undefined

  self._isWrtc = !!opts.wrtc // HACK: to fix `wrtc` bug. See issue: #60
  self._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
    ? opts.wrtc
    : getBrowserRTC()
  if (!self._wrtc) {
    if (typeof window === 'undefined') {
      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment')
    } else {
      throw new Error('No WebRTC support: Not a supported browser')
    }
  }

  self._maxBufferedAmount = opts.highWaterMark
  self._pcReady = false
  self._channelReady = false
  self._iceComplete = false // ice candidate trickle done (got null candidate)
  self._channel = null
  self._pendingCandidates = []

  self._chunk = null
  self._cb = null
  self._interval = null
  self._reconnectTimeout = null

  self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)
  self._pc.oniceconnectionstatechange = function () {
    self._onIceConnectionStateChange()
  }
  self._pc.onsignalingstatechange = function () {
    self._onSignalingStateChange()
  }
  self._pc.onicecandidate = function (event) {
    self._onIceCandidate(event)
  }

  if (self.stream) self._pc.addStream(self.stream)
  self._pc.onaddstream = function (event) {
    self._onAddStream(event)
  }

  if (self.initiator) {
    self._setupData({
      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)
    })
    self._pc.onnegotiationneeded = once(function () {
      self._createOffer()
    })
    // Only Chrome triggers "negotiationneeded"; this is a workaround for other
    // implementations
    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {
      self._pc.onnegotiationneeded()
    }
  } else {
    self._pc.ondatachannel = function (event) {
      self._setupData(event)
    }
  }

  self.on('finish', function () {
    if (self.connected) {
      // When local peer is finished writing, close connection to remote peer.
      // Half open connections are currently not supported.
      // Wait a bit before destroying so the datachannel flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If data channel is not connected when local peer is finished writing, wait until
      // data is flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose config, constraints, and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      url: 'stun:23.21.150.121', // deprecated, replaced by `urls`
      urls: 'stun:23.21.150.121'
    }
  ]
}
Peer.constraints = {}
Peer.channelConfig = {}

Object.defineProperty(Peer.prototype, 'bufferSize', {
  get: function () {
    var self = this
    return (self._channel && self._channel.bufferedAmount) || 0
  }
})

Peer.prototype.address = function () {
  var self = this
  return { port: self.localPort, family: 'IPv4', address: self.localAddress }
}

Peer.prototype.signal = function (data) {
  var self = this
  if (self.destroyed) throw new Error('cannot signal after peer is destroyed')
  if (typeof data === 'string') {
    try {
      data = JSON.parse(data)
    } catch (err) {
      data = {}
    }
  }
  self._debug('signal()')

  function addIceCandidate (candidate) {
    try {
      self._pc.addIceCandidate(
        new self._wrtc.RTCIceCandidate(candidate),
        noop,
        function (err) { self._onError(err) }
      )
    } catch (err) {
      self._destroy(new Error('error adding candidate: ' + err.message))
    }
  }

  if (data.sdp) {
    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data), function () {
      if (self.destroyed) return
      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()

      self._pendingCandidates.forEach(addIceCandidate)
      self._pendingCandidates = []
    }, function (err) { self._onError(err) })
  }
  if (data.candidate) {
    if (self._pc.remoteDescription) addIceCandidate(data.candidate)
    else self._pendingCandidates.push(data.candidate)
  }
  if (!data.sdp && !data.candidate) {
    self._destroy(new Error('signal() called with invalid signal data'))
  }
}

/**
 * Send text/binary data to the remote peer.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Peer.prototype.send = function (chunk) {
  var self = this

  // HACK: `wrtc` module doesn't accept node.js buffer. See issue: #60
  if (Buffer.isBuffer(chunk) && self._isWrtc) {
    chunk = new Uint8Array(chunk)
  }

  var len = chunk.length || chunk.byteLength || chunk.size
  self._channel.send(chunk)
  self._debug('write: %d bytes', len)
}

Peer.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Peer.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  self._debug('destroy (error: %s)', err && err.message)

  self.readable = self.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.destroyed = true
  self.connected = false
  self._pcReady = false
  self._channelReady = false

  self._chunk = null
  self._cb = null
  clearInterval(self._interval)
  clearTimeout(self._reconnectTimeout)

  if (self._pc) {
    try {
      self._pc.close()
    } catch (err) {}

    self._pc.oniceconnectionstatechange = null
    self._pc.onsignalingstatechange = null
    self._pc.onicecandidate = null
    self._pc.onaddstream = null
    self._pc.onnegotiationneeded = null
    self._pc.ondatachannel = null
  }

  if (self._channel) {
    try {
      self._channel.close()
    } catch (err) {}

    self._channel.onmessage = null
    self._channel.onopen = null
    self._channel.onclose = null
  }
  self._pc = null
  self._channel = null

  if (err) self.emit('error', err)
  self.emit('close')
}

Peer.prototype._setupData = function (event) {
  var self = this
  self._channel = event.channel
  self.channelName = self._channel.label

  self._channel.binaryType = 'arraybuffer'
  self._channel.onmessage = function (event) {
    self._onChannelMessage(event)
  }
  self._channel.onopen = function () {
    self._onChannelOpen()
  }
  self._channel.onclose = function () {
    self._onChannelClose()
  }
}

Peer.prototype._read = function () {}

Peer.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (self._channel.bufferedAmount > self._maxBufferedAmount) {
      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    self._debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Peer.prototype._createOffer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createOffer(function (offer) {
    if (self.destroyed) return
    offer.sdp = self.sdpTransform(offer.sdp)
    self._pc.setLocalDescription(offer, noop, function (err) { self._onError(err) })
    var sendOffer = function () {
      var signal = self._pc.localDescription || offer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendOffer()
    else self.once('_iceComplete', sendOffer) // wait for candidates
  }, function (err) { self._onError(err) }, self.offerConstraints)
}

Peer.prototype._createAnswer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createAnswer(function (answer) {
    if (self.destroyed) return
    answer.sdp = self.sdpTransform(answer.sdp)
    self._pc.setLocalDescription(answer, noop, function (err) { self._onError(err) })
    var sendAnswer = function () {
      var signal = self._pc.localDescription || answer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendAnswer()
    else self.once('_iceComplete', sendAnswer)
  }, function (err) { self._onError(err) }, self.answerConstraints)
}

Peer.prototype._onIceConnectionStateChange = function () {
  var self = this
  if (self.destroyed) return
  var iceGatheringState = self._pc.iceGatheringState
  var iceConnectionState = self._pc.iceConnectionState
  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState)
  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState)
  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
    clearTimeout(self._reconnectTimeout)
    self._pcReady = true
    self._maybeReady()
  }
  if (iceConnectionState === 'disconnected') {
    if (self.reconnectTimer) {
      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect
      clearTimeout(self._reconnectTimeout)
      self._reconnectTimeout = setTimeout(function () {
        self._destroy()
      }, self.reconnectTimer)
    } else {
      self._destroy()
    }
  }
  if (iceConnectionState === 'failed') {
    self._destroy()
  }
  if (iceConnectionState === 'closed') {
    self._destroy()
  }
}

Peer.prototype.getStats = function (cb) {
  var self = this
  if (!self._pc.getStats) { // No ability to call stats
    cb([])
  } else if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) { // Mozilla
    self._pc.getStats(null, function (res) {
      var items = []
      res.forEach(function (item) {
        items.push(item)
      })
      cb(items)
    }, function (err) { self._onError(err) })
  } else {
    self._pc.getStats(function (res) { // Chrome
      var items = []
      res.result().forEach(function (result) {
        var item = {}
        result.names().forEach(function (name) {
          item[name] = result.stat(name)
        })
        item.id = result.id
        item.type = result.type
        item.timestamp = result.timestamp
        items.push(item)
      })
      cb(items)
    })
  }
}

Peer.prototype._maybeReady = function () {
  var self = this
  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return
  self._connecting = true

  self.getStats(function (items) {
    self._connecting = false
    self.connected = true

    var remoteCandidates = {}
    var localCandidates = {}

    function setActiveCandidates (item) {
      var local = localCandidates[item.localCandidateId]
      var remote = remoteCandidates[item.remoteCandidateId]

      if (local) {
        self.localAddress = local.ipAddress
        self.localPort = Number(local.portNumber)
      } else if (typeof item.googLocalAddress === 'string') {
        // Sometimes `item.id` is undefined in `wrtc` and Chrome
        // See: https://github.com/feross/simple-peer/issues/66
        local = item.googLocalAddress.split(':')
        self.localAddress = local[0]
        self.localPort = Number(local[1])
      }
      self._debug('connect local: %s:%s', self.localAddress, self.localPort)

      if (remote) {
        self.remoteAddress = remote.ipAddress
        self.remotePort = Number(remote.portNumber)
        self.remoteFamily = 'IPv4'
      } else if (typeof item.googRemoteAddress === 'string') {
        remote = item.googRemoteAddress.split(':')
        self.remoteAddress = remote[0]
        self.remotePort = Number(remote[1])
        self.remoteFamily = 'IPv4'
      }
      self._debug('connect remote: %s:%s', self.remoteAddress, self.remotePort)
    }

    items.forEach(function (item) {
      if (item.type === 'remotecandidate') remoteCandidates[item.id] = item
      if (item.type === 'localcandidate') localCandidates[item.id] = item
    })

    items.forEach(function (item) {
      var isCandidatePair = (
        (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
        (item.type === 'candidatepair' && item.selected)
      )
      if (isCandidatePair) setActiveCandidates(item)
    })

    if (self._chunk) {
      try {
        self.send(self._chunk)
      } catch (err) {
        return self._onError(err)
      }
      self._chunk = null
      self._debug('sent chunk from "write before connect"')

      var cb = self._cb
      self._cb = null
      cb(null)
    }

    self._interval = setInterval(function () {
      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return
      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()

    self._debug('connect')
    self.emit('connect')
  })
}

Peer.prototype._onSignalingStateChange = function () {
  var self = this
  if (self.destroyed) return
  self._debug('signalingStateChange %s', self._pc.signalingState)
  self.emit('signalingStateChange', self._pc.signalingState)
}

Peer.prototype._onIceCandidate = function (event) {
  var self = this
  if (self.destroyed) return
  if (event.candidate && self.trickle) {
    self.emit('signal', {
      candidate: {
        candidate: event.candidate.candidate,
        sdpMLineIndex: event.candidate.sdpMLineIndex,
        sdpMid: event.candidate.sdpMid
      }
    })
  } else if (!event.candidate) {
    self._iceComplete = true
    self.emit('_iceComplete')
  }
}

Peer.prototype._onChannelMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  self._debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Peer.prototype._onChannelOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self._debug('on channel open')
  self._channelReady = true
  self._maybeReady()
}

Peer.prototype._onChannelClose = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on channel close')
  self._destroy()
}

Peer.prototype._onAddStream = function (event) {
  var self = this
  if (self.destroyed) return
  self._debug('on add stream')
  self.emit('stream', event.stream)
}

Peer.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  self._debug('error %s', err.message || err)
  self._destroy(err)
}

Peer.prototype._debug = function () {
  var self = this
  var args = [].slice.call(arguments)
  var id = self.channelName && self.channelName.substring(0, 7)
  args[0] = '[' + id + '] ' + args[0]
  debug.apply(null, args)
}

function noop () {}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"debug":31,"get-browser-rtc":38,"hat":39,"inherits":43,"once":63,"readable-stream":86}],96:[function(require,module,exports){
var Rusha = require('rusha')

var rusha = new Rusha
var crypto = window.crypto || window.msCrypto || {}
var subtle = crypto.subtle || crypto.webkitSubtle

function sha1sync (buf) {
  return rusha.digest(buf)
}

// Browsers throw if they lack support for an algorithm.
// Promise will be rejected on non-secure origins. (http://goo.gl/lq4gCo)
try {
  subtle.digest({ name: 'sha-1' }, new Uint8Array).catch(function () {
    subtle = false
  })
} catch (err) { subtle = false }

function sha1 (buf, cb) {
  if (!subtle) {
    // Use Rusha
    setTimeout(cb, 0, sha1sync(buf))
    return
  }

  if (typeof buf === 'string') {
    buf = uint8array(buf)
  }

  subtle.digest({ name: 'sha-1' }, buf)
    .then(function succeed (result) {
      cb(hex(new Uint8Array(result)))
    },
    function fail (error) {
      cb(sha1sync(buf))
    })
}

function uint8array (s) {
  var l = s.length
  var array = new Uint8Array(l)
  for (var i = 0; i < l; i++) {
    array[i] = s.charCodeAt(i)
  }
  return array
}

function hex (buf) {
  var l = buf.length
  var chars = []
  for (var i = 0; i < l; i++) {
    var bite = buf[i]
    chars.push((bite >>> 4).toString(16))
    chars.push((bite & 0x0f).toString(16))
  }
  return chars.join('')
}

module.exports = sha1
module.exports.sync = sha1sync

},{"rusha":91}],97:[function(require,module,exports){
(function (process,Buffer){
/* global WebSocket */

module.exports = Socket

var debug = require('debug')('simple-websocket')
var inherits = require('inherits')
var stream = require('readable-stream')
var ws = require('ws') // websockets in node - will be empty object in browser

var _WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : ws

inherits(Socket, stream.Duplex)

/**
 * WebSocket. Same API as node core `net.Socket`. Duplex stream.
 * @param {string} url websocket server url
 * @param {Object} opts options to stream.Duplex
 */
function Socket (url, opts) {
  var self = this
  if (!(self instanceof Socket)) return new Socket(url, opts)
  if (!opts) opts = {}
  debug('new websocket: %s %o', url, opts)

  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.url = url
  self.connected = false
  self.destroyed = false

  self._maxBufferedAmount = opts.highWaterMark
  self._chunk = null
  self._cb = null
  self._interval = null

  try {
    if (typeof WebSocket === 'undefined') {
      // `ws` package accepts options
      self._ws = new _WebSocket(self.url, opts)
    } else {
      self._ws = new _WebSocket(self.url)
    }
  } catch (err) {
    process.nextTick(function () {
      self._onError(err)
    })
    return
  }
  self._ws.binaryType = 'arraybuffer'
  self._ws.onopen = function () {
    self._onOpen()
  }
  self._ws.onmessage = function (event) {
    self._onMessage(event)
  }
  self._ws.onclose = function () {
    self._onClose()
  }
  self._ws.onerror = function () {
    self._onError(new Error('connection error to ' + self.url))
  }

  self.on('finish', function () {
    if (self.connected) {
      // When stream is finished writing, close socket connection. Half open connections
      // are currently not supported.
      // Wait a bit before destroying so the socket flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If socket is not connected when stream is finished writing, wait until data is
      // flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Socket.WEBSOCKET_SUPPORT = !!_WebSocket

/**
 * Send text/binary data to the WebSocket server.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Socket.prototype.send = function (chunk) {
  var self = this

  var len = chunk.length || chunk.byteLength || chunk.size
  self._ws.send(chunk)
  debug('write: %d bytes', len)
}

Socket.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Socket.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  debug('destroy (error: %s)', err && err.message)

  this.readable = this.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.connected = false
  self.destroyed = true

  clearInterval(self._interval)
  self._interval = null
  self._chunk = null
  self._cb = null

  if (self._ws) {
    var ws = self._ws
    var onClose = function () {
      ws.onclose = null
      self.emit('close')
    }
    if (ws.readyState === _WebSocket.CLOSED) {
      onClose()
    } else {
      try {
        ws.onclose = onClose
        ws.close()
      } catch (err) {
        onClose()
      }
    }

    ws.onopen = null
    ws.onmessage = null
    ws.onerror = null
  }
  self._ws = null

  if (err) self.emit('error', err)
}

Socket.prototype._read = function () {}

Socket.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after socket is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (typeof ws !== 'function' && self._ws.bufferedAmount > self._maxBufferedAmount) {
      debug('start backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Socket.prototype._onMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Socket.prototype._onOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self.connected = true

  if (self._chunk) {
    try {
      self.send(self._chunk)
    } catch (err) {
      return self._onError(err)
    }
    self._chunk = null
    debug('sent chunk from "write before connect"')

    var cb = self._cb
    self._cb = null
    cb(null)
  }

  // No backpressure in node. The `ws` module has a buggy `bufferedAmount` property.
  // See: https://github.com/websockets/ws/issues/492
  if (typeof ws !== 'function') {
    self._interval = setInterval(function () {
      if (!self._cb || !self._ws || self._ws.bufferedAmount > self._maxBufferedAmount) {
        return
      }
      debug('ending backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()
  }

  debug('connect')
  self.emit('connect')
}

Socket.prototype._onClose = function () {
  var self = this
  if (self.destroyed) return
  debug('on close')
  self._destroy()
}

Socket.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  debug('error: %s', err.message || err)
  self._destroy(err)
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":73,"buffer":20,"debug":31,"inherits":43,"readable-stream":86,"ws":17}],98:[function(require,module,exports){
var tick = 1
var maxTick = 65535
var resolution = 4
var inc = function () {
  tick = (tick + 1) & maxTick
}

var timer = setInterval(inc, (1000 / resolution) | 0)
if (timer.unref) timer.unref()

module.exports = function (seconds) {
  var size = resolution * (seconds || 5)
  var buffer = [0]
  var pointer = 1
  var last = (tick - 1) & maxTick

  return function (delta) {
    var dist = (tick - last) & maxTick
    if (dist > size) dist = size
    last = tick

    while (dist--) {
      if (pointer === size) pointer = 0
      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1]
      pointer++
    }

    if (delta) buffer[pointer - 1] += delta

    var top = buffer[pointer - 1]
    var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer]

    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length
  }
}

},{}],99:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/request":101,"builtin-status-codes":21,"url":117,"xtend":139}],100:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

var xhr = new global.XMLHttpRequest()
// If location.host is empty, e.g. if this page/worker was loaded
// from a Blob, then use example.com to avoid an error
xhr.open('GET', global.location.host ? '/' : 'https://example.com')

function checkTypeSupport (type) {
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')
// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')
exports.overrideMimeType = isFunction(xhr.overrideMimeType)
exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
  return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],101:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary) {
	if (capability.fetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary)

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var self = this
	return self._headers[name.toLowerCase()].value
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body
	if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {
		if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	if (self._mode === 'fetch') {
		var headers = Object.keys(headersObj).map(function (name) {
			return [headersObj[name].name, headersObj[name].value]
		})

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headers,
			body: body,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin'
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		Object.keys(headersObj).forEach(function (name) {
			xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	// Currently, there isn't a way to truly abort a fetch.
	// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":100,"./response":102,"_process":73,"buffer":20,"inherits":43,"readable-stream":86,"to-arraybuffer":110}],102:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		// backwards compatible version of for (<item> of <iterable>):
		// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
		for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
			self.headers[header[0].toLowerCase()] = header[1]
			self.rawHeaders.push(header[0], header[1])
		}

		// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			})
		}
		read()

	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":100,"_process":73,"buffer":20,"inherits":43,"readable-stream":86}],103:[function(require,module,exports){
/* global URL */

var getBlob = require('stream-to-blob')

module.exports = function getBlobURL (stream, mimeType, cb) {
  if (typeof mimeType === 'function') return getBlobURL(stream, null, mimeType)
  getBlob(stream, mimeType, function (err, blob) {
    if (err) return cb(err)
    var url = URL.createObjectURL(blob)
    cb(null, url)
  })
}

},{"stream-to-blob":104}],104:[function(require,module,exports){
/* global Blob */

var once = require('once')

module.exports = function getBlob (stream, mimeType, cb) {
  if (typeof mimeType === 'function') return getBlob(stream, null, mimeType)
  cb = once(cb)
  var chunks = []
  stream
    .on('data', function (chunk) {
      chunks.push(chunk)
    })
    .on('end', function () {
      var blob = mimeType
        ? new Blob(chunks, { type: mimeType })
        : new Blob(chunks)
      cb(null, blob)
    })
    .on('error', cb)
}

},{"once":63}],105:[function(require,module,exports){
(function (Buffer){
var once = require('once')

module.exports = function getBuffer (stream, length, cb) {
  cb = once(cb)
  var buf = new Buffer(length)
  var offset = 0
  stream
    .on('data', function (chunk) {
      chunk.copy(buf, offset)
      offset += chunk.length
    })
    .on('end', function () { cb(null, buf) })
    .on('error', cb)
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"once":63}],106:[function(require,module,exports){
(function (Buffer){
var addrToIPPort = require('addr-to-ip-port')
var ipaddr = require('ipaddr.js')

module.exports = function (addrs) {
  if (typeof addrs === 'string') {
    addrs = [ addrs ]
  }

  return Buffer.concat(addrs.map(function (addr) {
    var s = addrToIPPort(addr)
    if (s.length !== 2) {
      throw new Error('invalid address format, expecting: 10.10.10.5:128')
    }

    var ip = ipaddr.parse(s[0])
    var ipBuf = new Buffer(ip.toByteArray())
    var port = Number(s[1])
    var portBuf = new Buffer(2)
    portBuf.writeUInt16BE(port, 0)
    return Buffer.concat([ipBuf, portBuf])
  }))
}

/**
 * Also support this usage:
 *   string2compact.multi([ '10.10.10.5:128', '100.56.58.99:28525' ])
 *
 * for parallelism with the `compact2string` module.
 */
module.exports.multi = module.exports
module.exports.multi6 = module.exports

}).call(this,require("buffer").Buffer)

},{"addr-to-ip-port":3,"buffer":20,"ipaddr.js":44}],107:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":20}],108:[function(require,module,exports){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in      
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.
*/

var base32 = require('./thirty-two');

exports.encode = base32.encode;
exports.decode = base32.decode;

},{"./thirty-two":109}],109:[function(require,module,exports){
(function (Buffer){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.                                                                   
*/

var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var byteTable = [
    0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff
];

function quintetCount(buff) {
    var quintets = Math.floor(buff.length / 5);
    return buff.length % 5 == 0 ? quintets: quintets + 1;
}

exports.encode = function(plain) {
    if(!Buffer.isBuffer(plain)){
    	plain = new Buffer(plain);
    }
    var i = 0;
    var j = 0;
    var shiftIndex = 0;
    var digit = 0;
    var encoded = new Buffer(quintetCount(plain) * 8);

    /* byte by byte isn't as pretty as quintet by quintet but tests a bit
        faster. will have to revisit. */
    while(i < plain.length) {
        var current = plain[i];
    
        if(shiftIndex > 3) {
            digit = current & (0xff >> shiftIndex);
            shiftIndex = (shiftIndex + 5) % 8;
            digit = (digit << shiftIndex) | ((i + 1 < plain.length) ?
                plain[i + 1] : 0) >> (8 - shiftIndex);
            i++;
        } else {
            digit = (current >> (8 - (shiftIndex + 5))) & 0x1f;
            shiftIndex = (shiftIndex + 5) % 8;            
            if(shiftIndex == 0) i++;
        }
        
        encoded[j] = charTable.charCodeAt(digit);
        j++;
    }

    for(i = j; i < encoded.length; i++)
        encoded[i] = 0x3d; //'='.charCodeAt(0)
        
    return encoded;
};

exports.decode = function(encoded) {
    var shiftIndex = 0;
    var plainDigit = 0;
    var plainChar;
    var plainPos = 0;
    if(!Buffer.isBuffer(encoded)){
    	encoded = new Buffer(encoded);
    }
    var decoded = new Buffer(Math.ceil(encoded.length * 5 / 8));
    
    /* byte by byte isn't as pretty as octet by octet but tests a bit
        faster. will have to revisit. */    
    for(var i = 0; i < encoded.length; i++) {
    	if(encoded[i] == 0x3d){ //'='
    		break;
    	}
    		
        var encodedByte = encoded[i] - 0x30;
        
        if(encodedByte < byteTable.length) {
            plainDigit = byteTable[encodedByte];
            
            if(shiftIndex <= 3) {
                shiftIndex = (shiftIndex + 5) % 8;
                
                if(shiftIndex == 0) {
                    plainChar |= plainDigit;
                    decoded[plainPos] = plainChar;
                    plainPos++;
                    plainChar = 0;
                } else {
                    plainChar |= 0xff & (plainDigit << (8 - shiftIndex));
                }
            } else {
                shiftIndex = (shiftIndex + 5) % 8;
                plainChar |= 0xff & (plainDigit >>> shiftIndex);
                decoded[plainPos] = plainChar;
                plainPos++;

                plainChar = 0xff & (plainDigit << (8 - shiftIndex));
            }
        } else {
        	throw new Error('Invalid input - it is not base32 encoded string');
        }
    }
    return decoded.slice(0, plainPos);
};

}).call(this,require("buffer").Buffer)

},{"buffer":20}],110:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":20}],111:[function(require,module,exports){
(function (process){
module.exports = Discovery

var debug = require('debug')('torrent-discovery')
var DHT = require('bittorrent-dht/client') // empty object in browser
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var parallel = require('run-parallel')
var Tracker = require('bittorrent-tracker/client')

inherits(Discovery, EventEmitter)

function Discovery (opts) {
  var self = this
  if (!(self instanceof Discovery)) return new Discovery(opts)
  EventEmitter.call(self)

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._port = opts.port // torrent port

  self.destroyed = false

  self._announce = opts.announce || []
  self._intervalMs = opts.intervalMs || (15 * 60 * 1000)
  self._trackerOpts = null
  self._dhtAnnouncing = false
  self._dhtTimeout = false
  self._internalDHT = false // is the DHT created internally?

  self._onWarning = function (err) {
    self.emit('warning', err)
  }
  self._onError = function (err) {
    self.emit('error', err)
  }
  self._onDHTPeer = function (peer, infoHash) {
    if (infoHash.toString('hex') !== self.infoHash) return
    self.emit('peer', peer.host + ':' + peer.port)
  }
  self._onTrackerPeer = function (peer) {
    self.emit('peer', peer)
  }
  self._onTrackerAnnounce = function () {
    self.emit('trackerAnnounce')
  }

  if (opts.tracker === false) {
    self.tracker = null
  } else if (opts.tracker && typeof opts.tracker === 'object') {
    self._trackerOpts = extend(opts.tracker)
    self.tracker = self._createTracker()
  } else {
    self.tracker = self._createTracker()
  }

  if (opts.dht === false || typeof DHT !== 'function') {
    self.dht = null
  } else if (opts.dht && typeof opts.dht.addNode === 'function') {
    self.dht = opts.dht
  } else if (opts.dht && typeof opts.dht === 'object') {
    self.dht = createDHT(opts.dhtPort, opts.dht)
  } else {
    self.dht = createDHT(opts.dhtPort)
  }

  if (self.dht) {
    self.dht.on('peer', self._onDHTPeer)
    self._dhtAnnounce()
  }

  function createDHT (port, opts) {
    var dht = new DHT(opts)
    dht.on('warning', self._onWarning)
    dht.on('error', self._onError)
    dht.listen(port)
    self._internalDHT = true
    return dht
  }
}

Discovery.prototype.updatePort = function (port) {
  var self = this
  if (port === self._port) return
  self._port = port

  if (self.dht) self._dhtAnnounce()

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.destroy(function () {
      self.tracker = self._createTracker()
    })
  }
}

Discovery.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  clearTimeout(self._dhtTimeout)

  var tasks = []

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.removeListener('warning', self._onWarning)
    self.tracker.removeListener('error', self._onError)
    self.tracker.removeListener('peer', self._onTrackerPeer)
    self.tracker.removeListener('update', self._onTrackerAnnounce)
    tasks.push(function (cb) {
      self.tracker.destroy(cb)
    })
  }

  if (self.dht) {
    self.dht.removeListener('peer', self._onDHTPeer)
  }

  if (self._internalDHT) {
    self.dht.removeListener('warning', self._onWarning)
    self.dht.removeListener('error', self._onError)
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  // cleanup
  self.dht = null
  self.tracker = null
  self._announce = null
}

Discovery.prototype._createTracker = function () {
  var self = this

  var opts = extend(self._trackerOpts, {
    infoHash: self.infoHash,
    announce: self._announce,
    peerId: self.peerId,
    port: self._port
  })

  var tracker = new Tracker(opts)
  tracker.on('warning', self._onWarning)
  tracker.on('error', self._onError)
  tracker.on('peer', self._onTrackerPeer)
  tracker.on('update', self._onTrackerAnnounce)
  tracker.setInterval(self._intervalMs)
  tracker.start()
  return tracker
}

Discovery.prototype._dhtAnnounce = function () {
  var self = this
  if (self._dhtAnnouncing) return
  debug('dht announce')

  self._dhtAnnouncing = true
  clearTimeout(self._dhtTimeout)

  self.dht.announce(self.infoHash, self._port, function (err) {
    self._dhtAnnouncing = false
    debug('dht announce complete')

    if (err) self.emit('warning', err)
    self.emit('dhtAnnounce')

    if (!self.destroyed) {
      self._dhtTimeout = setTimeout(function () {
        self._dhtAnnounce()
      }, getRandomTimeout())
      if (self._dhtTimeout.unref) self._dhtTimeout.unref()
    }
  })

  // Returns timeout interval, with some random jitter
  function getRandomTimeout () {
    return self._intervalMs + Math.floor(Math.random() * self._intervalMs / 5)
  }
}

}).call(this,require('_process'))

},{"_process":73,"bittorrent-dht/client":17,"bittorrent-tracker/client":11,"debug":31,"events":35,"inherits":43,"run-parallel":90,"xtend":139}],112:[function(require,module,exports){
(function (Buffer){
module.exports = Piece

var BLOCK_LENGTH = 1 << 14

function Piece (length) {
  if (!(this instanceof Piece)) return new Piece(length)

  this.length = length
  this.missing = length
  this.sources = null

  this._chunks = Math.ceil(length / BLOCK_LENGTH)
  this._remainder = (length % BLOCK_LENGTH) || BLOCK_LENGTH
  this._buffered = 0
  this._buffer = null
  this._cancellations = null
  this._reservations = 0
  this._flushed = false
}

Piece.BLOCK_LENGTH = BLOCK_LENGTH

Piece.prototype.chunkLength = function (i) {
  return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH
}

Piece.prototype.chunkLengthRemaining = function (i) {
  return this.length - (i * BLOCK_LENGTH)
}

Piece.prototype.chunkOffset = function (i) {
  return i * BLOCK_LENGTH
}

Piece.prototype.reserve = function () {
  if (!this.init()) return -1
  if (this._cancellations.length) return this._cancellations.pop()
  if (this._reservations < this._chunks) return this._reservations++
  return -1
}

Piece.prototype.reserveRemaining = function () {
  if (!this.init()) return -1
  if (this._reservations < this._chunks) {
    var min = this._reservations
    this._reservations = this._chunks
    return min
  }
  return -1
}

Piece.prototype.cancel = function (i) {
  if (!this.init()) return
  this._cancellations.push(i)
}

Piece.prototype.cancelRemaining = function (i) {
  if (!this.init()) return
  this._reservations = i
}

Piece.prototype.get = function (i) {
  if (!this.init()) return null
  return this._buffer[i]
}

Piece.prototype.set = function (i, data, source) {
  if (!this.init()) return false
  var len = data.length
  var blocks = Math.ceil(len / BLOCK_LENGTH)
  for (var j = 0; j < blocks; j++) {
    if (!this._buffer[i + j]) {
      var offset = j * BLOCK_LENGTH
      var splitData = data.slice(offset, offset + BLOCK_LENGTH)
      this._buffered++
      this._buffer[i + j] = splitData
      this.missing -= splitData.length
      if (this.sources.indexOf(source) === -1) {
        this.sources.push(source)
      }
    }
  }
  return this._buffered === this._chunks
}

Piece.prototype.flush = function () {
  if (!this._buffer || this._chunks !== this._buffered) return null
  var buffer = Buffer.concat(this._buffer, this.length)
  this._buffer = null
  this._cancellations = null
  this.sources = null
  this._flushed = true
  return buffer
}

Piece.prototype.init = function () {
  if (this._flushed) return false
  if (this._buffer) return true
  this._buffer = new Array(this._chunks)
  this._cancellations = []
  this.sources = []
  return true
}

}).call(this,require("buffer").Buffer)

},{"buffer":20}],113:[function(require,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = new Buffer(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to the `Buffer` constructor
    return new Buffer(arr)
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":20,"is-typedarray":48}],114:[function(require,module,exports){
(function (Buffer){
var UINT_32_MAX = 0xffffffff

exports.encodingLength = function () {
  return 8
}

exports.encode = function (num, buf, offset) {
  if (!buf) buf = new Buffer(8)
  if (!offset) offset = 0

  var top = Math.floor(num / UINT_32_MAX)
  var rem = num - top * UINT_32_MAX

  buf.writeUInt32BE(top, offset)
  buf.writeUInt32BE(rem, offset + 4)
  return buf
}

exports.decode = function (buf, offset) {
  if (!offset) offset = 0

  if (!buf) buf = new Buffer(4)
  if (!offset) offset = 0

  var top = buf.readUInt32BE(offset)
  var rem = buf.readUInt32BE(offset + 4)

  return top * UINT_32_MAX + rem
}

exports.encode.bytes = 8
exports.decode.bytes = 8

}).call(this,require("buffer").Buffer)

},{"buffer":20}],115:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],116:[function(require,module,exports){
module.exports = remove

function remove (arr, i) {
  if (i >= arr.length || i < 0) return
  var last = arr.pop()
  if (i < arr.length) {
    var tmp = arr[i]
    arr[i] = last
    return tmp
  }
  return last
}

},{}],117:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":118,"punycode":75,"querystring":78}],118:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],119:[function(require,module,exports){
var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('ut_metadata')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var sha1 = require('simple-sha1')

var MAX_METADATA_SIZE = 10000000 // 10MB
var BITFIELD_GROW = 1000
var PIECE_LENGTH = 16 * 1024

module.exports = function (metadata) {
  inherits(utMetadata, EventEmitter)

  function utMetadata (wire) {
    EventEmitter.call(this)

    this._wire = wire

    this._metadataComplete = false
    this._metadataSize = null
    this._remainingRejects = null // how many reject messages to tolerate before quitting
    this._fetching = false

    // The largest .torrent file that I know of is ~1-2MB, which is ~100 pieces.
    // Therefore, cap the bitfield to 10x that (1000 pieces) so a malicious peer can't
    // make it grow to fill all memory.
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })

    if (Buffer.isBuffer(metadata)) {
      this.setMetadata(metadata)
    }
  }

  // Name of the bittorrent-protocol extension
  utMetadata.prototype.name = 'ut_metadata'

  utMetadata.prototype.onHandshake = function (infoHash, peerId, extensions) {
    this._infoHash = infoHash
  }

  utMetadata.prototype.onExtendedHandshake = function (handshake) {
    if (!handshake.m || !handshake.m.ut_metadata) {
      return this.emit('warning', new Error('Peer does not support ut_metadata'))
    }
    if (!handshake.metadata_size) {
      return this.emit('warning', new Error('Peer does not have metadata'))
    }
    if (typeof handshake.metadata_size !== 'number' ||
        MAX_METADATA_SIZE < handshake.metadata_size ||
        handshake.metadata_size <= 0) {
      return this.emit('warning', new Error('Peer gave invalid metadata size'))
    }

    this._metadataSize = handshake.metadata_size
    this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH)
    this._remainingRejects = this._numPieces * 2

    if (this._fetching) {
      this._requestPieces()
    }
  }

  utMetadata.prototype.onMessage = function (buf) {
    var dict, trailer
    try {
      var str = buf.toString()
      var trailerIndex = str.indexOf('ee') + 2
      dict = bencode.decode(str.substring(0, trailerIndex))
      trailer = buf.slice(trailerIndex)
    } catch (err) {
      // drop invalid messages
      return
    }

    switch (dict.msg_type) {
      case 0:
        // ut_metadata request (from peer)
        // example: { 'msg_type': 0, 'piece': 0 }
        this._onRequest(dict.piece)
        break
      case 1:
        // ut_metadata data (in response to our request)
        // example: { 'msg_type': 1, 'piece': 0, 'total_size': 3425 }
        this._onData(dict.piece, trailer, dict.total_size)
        break
      case 2:
        // ut_metadata reject (peer doesn't have piece we requested)
        // { 'msg_type': 2, 'piece': 0 }
        this._onReject(dict.piece)
        break
    }
  }

  /**
   * Ask the peer to send metadata.
   * @public
   */
  utMetadata.prototype.fetch = function () {
    if (this._metadataComplete) {
      return
    }
    this._fetching = true
    if (this._metadataSize) {
      this._requestPieces()
    }
  }

  /**
   * Stop asking the peer to send metadata.
   * @public
   */
  utMetadata.prototype.cancel = function () {
    this._fetching = false
  }

  utMetadata.prototype.setMetadata = function (metadata) {
    if (this._metadataComplete) return true
    debug('set metadata')

    // if full torrent dictionary was passed in, pull out just `info` key
    try {
      var info = bencode.decode(metadata).info
      if (info) {
        metadata = bencode.encode(info)
      }
    } catch (err) {}

    // check hash
    if (this._infoHash && this._infoHash !== sha1.sync(metadata)) {
      return false
    }

    this.cancel()

    this.metadata = metadata
    this._metadataComplete = true
    this._metadataSize = this.metadata.length
    this._wire.extendedHandshake.metadata_size = this._metadataSize

    this.emit('metadata', bencode.encode({ info: bencode.decode(this.metadata) }))

    return true
  }

  utMetadata.prototype._send = function (dict, trailer) {
    var buf = bencode.encode(dict)
    if (Buffer.isBuffer(trailer)) {
      buf = Buffer.concat([buf, trailer])
    }
    this._wire.extended('ut_metadata', buf)
  }

  utMetadata.prototype._request = function (piece) {
    this._send({ msg_type: 0, piece: piece })
  }

  utMetadata.prototype._data = function (piece, buf, totalSize) {
    var msg = { msg_type: 1, piece: piece }
    if (typeof totalSize === 'number') {
      msg.total_size = totalSize
    }
    this._send(msg, buf)
  }

  utMetadata.prototype._reject = function (piece) {
    this._send({ msg_type: 2, piece: piece })
  }

  utMetadata.prototype._onRequest = function (piece) {
    if (!this._metadataComplete) {
      this._reject(piece)
      return
    }
    var start = piece * PIECE_LENGTH
    var end = start + PIECE_LENGTH
    if (end > this._metadataSize) {
      end = this._metadataSize
    }
    var buf = this.metadata.slice(start, end)
    this._data(piece, buf, this._metadataSize)
  }

  utMetadata.prototype._onData = function (piece, buf, totalSize) {
    if (buf.length > PIECE_LENGTH) {
      return
    }
    buf.copy(this.metadata, piece * PIECE_LENGTH)
    this._bitfield.set(piece)
    this._checkDone()
  }

  utMetadata.prototype._onReject = function (piece) {
    if (this._remainingRejects > 0 && this._fetching) {
      // If we haven't been rejected too much, then try to request the piece again
      this._request(piece)
      this._remainingRejects -= 1
    } else {
      this.emit('warning', new Error('Peer sent "reject" too much'))
    }
  }

  utMetadata.prototype._requestPieces = function () {
    this.metadata = Buffer.alloc(this._metadataSize)
    for (var piece = 0; piece < this._numPieces; piece++) {
      this._request(piece)
    }
  }

  utMetadata.prototype._checkDone = function () {
    var done = true
    for (var piece = 0; piece < this._numPieces; piece++) {
      if (!this._bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) return

    // attempt to set metadata -- may fail sha1 check
    var success = this.setMetadata(this.metadata)

    if (!success) {
      this._failedMetadata()
    }
  }

  utMetadata.prototype._failedMetadata = function () {
    // reset bitfield & try again
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })
    this._remainingRejects -= this._numPieces
    if (this._remainingRejects > 0) {
      this._requestPieces()
    } else {
      this.emit('warning', new Error('Peer sent invalid metadata'))
    }
  }

  return utMetadata
}

},{"bencode":7,"bitfield":9,"debug":31,"events":35,"inherits":43,"safe-buffer":92,"simple-sha1":96}],120:[function(require,module,exports){
(function (Buffer){
/* jshint camelcase: false */

// TODO: ipv6 support
// TODO: parse and send peer flags (currently unused)
// NOTE: addPeer should take in an optional second argument, flags
// TODO: destroy wire if peer sends PEX messages too frequently

var EventEmitter = require('events').EventEmitter
var compact2string = require('compact2string')
var string2compact = require('string2compact')
var bencode = require('bencode')
var inherits = require('inherits')

var PEX_INTERVAL = 65000 // just over one minute
var PEX_MAX_PEERS = 50    // max number of peers to advertise per PEX message

module.exports = function () {
  inherits(ut_pex, EventEmitter)

  function ut_pex (wire) {
    var self = this
    EventEmitter.call(self)

    self._wire = wire
    self._intervalId = null

    self.reset()
  }

  ut_pex.prototype.name = 'ut_pex'

  /**
   * Start sending regular PEX updates to remote peer.
   */
  ut_pex.prototype.start = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = setInterval(self._sendMessage.bind(self), PEX_INTERVAL)
    if (self._intervalId.unref) self._intervalId.unref()
  }

  /**
   * Stop sending PEX updates to the remote peer.
   */
  ut_pex.prototype.stop = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = null
  }

  /**
   * Stops sending updates to the remote peer and resets internal state of peers seen.
   */
  ut_pex.prototype.reset = function () {
    var self = this
    self._remoteAddedPeers = {}
    self._remoteDroppedPeers = {}
    self._localAddedPeers = {}
    self._localDroppedPeers = {}
    self.stop()
  }

  /**
   * Adds a peer to the locally discovered peer list for the next PEX message.
   */
  ut_pex.prototype.addPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteAddedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localDroppedPeers) delete self._localDroppedPeers[peer]
    self._localAddedPeers[peer] = true
  }

  /**
   * Adds a peer to the locally dropped peer list for the next PEX message.
   */
  ut_pex.prototype.dropPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteDroppedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localAddedPeers) delete self._localAddedPeers[peer]
    self._localDroppedPeers[peer] = true
  }

  ut_pex.prototype.onExtendedHandshake = function (handshake) {
    var self = this
    if (!handshake.m || !handshake.m.ut_pex) {
      return self.emit('warning', new Error('Peer does not support ut_pex'))
    }
  }

  /**
   * PEX messages are bencoded dictionaries with the following keys:
   * 'added'     : array of peers met since last PEX message
   * 'added.f'   : array of flags per peer
   *  '0x01'     : peer prefers encryption
   *  '0x02'     : peer is seeder
   * 'dropped'   : array of peers locally dropped from swarm since last PEX message
   * 'added6'    : ipv6 version of 'added'
   * 'added6.f'  : ipv6 version of 'added.f'
   * 'dropped.f' : ipv6 version of 'dropped'
   *
   * @param {Buffer} buf bencoded PEX dictionary
   */
  ut_pex.prototype.onMessage = function (buf) {
    var self = this
    var message

    try {
      message = bencode.decode(buf)
    } catch (err) {
      // drop invalid messages
      return
    }

    if (message.added) {
      compact2string.multi(message.added).forEach(function (peer) {
        delete self._remoteDroppedPeers[peer]
        if (!(peer in self._remoteAddedPeers)) {
          self._remoteAddedPeers[peer] = true
          self.emit('peer', peer)
        }
      })
    }

    if (message.dropped) {
      compact2string.multi(message.dropped).forEach(function (peer) {
        delete self._remoteAddedPeers[peer]
        if (!(peer in self._remoteDroppedPeers)) {
          self._remoteDroppedPeers[peer] = true
          self.emit('dropped', peer)
        }
      })
    }
  }

  /**
   * Sends a PEX message to the remote peer including information about any locally
   * added / dropped peers.
   */
  ut_pex.prototype._sendMessage = function () {
    var self = this

    var localAdded = Object.keys(self._localAddedPeers).slice(0, PEX_MAX_PEERS)
    var localDropped = Object.keys(self._localDroppedPeers).slice(0, PEX_MAX_PEERS)

    var added = Buffer.concat(localAdded.map(string2compact))
    var dropped = Buffer.concat(localDropped.map(string2compact))

    var addedFlags = Buffer.concat(localAdded.map(function () {
      // TODO: support flags
      return new Buffer([0])
    }))

    // update local deltas
    localAdded.forEach(function (peer) { delete self._localAddedPeers[peer] })
    localDropped.forEach(function (peer) { delete self._localDroppedPeers[peer] })

    // send PEX message
    self._wire.extended('ut_pex', {
      'added': added,
      'added.f': addedFlags,
      'dropped': dropped,
      'added6': new Buffer(0),
      'added6.f': new Buffer(0),
      'dropped6': new Buffer(0)
    })
  }

  return ut_pex
}

}).call(this,require("buffer").Buffer)

},{"bencode":121,"buffer":20,"compact2string":24,"events":35,"inherits":43,"string2compact":106}],121:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./lib/decode":122,"./lib/encode":124,"dup":27}],122:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":123,"buffer":20}],123:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],124:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":20}],125:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],126:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],127:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":126,"_process":73,"inherits":43}],128:[function(require,module,exports){
(function (Buffer){
var bs = require('binary-search')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var mp4 = require('mp4-stream')
var Box = require('mp4-box-encoding')
var RangeSliceStream = require('range-slice-stream')

module.exports = MP4Remuxer

function MP4Remuxer (file) {
	var self = this
	EventEmitter.call(self)
	self._tracks = []
	self._fragmentSequence = 1
	self._file = file
	self._decoder = null
	self._findMoov(0)
}

inherits(MP4Remuxer, EventEmitter)

MP4Remuxer.prototype._findMoov = function (offset) {
	var self = this

	if (self._decoder) {
		self._decoder.destroy()
	}

	self._decoder = mp4.decode()
	var fileStream = self._file.createReadStream({
		start: offset
	})
	fileStream.pipe(self._decoder)

	self._decoder.once('box', function (headers) {
		if (headers.type === 'moov') {
			self._decoder.decode(function (moov) {
				fileStream.destroy()
				try {
					self._processMoov(moov)
				} catch (err) {
					err.message = 'Cannot parse mp4 file: ' + err.message
					self.emit('error', err)
				}
			})
		} else {
			fileStream.destroy()
			self._findMoov(offset + headers.length)
		}
	})
}

function RunLengthIndex (entries, countName) {
	var self = this
	self._entries = entries
	self._countName = countName || 'count'
	self._index = 0
	self._offset = 0

	self.value = self._entries[0]
}

RunLengthIndex.prototype.inc = function () {
	var self = this
	self._offset++
	if (self._offset >= self._entries[self._index][self._countName]) {
		self._index++
		self._offset = 0
	}

	self.value = self._entries[self._index]
}

MP4Remuxer.prototype._processMoov = function (moov) {
	var self = this

	var traks = moov.traks
	self._tracks = []
	self._hasVideo = false
	self._hasAudio = false
	for (var i = 0; i < traks.length; i++) {
		var trak = traks[i]
		var stbl = trak.mdia.minf.stbl
		var stsdEntry = stbl.stsd.entries[0]
		var handlerType = trak.mdia.hdlr.handlerType
		var codec
		var mime
		if (handlerType === 'vide' && stsdEntry.type === 'avc1') {
			if (self._hasVideo) {
				continue
			}
			self._hasVideo = true
			codec = 'avc1'
			if (stsdEntry.avcC) {
				codec += '.' + stsdEntry.avcC.mimeCodec
			}
			mime = 'video/mp4; codecs="' + codec + '"'
		} else if (handlerType === 'soun' && stsdEntry.type === 'mp4a') {
			if (self._hasAudio) {
				continue
			}
			self._hasAudio = true
			codec = 'mp4a'
			if (stsdEntry.esds && stsdEntry.esds.mimeCodec) {
				codec += '.' + stsdEntry.esds.mimeCodec
			}
			mime = 'audio/mp4; codecs="' + codec + '"'
		} else {
			continue
		}

		var samples = []
		var sample = 0

		// Chunk/position data
		var sampleInChunk = 0
		var chunk = 0
		var offsetInChunk = 0
		var sampleToChunkIndex = 0

		// Time data
		var dts = 0
		var decodingTimeEntry = new RunLengthIndex(stbl.stts.entries)
		var presentationOffsetEntry = null
		if (stbl.ctts) {
			presentationOffsetEntry = new RunLengthIndex(stbl.ctts.entries)
		}

		// Sync table index
		var syncSampleIndex = 0

		while (true) {
			var currChunkEntry = stbl.stsc.entries[sampleToChunkIndex]

			// Compute size
			var size = stbl.stsz.entries[sample]

			// Compute time data
			var duration = decodingTimeEntry.value.duration
			var presentationOffset = presentationOffsetEntry ? presentationOffsetEntry.value.compositionOffset : 0

			// Compute sync
			var sync = true
			if (stbl.stss) {
				sync = stbl.stss.entries[syncSampleIndex] === sample + 1
			}

			// Create new sample entry
			samples.push({
				size: size,
				duration: duration,
				dts: dts,
				presentationOffset: presentationOffset,
				sync: sync,
				offset: offsetInChunk + stbl.stco.entries[chunk]
			})

			// Go to next sample
			sample++
			if (sample >= stbl.stsz.entries.length) {
				break
			}

			// Move position/chunk
			sampleInChunk++
			offsetInChunk += size
			if (sampleInChunk >= currChunkEntry.samplesPerChunk) {
				// Move to new chunk
				sampleInChunk = 0
				offsetInChunk = 0
				chunk++
				// Move sample to chunk box index
				var nextChunkEntry = stbl.stsc.entries[sampleToChunkIndex + 1]
				if (nextChunkEntry && chunk + 1 >= nextChunkEntry.firstChunk) {
					sampleToChunkIndex++
				}
			}

			// Move time forward
			dts += duration
			decodingTimeEntry.inc()
			presentationOffsetEntry && presentationOffsetEntry.inc()

			// Move sync table index
			if (sync) {
				syncSampleIndex++
			}
		}

		trak.mdia.mdhd.duration = 0
		trak.tkhd.duration = 0

		var defaultSampleDescriptionIndex = currChunkEntry.sampleDescriptionId

		var trackMoov = {
			type: 'moov',
			mvhd: moov.mvhd,
			traks: [{
				tkhd: trak.tkhd,
				mdia: {
					mdhd: trak.mdia.mdhd,
					hdlr: trak.mdia.hdlr,
					elng: trak.mdia.elng,
					minf: {
						vmhd: trak.mdia.minf.vmhd,
						smhd: trak.mdia.minf.smhd,
						dinf: trak.mdia.minf.dinf,
						stbl: {
							stsd: stbl.stsd,
							stts: empty(),
							ctts: empty(),
							stsc: empty(),
							stsz: empty(),
							stco: empty(),
							stss: empty()
						}
					}
				}
			}],
			mvex: {
				mehd: {
					fragmentDuration: moov.mvhd.duration
				},
				trexs: [{
					trackId: trak.tkhd.trackId,
					defaultSampleDescriptionIndex: defaultSampleDescriptionIndex,
					defaultSampleDuration: 0,
					defaultSampleSize: 0,
					defaultSampleFlags: 0
				}]
			}
		}

		self._tracks.push({
			trackId: trak.tkhd.trackId,
			timeScale: trak.mdia.mdhd.timeScale,
			samples: samples,
			currSample: null,
			currTime: null,
			moov: trackMoov,
			mime: mime
		})
	}

	if (self._tracks.length === 0) {
		self.emit('error', new Error('no playable tracks'))
		return
	}

	// Must be set last since this is used above
	moov.mvhd.duration = 0

	self._ftyp = {
		type: 'ftyp',
		brand: 'iso5',
		brandVersion: 0,
		compatibleBrands: [
			'iso5'
		]
	}

	var ftypBuf = Box.encode(self._ftyp)
	var data = self._tracks.map(function (track) {
		var moovBuf = Box.encode(track.moov)
		return {
			mime: track.mime,
			init: Buffer.concat([ftypBuf, moovBuf])
		}
	})

	self.emit('ready', data)
}

function empty () {
	return {
		version: 0,
		flags: 0,
		entries: []
	}
}

MP4Remuxer.prototype.seek = function (time) {
	var self = this
	if (!self._tracks) {
		throw new Error('Not ready yet; wait for \'ready\' event')
	}

	if (self._fileStream) {
		self._fileStream.destroy()
		self._fileStream = null
	}

	var startOffset = -1
	self._tracks.map(function (track, i) {
		// find the keyframe before the time
		// stream from there
		if (track.outStream) {
			track.outStream.destroy()
		}
		if (track.inStream) {
			track.inStream.destroy()
			track.inStream = null
		}
		var outStream = track.outStream = mp4.encode()
		var fragment = self._generateFragment(i, time)
		if (!fragment) {
			return outStream.finalize()
		}

		if (startOffset === -1 || fragment.ranges[0].start < startOffset) {
			startOffset = fragment.ranges[0].start
		}

		writeFragment(fragment)

		function writeFragment (frag) {
			if (outStream.destroyed) return
			outStream.box(frag.moof, function (err) {
				if (err) return self.emit('error', err)
				if (outStream.destroyed) return
				var slicedStream = track.inStream.slice(frag.ranges)
				slicedStream.pipe(outStream.mediaData(frag.length, function (err) {
					if (err) return self.emit('error', err)
					if (outStream.destroyed) return
					var nextFrag = self._generateFragment(i)
					if (!nextFrag) {
						return outStream.finalize()
					}
					writeFragment(nextFrag)
				}))
			})
		}
	})

	if (startOffset >= 0) {
		var fileStream = self._fileStream = self._file.createReadStream({
			start: startOffset
		})

		self._tracks.forEach(function (track) {
			track.inStream = new RangeSliceStream(startOffset)
			fileStream.pipe(track.inStream)
		})
	}

	return self._tracks.map(function (track) {
		return track.outStream
	})
}

MP4Remuxer.prototype._findSampleBefore = function (trackInd, time) {
	var self = this

	var track = self._tracks[trackInd]
	var scaledTime = Math.floor(track.timeScale * time)
	var sample = bs(track.samples, scaledTime, function (sample, t) {
		var pts = sample.dts + sample.presentationOffset// - track.editShift
		return pts - t
	})
	if (sample === -1) {
		sample = 0
	} else if (sample < 0) {
		sample = -sample - 2
	}
	// sample is now the last sample with dts <= time
	// Find the preceeding sync sample
	while (!track.samples[sample].sync) {
		sample--
	}
	return sample
}

var MIN_FRAGMENT_DURATION = 1 // second

MP4Remuxer.prototype._generateFragment = function (track, time) {
	var self = this
	/*
	1. Find correct sample
	2. Process backward until sync sample found
	3. Process forward until next sync sample after MIN_FRAGMENT_DURATION found
	*/
	var currTrack = self._tracks[track]
	var firstSample
	if (time !== undefined) {
		firstSample = self._findSampleBefore(track, time)
	} else {
		firstSample = currTrack.currSample
	}

	if (firstSample >= currTrack.samples.length)
		return null

	var startDts = currTrack.samples[firstSample].dts

	var totalLen = 0
	var ranges = []
	for (var currSample = firstSample; currSample < currTrack.samples.length; currSample++) {
		var sample = currTrack.samples[currSample]
		if (sample.sync && sample.dts - startDts >= currTrack.timeScale * MIN_FRAGMENT_DURATION) {
			break // This is a reasonable place to end the fragment
		}

		totalLen += sample.size
		var currRange = ranges.length - 1
		if (currRange < 0 || ranges[currRange].end !== sample.offset) {
			// Push a new range
			ranges.push({
				start: sample.offset,
				end: sample.offset + sample.size
			})
		} else {
			ranges[currRange].end += sample.size
		}
	}

	currTrack.currSample = currSample

	return {
		moof: self._generateMoof(track, firstSample, currSample),
		ranges: ranges,
		length: totalLen
	}
}

MP4Remuxer.prototype._generateMoof = function (track, firstSample, lastSample) {
	var self = this

	var currTrack = self._tracks[track]

	var entries = []
	for (var j = firstSample; j < lastSample; j++) {
		var currSample = currTrack.samples[j]
		entries.push({
			sampleDuration: currSample.duration,
			sampleSize: currSample.size,
			sampleFlags: currSample.sync ? 0x2000000 : 0x1010000,
			sampleCompositionTimeOffset: currSample.presentationOffset
		})
	}

	var moof = {
		type: 'moof',
		mfhd: {
			sequenceNumber: self._fragmentSequence++
		},
		trafs: [{
			tfhd: {
				flags: 0x20000, // default-base-is-moof
				trackId: currTrack.trackId
			},
			tfdt: {
				baseMediaDecodeTime: currTrack.samples[firstSample].dts
			},
			trun: {
				flags: 0xf01,
				dataOffset: 8, // The moof size has to be added to this later as well
				entries: entries
			}
		}]
	}

	// Update the offset
	moof.trafs[0].trun.dataOffset += Box.encodingLength(moof)

	return moof
}

}).call(this,require("buffer").Buffer)

},{"binary-search":8,"buffer":20,"events":35,"inherits":43,"mp4-box-encoding":56,"mp4-stream":59,"range-slice-stream":80}],129:[function(require,module,exports){
var MediaElementWrapper = require('mediasource')
var pump = require('pump')

var MP4Remuxer = require('./mp4-remuxer')

module.exports = VideoStream

function VideoStream (file, mediaElem, opts) {
	var self = this
	if (!(this instanceof VideoStream)) return new VideoStream(file, mediaElem, opts)
	opts = opts || {}

	self._elem = mediaElem
	self._elemWrapper = new MediaElementWrapper(mediaElem)
	self._waitingFired = false
	self._trackMeta = null
	self._file = file
	self._tracks = null
	if (self._elem.preload !== 'none') {
		self._createMuxer()
	}

	self._onError = function (err) {
		self.destroy() // don't pass err though so the user doesn't need to listen for errors
	}
	self._onWaiting = function () {
		self._waitingFired = true
		if (!self._muxer) {
			self._createMuxer()
		} else if (self._tracks) {
			self._pump()
		}
	}
	self._elem.addEventListener('waiting', self._onWaiting)
	self._elem.addEventListener('error', self._onError)
}

VideoStream.prototype._createMuxer = function () {
	var self = this
	self._muxer = new MP4Remuxer(self._file)
	self._muxer.on('ready', function (data) {
		self._tracks = data.map(function (trackData) {
			var mediaSource = self._elemWrapper.createWriteStream(trackData.mime)
			mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
			mediaSource.write(trackData.init)
			return {
				muxed: null,
				mediaSource: mediaSource
			}
		})

		if (self._waitingFired || self._elem.preload === 'auto') {
			self._pump()
		}
	})

	self._muxer.on('error', function (err) {
		self._elemWrapper.error(err)
	})
}

VideoStream.prototype._pump = function () {
	var self = this

	var muxed = self._muxer.seek(self._elem.currentTime, !self._tracks)

	self._tracks.forEach(function (track, i) {
		if (track.muxed) {
			track.muxed.destroy()
			track.mediaSource = self._elemWrapper.createWriteStream(track.mediaSource)
			track.mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
		}
		track.muxed = muxed[i]
		pump(track.muxed, track.mediaSource)
	})
}

VideoStream.prototype.destroy = function () {
	var self = this
	if (self.destroyed) {
		return
	}
	self.destroyed = true

	self._elem.removeEventListener('waiting', self._onWaiting)
	self._elem.removeEventListener('error', self._onError)

	if (self._tracks) {
		self._tracks.forEach(function (track) {
			track.muxed.destroy()
		})
	}

	self._elem.src = ''
}

},{"./mp4-remuxer":128,"mediasource":52,"pump":74}],130:[function(require,module,exports){
(function (process,global){
module.exports = WebTorrent

var Buffer = require('safe-buffer').Buffer
var concat = require('simple-concat')
var createTorrent = require('create-torrent')
var debug = require('debug')('webtorrent')
var DHT = require('bittorrent-dht/client') // browser exclude
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var loadIPSet = require('load-ip-set') // browser exclude
var parallel = require('run-parallel')
var parseTorrent = require('parse-torrent')
var path = require('path')
var Peer = require('simple-peer')
var speedometer = require('speedometer')
var zeroFill = require('zero-fill')

var TCPPool = require('./lib/tcp-pool') // browser exclude
var Torrent = require('./lib/torrent')

/**
 * WebTorrent version.
 */
var VERSION = require('./package.json').version

/**
 * Version number in Azureus-style. Generated from major and minor semver version.
 * For example:
 *   '0.16.1' -> '0016'
 *   '1.2.5' -> '0102'
 */
var VERSION_STR = VERSION.match(/([0-9]+)/g).slice(0, 2).map(zeroFill(2)).join('')

/**
 * Version prefix string (used in peer ID). WebTorrent uses the Azureus-style
 * encoding: '-', two characters for client id ('WW'), four ascii digits for version
 * number, '-', followed by random numbers.
 * For example:
 *   '-WW0102-'...
 */
var VERSION_PREFIX = '-WW' + VERSION_STR + '-'

inherits(WebTorrent, EventEmitter)

/**
 * WebTorrent Client
 * @param {Object=} opts
 */
function WebTorrent (opts) {
  var self = this
  if (!(self instanceof WebTorrent)) return new WebTorrent(opts)
  EventEmitter.call(self)

  if (!opts) opts = {}

  if (typeof opts.peerId === 'string') {
    self.peerId = opts.peerId
  } else if (Buffer.isBuffer(opts.peerId)) {
    self.peerId = opts.peerId.toString('hex')
  } else {
    self.peerId = Buffer.from(VERSION_PREFIX + hat(48))
  }
  self.peerIdBuffer = Buffer.from(self.peerId, 'hex')

  if (typeof opts.nodeId === 'string') {
    self.nodeId = opts.nodeId
  } else if (Buffer.isBuffer(opts.nodeId)) {
    self.nodeId = opts.nodeId.toString('hex')
  } else {
    self.nodeId = hat(160)
  }
  self.nodeIdBuffer = Buffer.from(self.nodeId, 'hex')

  self.destroyed = false
  self.listening = false
  self.torrentPort = opts.torrentPort || 0
  self.dhtPort = opts.dhtPort || 0
  self.tracker = opts.tracker !== undefined ? opts.tracker : {}
  self.torrents = []
  self.maxConns = Number(opts.maxConns) || 55

  if (self.tracker) {
    if (typeof self.tracker !== 'object') self.tracker = {}
    if (opts.rtcConfig) {
      // TODO: remove in v1
      console.warn('WebTorrent: opts.rtcConfig is deprecated. Use opts.tracker.rtcConfig instead')
      self.tracker.rtcConfig = opts.rtcConfig
    }
    if (opts.wrtc) {
      // TODO: remove in v1
      console.warn('WebTorrent: opts.wrtc is deprecated. Use opts.tracker.wrtc instead')
      self.tracker.wrtc = opts.wrtc // to support `webtorrent-hybrid` package
    }
    if (global.WRTC && !self.tracker.wrtc) self.tracker.wrtc = global.WRTC
  }

  if (typeof TCPPool === 'function') {
    self._tcpPool = new TCPPool(self)
  } else {
    process.nextTick(function () {
      self._onListening()
    })
  }

  // stats
  self._downloadSpeed = speedometer()
  self._uploadSpeed = speedometer()

  if (opts.dht !== false && typeof DHT === 'function' /* browser exclude */) {
    // use a single DHT instance for all torrents, so the routing table can be reused
    self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))

    self.dht.once('error', function (err) {
      self._destroy(err)
    })

    self.dht.once('listening', function () {
      var address = self.dht.address()
      if (address) self.dhtPort = address.port
    })

    // Ignore warning when there are > 10 torrents in the client
    self.dht.setMaxListeners(0)

    self.dht.listen(self.dhtPort)
  } else {
    self.dht = false
  }

  debug('new webtorrent (peerId %s, nodeId %s)', self.peerId, self.nodeId)

  if (typeof loadIPSet === 'function') {
    loadIPSet(opts.blocklist, {
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'
      }
    }, function (err, ipSet) {
      if (err) return self.error('Failed to load blocklist: ' + err.message)
      self.blocked = ipSet
      ready()
    })
  } else process.nextTick(ready)

  function ready () {
    if (self.destroyed) return
    self.ready = true
    self.emit('ready')
  }
}

WebTorrent.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT

Object.defineProperty(WebTorrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'progress', {
  get: function () {
    var torrents = this.torrents.filter(function (torrent) {
      return torrent.progress !== 1
    })
    var downloaded = torrents.reduce(function (total, torrent) {
      return total + torrent.downloaded
    }, 0)
    var length = torrents.reduce(function (total, torrent) {
      return total + (torrent.length || 0)
    }, 0) || 1
    return downloaded / length
  }
})

Object.defineProperty(WebTorrent.prototype, 'ratio', {
  get: function () {
    var uploaded = this.torrents.reduce(function (total, torrent) {
      return total + torrent.uploaded
    }, 0)
    var received = this.torrents.reduce(function (total, torrent) {
      return total + torrent.received
    }, 0) || 1
    return uploaded / received
  }
})

/**
 * Returns the torrent with the given `torrentId`. Convenience method. Easier than
 * searching through the `client.torrents` array. Returns `null` if no matching torrent
 * found.
 *
 * @param  {string|Buffer|Object|Torrent} torrentId
 * @return {Torrent|null}
 */
WebTorrent.prototype.get = function (torrentId) {
  var self = this
  var i, torrent
  var len = self.torrents.length

  if (torrentId instanceof Torrent) {
    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent === torrentId) return torrent
    }
  } else {
    var parsed
    try { parsed = parseTorrent(torrentId) } catch (err) {}

    if (!parsed) return null
    if (!parsed.infoHash) throw new Error('Invalid torrent identifier')

    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent.infoHash === parsed.infoHash) return torrent
    }
  }
  return null
}

// TODO: remove in v1
WebTorrent.prototype.download = function (torrentId, opts, ontorrent) {
  console.warn('WebTorrent: client.download() is deprecated. Use client.add() instead')
  return this.add(torrentId, opts, ontorrent)
}

/**
 * Start downloading a new torrent. Aliased as `client.download`.
 * @param {string|Buffer|Object} torrentId
 * @param {Object} opts torrent-specific options
 * @param {function=} ontorrent called when the torrent is ready (has metadata)
 */
WebTorrent.prototype.add = function (torrentId, opts, ontorrent) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.add(torrentId, null, opts)

  debug('add')
  opts = opts ? extend(opts) : {}

  var torrent = new Torrent(torrentId, self, opts)
  self.torrents.push(torrent)

  torrent.once('_infoHash', onInfoHash)
  torrent.once('ready', onReady)
  torrent.once('close', onClose)

  function onInfoHash () {
    if (self.destroyed) return
    for (var i = 0, len = self.torrents.length; i < len; i++) {
      var t = self.torrents[i]
      if (t.infoHash === torrent.infoHash && t !== torrent) {
        torrent._destroy(new Error('Cannot add duplicate torrent ' + torrent.infoHash))
        return
      }
    }
  }

  function onReady () {
    if (self.destroyed) return
    if (typeof ontorrent === 'function') ontorrent(torrent)
    self.emit('torrent', torrent)
  }

  function onClose () {
    torrent.removeListener('_infoHash', onInfoHash)
    torrent.removeListener('ready', onReady)
    torrent.removeListener('close', onClose)
  }

  return torrent
}

/**
 * Start seeding a new file/folder.
 * @param  {string|File|FileList|Buffer|Array.<string|File|Buffer>} input
 * @param  {Object=} opts
 * @param  {function=} onseed called when torrent is seeding
 */
WebTorrent.prototype.seed = function (input, opts, onseed) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.seed(input, null, opts)

  debug('seed')
  opts = opts ? extend(opts) : {}

  // When seeding from fs path, initialize store from that path to avoid a copy
  if (typeof input === 'string') opts.path = path.dirname(input)
  if (!opts.createdBy) opts.createdBy = 'WebTorrent/' + VERSION_STR
  if (!self.tracker) opts.announce = []

  var torrent = self.add(null, opts, onTorrent)
  var streams

  if (!Array.isArray(input)) input = [ input ]
  parallel(input.map(function (item) {
    return function (cb) {
      if (isReadable(item)) concat(item, cb)
      else cb(null, item)
    }
  }), function (err, input) {
    if (self.destroyed) return
    if (err) return torrent._destroy(err)

    createTorrent.parseInput(input, opts, function (err, files) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)

      streams = files.map(function (file) {
        return file.getStream
      })

      createTorrent(input, opts, function (err, torrentBuf) {
        if (self.destroyed) return
        if (err) return torrent._destroy(err)

        var existingTorrent = self.get(torrentBuf)
        if (existingTorrent) {
          torrent._destroy(new Error('Cannot add duplicate torrent ' + existingTorrent.infoHash))
        } else {
          torrent._onTorrentId(torrentBuf)
        }
      })
    })
  })

  function onTorrent (torrent) {
    var tasks = [
      function (cb) {
        torrent.load(streams, cb)
      }
    ]
    if (self.dht) {
      tasks.push(function (cb) {
        torrent.once('dhtAnnounce', cb)
      })
    }
    parallel(tasks, function (err) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)
      _onseed(torrent)
    })
  }

  function _onseed (torrent) {
    debug('on seed')
    if (typeof onseed === 'function') onseed(torrent)
    self.emit('seed', torrent)
  }

  return torrent
}

/**
 * Remove a torrent from the client.
 * @param  {string|Buffer|Torrent}   torrentId
 * @param  {function} cb
 */
WebTorrent.prototype.remove = function (torrentId, cb) {
  debug('remove')
  var torrent = this.get(torrentId)
  if (!torrent) throw new Error('No torrent with id ' + torrentId)
  this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
  var torrent = this.get(torrentId)
  if (!torrent) return
  this.torrents.splice(this.torrents.indexOf(torrent), 1)
  torrent.destroy(cb)
}

WebTorrent.prototype.address = function () {
  if (!this.listening) return null
  return this._tcpPool
    ? this._tcpPool.server.address()
    : { address: '0.0.0.0', family: 'IPv4', port: 0 }
}

/**
 * Destroy the client, including all torrents and connections to peers.
 * @param  {function} cb
 */
WebTorrent.prototype.destroy = function (cb) {
  if (this.destroyed) throw new Error('client already destroyed')
  this._destroy(null, cb)
}

WebTorrent.prototype._destroy = function (err, cb) {
  var self = this
  debug('client destroy')
  self.destroyed = true

  var tasks = self.torrents.map(function (torrent) {
    return function (cb) {
      torrent.destroy(cb)
    }
  })

  if (self._tcpPool) {
    tasks.push(function (cb) {
      self._tcpPool.destroy(cb)
    })
  }

  if (self.dht) {
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  if (err) self.emit('error', err)

  self.torrents = []
  self._tcpPool = null
  self.dht = null
}

WebTorrent.prototype._onListening = function () {
  this.listening = true

  if (this._tcpPool) {
    // Sometimes server.address() returns `null` in Docker.
    // WebTorrent issue: https://github.com/feross/bittorrent-swarm/pull/18
    var address = this._tcpPool.server.address()
    if (address) this.torrentPort = address.port
  }

  this.emit('listening')
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/tcp-pool":17,"./lib/torrent":135,"./package.json":137,"_process":73,"bittorrent-dht/client":17,"create-torrent":26,"debug":31,"events":35,"hat":39,"inherits":43,"load-ip-set":17,"parse-torrent":69,"path":70,"run-parallel":90,"safe-buffer":92,"simple-concat":93,"simple-peer":95,"speedometer":98,"xtend":139,"zero-fill":141}],131:[function(require,module,exports){
module.exports = FileStream

var debug = require('debug')('webtorrent:file-stream')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(FileStream, stream.Readable)

/**
 * Readable stream of a torrent file
 *
 * @param {File} file
 * @param {Object} opts
 * @param {number} opts.start stream slice of file, starting from this byte (inclusive)
 * @param {number} opts.end stream slice of file, ending with this byte (inclusive)
 */
function FileStream (file, opts) {
  stream.Readable.call(this, opts)

  this.destroyed = false
  this._torrent = file._torrent

  var start = (opts && opts.start) || 0
  var end = (opts && opts.end && opts.end < file.length)
    ? opts.end
    : file.length - 1

  var pieceLength = file._torrent.pieceLength

  this._startPiece = (start + file.offset) / pieceLength | 0
  this._endPiece = (end + file.offset) / pieceLength | 0

  this._piece = this._startPiece
  this._offset = (start + file.offset) - (this._startPiece * pieceLength)

  this._missing = end - start + 1
  this._reading = false
  this._notifying = false
  this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
}

FileStream.prototype._read = function () {
  if (this._reading) return
  this._reading = true
  this._notify()
}

FileStream.prototype._notify = function () {
  var self = this

  if (!self._reading || self._missing === 0) return
  if (!self._torrent.bitfield.get(self._piece)) {
    return self._torrent.critical(self._piece, self._piece + self._criticalLength)
  }

  if (self._notifying) return
  self._notifying = true

  var p = self._piece
  self._torrent.store.get(p, function (err, buffer) {
    self._notifying = false
    if (self.destroyed) return
    if (err) return self._destroy(err)
    debug('read %s (length %s) (err %s)', p, buffer.length, err && err.message)

    if (self._offset) {
      buffer = buffer.slice(self._offset)
      self._offset = 0
    }

    if (self._missing < buffer.length) {
      buffer = buffer.slice(0, self._missing)
    }
    self._missing -= buffer.length

    debug('pushing buffer of length %s', buffer.length)
    self._reading = false
    self.push(buffer)

    if (self._missing === 0) self.push(null)
  })
  self._piece += 1
}

FileStream.prototype.destroy = function (onclose) {
  this._destroy(null, onclose)
}

FileStream.prototype._destroy = function (err, onclose) {
  if (this.destroyed) return
  this.destroyed = true

  if (!this._torrent.destroyed) {
    this._torrent.deselect(this._startPiece, this._endPiece, true)
  }

  if (err) this.emit('error', err)
  this.emit('close')
  if (onclose) onclose()
}

},{"debug":31,"inherits":43,"readable-stream":86}],132:[function(require,module,exports){
(function (process){
module.exports = File

var eos = require('end-of-stream')
var EventEmitter = require('events').EventEmitter
var FileStream = require('./file-stream')
var inherits = require('inherits')
var path = require('path')
var render = require('render-media')
var stream = require('readable-stream')
var streamToBlobURL = require('stream-to-blob-url')
var streamToBuffer = require('stream-with-known-length-to-buffer')

inherits(File, EventEmitter)

function File (torrent, file) {
  EventEmitter.call(this)

  this._torrent = torrent
  this._destroyed = false

  this.name = file.name
  this.path = file.path
  this.length = file.length
  this.offset = file.offset

  this.done = false

  var start = file.offset
  var end = start + file.length - 1

  this._startPiece = start / this._torrent.pieceLength | 0
  this._endPiece = end / this._torrent.pieceLength | 0

  if (this.length === 0) {
    this.done = true
    this.emit('done')
  }
}

File.prototype.select = function (priority) {
  if (this.length === 0) return
  this._torrent.select(this._startPiece, this._endPiece, priority)
}

File.prototype.deselect = function () {
  if (this.length === 0) return
  this._torrent.deselect(this._startPiece, this._endPiece, false)
}

File.prototype.createReadStream = function (opts) {
  var self = this
  if (this.length === 0) {
    var empty = new stream.PassThrough()
    process.nextTick(function () {
      empty.end()
    })
    return empty
  }

  var fileStream = new FileStream(self, opts)
  self._torrent.select(fileStream._startPiece, fileStream._endPiece, true, function () {
    fileStream._notify()
  })
  eos(fileStream, function () {
    if (self._destroyed) return
    if (!self._torrent.destroyed) {
      self._torrent.deselect(fileStream._startPiece, fileStream._endPiece, true)
    }
  })
  return fileStream
}

File.prototype.getBuffer = function (cb) {
  streamToBuffer(this.createReadStream(), this.length, cb)
}

File.prototype.getBlobURL = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  var mime = render.mime[path.extname(this.name).toLowerCase()]
  streamToBlobURL(this.createReadStream(), mime, cb)
}

File.prototype.appendTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.append(this, elem, cb)
}

File.prototype.renderTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.render(this, elem, cb)
}

File.prototype._destroy = function () {
  this._destroyed = true
  this._torrent = null
}

}).call(this,require('_process'))

},{"./file-stream":131,"_process":73,"end-of-stream":34,"events":35,"inherits":43,"path":70,"readable-stream":86,"render-media":87,"stream-to-blob-url":103,"stream-with-known-length-to-buffer":105}],133:[function(require,module,exports){
var arrayRemove = require('unordered-array-remove')
var debug = require('debug')('webtorrent:peer')
var Wire = require('bittorrent-protocol')

var WebConn = require('./webconn')

var CONNECT_TIMEOUT_TCP = 5000
var CONNECT_TIMEOUT_WEBRTC = 25000
var HANDSHAKE_TIMEOUT = 25000

/**
 * WebRTC peer connections start out connected, because WebRTC peers require an
 * "introduction" (i.e. WebRTC signaling), and there's no equivalent to an IP address
 * that lets you refer to a WebRTC endpoint.
 */
exports.createWebRTCPeer = function (conn, swarm) {
  var peer = new Peer(conn.id, 'webrtc')
  peer.conn = conn
  peer.swarm = swarm

  if (peer.conn.connected) {
    peer.onConnect()
  } else {
    peer.conn.once('connect', function () { peer.onConnect() })
    peer.conn.once('error', function (err) { peer.destroy(err) })
    peer.startConnectTimeout()
  }

  return peer
}

/**
 * Incoming TCP peers start out connected, because the remote peer connected to the
 * listening port of the TCP server. Until the remote peer sends a handshake, we don't
 * know what swarm the connection is intended for.
 */
exports.createTCPIncomingPeer = function (conn) {
  var addr = conn.remoteAddress + ':' + conn.remotePort
  var peer = new Peer(addr, 'tcpIncoming')
  peer.conn = conn
  peer.addr = addr

  peer.onConnect()

  return peer
}

/**
 * Outgoing TCP peers start out with just an IP address. At some point (when there is an
 * available connection), the client can attempt to connect to the address.
 */
exports.createTCPOutgoingPeer = function (addr, swarm) {
  var peer = new Peer(addr, 'tcpOutgoing')
  peer.addr = addr
  peer.swarm = swarm

  return peer
}

/**
 * Peer that represents a Web Seed (BEP17 / BEP19).
 */
exports.createWebSeedPeer = function (url, swarm) {
  var peer = new Peer(url, 'webSeed')
  peer.swarm = swarm
  peer.conn = new WebConn(url, swarm)

  peer.onConnect()

  return peer
}

/**
 * Peer. Represents a peer in the torrent swarm.
 *
 * @param {string} id "ip:port" string, peer id (for WebRTC peers), or url (for Web Seeds)
 * @param {string} type the type of the peer
 */
function Peer (id, type) {
  var self = this
  self.id = id
  self.type = type

  debug('new Peer %s', id)

  self.addr = null
  self.conn = null
  self.swarm = null
  self.wire = null

  self.connected = false
  self.destroyed = false
  self.timeout = null // handshake timeout
  self.retries = 0 // outgoing TCP connection retry count

  self.sentHandshake = false
}

/**
 * Called once the peer is connected (i.e. fired 'connect' event)
 * @param {Socket} conn
 */
Peer.prototype.onConnect = function () {
  var self = this
  if (self.destroyed) return
  self.connected = true

  debug('Peer %s connected', self.id)

  clearTimeout(self.connectTimeout)

  var conn = self.conn
  conn.once('end', function () {
    self.destroy()
  })
  conn.once('close', function () {
    self.destroy()
  })
  conn.once('finish', function () {
    self.destroy()
  })
  conn.once('error', function (err) {
    self.destroy(err)
  })

  var wire = self.wire = new Wire()
  wire.type = self.type
  wire.once('end', function () {
    self.destroy()
  })
  wire.once('close', function () {
    self.destroy()
  })
  wire.once('finish', function () {
    self.destroy()
  })
  wire.once('error', function (err) {
    self.destroy(err)
  })

  wire.once('handshake', function (infoHash, peerId) {
    self.onHandshake(infoHash, peerId)
  })
  self.startHandshakeTimeout()

  conn.pipe(wire).pipe(conn)
  if (self.swarm && !self.sentHandshake) self.handshake()
}

/**
 * Called when handshake is received from remote peer.
 * @param {string} infoHash
 * @param {string} peerId
 */
Peer.prototype.onHandshake = function (infoHash, peerId) {
  var self = this
  if (!self.swarm) return // `self.swarm` not set yet, so do nothing
  if (self.destroyed) return

  if (self.swarm.destroyed) {
    return self.destroy(new Error('swarm already destroyed'))
  }
  if (infoHash !== self.swarm.infoHash) {
    return self.destroy(new Error('unexpected handshake info hash for this swarm'))
  }
  if (peerId === self.swarm.peerId) {
    return self.destroy(new Error('refusing to connect to ourselves'))
  }

  debug('Peer %s got handshake %s', self.id, infoHash)

  clearTimeout(self.handshakeTimeout)

  self.retries = 0

  var addr = self.addr
  if (!addr && self.conn.remoteAddress) {
    addr = self.conn.remoteAddress + ':' + self.conn.remotePort
  }
  self.swarm._onWire(self.wire, addr)

  // swarm could be destroyed in user's 'wire' event handler
  if (!self.swarm || self.swarm.destroyed) return

  if (!self.sentHandshake) self.handshake()
}

Peer.prototype.handshake = function () {
  var self = this
  var opts = {
    dht: self.swarm.private ? false : !!self.swarm.client.dht
  }
  self.wire.handshake(self.swarm.infoHash, self.swarm.client.peerId, opts)
  self.sentHandshake = true
}

Peer.prototype.startConnectTimeout = function () {
  var self = this
  clearTimeout(self.connectTimeout)
  self.connectTimeout = setTimeout(function () {
    self.destroy(new Error('connect timeout'))
  }, self.type === 'webrtc' ? CONNECT_TIMEOUT_WEBRTC : CONNECT_TIMEOUT_TCP)
  if (self.connectTimeout.unref) self.connectTimeout.unref()
}

Peer.prototype.startHandshakeTimeout = function () {
  var self = this
  clearTimeout(self.handshakeTimeout)
  self.handshakeTimeout = setTimeout(function () {
    self.destroy(new Error('handshake timeout'))
  }, HANDSHAKE_TIMEOUT)
  if (self.handshakeTimeout.unref) self.handshakeTimeout.unref()
}

Peer.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self.connected = false

  debug('destroy %s (error: %s)', self.id, err && (err.message || err))

  clearTimeout(self.connectTimeout)
  clearTimeout(self.handshakeTimeout)

  var swarm = self.swarm
  var conn = self.conn
  var wire = self.wire

  self.swarm = null
  self.conn = null
  self.wire = null

  if (swarm && wire) {
    arrayRemove(swarm.wires, swarm.wires.indexOf(wire))
  }
  if (conn) {
    conn.on('error', noop)
    conn.destroy()
  }
  if (wire) wire.destroy()
  if (swarm) swarm.removePeer(self.id)
}

function noop () {}

},{"./webconn":136,"bittorrent-protocol":10,"debug":31,"unordered-array-remove":116}],134:[function(require,module,exports){
module.exports = RarityMap

/**
 * Mapping of torrent pieces to their respective availability in the torrent swarm. Used
 * by the torrent manager for implementing the rarest piece first selection strategy.
 */
function RarityMap (torrent) {
  var self = this

  self._torrent = torrent
  self._numPieces = torrent.pieces.length
  self._pieces = []

  self._onWire = function (wire) {
    self.recalculate()
    self._initWire(wire)
  }
  self._onWireHave = function (index) {
    self._pieces[index] += 1
  }
  self._onWireBitfield = function () {
    self.recalculate()
  }

  self._torrent.wires.forEach(function (wire) {
    self._initWire(wire)
  })
  self._torrent.on('wire', self._onWire)
  self.recalculate()
}

/**
 * Get the index of the rarest piece. Optionally, pass a filter function to exclude
 * certain pieces (for instance, those that we already have).
 *
 * @param {function} pieceFilterFunc
 * @return {number} index of rarest piece, or -1
 */
RarityMap.prototype.getRarestPiece = function (pieceFilterFunc) {
  if (!pieceFilterFunc) pieceFilterFunc = trueFn

  var candidates = []
  var min = Infinity

  for (var i = 0; i < this._numPieces; ++i) {
    if (!pieceFilterFunc(i)) continue

    var availability = this._pieces[i]
    if (availability === min) {
      candidates.push(i)
    } else if (availability < min) {
      candidates = [ i ]
      min = availability
    }
  }

  if (candidates.length > 0) {
    // if there are multiple pieces with the same availability, choose one randomly
    return candidates[Math.random() * candidates.length | 0]
  } else {
    return -1
  }
}

RarityMap.prototype.destroy = function () {
  var self = this
  self._torrent.removeListener('wire', self._onWire)
  self._torrent.wires.forEach(function (wire) {
    self._cleanupWireEvents(wire)
  })
  self._torrent = null
  self._pieces = null

  self._onWire = null
  self._onWireHave = null
  self._onWireBitfield = null
}

RarityMap.prototype._initWire = function (wire) {
  var self = this

  wire._onClose = function () {
    self._cleanupWireEvents(wire)
    for (var i = 0; i < this._numPieces; ++i) {
      self._pieces[i] -= wire.peerPieces.get(i)
    }
  }

  wire.on('have', self._onWireHave)
  wire.on('bitfield', self._onWireBitfield)
  wire.once('close', wire._onClose)
}

/**
 * Recalculates piece availability across all peers in the torrent.
 */
RarityMap.prototype.recalculate = function () {
  var i
  for (i = 0; i < this._numPieces; ++i) {
    this._pieces[i] = 0
  }

  var numWires = this._torrent.wires.length
  for (i = 0; i < numWires; ++i) {
    var wire = this._torrent.wires[i]
    for (var j = 0; j < this._numPieces; ++j) {
      this._pieces[j] += wire.peerPieces.get(j)
    }
  }
}

RarityMap.prototype._cleanupWireEvents = function (wire) {
  wire.removeListener('have', this._onWireHave)
  wire.removeListener('bitfield', this._onWireBitfield)
  if (wire._onClose) wire.removeListener('close', wire._onClose)
  wire._onClose = null
}

function trueFn () {
  return true
}

},{}],135:[function(require,module,exports){
(function (process,global){
/* global URL, Blob */

module.exports = Torrent

var addrToIPPort = require('addr-to-ip-port')
var BitField = require('bitfield')
var ChunkStoreWriteStream = require('chunk-store-stream/write')
var debug = require('debug')('webtorrent:torrent')
var Discovery = require('torrent-discovery')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var extendMutable = require('xtend/mutable')
var fs = require('fs')
var FSChunkStore = require('fs-chunk-store') // browser: `memory-chunk-store`
var get = require('simple-get')
var ImmediateChunkStore = require('immediate-chunk-store')
var inherits = require('inherits')
var MultiStream = require('multistream')
var net = require('net') // browser exclude
var os = require('os') // browser exclude
var parallel = require('run-parallel')
var parallelLimit = require('run-parallel-limit')
var parseTorrent = require('parse-torrent')
var path = require('path')
var Piece = require('torrent-piece')
var pump = require('pump')
var randomIterate = require('random-iterate')
var sha1 = require('simple-sha1')
var speedometer = require('speedometer')
var uniq = require('uniq')
var utMetadata = require('ut_metadata')
var utPex = require('ut_pex') // browser exclude

var File = require('./file')
var Peer = require('./peer')
var RarityMap = require('./rarity-map')
var Server = require('./server') // browser exclude

var MAX_BLOCK_LENGTH = 128 * 1024
var PIECE_TIMEOUT = 30000
var CHOKE_TIMEOUT = 5000
var SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH

var PIPELINE_MIN_DURATION = 0.5
var PIPELINE_MAX_DURATION = 1

var RECHOKE_INTERVAL = 10000 // 10 seconds
var RECHOKE_OPTIMISTIC_DURATION = 2 // 30 seconds

var FILESYSTEM_CONCURRENCY = 2

var RECONNECT_WAIT = [ 1000, 5000, 15000 ]

var VERSION = require('../package.json').version

var TMP
try {
  TMP = path.join(fs.statSync('/tmp') && '/tmp', 'webtorrent')
} catch (err) {
  TMP = path.join(typeof os.tmpDir === 'function' ? os.tmpDir() : '/', 'webtorrent')
}

inherits(Torrent, EventEmitter)

function Torrent (torrentId, client, opts) {
  EventEmitter.call(this)

  this.client = client
  this._debugId = this.client.peerId.slice(32)

  this._debug('new torrent')

  this.announce = opts.announce
  this.urlList = opts.urlList

  this.path = opts.path
  this._store = opts.store || FSChunkStore
  this._getAnnounceOpts = opts.getAnnounceOpts

  this.strategy = opts.strategy || 'sequential'

  this.maxWebConns = opts.maxWebConns || 4

  this._rechokeNumSlots = (opts.uploads === false || opts.uploads === 0)
    ? 0
    : (+opts.uploads || 10)
  this._rechokeOptimisticWire = null
  this._rechokeOptimisticTime = 0
  this._rechokeIntervalId = null

  this.ready = false
  this.destroyed = false
  this.paused = false
  this.done = false

  this.metadata = null
  this.store = null
  this.files = []
  this.pieces = []

  this._amInterested = false
  this._selections = []
  this._critical = []

  this.wires = [] // open wires (added *after* handshake)

  this._queue = [] // queue of outgoing tcp peers to connect to
  this._peers = {} // connected peers (addr/peerId -> Peer)
  this._peersLength = 0 // number of elements in `this._peers` (cache, for perf)

  // stats
  this.received = 0
  this.uploaded = 0
  this._downloadSpeed = speedometer()
  this._uploadSpeed = speedometer()

  // for cleanup
  this._servers = []
  this._xsRequests = []

  // TODO: remove this and expose a hook instead
  // optimization: don't recheck every file if it hasn't changed
  this._fileModtimes = opts.fileModtimes

  if (torrentId !== null) this._onTorrentId(torrentId)
}

Object.defineProperty(Torrent.prototype, 'timeRemaining', {
  get: function () {
    if (this.done) return 0
    if (this.downloadSpeed === 0) return Infinity
    return ((this.length - this.downloaded) / this.downloadSpeed) * 1000
  }
})

Object.defineProperty(Torrent.prototype, 'downloaded', {
  get: function () {
    if (!this.bitfield) return 0
    var downloaded = 0
    for (var index = 0, len = this.pieces.length; index < len; ++index) {
      if (this.bitfield.get(index)) { // verified data
        downloaded += (index === len - 1) ? this.lastPieceLength : this.pieceLength
      } else { // "in progress" data
        var piece = this.pieces[index]
        downloaded += (piece.length - piece.missing)
      }
    }
    return downloaded
  }
})

// TODO: re-enable this. The number of missing pieces. Used to implement 'end game' mode.
// Object.defineProperty(Storage.prototype, 'numMissing', {
//   get: function () {
//     var self = this
//     var numMissing = self.pieces.length
//     for (var index = 0, len = self.pieces.length; index < len; index++) {
//       numMissing -= self.bitfield.get(index)
//     }
//     return numMissing
//   }
// })

Object.defineProperty(Torrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'progress', {
  get: function () { return this.length ? this.downloaded / this.length : 0 }
})

Object.defineProperty(Torrent.prototype, 'ratio', {
  get: function () { return this.uploaded / (this.received || 1) }
})

Object.defineProperty(Torrent.prototype, 'numPeers', {
  get: function () { return this.wires.length }
})

Object.defineProperty(Torrent.prototype, 'torrentFileBlobURL', {
  get: function () {
    if (typeof window === 'undefined') throw new Error('browser-only property')
    if (!this.torrentFile) return null
    return URL.createObjectURL(
      new Blob([ this.torrentFile ], { type: 'application/x-bittorrent' })
    )
  }
})

Object.defineProperty(Torrent.prototype, '_numQueued', {
  get: function () {
    return this._queue.length + (this._peersLength - this._numConns)
  }
})

Object.defineProperty(Torrent.prototype, '_numConns', {
  get: function () {
    var self = this
    var numConns = 0
    for (var id in self._peers) {
      if (self._peers[id].connected) numConns += 1
    }
    return numConns
  }
})

// TODO: remove in v1
Object.defineProperty(Torrent.prototype, 'swarm', {
  get: function () {
    console.warn('WebTorrent: `torrent.swarm` is deprecated. Use `torrent` directly instead.')
    return this
  }
})

Torrent.prototype._onTorrentId = function (torrentId) {
  var self = this
  if (self.destroyed) return

  var parsedTorrent
  try { parsedTorrent = parseTorrent(torrentId) } catch (err) {}
  if (parsedTorrent) {
    // Attempt to set infoHash property synchronously
    self.infoHash = parsedTorrent.infoHash
    process.nextTick(function () {
      if (self.destroyed) return
      self._onParsedTorrent(parsedTorrent)
    })
  } else {
    // If torrentId failed to parse, it could be in a form that requires an async
    // operation, i.e. http/https link, filesystem path, or Blob.
    parseTorrent.remote(torrentId, function (err, parsedTorrent) {
      if (self.destroyed) return
      if (err) return self._destroy(err)
      self._onParsedTorrent(parsedTorrent)
    })
  }
}

Torrent.prototype._onParsedTorrent = function (parsedTorrent) {
  var self = this
  if (self.destroyed) return

  self._processParsedTorrent(parsedTorrent)

  if (!self.infoHash) {
    return self._destroy(new Error('Malformed torrent data: No info hash'))
  }

  if (!self.path) self.path = path.join(TMP, self.infoHash)

  self._rechokeIntervalId = setInterval(function () {
    self._rechoke()
  }, RECHOKE_INTERVAL)
  if (self._rechokeIntervalId.unref) self._rechokeIntervalId.unref()

  // Private 'infoHash' event allows client.add to check for duplicate torrents and
  // destroy them before the normal 'infoHash' event is emitted. Prevents user
  // applications from needing to deal with duplicate 'infoHash' events.
  self.emit('_infoHash', self.infoHash)
  if (self.destroyed) return

  self.emit('infoHash', self.infoHash)
  if (self.destroyed) return // user might destroy torrent in event handler

  if (self.client.listening) {
    self._onListening()
  } else {
    self.client.once('listening', function () {
      self._onListening()
    })
  }
}

Torrent.prototype._processParsedTorrent = function (parsedTorrent) {
  if (this.announce) {
    // Allow specifying trackers via `opts` parameter
    parsedTorrent.announce = parsedTorrent.announce.concat(this.announce)
  }

  if (this.client.tracker && global.WEBTORRENT_ANNOUNCE && !this.private) {
    // So `webtorrent-hybrid` can force specific trackers to be used
    parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE)
  }

  if (this.urlList) {
    // Allow specifying web seeds via `opts` parameter
    parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList)
  }

  uniq(parsedTorrent.announce)
  uniq(parsedTorrent.urlList)

  extendMutable(this, parsedTorrent)

  this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent)
  this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent)
}

Torrent.prototype._onListening = function () {
  var self = this
  if (self.discovery || self.destroyed) return

  var trackerOpts = self.client.tracker
  if (trackerOpts) {
    trackerOpts = extend(self.client.tracker, {
      getAnnounceOpts: function () {
        var opts = {
          uploaded: self.uploaded,
          downloaded: self.downloaded,
          left: Math.max(self.length - self.downloaded, 0)
        }
        if (self.client.tracker.getAnnounceOpts) {
          extendMutable(opts, self.client.tracker.getAnnounceOpts())
        }
        if (self._getAnnounceOpts) {
          // TODO: consider deprecating this, as it's redundant with the former case
          extendMutable(opts, self._getAnnounceOpts())
        }
        return opts
      }
    })
  }

  // begin discovering peers via DHT and trackers
  self.discovery = new Discovery({
    infoHash: self.infoHash,
    announce: self.announce,
    peerId: self.client.peerId,
    dht: !self.private && self.client.dht,
    tracker: trackerOpts,
    port: self.client.torrentPort
  })

  self.discovery.on('error', onError)
  self.discovery.on('peer', onPeer)
  self.discovery.on('trackerAnnounce', onTrackerAnnounce)
  self.discovery.on('dhtAnnounce', onDHTAnnounce)
  self.discovery.on('warning', onWarning)

  function onError (err) {
    self._destroy(err)
  }

  function onPeer (peer) {
    // Don't create new outgoing TCP connections when torrent is done
    if (typeof peer === 'string' && self.done) return
    self.addPeer(peer)
  }

  function onTrackerAnnounce () {
    self.emit('trackerAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'tracker')
  }

  function onDHTAnnounce () {
    self.emit('dhtAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'dht')
  }

  function onWarning (err) {
    self.emit('warning', err)
  }

  if (self.info) {
    // if full metadata was included in initial torrent id, use it immediately. Otherwise,
    // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
    self._onMetadata(self)
  } else if (self.xs) {
    self._getMetadataFromServer()
  }
}

Torrent.prototype._getMetadataFromServer = function () {
  var self = this
  var urls = Array.isArray(self.xs) ? self.xs : [ self.xs ]

  var tasks = urls.map(function (url) {
    return function (cb) {
      getMetadataFromURL(url, cb)
    }
  })
  parallel(tasks)

  function getMetadataFromURL (url, cb) {
    if (url.indexOf('http://') !== 0 && url.indexOf('https://') !== 0) {
      self._debug('skipping non-http xs param: %s', url)
      return cb(null)
    }

    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'
      }
    }
    var req
    try {
      req = get.concat(opts, onResponse)
    } catch (err) {
      self._debug('skipping invalid url xs param: %s', url)
      return cb(null)
    }

    self._xsRequests.push(req)

    function onResponse (err, res, torrent) {
      if (self.destroyed) return cb(null)
      if (self.metadata) return cb(null)

      if (err) {
        self._debug('http error from xs param: %s', url)
        return cb(null)
      }
      if (res.statusCode !== 200) {
        self._debug('non-200 status code %s from xs param: %s', res.statusCode, url)
        return cb(null)
      }

      var parsedTorrent
      try {
        parsedTorrent = parseTorrent(torrent)
      } catch (err) {}

      if (!parsedTorrent) {
        self._debug('got invalid torrent file from xs param: %s', url)
        return cb(null)
      }

      if (parsedTorrent.infoHash !== self.infoHash) {
        self._debug('got torrent file with incorrect info hash from xs param: %s', url)
        return cb(null)
      }

      self._onMetadata(parsedTorrent)
      cb(null)
    }
  }
}

/**
 * Called when the full torrent metadata is received.
 */
Torrent.prototype._onMetadata = function (metadata) {
  var self = this
  if (self.metadata || self.destroyed) return
  self._debug('got metadata')

  self._xsRequests.forEach(function (req) {
    req.abort()
  })
  self._xsRequests = []

  var parsedTorrent
  if (metadata && metadata.infoHash) {
    // `metadata` is a parsed torrent (from parse-torrent module)
    parsedTorrent = metadata
  } else {
    try {
      parsedTorrent = parseTorrent(metadata)
    } catch (err) {
      return self._destroy(err)
    }
  }

  self._processParsedTorrent(parsedTorrent)
  self.metadata = self.torrentFile

  // add web seed urls (BEP19)
  self.urlList.forEach(function (url) {
    self.addWebSeed(url)
  })

  self._rarityMap = new RarityMap(self)

  self.store = new ImmediateChunkStore(
    new self._store(self.pieceLength, {
      torrent: {
        infoHash: self.infoHash
      },
      files: self.files.map(function (file) {
        return {
          path: path.join(self.path, file.path),
          length: file.length,
          offset: file.offset
        }
      }),
      length: self.length
    })
  )

  self.files = self.files.map(function (file) {
    return new File(self, file)
  })

  self._hashes = self.pieces

  self.pieces = self.pieces.map(function (hash, i) {
    var pieceLength = (i === self.pieces.length - 1)
      ? self.lastPieceLength
      : self.pieceLength
    return new Piece(pieceLength)
  })

  self._reservations = self.pieces.map(function () {
    return []
  })

  self.bitfield = new BitField(self.pieces.length)

  self.wires.forEach(function (wire) {
    // If we didn't have the metadata at the time ut_metadata was initialized for this
    // wire, we still want to make it available to the peer in case they request it.
    if (wire.ut_metadata) wire.ut_metadata.setMetadata(self.metadata)

    self._onWireWithMetadata(wire)
  })

  self._debug('verifying existing torrent data')
  if (self._fileModtimes && self._store === FSChunkStore) {
    // don't verify if the files haven't been modified since we last checked
    self.getFileModtimes(function (err, fileModtimes) {
      if (err) return self._destroy(err)

      var unchanged = self.files.map(function (_, index) {
        return fileModtimes[index] === self._fileModtimes[index]
      }).every(function (x) {
        return x
      })

      if (unchanged) {
        for (var index = 0; index < self.pieces.length; index++) {
          self._markVerified(index)
        }
        self._onStore()
      } else {
        self._verifyPieces()
      }
    })
  } else {
    self._verifyPieces()
  }

  self.emit('metadata')
}

/*
 * TODO: remove this
 * Gets the last modified time of every file on disk for this torrent.
 * Only valid in Node, not in the browser.
 */
Torrent.prototype.getFileModtimes = function (cb) {
  var self = this
  var ret = []
  parallelLimit(self.files.map(function (file, index) {
    return function (cb) {
      fs.stat(path.join(self.path, file.path), function (err, stat) {
        if (err && err.code !== 'ENOENT') return cb(err)
        ret[index] = stat && stat.mtime.getTime()
        cb(null)
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    self._debug('done getting file modtimes')
    cb(err, ret)
  })
}

Torrent.prototype._verifyPieces = function () {
  var self = this
  parallelLimit(self.pieces.map(function (_, index) {
    return function (cb) {
      if (self.destroyed) return cb(new Error('torrent is destroyed'))
      self.store.get(index, function (err, buf) {
        if (err) return cb(null) // ignore error
        sha1(buf, function (hash) {
          if (hash === self._hashes[index]) {
            if (!self.pieces[index]) return
            self._debug('piece verified %s', index)
            self._markVerified(index)
          } else {
            self._debug('piece invalid %s', index)
          }
          cb(null)
        })
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    if (err) return self._destroy(err)
    self._debug('done verifying')
    self._onStore()
  })
}

Torrent.prototype._markVerified = function (index) {
  this.pieces[index] = null
  this._reservations[index] = null
  this.bitfield.set(index, true)
}

/**
 * Called when the metadata, listening server, and underlying chunk store is initialized.
 */
Torrent.prototype._onStore = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on store')

  // start off selecting the entire torrent with low priority
  if (self.pieces.length !== 0) {
    self.select(0, self.pieces.length - 1, false)
  }

  self.ready = true
  self.emit('ready')

  // Files may start out done if the file was already in the store
  self._checkDone()

  // In case any selections were made before torrent was ready
  self._updateSelections()
}

Torrent.prototype.destroy = function (cb) {
  var self = this
  self._destroy(null, cb)
}

Torrent.prototype._destroy = function (err, cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self._debug('destroy')

  self.client._remove(self)

  clearInterval(self._rechokeIntervalId)

  self._xsRequests.forEach(function (req) {
    req.abort()
  })

  if (self._rarityMap) {
    self._rarityMap.destroy()
  }

  for (var id in self._peers) {
    self.removePeer(id)
  }

  self.files.forEach(function (file) {
    if (file instanceof File) file._destroy()
  })

  var tasks = self._servers.map(function (server) {
    return function (cb) {
      server.destroy(cb)
    }
  })

  if (self.discovery) {
    tasks.push(function (cb) {
      self.discovery.destroy(cb)
    })
  }

  if (self.store) {
    tasks.push(function (cb) {
      self.store.close(cb)
    })
  }

  parallel(tasks, cb)

  if (err) {
    // Torrent errors are emitted at `torrent.on('error')`. If there are no 'error' event
    // handlers on the torrent instance, the error will be emitted at
    // `client.on('error')`. This prevents crashing the user's program, but it makes it
    // impossible to determine a client error versus a torrent error (where the client
    // is still usable afterwards). Users are recommended for errors in both places
    // to distinguish between the error types.
    if (self.listenerCount('error') === 0) {
      self.client.emit('error', err)
    } else {
      self.emit('error', err)
    }
  }

  self.emit('close')

  self.client = null
  self.files = []
  self.discovery = null
  self.store = null
  self._rarityMap = null
  self._peers = null
  self._servers = null
  self._xsRequests = null
}

Torrent.prototype.addPeer = function (peer) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.infoHash) throw new Error('addPeer() must not be called before the `infoHash` event')

  if (self.client.blocked) {
    var host
    if (typeof peer === 'string') {
      var parts
      try {
        parts = addrToIPPort(peer)
      } catch (e) {
        self._debug('ignoring peer: invalid %s', peer)
        self.emit('invalidPeer', peer)
        return false
      }
      host = parts[0]
    } else if (typeof peer.remoteAddress === 'string') {
      host = peer.remoteAddress
    }

    if (host && self.client.blocked.contains(host)) {
      self._debug('ignoring peer: blocked %s', peer)
      if (typeof peer !== 'string') peer.destroy()
      self.emit('blockedPeer', peer)
      return false
    }
  }

  var wasAdded = !!self._addPeer(peer)
  if (wasAdded) {
    self.emit('peer', peer)
  } else {
    self.emit('invalidPeer', peer)
  }
  return wasAdded
}

Torrent.prototype._addPeer = function (peer) {
  var self = this
  if (self.destroyed) {
    self._debug('ignoring peer: torrent is destroyed')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }
  if (typeof peer === 'string' && !self._validAddr(peer)) {
    self._debug('ignoring peer: invalid %s', peer)
    return null
  }

  var id = (peer && peer.id) || peer
  if (self._peers[id]) {
    self._debug('ignoring peer: duplicate (%s)', id)
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  if (self.paused) {
    self._debug('ignoring peer: torrent is paused')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  self._debug('add peer %s', id)

  var newPeer
  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    newPeer = Peer.createTCPOutgoingPeer(peer, self)
  } else {
    // `peer` is a WebRTC connection (simple-peer)
    newPeer = Peer.createWebRTCPeer(peer, self)
  }

  self._peers[newPeer.id] = newPeer
  self._peersLength += 1

  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    self._queue.push(newPeer)
    self._drain()
  }

  return newPeer
}

Torrent.prototype.addWebSeed = function (url) {
  if (this.destroyed) throw new Error('torrent is destroyed')

  if (!/^https?:\/\/.+/.test(url)) {
    this._debug('ignoring invalid web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  if (this._peers[url]) {
    this._debug('ignoring duplicate web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  this._debug('add web seed %s', url)

  var newPeer = Peer.createWebSeedPeer(url, this)
  this._peers[newPeer.id] = newPeer
  this._peersLength += 1

  this.emit('peer', url)
}

/**
 * Called whenever a new incoming TCP peer connects to this torrent swarm. Called with a
 * peer that has already sent a handshake.
 */
Torrent.prototype._addIncomingPeer = function (peer) {
  var self = this
  if (self.destroyed) return peer.destroy(new Error('torrent is destroyed'))
  if (self.paused) return peer.destroy(new Error('torrent is paused'))

  this._debug('add incoming peer %s', peer.id)

  self._peers[peer.id] = peer
  self._peersLength += 1
}

Torrent.prototype.removePeer = function (peer) {
  var self = this
  var id = (peer && peer.id) || peer
  peer = self._peers[id]

  if (!peer) return

  this._debug('removePeer %s', id)

  delete self._peers[id]
  self._peersLength -= 1

  peer.destroy()

  // If torrent swarm was at capacity before, try to open a new connection now
  self._drain()
}

Torrent.prototype.select = function (start, end, priority, notify) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  if (start < 0 || end < start || self.pieces.length <= end) {
    throw new Error('invalid selection ', start, ':', end)
  }
  priority = Number(priority) || 0

  self._debug('select %s-%s (priority %s)', start, end, priority)

  self._selections.push({
    from: start,
    to: end,
    offset: 0,
    priority: priority,
    notify: notify || noop
  })

  self._selections.sort(function (a, b) {
    return b.priority - a.priority
  })

  self._updateSelections()
}

Torrent.prototype.deselect = function (start, end, priority) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  priority = Number(priority) || 0
  self._debug('deselect %s-%s (priority %s)', start, end, priority)

  for (var i = 0; i < self._selections.length; ++i) {
    var s = self._selections[i]
    if (s.from === start && s.to === end && s.priority === priority) {
      self._selections.splice(i--, 1)
      break
    }
  }

  self._updateSelections()
}

Torrent.prototype.critical = function (start, end) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  self._debug('critical %s-%s', start, end)

  for (var i = start; i <= end; ++i) {
    self._critical[i] = true
  }

  self._updateSelections()
}

Torrent.prototype._onWire = function (wire, addr) {
  var self = this
  self._debug('got wire %s (%s)', wire._debugId, addr || 'Unknown')

  wire.on('download', function (downloaded) {
    if (self.destroyed) return
    self.received += downloaded
    self._downloadSpeed(downloaded)
    self.client._downloadSpeed(downloaded)
    self.emit('download', downloaded)
    self.client.emit('download', downloaded)
  })

  wire.on('upload', function (uploaded) {
    if (self.destroyed) return
    self.uploaded += uploaded
    self._uploadSpeed(uploaded)
    self.client._uploadSpeed(uploaded)
    self.emit('upload', uploaded)
    self.client.emit('upload', uploaded)
  })

  self.wires.push(wire)

  if (addr) {
    // Sometimes RTCPeerConnection.getStats() doesn't return an ip:port for peers
    var parts = addrToIPPort(addr)
    wire.remoteAddress = parts[0]
    wire.remotePort = parts[1]
  }

  // When peer sends PORT message, add that DHT node to routing table
  if (self.client.dht && self.client.dht.listening) {
    wire.on('port', function (port) {
      if (self.destroyed || self.client.dht.destroyed) {
        return
      }
      if (!wire.remoteAddress) {
        return self._debug('ignoring PORT from peer with no address')
      }
      if (port === 0 || port > 65536) {
        return self._debug('ignoring invalid PORT from peer')
      }

      self._debug('port: %s (from %s)', port, addr)
      self.client.dht.addNode({ host: wire.remoteAddress, port: port })
    })
  }

  wire.on('timeout', function () {
    self._debug('wire timeout (%s)', addr)
    // TODO: this might be destroying wires too eagerly
    wire.destroy()
  })

  // Timeout for piece requests to this peer
  wire.setTimeout(PIECE_TIMEOUT, true)

  // Send KEEP-ALIVE (every 60s) so peers will not disconnect the wire
  wire.setKeepAlive(true)

  // use ut_metadata extension
  wire.use(utMetadata(self.metadata))

  wire.ut_metadata.on('warning', function (err) {
    self._debug('ut_metadata warning: %s', err.message)
  })

  if (!self.metadata) {
    wire.ut_metadata.on('metadata', function (metadata) {
      self._debug('got metadata via ut_metadata')
      self._onMetadata(metadata)
    })
    wire.ut_metadata.fetch()
  }

  // use ut_pex extension if the torrent is not flagged as private
  if (typeof utPex === 'function' && !self.private) {
    wire.use(utPex())

    wire.ut_pex.on('peer', function (peer) {
      // Only add potential new peers when we're not seeding
      if (self.done) return
      self._debug('ut_pex: got peer: %s (from %s)', peer, addr)
      self.addPeer(peer)
    })

    wire.ut_pex.on('dropped', function (peer) {
      // the remote peer believes a given peer has been dropped from the torrent swarm.
      // if we're not currently connected to it, then remove it from the queue.
      var peerObj = self._peers[peer]
      if (peerObj && !peerObj.connected) {
        self._debug('ut_pex: dropped peer: %s (from %s)', peer, addr)
        self.removePeer(peer)
      }
    })

    wire.once('close', function () {
      // Stop sending updates to remote peer
      wire.ut_pex.reset()
    })
  }

  // Hook to allow user-defined `bittorrent-protocol` extensions
  // More info: https://github.com/feross/bittorrent-protocol#extension-api
  self.emit('wire', wire, addr)

  if (self.metadata) {
    process.nextTick(function () {
      // This allows wire.handshake() to be called (by Peer.onHandshake) before any
      // messages get sent on the wire
      self._onWireWithMetadata(wire)
    })
  }
}

Torrent.prototype._onWireWithMetadata = function (wire) {
  var self = this
  var timeoutId = null

  function onChokeTimeout () {
    if (self.destroyed || wire.destroyed) return

    if (self._numQueued > 2 * (self._numConns - self.numPeers) &&
      wire.amInterested) {
      wire.destroy()
    } else {
      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
      if (timeoutId.unref) timeoutId.unref()
    }
  }

  var i = 0
  function updateSeedStatus () {
    if (wire.peerPieces.length !== self.pieces.length) return
    for (; i < self.pieces.length; ++i) {
      if (!wire.peerPieces.get(i)) return
    }
    wire.isSeeder = true
    wire.choke() // always choke seeders
  }

  wire.on('bitfield', function () {
    updateSeedStatus()
    self._update()
  })

  wire.on('have', function () {
    updateSeedStatus()
    self._update()
  })

  wire.once('interested', function () {
    wire.unchoke()
  })

  wire.once('close', function () {
    clearTimeout(timeoutId)
  })

  wire.on('choke', function () {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
    if (timeoutId.unref) timeoutId.unref()
  })

  wire.on('unchoke', function () {
    clearTimeout(timeoutId)
    self._update()
  })

  wire.on('request', function (index, offset, length, cb) {
    if (length > MAX_BLOCK_LENGTH) {
      // Per spec, disconnect from peers that request >128KB
      return wire.destroy()
    }
    if (self.pieces[index]) return
    self.store.get(index, { offset: offset, length: length }, cb)
  })

  wire.bitfield(self.bitfield) // always send bitfield (required)
  wire.interested() // always start out interested

  // Send PORT message to peers that support DHT
  if (wire.peerExtensions.dht && self.client.dht && self.client.dht.listening) {
    wire.port(self.client.dht.address().port)
  }

  timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
  if (timeoutId.unref) timeoutId.unref()

  wire.isSeeder = false
  updateSeedStatus()
}

/**
 * Called on selection changes.
 */
Torrent.prototype._updateSelections = function () {
  var self = this
  if (!self.ready || self.destroyed) return

  process.nextTick(function () {
    self._gcSelections()
  })
  self._updateInterest()
  self._update()
}

/**
 * Garbage collect selections with respect to the store's current state.
 */
Torrent.prototype._gcSelections = function () {
  var self = this

  for (var i = 0; i < self._selections.length; i++) {
    var s = self._selections[i]
    var oldOffset = s.offset

    // check for newly downloaded pieces in selection
    while (self.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
      s.offset++
    }

    if (oldOffset !== s.offset) s.notify()
    if (s.to !== s.from + s.offset) continue
    if (!self.bitfield.get(s.from + s.offset)) continue

    // remove fully downloaded selection
    self._selections.splice(i--, 1) // decrement i to offset splice
    s.notify() // TODO: this may notify twice in a row. is this a problem?
    self._updateInterest()
  }

  if (!self._selections.length) self.emit('idle')
}

/**
 * Update interested status for all peers.
 */
Torrent.prototype._updateInterest = function () {
  var self = this

  var prev = self._amInterested
  self._amInterested = !!self._selections.length

  self.wires.forEach(function (wire) {
    // TODO: only call wire.interested if the wire has at least one piece we need
    if (self._amInterested) wire.interested()
    else wire.uninterested()
  })

  if (prev === self._amInterested) return
  if (self._amInterested) self.emit('interested')
  else self.emit('uninterested')
}

/**
 * Heartbeat to update all peers and their requests.
 */
Torrent.prototype._update = function () {
  var self = this
  if (self.destroyed) return

  // update wires in random order for better request distribution
  var ite = randomIterate(self.wires)
  var wire
  while ((wire = ite())) {
    self._updateWire(wire)
  }
}

/**
 * Attempts to update a peer's requests
 */
Torrent.prototype._updateWire = function (wire) {
  var self = this

  if (wire.peerChoking) return
  if (!wire.downloaded) return validateWire()

  var minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION)
  if (wire.requests.length >= minOutstandingRequests) return
  var maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  trySelectWire(false) || trySelectWire(true)

  function genPieceFilterFunc (start, end, tried, rank) {
    return function (i) {
      return i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i))
    }
  }

  // TODO: Do we need both validateWire and trySelectWire?
  function validateWire () {
    if (wire.requests.length) return

    var i = self._selections.length
    while (i--) {
      var next = self._selections[i]
      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break
          if (self._request(wire, piece, false)) return
          tried[piece] = true
          tries += 1
        }
      } else {
        for (piece = next.to; piece >= next.from + next.offset; --piece) {
          if (!wire.peerPieces.get(piece)) continue
          if (self._request(wire, piece, false)) return
        }
      }
    }

    // TODO: wire failed to validate as useful; should we close it?
    // probably not, since 'have' and 'bitfield' messages might be coming
  }

  function speedRanker () {
    var speed = wire.downloadSpeed() || 1
    if (speed > SPEED_THRESHOLD) return function () { return true }

    var secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed
    var tries = 10
    var ptr = 0

    return function (index) {
      if (!tries || self.bitfield.get(index)) return true

      var missing = self.pieces[index].missing

      for (; ptr < self.wires.length; ptr++) {
        var otherWire = self.wires[ptr]
        var otherSpeed = otherWire.downloadSpeed()

        if (otherSpeed < SPEED_THRESHOLD) continue
        if (otherSpeed <= speed) continue
        if (!otherWire.peerPieces.get(index)) continue
        if ((missing -= otherSpeed * secs) > 0) continue

        tries--
        return false
      }

      return true
    }
  }

  function shufflePriority (i) {
    var last = i
    for (var j = i; j < self._selections.length && self._selections[j].priority; j++) {
      last = j
    }
    var tmp = self._selections[i]
    self._selections[i] = self._selections[last]
    self._selections[last] = tmp
  }

  function trySelectWire (hotswap) {
    if (wire.requests.length >= maxOutstandingRequests) return true
    var rank = speedRanker()

    for (var i = 0; i < self._selections.length; i++) {
      var next = self._selections[i]

      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried, rank)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break

          // request all non-reserved blocks in this piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) {
            tried[piece] = true
            tries++
            continue
          }

          if (next.priority) shufflePriority(i)
          return true
        }
      } else {
        for (piece = next.from + next.offset; piece <= next.to; piece++) {
          if (!wire.peerPieces.get(piece) || !rank(piece)) continue

          // request all non-reserved blocks in piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) continue

          if (next.priority) shufflePriority(i)
          return true
        }
      }
    }

    return false
  }
}

/**
 * Called periodically to update the choked status of all peers, handling optimistic
 * unchoking as described in BEP3.
 */
Torrent.prototype._rechoke = function () {
  var self = this
  if (!self.ready) return

  if (self._rechokeOptimisticTime > 0) self._rechokeOptimisticTime -= 1
  else self._rechokeOptimisticWire = null

  var peers = []

  self.wires.forEach(function (wire) {
    if (!wire.isSeeder && wire !== self._rechokeOptimisticWire) {
      peers.push({
        wire: wire,
        downloadSpeed: wire.downloadSpeed(),
        uploadSpeed: wire.uploadSpeed(),
        salt: Math.random(),
        isChoked: true
      })
    }
  })

  peers.sort(rechokeSort)

  var unchokeInterested = 0
  var i = 0
  for (; i < peers.length && unchokeInterested < self._rechokeNumSlots; ++i) {
    peers[i].isChoked = false
    if (peers[i].wire.peerInterested) unchokeInterested += 1
  }

  // Optimistically unchoke a peer
  if (!self._rechokeOptimisticWire && i < peers.length && self._rechokeNumSlots) {
    var candidates = peers.slice(i).filter(function (peer) { return peer.wire.peerInterested })
    var optimistic = candidates[randomInt(candidates.length)]

    if (optimistic) {
      optimistic.isChoked = false
      self._rechokeOptimisticWire = optimistic.wire
      self._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION
    }
  }

  // Unchoke best peers
  peers.forEach(function (peer) {
    if (peer.wire.amChoking !== peer.isChoked) {
      if (peer.isChoked) peer.wire.choke()
      else peer.wire.unchoke()
    }
  })

  function rechokeSort (peerA, peerB) {
    // Prefer higher download speed
    if (peerA.downloadSpeed !== peerB.downloadSpeed) {
      return peerB.downloadSpeed - peerA.downloadSpeed
    }

    // Prefer higher upload speed
    if (peerA.uploadSpeed !== peerB.uploadSpeed) {
      return peerB.uploadSpeed - peerA.uploadSpeed
    }

    // Prefer unchoked
    if (peerA.wire.amChoking !== peerB.wire.amChoking) {
      return peerA.wire.amChoking ? 1 : -1
    }

    // Random order
    return peerA.salt - peerB.salt
  }
}

/**
 * Attempts to cancel a slow block request from another wire such that the
 * given wire may effectively swap out the request for one of its own.
 */
Torrent.prototype._hotswap = function (wire, index) {
  var self = this

  var speed = wire.downloadSpeed()
  if (speed < Piece.BLOCK_LENGTH) return false
  if (!self._reservations[index]) return false

  var r = self._reservations[index]
  if (!r) {
    return false
  }

  var minSpeed = Infinity
  var minWire

  var i
  for (i = 0; i < r.length; i++) {
    var otherWire = r[i]
    if (!otherWire || otherWire === wire) continue

    var otherSpeed = otherWire.downloadSpeed()
    if (otherSpeed >= SPEED_THRESHOLD) continue
    if (2 * otherSpeed > speed || otherSpeed > minSpeed) continue

    minWire = otherWire
    minSpeed = otherSpeed
  }

  if (!minWire) return false

  for (i = 0; i < r.length; i++) {
    if (r[i] === minWire) r[i] = null
  }

  for (i = 0; i < minWire.requests.length; i++) {
    var req = minWire.requests[i]
    if (req.piece !== index) continue

    self.pieces[index].cancel((req.offset / Piece.BLOCK_LENGTH) | 0)
  }

  self.emit('hotswap', minWire, wire, index)
  return true
}

/**
 * Attempts to request a block from the given wire.
 */
Torrent.prototype._request = function (wire, index, hotswap) {
  var self = this
  var numRequests = wire.requests.length
  var isWebSeed = wire.type === 'webSeed'

  if (self.bitfield.get(index)) return false

  var maxOutstandingRequests = isWebSeed
    ? Math.min(
        getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength),
        self.maxWebConns
      )
    : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  if (numRequests >= maxOutstandingRequests) return false
  // var endGame = (wire.requests.length === 0 && self.store.numMissing < 30)

  var piece = self.pieces[index]
  var reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()

  if (reservation === -1 && hotswap && self._hotswap(wire, index)) {
    reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()
  }
  if (reservation === -1) return false

  var r = self._reservations[index]
  if (!r) r = self._reservations[index] = []
  var i = r.indexOf(null)
  if (i === -1) i = r.length
  r[i] = wire

  var chunkOffset = piece.chunkOffset(reservation)
  var chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation)

  wire.request(index, chunkOffset, chunkLength, function onChunk (err, chunk) {
    // TODO: what is this for?
    if (!self.ready) return self.once('ready', function () { onChunk(err, chunk) })

    if (r[i] === wire) r[i] = null

    if (piece !== self.pieces[index]) return onUpdateTick()

    if (err) {
      self._debug(
        'error getting piece %s (offset: %s length: %s) from %s: %s',
        index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort,
        err.message
      )
      isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation)
      onUpdateTick()
      return
    }

    self._debug(
      'got piece %s (offset: %s length: %s) from %s',
      index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort
    )

    if (!piece.set(reservation, chunk, wire)) return onUpdateTick()

    var buf = piece.flush()

    // TODO: might need to set self.pieces[index] = null here since sha1 is async

    sha1(buf, function (hash) {
      if (hash === self._hashes[index]) {
        if (!self.pieces[index]) return
        self._debug('piece verified %s', index)

        self.pieces[index] = null
        self._reservations[index] = null
        self.bitfield.set(index, true)

        self.store.put(index, buf)

        self.wires.forEach(function (wire) {
          wire.have(index)
        })

        self._checkDone()
      } else {
        self.pieces[index] = new Piece(piece.length)
        self.emit('warning', new Error('Piece ' + index + ' failed verification'))
      }
      onUpdateTick()
    })
  })

  function onUpdateTick () {
    process.nextTick(function () { self._update() })
  }

  return true
}

Torrent.prototype._checkDone = function () {
  var self = this
  if (self.destroyed) return

  // are any new files done?
  self.files.forEach(function (file) {
    if (file.done) return
    for (var i = file._startPiece; i <= file._endPiece; ++i) {
      if (!self.bitfield.get(i)) return
    }
    file.done = true
    file.emit('done')
    self._debug('file done: ' + file.name)
  })

  // is the torrent done? (if all current selections are satisfied, or there are
  // no selections, then torrent is done)
  var done = true
  for (var i = 0; i < self._selections.length; i++) {
    var selection = self._selections[i]
    for (var piece = selection.from; piece <= selection.to; piece++) {
      if (!self.bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) break
  }
  if (!self.done && done) {
    self.done = true
    self._debug('torrent done: ' + self.infoHash)
    if (self.discovery.tracker) {
      self.discovery.tracker.complete()
    }
    self.emit('done')
  }

  self._gcSelections()
}

Torrent.prototype.load = function (streams, cb) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.ready) return self.once('ready', function () { self.load(streams, cb) })

  if (!Array.isArray(streams)) streams = [ streams ]
  if (!cb) cb = noop

  var readable = new MultiStream(streams)
  var writable = new ChunkStoreWriteStream(self.store, self.pieceLength)

  pump(readable, writable, function (err) {
    if (err) return cb(err)
    self.pieces.forEach(function (piece, index) {
      self.pieces[index] = null
      self._reservations[index] = null
      self.bitfield.set(index, true)
    })
    self._checkDone()
    cb(null)
  })
}

Torrent.prototype.createServer = function (opts) {
  if (typeof Server !== 'function') throw new Error('node.js-only method')
  if (this.destroyed) throw new Error('torrent is destroyed')
  var server = new Server(this, opts)
  this._servers.push(server)
  return server
}

Torrent.prototype.pause = function () {
  if (this.destroyed) return
  this._debug('pause')
  this.paused = true
}

Torrent.prototype.resume = function () {
  if (this.destroyed) return
  this._debug('resume')
  this.paused = false
  this._drain()
}

Torrent.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

/**
 * Pop a peer off the FIFO queue and connect to it. When _drain() gets called,
 * the queue will usually have only one peer in it, except when there are too
 * many peers (over `this.maxConns`) in which case they will just sit in the
 * queue until another connection closes.
 */
Torrent.prototype._drain = function () {
  var self = this
  this._debug('_drain numConns %s maxConns %s', self._numConns, self.client.maxConns)
  if (typeof net.connect !== 'function' || self.destroyed || self.paused ||
      self._numConns >= self.client.maxConns) {
    return
  }
  this._debug('drain (%s queued, %s/%s peers)', self._numQueued, self.numPeers, self.client.maxConns)

  var peer = self._queue.shift()
  if (!peer) return // queue could be empty

  this._debug('tcp connect attempt to %s', peer.addr)

  var parts = addrToIPPort(peer.addr)
  var opts = {
    host: parts[0],
    port: parts[1]
  }

  var conn = peer.conn = net.connect(opts)

  conn.once('connect', function () { peer.onConnect() })
  conn.once('error', function (err) { peer.destroy(err) })
  peer.startConnectTimeout()

  // When connection closes, attempt reconnect after timeout (with exponential backoff)
  conn.on('close', function () {
    if (self.destroyed) return

    // TODO: If torrent is done, do not try to reconnect after a timeout

    if (peer.retries >= RECONNECT_WAIT.length) {
      self._debug(
        'conn %s closed: will not re-add (max %s attempts)',
        peer.addr, RECONNECT_WAIT.length
      )
      return
    }

    var ms = RECONNECT_WAIT[peer.retries]
    self._debug(
      'conn %s closed: will re-add to queue in %sms (attempt %s)',
      peer.addr, ms, peer.retries + 1
    )

    var reconnectTimeout = setTimeout(function reconnectTimeout () {
      var newPeer = self._addPeer(peer.addr)
      if (newPeer) newPeer.retries = peer.retries + 1
    }, ms)
    if (reconnectTimeout.unref) reconnectTimeout.unref()
  })
}

/**
 * Returns `true` if string is valid IPv4/6 address.
 * @param {string} addr
 * @return {boolean}
 */
Torrent.prototype._validAddr = function (addr) {
  var parts
  try {
    parts = addrToIPPort(addr)
  } catch (e) {
    return false
  }
  var host = parts[0]
  var port = parts[1]
  return port > 0 && port < 65535 &&
    !(host === '127.0.0.1' && port === this.client.torrentPort)
}

function getBlockPipelineLength (wire, duration) {
  return 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH)
}

function getPiecePipelineLength (wire, duration, pieceLength) {
  return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength)
}

/**
 * Returns a random integer in [0,high)
 */
function randomInt (high) {
  return Math.random() * high | 0
}

function noop () {}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":137,"./file":132,"./peer":133,"./rarity-map":134,"./server":17,"_process":73,"addr-to-ip-port":3,"bitfield":9,"chunk-store-stream/write":22,"debug":31,"events":35,"fs":18,"fs-chunk-store":53,"immediate-chunk-store":42,"inherits":43,"multistream":61,"net":17,"os":17,"parse-torrent":69,"path":70,"pump":74,"random-iterate":79,"run-parallel":90,"run-parallel-limit":89,"simple-get":94,"simple-sha1":96,"speedometer":98,"torrent-discovery":111,"torrent-piece":112,"uniq":115,"ut_metadata":119,"ut_pex":17,"xtend":139,"xtend/mutable":140}],136:[function(require,module,exports){
module.exports = WebConn

var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('webtorrent:webconn')
var get = require('simple-get')
var inherits = require('inherits')
var sha1 = require('simple-sha1')
var Wire = require('bittorrent-protocol')

var VERSION = require('../package.json').version

inherits(WebConn, Wire)

/**
 * Converts requests for torrent blocks into http range requests.
 * @param {string} url web seed url
 * @param {Object} torrent
 */
function WebConn (url, torrent) {
  Wire.call(this)

  this.url = url
  this.webPeerId = sha1.sync(url)
  this._torrent = torrent

  this._init()
}

WebConn.prototype._init = function () {
  var self = this
  self.setKeepAlive(true)

  self.once('handshake', function (infoHash, peerId) {
    if (self.destroyed) return
    self.handshake(infoHash, self.webPeerId)
    var numPieces = self._torrent.pieces.length
    var bitfield = new BitField(numPieces)
    for (var i = 0; i <= numPieces; i++) {
      bitfield.set(i, true)
    }
    self.bitfield(bitfield)
  })

  self.once('interested', function () {
    debug('interested')
    self.unchoke()
  })

  self.on('uninterested', function () { debug('uninterested') })
  self.on('choke', function () { debug('choke') })
  self.on('unchoke', function () { debug('unchoke') })
  self.on('bitfield', function () { debug('bitfield') })

  self.on('request', function (pieceIndex, offset, length, callback) {
    debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length)
    self.httpRequest(pieceIndex, offset, length, callback)
  })
}

WebConn.prototype.httpRequest = function (pieceIndex, offset, length, cb) {
  var self = this
  var pieceOffset = pieceIndex * self._torrent.pieceLength
  var rangeStart = pieceOffset + offset /* offset within whole torrent */
  var rangeEnd = rangeStart + length - 1

  // Web seed URL format:
  // For single-file torrents, make HTTP range requests directly to the web seed URL
  // For multi-file torrents, add the torrent folder and file name to the URL
  var files = self._torrent.files
  var requests
  if (files.length <= 1) {
    requests = [{
      url: self.url,
      start: rangeStart,
      end: rangeEnd
    }]
  } else {
    var requestedFiles = files.filter(function (file) {
      return file.offset <= rangeEnd && (file.offset + file.length) > rangeStart
    })
    if (requestedFiles.length < 1) {
      return cb(new Error('Could not find file corresponnding to web seed range request'))
    }

    requests = requestedFiles.map(function (requestedFile) {
      var fileEnd = requestedFile.offset + requestedFile.length - 1
      var url = self.url +
        (self.url[self.url.length - 1] === '/' ? '' : '/') +
        requestedFile.path
      return {
        url: url,
        fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
        start: Math.max(rangeStart - requestedFile.offset, 0),
        end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
      }
    })
  }

  // Now make all the HTTP requests we need in order to load this piece
  // Usually that's one requests, but sometimes it will be multiple
  // Send requests in parallel and wait for them all to come back
  var numRequestsSucceeded = 0
  var hasError = false

  var ret
  if (requests.length > 1) {
    ret = Buffer.alloc(length)
  }

  requests.forEach(function (request) {
    var url = request.url
    var start = request.start
    var end = request.end
    debug(
      'Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d',
      url, pieceIndex, offset, length, start, end
    )
    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)',
        range: 'bytes=' + start + '-' + end
      }
    }
    get.concat(opts, function (err, res, data) {
      if (hasError) return
      if (err) {
        hasError = true
        return cb(err)
      }
      if (res.statusCode < 200 || res.statusCode >= 300) {
        hasError = true
        return cb(new Error('Unexpected HTTP status code ' + res.statusCode))
      }
      debug('Got data of length %d', data.length)

      if (requests.length === 1) {
        // Common case: fetch piece in a single HTTP request, return directly
        cb(null, data)
      } else {
        // Rare case: reconstruct multiple HTTP requests across 2+ files into one
        // piece buffer
        data.copy(ret, request.fileOffsetInRange)
        if (++numRequestsSucceeded === requests.length) {
          cb(null, ret)
        }
      }
    })
  })
}

WebConn.prototype.destroy = function () {
  Wire.prototype.destroy.call(this)
  this._torrent = null
}

},{"../package.json":137,"bitfield":9,"bittorrent-protocol":10,"debug":31,"inherits":43,"safe-buffer":92,"simple-get":94,"simple-sha1":96}],137:[function(require,module,exports){
module.exports={"version":"0.94.4"}
},{}],138:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],139:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],140:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],141:[function(require,module,exports){
/**
 * Given a number, return a zero-filled string.
 * From http://stackoverflow.com/questions/1267283/
 * @param  {number} width
 * @param  {number} number
 * @return {string}
 */
module.exports = function zeroFill (width, number, pad) {
  if (number === undefined) {
    return function (number, pad) {
      return zeroFill(width, number, pad)
    }
  }
  if (pad === undefined) pad = '0'
  width -= number.toString().length
  if (width > 0) return new Array(width + (/\./.test(number) ? 2 : 1)).join(pad) + number
  return number + ''
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJKYXNtaW5lX3Rlc3RzdWl0ZXNfaGVscC5qcyIsIk9ha1N0cmVhbWluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hZGRyLXRvLWlwLXBvcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCJub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtcHJvdG9jb2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0dG9ycmVudC10cmFja2VyL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR0b3JyZW50LXRyYWNrZXIvbGliL2NsaWVudC90cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY2xpZW50L3dlYnNvY2tldC10cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2Jsb2ItdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jsb2NrLXN0cmVhbTIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci1zaGltcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVpbHRpbi1zdGF0dXMtY29kZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jaHVuay1zdG9yZS1zdHJlYW0vd3JpdGUuanMiLCJub2RlX21vZHVsZXMvY2xvc2VzdC10by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb21wYWN0MnN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLXRvcnJlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLXRvcnJlbnQvbm9kZV9tb2R1bGVzL2JlbmNvZGUvYmVuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtdG9ycmVudC9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS10b3JyZW50L25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9kaWN0LmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS10b3JyZW50L25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvZGVidWcvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9kZWZpbmVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZC1vZi1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9maWxlc3RyZWFtL3JlYWQuanMiLCJub2RlX21vZHVsZXMvZmxhdHRlbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtYnJvd3Nlci1ydGMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGF0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbW1lZGlhdGUtY2h1bmstc3RvcmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGFkZHIuanMvbGliL2lwYWRkci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hc2NpaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZmlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy10eXBlZGFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanVuay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYWduZXQtdXJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lbW9yeS1jaHVuay1zdG9yZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtYm94LWVuY29kaW5nL2JveGVzLmpzIiwibm9kZV9tb2R1bGVzL21wNC1ib3gtZW5jb2RpbmcvZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9tcDQtYm94LWVuY29kaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21wNC1zdHJlYW0vZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL21wNC1zdHJlYW0vZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL21wNC1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGlzdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmV4dC1ldmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvcGFyc2UtdG9ycmVudC1maWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXRvcnJlbnQtZmlsZS9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXRvcnJlbnQtZmlsZS9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLXRvcnJlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BpZWNlLWxlbmd0aC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVtcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmRvbS1pdGVyYXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmdlLXNsaWNlLXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlbmRlci1tZWRpYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZW5kZXItbWVkaWEvbGliL21pbWUuanNvbiIsIm5vZGVfbW9kdWxlcy9ydW4tcGFyYWxsZWwtbGltaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcnVuLXBhcmFsbGVsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3J1c2hhL3J1c2hhLmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLWNvbmNhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zaGExL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXdlYnNvY2tldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGVlZG9tZXRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVzcG9uc2UuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLXRvLWJsb2ItdXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS10by1ibG9iL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS13aXRoLWtub3duLWxlbmd0aC10by1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nMmNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhpcnR5LXR3by9saWIvdGhpcnR5LXR3by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aGlydHktdHdvL2xpYi90aGlydHktdHdvL3RoaXJ0eS10d28uanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXlidWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycmVudC1kaXNjb3ZlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycmVudC1waWVjZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90eXBlZGFycmF5LXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91aW50NjRiZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJub2RlX21vZHVsZXMvdW5vcmRlcmVkLWFycmF5LXJlbW92ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3V0X21ldGFkYXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0X3BleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dF9wZXgvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy91dF9wZXgvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZGVvc3RyZWFtL21wNC1yZW11eGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZGVvc3RyZWFtL3ZpZGVvc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvZmlsZS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvZmlsZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi9wZWVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvbGliL3Jhcml0eS1tYXAuanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvdG9ycmVudC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi93ZWJjb25uLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL211dGFibGUuanMiLCJub2RlX21vZHVsZXMvemVyby1maWxsL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNydUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkRBOzs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL3FEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbElBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNTNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNVpBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ3aW5kb3cuT2FrU3RyZWFtaW5nID0gcmVxdWlyZSgnLi9PYWtTdHJlYW1pbmcnKTtcclxud2luZG93Lmh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbndpbmRvdy5XZWJUb3JyZW50ID0gcmVxdWlyZSgnd2VidG9ycmVudCcpO1xyXG5cclxuXHJcbmRvY3VtZW50LmJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcclxuXHJcbnZhciBwYXJhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xyXG5wYXJhLmlkID0gXCJteVZpZGVvXCI7XHJcbnBhcmEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmEpO1xyXG5cclxucGFyYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xyXG5wYXJhLmlkID0gXCJXZWJUb3JyZW50LXJlY2VpdmVkXCI7XHJcbnBhcmEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmEpO1xyXG5cclxud2luZG93Lm15U3RyZWFtaW5nQSA9IG5ldyBPYWtTdHJlYW1pbmcoXCJteVN0cmVhbWluZ0FcIik7XHJcbndpbmRvdy5teVN0cmVhbWluZ0IgPSBuZXcgT2FrU3RyZWFtaW5nKFwibXlTdHJlYW1pbmdCXCIpO1xyXG53aW5kb3cubXlTdHJlYW1pbmdDID0gbmV3IE9ha1N0cmVhbWluZyhcIm15U3RyZWFtaW5nQ1wiKTsiLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcclxudmFyIE11bHRpU3RyZWFtID0gcmVxdWlyZSgnbXVsdGlzdHJlYW0nKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcbnZhciByZWFkYWJsZVN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpO1xyXG52YXIgVmlkZW9zdHJlYW0gPSByZXF1aXJlKCd2aWRlb3N0cmVhbScpO1xyXG52YXIgdXRfcGV4ID0gcmVxdWlyZSgndXRfcGV4Jyk7XHJcbnZhciBXZWJUb3JyZW50ID0gcmVxdWlyZSgnd2VidG9ycmVudCcpO1xyXG52YXIgU2ltcGxlUGVlciA9IHJlcXVpcmUoJ3NpbXBsZS1wZWVyJyk7XHJcbnZhciBwYXJzZVRvcnJlbnQgPSByZXF1aXJlKCdwYXJzZS10b3JyZW50Jyk7XHJcblxyXG5cclxuIC8qKlxyXG4gKiBAbW9kdWxlIEZWU0xcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gRlZTTDtcclxuXHJcblxyXG4gLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgRlZTTCBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIG1ldGhvZHMgc3RyZWFtVmlkZW8sIGxvYWRWaWRlbywgY3JlYXRlU2lnbmFsaW5nRGF0YSwgY3JlYXRlU2lnbmFsaW5nRGF0YVJlc3BvbnNlLCBwcm9jZXNzU2lnbmFsaW5nUmVzcG9uc2UgYW5kIHNldmVyYWwgc2ltcGxlIGdldCBtZXRob2RzICBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqLyBcclxuZnVuY3Rpb24gRlZTTChPYWtOYW1lKXtcclxuICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAoZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIHBlZXJJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDEwLDMwMCkgKyAxKTsgICBcclxuICAgICAgY29uc29sZS5sb2coXCJWZXJzaW9uOiBIZWFkaHVudGVyICAgSW4gT2FrU3RyZWFtaW5nIGNvbnN0cnVjdG9yLiB0aGlzLm5hbWU6IFwiICsgT2FrTmFtZSk7XHJcbiAgICAgIHZhciBPYWtOYW1lID0gT2FrTmFtZSB8fCBcIk5vTmFtZSBGVlNMIGluc3RhbmNlXCI7XHJcbiAgICAgIFxyXG4gICAgICAvLyBPbmx5IG1ldGhvZHMgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIEFQSSwgaS5lLiBvbmx5IG1ldGhvZHMgc2hvdWxkIGJlIHB1YmxpY2FsbHkgYWNjZXNzaWJsZS5cclxuICAgICAgLy8gRXZlcnkgbWV0aG9kIHNob3VsZCBoYXZlIGFjY2VzcyB0byB0aGVzZSB2YXJpYWJsZXMuIFRoZXJlZm9yZSB0aGV5IGFyZSBkZWZpbmllZCBhdCB0aGlzIGhpZ2ggc2NvcGUuXHJcbiAgICAgIHZhciBzaW1wbGVQZWVyQ3JlYXRpb25Db3VudGVyID0gMDtcclxuICAgICAgdmFyIGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGEgPSBbXTtcclxuICAgICAgdmFyIHRoZVRvcnJlbnQgPSBudWxsO1xyXG4gICAgICB2YXIgcGVlcnNUb0FkZCA9IFtdO1xyXG4gICAgICB2YXIgYnl0ZXNSZWNlaXZlZEZyb21TZXJ2ZXIgPSAwO1xyXG4gICAgICB2YXIgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA9IDA7XHJcbiAgICAgIHZhciBTSVpFX09GX1ZJREVPX0ZJTEUgPSAtNDI7XHJcbiAgICAgIFxyXG4gICAgICBzZWxmLnN0cmVhbVZpZGVvID0gc3RyZWFtVmlkZW87XHJcbiAgICAgIHNlbGYubG9hZFZpZGVvID0gbG9hZFZpZGVvO1xyXG4gICAgICBzZWxmLmZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgc2VsZi5nZXROdW1iZXJPZkJ5dGVzRG93bmxvYWRlZEZyb21TZXJ2ZXIgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICByZXR1cm4gYnl0ZXNSZWNlaXZlZEZyb21TZXJ2ZXI7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBzZWxmLmdldE51bWJlck9mQnlzdGVzRG93bmxvYWRlZFAyUCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhlVG9ycmVudC5kb3dubG9hZGVkO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5nZXROdW1iZXJPZkJ5dGVzVXBsb2FkZWRQMlAgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICBpZih0aGVUb3JyZW50KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoZVRvcnJlbnQudXBsb2FkZWQ7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBzZWxmLmdldFBlcmNlbnRhZ2VEb3dubG9hZGVkVG9ycmVudCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhlVG9ycmVudC5wcm9ncmVzcztcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHNlbGYuZ2V0RmlsZVNpemUgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICByZXR1cm4gU0laRV9PRl9WSURFT19GSUxFO1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5jcmVhdGVTaWduYWxpbmdEYXRhID0gZnVuY3Rpb24gKGNhbGxiYWNrKXtcclxuICAgICAgICAgdmFyIGFscmVhZHlDYWxsZWRDYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgICAgICB2YXIgb2FrTnVtYmVyID0gc2ltcGxlUGVlckNyZWF0aW9uQ291bnRlcjtcclxuICAgICAgICAgY29uc29sZS5sb2coXCJJbiBjcmVhdGVTaWduYWxpbmdEYXRhIGZvciBvYWtOdW1iZXI6IFwiICsgb2FrTnVtYmVyKTtcclxuICAgICAgICAgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdID0gbmV3IFNpbXBsZVBlZXIoe2luaXRpYXRvcjogdHJ1ZSwgdGlja2xlOiBmYWxzZX0pO1xyXG4gICAgICAgICBzaW1wbGVQZWVyQ3JlYXRpb25Db3VudGVyKys7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICBjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0ub24oJ3NpZ25hbCcsIGZ1bmN0aW9uIChzaWduYWxpbmdEYXRhKXtcclxuICAgICAgICAgICAgaWYoIWFscmVhZHlDYWxsZWRDYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgIGFscmVhZHlDYWxsZWRDYWxsYmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgIHNpZ25hbGluZ0RhdGEub2FrTnVtYmVyID0gb2FrTnVtYmVyO1xyXG4gICAgICAgICAgICAgICBjYWxsYmFjayhzaWduYWxpbmdEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHNlbGYuY3JlYXRlU2lnbmFsaW5nRGF0YVJlc3BvbnNlID0gZnVuY3Rpb24gKHNpZ25hbGluZ0RhdGEsIGNhbGxiYWNrKXtcclxuICAgICAgICAgdmFyIG9ha051bWJlciA9IHNpZ25hbGluZ0RhdGEub2FrTnVtYmVyO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZS4gSW4gdGhlIGJlZ2lubmluZyBvYWtOdW1iZXI6IFwiICsgb2FrTnVtYmVyKTtcclxuICAgICAgICAgZGVsZXRlIHNpZ25hbGluZ0RhdGEub2FrTnVtYmVyO1xyXG4gICAgICAgICBcclxuICAgICAgICAgdmFyIG15UGVlciA9IG5ldyBTaW1wbGVQZWVyKHtpbml0aWF0b3I6IGZhbHNlLCB0aWNrbGU6IGZhbHNlfSk7XHJcbiAgICAgICAgIHZhciBpbmRleCA9IHNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXI7XHJcbiAgICAgICAgIGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbaW5kZXhdID0gbXlQZWVyO1xyXG4gICAgICAgICBzaW1wbGVQZWVyQ3JlYXRpb25Db3VudGVyKys7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICBteVBlZXIub24oJ3NpZ25hbCcsIGZ1bmN0aW9uIChhbnN3ZXJTaWduYWxpbmdEYXRhKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBjcmVhdGVTaWduYWxpbmdEYXRhUmVzcG9uc2UsIGFmdGVyIG9uU2lnbmFsIG9ha051bWJlcjogXCIgKyBvYWtOdW1iZXIpO1xyXG4gICAgICAgICAgICBhbnN3ZXJTaWduYWxpbmdEYXRhLm9ha051bWJlciA9IG9ha051bWJlcjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBjcmVhdGVTaWduYWxpbmdEYXRhUmVzcG9uc2UsICBvYmplY3QgdGhhdCBpcyByZXR1cm5lZCB3aXRoIGNhbGxiYWNrOiBcIiArIEpTT04uc3RyaW5naWZ5KGFuc3dlclNpZ25hbGluZ0RhdGEpKTtcclxuICAgICAgICAgICAgY2FsbGJhY2soYW5zd2VyU2lnbmFsaW5nRGF0YSk7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgICBteVBlZXIuc2lnbmFsKHNpZ25hbGluZ0RhdGEpO1xyXG4gICAgICAgICBcclxuICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICBteVBlZXIub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBzZWxmLmFkZFNpbXBsZVBlZXJJbnN0YW5jZShjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW2luZGV4XSwge30sIGZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJhZGRTaW1wbGVQZWVySW5zdGFuY2UgZW5kZWRcIik7fSk7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5wcm9jZXNzU2lnbmFsaW5nUmVzcG9uc2UgPSBmdW5jdGlvbiAoc2lnbmFsaW5nRGF0YSwgY2FsbGJhY2spe1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSwgIHNpZ25hbGluZ0RhdGEgcGFyYW10ZXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsaW5nRGF0YSkpO1xyXG4gICAgICAgICB2YXIgb2FrTnVtYmVyID0gc2lnbmFsaW5nRGF0YS5vYWtOdW1iZXI7XHJcbiAgICAgICAgIGRlbGV0ZSBzaWduYWxpbmdEYXRhLm9ha051bWJlcjtcclxuICAgICAgICAgY29uc29sZS5sb2coXCJJbiBwcm9jZXNzU2lnbmFsaW5nUmVzcG9uc2UsICBvYWtOdW1iZXI6IFwiICsgb2FrTnVtYmVyKTtcclxuICAgICAgICAgY29uc29sZS5sb2coXCJjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhOiBcIiArIGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGEpO1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIChjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0pLm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFc3RhYmxpc2hlZCBhIHNpbXBsZS1wZWVyIGNvbm5lY3Rpb24nKTtcclxuICAgICAgICAgICAgc2VsZi5hZGRTaW1wbGVQZWVySW5zdGFuY2UoY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdKTtcclxuICAgICAgICAgICAgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgICAgY29uc29sZS5sb2coXCJJbiBwcm9jZXNzU2lnbmFsaW5nUmVzcG9uc2UsICBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gLnNpZ25hbCgpOiBcIiArIEpTT04uc3RyaW5naWZ5KHNpZ25hbGluZ0RhdGEpKTtcclxuICAgICAgICAgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtvYWtOdW1iZXJdLnNpZ25hbChzaWduYWxpbmdEYXRhKTtcclxuICAgICAgfTtcclxuICAgICAgIFxyXG4gICAgICAgLyoqXHJcbiAgICAgICAqIEB0eXBlZGVmIFN0cmVhbUluZm9ybWF0aW9uT2JqZWN0XHJcbiAgICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2aWRlb19maWxlX3NpemUgLSBUaGUgc2l6ZSBpbiBieXRlIG9mIHRoZSB2aWRlbyBmaWxlIHRoYXQgd2FzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cclxuICAgICAgICovXHJcbiAgICAgICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBjYWxsYmFjayBPYWtTdHJlYW1pbmd+c3RyZWFtVmlkZW9GaW5pc2hlZFxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmVhbUluZm9ybWF0aW9uT2JqZWN0fSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCAtIEFuIG9iamVjdCB0aGF0IG90aGVyIGNsaWVudHMvcGVlcnMgY2FuIHBhc3MgYXMgYW4gYXJndW1lbnQgdG8gdGhlaXIgbG9hZFZpZGVvIG1ldGhvZCB0byBkb3dubG9hZCB0aGUgdmlkZW8gZnJvbSBvdGhlciBjbGllbnRzL3BlZXJzIGFuZC9vciBhIFdlYiBTZXJ2ZXIuXHJcbiAgICAgICAqLyBcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTdHJlYW1zIGEgdmlkZW8gZmlsZSB0byBhbGwgb3RoZXIgY2xpZW50cy9wZWVycy5cclxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHZpZGVvX2ZpbGUgLSBUaGUgdmlkZW8gZmlsZSB0aGF0IHNob3VsZCBiZSBzdHJlYW1lZCB0byB0aGUgb3RoZXIgY2xpZW50cy9wZWVycy4gVGhpcyBwYXJhbXRlciBjYW4gZWl0aGVyIGJlIGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlIHxXM0MgRmlsZSBvYmplY3R9LCBhIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZUxpc3QgfFczQyBGaWxlTGlzdH0sIGEge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWwgfE5vZGUgQnVmZmVyIG9iamVjdH0gb3IgYSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fY2xhc3Nfc3RyZWFtX3JlYWRhYmxlIHxSZWFkYWJsZSBzdHJlYW0gb2JqZWN0fS5cclxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHRoZSBjcmVhdGlvbiBvZiB0aGUgU3RyZWFtSW5mb3JtYXRpb25PYmplY3QsIHRoYXQgYWZ0ZXIgaXRzIGNyZWF0aW9uIGdldHMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucGF0aF90b19maWxlX29uX1hIUl9zZXJ2ZXIgLSBUaGUgcGF0aCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIFhNTCBIVFRQIFJlcXVlc3QgKFhIUikuIEEgdmFsaWQgcGF0aCB3b3VsZCBiZSwgZm9yIGV4YW1wbGUsIFwiL3ZpZGVvcy9hVmlkZW9GaWxlLm1wNFwiLiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHNldCBib3RoIHRoZSBwYXRoVG9GaWxlT25YSFJTZXJ2ZXIgYW5kIHRoZSBoYXNoVmFsdWUgcGFyYW10ZXIgZm9yIHN1Y2Nlc3NmdWxsIFhIUiByZXF1ZXN0cy4gSWYgdGhpcyBwcm9wZXJ0eSBhbmQgdGhlIGhhc2hWYWx1ZSBwcm9wZXJ0eSBpcyB1bmRlZmluZWQsIG5vIHZpZGVvIGRhdGEgd2lsbCBiZSByZXF1ZXN0ZWQgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5oYXNoX3ZhbHVlIC0gSGFzaCB2YWx1ZSBvZiB0aGUgdmlkZW8gZmlsZSB0aGF0IHNob3VsZCBieSByZXF1ZXN0ZWQgZnJvbSB0aGUgU1ZTTCBXZWJTZXJ2ZXIuIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gc2V0IGJvdGggdGhlIHBhdGhUb0ZpbGVPblhIUlNlcnZlciBhbmQgdGhlIGhhc2hWYWx1ZSBwYXJhbXRlciBmb3Igc3VjY2Vzc2Z1bGwgWEhSIHJlcXVlc3RzLiBJZiB0aGlzIHByb3BlcnR5IGFuZCB0aGUgaGFzaFZhbHVlIHByb3BlcnR5IGlzIHVuZGVmaW5lZCwgbm8gdmlkZW8gZGF0YSB3aWxsIGJlIHJlcXVlc3RlZCBmcm9tIHRoZSBzZXJ2ZXIuIFxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5YSFJfc2VydmVyX1VSTCAtIFVSTCBvZiBhIFhIUiBzZXJ2ZXIgdGhhdCBjYW4gc2VydmUgdGhlIHZpZGVvIGZpbGUuIElmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldCwgWEhSIHdpbGwgYmUgc2VuZCB0byB0aGUgV2ViIHNlcnZlciB0aGF0IHNlcnZlZCB0aGUgV2ViIHBhZ2UuXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLlhIUl9wb3J0IC0gUG9ydCB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgWEhSIHNlcnZlciB0aGF0IHdhcyBzcGVjaWZpZWQgaW4gdGhlIFhIUlNlcnZlclVSTCBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBzaG91bGQgb25seSBiZSBzZXQgd2hlbiB0aGUgWEhSU2VydmVyVVJMIHByb3BlcnR5IGlzIHNldCB0b28uIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDgwLlxyXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5kb3dubG9hZF9mcm9tX3AycF90aW1lX3JhbmdlIC0gSG93IG1hbnkgc2Vjb25kcyBvZiB2aWRlbyBwbGF5YmFjayBtdXN0IGJlIGJ1ZmZlcmVkIGluIGFkdmFuY2Ugc3VjaCB0aGF0IG5vIG1vcmUgZGF0YSBzdHJlYW1zIGFyZSByZXF1ZXN0ZWQgZnJvbSB0aGUgV2ViVG9ycmVudCBuZXR3b3JrLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAyMCAoc2Vjb25kcykuXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNyZWF0ZV9yZWFkU3RyZWFtX3JlcXVlc3Rfc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBieXRlIHJhbmdlIHJlcXVlc3RzIHRvIHRoZSBXZWJUb3JyZW50IG5ldHdvcmsuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDUwMDAwMDAgKGJ5dGVzKS5cclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZG93bmxvYWRfZnJvbV9zZXJ2ZXJfdGltZV9yYW5nZSAtIEhvdyBtYW55IHNlY29uZHMgb2YgdmlkZW8gcGxheWJhY2sgbXVzdCBiZSBidWZmZXJlZCBpbiBhZHZhbmNlIHN1Y2ggdGhhdCBubyBtb3JlIGRhdGEgaXMgcmVxdWVzdGVkIGZyb20gdGhlIFhIUiBzZXJ2ZXIuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDUgKHNlY29uZHMpLlxyXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wZWVyX3VwbG9hZF9saW1pdF9tdWx0aXBsaWVyIC0gVGhlIEZWU0wgY2xpZW50IHdpbGwgc2V2ZXJseSB0aHJvdHRsZSB0aGUgdmlkZW8gZGF0YSB1cGxvYWQgdG8gb3RoZXIgcGVlcnMgd2hlbiAoYnl0ZXNfdXBsb2FkZWRfdG9fb3RoZXJfcGVlcnMgKiBwZWVyX3VwbG9hZF9saW1pdF9tdWx0aXBsaWVyICsgcGVlcl91cGxvYWRfbGltaXRfYWRkaXRpb24gPj0gIGJ5dGVzX2Rvd25sb2FkZWRfZnJvbV9vdGhlcl9wZWVycykgYW5kIHN0b3AgdGhlIHRocm90dGluZyBhcyBzb29uIGFzIHRoaXMgaW5lcXVhbGl0eSBpcyBubyBsb25nZXIgdHJ1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHBlZXJfdXBsb2FkX2xpbWl0X211bHRpcGxpZXIgaXMgMi5cclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucGVlcl91cGxvYWRfbGltaXRfYWRkaXRpb24gLSBUaGUgRlZTTCBjbGllbnQgd2lsbCBzZXZlcmx5IHRocm90dGxlIHRoZSB2aWRlbyBkYXRhIHVwbG9hZCB0byBvdGhlciBwZWVycyB3aGVuIChieXRlc191cGxvYWRlZF90b19vdGhlcl9wZWVycyAqIHBlZXJfdXBsb2FkX2xpbWl0X211bHRpcGxpZXIgKyBwZWVyX3VwbG9hZF9saW1pdF9hZGRpdGlvbiA+PSAgYnl0ZXNfZG93bmxvYWRlZF9mcm9tX290aGVyX3BlZXJzKSBhbmQgc3RvcCB0aGUgdGhyb3R0aW5nIGFzIHNvb24gYXMgdGhpcyBpbmVxdWFsaXR5IGlzIG5vIGxvbmdlciB0cnVlLiB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgcGVlcl91cGxvYWRfbGltaXRfYWRkaXRpb24gaXMgNTAwMDAwIChieXRlKS5cclxuICAgICAgICogQHBhcmFtIHtPYWtTdHJlYW1pbmd+c3RyZWFtVmlkZW9GaW5pc2hlZH0gY2FsbGJhY2sgLSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGdldHMgY2FsbGVkIHdpdGggdGhlIGdlbmVyYXRlZCBTdHJlYW1JbmZvcm1hdGlvbk9iamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBleGVjdXRpb24gb2Ygc3RyZWFtVmlkZW8uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBzdHJlYW1WaWRlbyh2aWRlb19maWxlLCBvcHRpb25zLCBjYWxsYmFjaywgcmV0dXJuVG9ycmVudCwgZGVzdHJveVRvcnJlbnQpeyBcclxuICAgICAgICAgdmFyIHdlYlRvcnJlbnRDbGllbnQgPSBuZXcgV2ViVG9ycmVudCgpO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwic3RyZWFtVmlkZW8gaXMgZXhlY3V0ZWRcIik7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJ2aWRlb0ZpbGU6IFwiICsgdmlkZW9GaWxlKTtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm9wdGlvbnM6IFwiICsgb3B0aW9ucyk7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7ICAgICAgICAgXHJcbiAgICAgICAgICBcclxuICAgICAgICAgdmFyIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0ID0gb3B0aW9uc1xyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgIGlmKHZpZGVvX2ZpbGUpe1xyXG4gICAgICAgICAgICB2YXIgc2VlZGluZ09wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgc2VlZGluZ09wdGlvbnMuYW5ub3VuY2VMaXN0ID0gb3B0aW9ucy53ZWJUb3JyZW50VHJhY2tlcnM7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IFxyXG4gICAgICAgICAgICB3ZWJUb3JyZW50Q2xpZW50LnNlZWQodmlkZW9fZmlsZSwgc2VlZGluZ09wdGlvbnMsIGZ1bmN0aW9uKHRvcnJlbnQpe1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRvcnJlbnQgZmlsZSBpcyBzZWVkZWRcIik7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvKiBLNDIgTWF5YmUgSSB3aWxsIG5lZWQgdGhpcyBsYXRlclxyXG4gICAgICAgICAgICAgICB2YXIgdG9ycmVudEZpbGVBc0Jsb2JVUkwgPSB0b3JyZW50LnRvcnJlbnRGaWxlQmxvYlVSTDtcclxuICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICB2YXIgWEhST3JNZXRob2RFbmRIYXBwZW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB0b3JyZW50RmlsZUFzQmxvYlVSTCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XHJcbiAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QudG9ycmVudEFzQmxvYiA9IHRoaXMucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICBpZihYSFJPck1ldGhvZEVuZEhhcHBlbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIFhIUk9yTWV0aG9kRW5kSGFwcGVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgc3RyZWFtSW5mb3JtYXRpb25PYmplY3Quc2l6ZV9vZl92aWRlb19maWxlID0gdG9ycmVudC5maWxlc1swXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0Lm1hZ25ldFVSSSA9IHRvcnJlbnQubWFnbmV0VVJJO1xyXG4gICAgICAgICAgICAgICBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5pbmZvSGFzaCA9IHRvcnJlbnQuaW5mb0hhc2g7XHJcbiAgICAgICAgICAgICAgIC8vIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnBhcnNlZFRvcnJlbnQgPSAgcGFyc2VUb3JyZW50KHRvcnJlbnQudG9ycmVudEZpbGUpOyAvLyBLNDJcclxuICAgICAgICAgICAgICAgLy8gdmFyIGJ1ZmZlclRvcnJlbnQgPSBwYXJzZVRvcnJlbnQoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QucGFyc2VkVG9ycmVudCk7IEs0MlxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBzdHJlYW1WaWRlbyAgICBcIiArIHNlbGYuT2FrTmFtZSArIFwiLmZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciBnZXRzIGNyZWF0ZWRcIik7XHJcbiAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhpcyBGVlNMIGluc3RhbmNlIGFscmVhZHkgY29ubmVjdGVkIHRvIGFub3RoZXIgcGVlciBvciBhcyBzb29uIGFzIGl0IGNvbm5lY3RzIHRvIGFub3RoZXIgcGVlci5cclxuICAgICAgICAgICAgICAgc2VsZi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gc3RyZWFtVmlkZW8gICAgXCIgKyBzZWxmLk9ha05hbWUgKyBcIi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgZ2V0cyBleGVjdXRlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgaWYobm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA8PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tDYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHRvcnJlbnQub24oJ3dpcmUnLCBmdW5jdGlvbih3aXJlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWNhbGxiYWNrQ2FsbGVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzLS07ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHN1Y2ggdGhhdCB0aGUgZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyIGZ1bmN0aW9uIGtub3dzIGhvdyBtYW55IHBlZXJzIGFscmVhZHkgY29ubmVjdGVkIHRvIHRoaXMgRlZTTCBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgdG9ycmVudC5vbignd2lyZScsIGZ1bmN0aW9uICh3aXJlKXtcclxuICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcysrOyAgXHJcbiAgICAgICAgICAgICAgIH0pOyAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYWRlZCBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdDpcXG5cIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0KSk7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvLyBGb3Igc29tZSBKYXNtaW5lIHRlc3RzIGl0IGlzIGFwcHJvcHJpYXRlIHRoYXQgdGhlIHRvcnJlbnQgZ2V0cyBkZXN0cm95ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0IGhhcyBiZWVuIGNyZWF0ZWQuIFRoZSBkZXN0cnVjdGlvbiBvZiB0aGUgdG9ycmVudCBzdG9wcyB0aGUgc2VlZGluZy5cclxuICAgICAgICAgICAgICAgaWYocmV0dXJuVG9ycmVudCA9PT0gXCJJdCdzIGEgdGVzdFwiKXtcclxuICAgICAgICAgICAgICAgICAgaWYoZGVzdHJveVRvcnJlbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgdG9ycmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3ZWJUb3JyZW50Q2xpZW50O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LCB0b3JyZW50KTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtSW5mb3JtYXRpb25PYmplY3Q7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0KTtcclxuICAgICAgICAgICAgLyogSzQyXHJcbiAgICAgICAgICAgIGlmKFhIUk9yTWV0aG9kRW5kSGFwcGVuZCl7XHJcbiAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFhIUk9yTWV0aG9kRW5kSGFwcGVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgfSAgXHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQGNhbGxiYWNrIE9ha1N0cmVhbWluZ35sb2FkZWRWaWRlb0ZpbmlzaGVkXHJcbiAgICAgICAqLyBcclxuICAgICAgIFxyXG4gICAgICAvKipcclxuICAgICAgICogU3RyZWFtcyBhIHZpZGVvIGZpbGUgdG8gYWxsIG90aGVyIGNsaWVudHMvcGVlcnMuXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyZWFtSW5mb3JtYXRpb25PYmplY3R9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0IC0gVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEgdGhhdCBpcyBuZWVkZWQgdG8gaW5pdGlhdGUgbG9hZGluZyB0aGUgdmlkZW8gZnJvbSBvdGhlciBwZWVycyBhbmQvb3IgYSBXZWIgc2VydmVyLiBTdHJlYW1JbmZvcm1hdGlvbk9iamVjdHMgY2FuIGJlIGNyZWF0ZWQgYnkgdGhlIHtAbGluayBzdHJlYW1WaWRlb3xzdHJlYW1WaWRlb30gbWV0aG9kLlxyXG4gICAgICAgKiBAcGFyYW0ge09ha1N0cmVhbWluZ35sb2FkZWRWaWRlb0ZpbmlzaGVkfSBjYWxsYmFjayAtIFRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGJlZW4gbG9hZGVkIGVudGlyZWx5IGludG8gdGhlIGJ1ZmZlciBvZiB0aGUgdmlkZW8gcGxheWVyLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gbG9hZFZpZGVvKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LCBjYWxsYmFjaywgZW5kSWZWaWRlb0xvYWRlZCl7ICAgICAgICAgXHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwibG9hZFZpZGVvIGlzIGNhbGxlZFwiKTtcclxuICAgICAgICAgLy8vLy8vY29uc29sZS5sb2coXCJvcHRpb24gcGFyYW10ZXI6XFxuXCIgKyBKU09OLnN0cmluZ2lmeShzdHJlYW1JbmZvcm1hdGlvbk9iamVjdCkpO1xyXG4gICAgICAgICB2YXIgZGVsaXZlcnlCeVNlcnZlciA9IChzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5wYXRoVG9GaWxlT25YSFJTZXJ2ZXIgfHwgc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuaGFzaFZhbHVlKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgdmFyIGRlbGl2ZXJ5QnlXZWJ0b3JyZW50ID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QucGFyc2VkVG9ycmVudCA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgdmFyIFhIUlNlcnZlclVSTCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LlhIUlNlcnZlclVSTCB8fCBmYWxzZTtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LlhIUlNlcnZlclVSTDogXCIgKyBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5YSFJTZXJ2ZXJVUkwpO1xyXG4gICAgICAgICB2YXIgWEhSX1BPUlQgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5YSFJQb3J0IHx8IDgwO1xyXG4gICAgICAgICB2YXIgcGF0aFRvRmlsZU9uWEhSU2VydmVyID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QucGF0aFRvRmlsZU9uWEhSU2VydmVyOyAgICAgICBcclxuICAgICAgICAgdmFyIGhhc2hWYWx1ZSA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0Lmhhc2hWYWx1ZTtcclxuICAgICAgICAgdmFyIHdlYlRvcnJlbnRUcmFja2VycyA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LndlYlRvcnJlbnRUcmFja2VycztcclxuICAgICAgICAgLy92YXIgZGVsaXZlcnlCeVdlYnRvcnJlbnQgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5tYWduZXRVUkkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgIHZhciBNQUdORVRfVVJJID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QubWFnbmV0VVJJO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiQnVmZmVyLmlzQnVmZmVyKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRvcnJlbnRGaWxlLmRhdGEpOiBcIiArIEJ1ZmZlci5pc0J1ZmZlcihzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZS5kYXRhKSk7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50b3JyZW50RmlsZTpcXG5cIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRvcnJlbnRGaWxlKSk7XHJcbiAgICAgICAgIHZhciBUSEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QucGFyc2VkVG9ycmVudDtcclxuICAgICAgICAgXHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJUSEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFOlxcblwiICsgSlNPTi5zdHJpbmdpZnkoVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRSkpO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiQnVmZmVyLmlzQnVmZmVyKFRIRV9SRUNFSVZFRF9UT1JSRU5UX0ZJTEUpOiBcIiArIEJ1ZmZlci5pc0J1ZmZlcihUSEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFKSk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRVxcblwiICsgcGFyc2VUb3JyZW50KFRIRV9SRUNFSVZFRF9UT1JSRU5UX0ZJTEUpKTtcclxuICAgICAgICAgLy92YXIgU0laRV9PRl9WSURFT19GSUxFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3Quc2l6ZU9mVmlkZW9GaWxlO1xyXG4gICAgICAgICB2YXIgU0laRV9PRl9WSURFT19GSUxFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3Quc2l6ZU9mVmlkZW9GaWxlO1xyXG5cclxuICAgICAgICAgdmFyIERPV05MT0FEX0ZST01fUDJQX1RJTUVfUkFOR0UgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5kb3dubG9hZEZyb21QMlBUaW1lUmFuZ2UgfHwgMjA7IC8vIGhvdyBtdWNoIHNlY29uZHMgbXVzdCBiZSBidWZmZXJlZCBpbiBhZHZhbmNlIHN1Y2ggdGhhdCBubyBtb3JlIGRhdGEgc3RyZWFtcyBhcmUgcmVxdWVzdGVkIGZyb20gdGhlIFAyUCBuZXR3b3JrICAgICAgICAgICAgICAgICAgT2xkIERlc2NyaWJ0aW9uOiBUaGlzIGlzIHRoZSBtaW5vbXVtIGJ5dGUgcmFuZ2UgdGhhdCB0aGUgV2ViVG9ycmVudCBjbGllbnQgd2lsbCBkb3dubG9hZCBpbiBhZHZhbmNlIChyZWdhcmRpbmcgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24pIHdpdGggYSBzZXF1ZW50aWFsIGNodW5rIHNlbGVjdGlvbiBzdHJhdGVneS4gVGhpcyBtZWFucyB0aGUgdmlkZW8gYnVmZmVyIHNpemUgaW4gYnl0ZVxyXG4gICAgICAgICB2YXIgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuY3JlYXRlUmVhZHN0cmVhbVJlcXVlc3RTaXplIHx8IDUwMDAwMDAwOyAvLyBUaGUgc2l6ZSBvZiB0aGUgY3JlYXRlUmVhZHN0cmVhbSBXZWJUb3JyZW50IHJlcXVlc3RzIGluIGJ5dGVzLiBcclxuICAgICAgICAgXHJcbiAgICAgICAgIHZhciBET1dOTE9BRF9GUk9NX1NFUlZFUl9USU1FX1JBTkdFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuZG93bmxvYWRGcm9tU2VydmVyVGltZVJhbmdlIHx8IDU7IC8vIGluIHNlY29uZHNcclxuICAgICAgICAgdmFyIFVQTE9BRF9MSU1JVCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnVwbG9hZExpbWl0IHx8IDI7IC8vIG11bHRpcGxpZWQgYnkgbnVtYmVyIG9mIGRvd25sb2FkZWQgYnl0ZXNcclxuICAgICAgICAgdmFyIEFERElUSU9OX1RPX1VQTE9BRF9MSU1JVCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmFkZGl0aW9uVG9VcGxvYWRMaW1pdCB8fCA1MDAwMDA7IC8vIGFtb3VudCBvZiBieXRlIGFkZGVkIHRvIHVwbG9hZCBsaW1pdFxyXG4gICAgICAgICBcclxuICAgICAgICAgXHJcbiAgICAgICAgIHZhciBYSFJfUkVRVUVTVF9TSVpFID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QueGhyUmVxdWVzdFNpemUgfHwgNTAwMDA7IC8vIGluIGJ5dGVcclxuICAgICAgICAgdmFyIFRIUkVTSE9MRF9GT1JfUkVUVVJOSU5HX09GX0FOU1dFUl9TVFJFQU0gPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC50aHJlc2hvbGRGb3JSZXR1cm5pbmdBbnN3ZXJTdHJlYW0gfHwgNTAwMDA7IC8vIGluIGJ5dGVcclxuXHJcbiAgICAgICAgIHZhciBDSEVDS19JRl9CVUZGRVJfRlVMTF9FTk9VR0hfSU5URVJWQUwgPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5jaGVja0lmQnVmZmVyRnVsbEVub3VnaEludGVydmFsIHx8IDMwMDsgLy8gaW4gbWlsaXNlY29uZHNcclxuICAgICAgICAgdmFyIENIRUNLX0lGX0FOU1dFUlNUUkVBTV9SRUFEWV9JTlRFUlZBTCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmNoZWNrSWZBbnN3ZXJzdHJlYW1SZWFkeUludGVydmFsIHx8IDIwMDsgLy8gaW4gbWlsaXNlY29uZHNcclxuICAgICAgICAgdmFyIFVQREFURV9DSEFSVF9JTlRFUlZBTCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnVwZGF0ZUNoYXJ0SW50ZXJ2YWwgfHwgMTAwMDsgLy8gaW4gbWlsaXNlY29uZHNcclxuICAgICAgICAgdmFyIENIT0tFX0lGX05FQ0VTU0FSWV9JTlRFUlZBTCA9IHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LmNob2tlSWZOZWNlc3NhcnlJbnRlcnZhbCB8fCA1MDA7IC8vIGluIG1pbGlzZWNvbmRzXHJcbiAgICAgICAgIHZhciBDSEVDS19JRl9ORVdfQ1JFQVRFX1JFQURTVFJFQU1fTkVDRVNTQVJZX0lOVEVSVkFMID0gc3RyZWFtSW5mb3JtYXRpb25PYmplY3QuY2hlY2tJZk5ld0NyZWF0ZVJlYWRzdHJlYW1JbnRlcnZhbCB8fCA1MDAgO1xyXG4gICAgICAgICBcclxuICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICB2YXIgZW5kU3RyZWFtaW5nID0gZmFsc2U7XHJcbiAgICAgICAgIHZhciB3ZWJUb3JyZW50Q2xpZW50ID0gbnVsbDtcclxuICAgICAgICAgdmFyIHdpcmVzID0gW107XHJcbiAgICAgICAgIHZhciBjb25zb2xlQ291bnRlciA9IDA7XHJcbiAgICAgICAgIHZhciBnbG9iYWx2aWRlb3N0cmVhbVJlcXVlc3ROdW1iZXIgPSAwO1xyXG4gICAgICAgICBieXRlc1JlY2VpdmVkRnJvbVNlcnZlciA9IDA7XHJcbiAgICAgICAgIHZhciB3ZWJUb3JyZW50RmlsZTtcclxuICAgICAgICAgdmFyIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzID0gW107XHJcbiAgICAgICAgIHZhciBpbkNyaXRpY2FsID0gdHJ1ZTtcclxuICAgICAgICAgdmFyIHZpZGVvQ29tcGxldGVseUxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICB2YXIgYnl0ZXNUYWtlbkZyb21XZWJUb3JyZW50ID0gMDtcclxuICAgICAgICAgdmFyIGJ5dGVzVGFrZW5Gcm9tU2VydmVyID0gMDsgICBcclxuICAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgbXlWaWRlbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XHJcbiAgICAgICAgIG15VmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXJyKXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihteVZpZGVvLmVycm9yKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICBmdW5jdGlvbiBNeVJlYWRhYmxlU3RyZWFtKG9wdGlvbnMpe1xyXG4gICAgICAgICAgICByZWFkYWJsZVN0cmVhbS5SZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHV0aWwuaW5oZXJpdHMoTXlSZWFkYWJsZVN0cmVhbSwgcmVhZGFibGVTdHJlYW0uUmVhZGFibGUpO1xyXG4gICAgICAgICBNeVJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKHNpemUpe307XHJcbiAgICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgICBpZihkZWxpdmVyeUJ5V2VidG9ycmVudCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZW50ZXJlZCBpZihkZWxpdmVyeUJ5V2VidG9ycmVudClcIik7XHJcbiAgICAgICAgICAgIHdlYlRvcnJlbnRDbGllbnQgPSBuZXcgV2ViVG9ycmVudCgpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRSBcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHdlYlRvcnJlbnRPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIC8qIFdlacOfIG5pY2h0IG1laHIgd2FydW0gZGFzIGhpZXIgc3RlaHRcclxuICAgICAgICAgICAgaWYoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QucGF0aFRvRmlsZVRvU2VlZCl7XHJcbiAgICAgICAgICAgICAgIHdlYlRvcnJlbnRPcHRpb25zLnBhdGggPSBzdHJlYW1JbmZvcm1hdGlvbk9iamVjdC5wYXRoVG9GaWxlVG9TZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0LnRvcnJlbnRBc0Jsb2IpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgd2ViVG9ycmVudENsaWVudC5hZGQodXJsLCB3ZWJUb3JyZW50T3B0aW9ucywgZnVuY3Rpb24gKHRvcnJlbnQpeyAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwid2ViVG9ycmVudENsaWVudC5hZGQgICB0b3JyZW50IG1ldGEgZGF0YSByZWFkeVwiKTsgICAgICAgICBcclxuICAgICAgICAgICAgICAgdGhlVG9ycmVudCA9IHRvcnJlbnQ7XHJcbiAgICAgICAgICAgICAgIHdlYlRvcnJlbnRGaWxlID0gdG9ycmVudC5maWxlc1swXTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPCBwZWVyc1RvQWRkLmxlbmd0aDsgaisrKXtcclxuICAgICAgICAgICAgICAgICAgdGhlVG9ycmVudC5hZGRQZWVyKHBlZXJzVG9BZGRbal1bMF0pO1xyXG4gICAgICAgICAgICAgICAgICBpZihwZWVyc1RvQWRkW2pdWzFdKXtcclxuICAgICAgICAgICAgICAgICAgICAgKHBlZXJzVG9BZGRbal1bMV0pKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSW4gbG9hZFZpZGVvIHR5cGVvZiB3ZWJUb3JyZW50RmlsZSBhZnRlciBhc3NpZ25tZW50OiBcIiArIHR5cGVvZiB3ZWJUb3JyZW50RmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGxvYWRWaWRlbyAgICBcIiArIHNlbGYuT2FrTmFtZSArIFwiLmZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciBnZXRzIGNyZWF0ZWRcIik7XHJcbiAgICAgICAgICAgICAgIHNlbGYuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGxvYWRWaWRlbyAgICAgXCIgKyBzZWxmLk9ha05hbWUgKyBcIi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgICBnZXRzIGNhbGxlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgaWYobm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA8PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tDYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHRvcnJlbnQub24oJ3dpcmUnLCBmdW5jdGlvbih3aXJlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWNhbGxiYWNrQ2FsbGVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzLS07ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHRvcnJlbnQub24oJ3dpcmUnLCBmdW5jdGlvbiAod2lyZSl7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidG9ycmVudC5vbignd2lyZScsIC4uKSBpcyBmaXJlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgd2lyZXMucHVzaCh3aXJlKTtcclxuICAgICAgICAgICAgICAgICAgaWYoIXdpbmRvdy5maXJzdFdpcmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZmlyc3RXaXJlID0gd2lyZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzKys7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgd2lyZS51c2UodXRfcGV4KCkpO1xyXG4gICAgICAgICAgICAgICAgICAvL3dpcmUudXRfcGV4LnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICB3aXJlLnV0X3BleC5vbigncGVlcicsIGZ1bmN0aW9uIChwZWVyKXtcclxuICAgICAgICAgICAgICAgICAgICAgdGhlVG9ycmVudC5hZGRQZWVyKHBlZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAvLyBnb3QgYSBwZWVyXHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGFkZCBpdCB0byBwZWVyIGNvbm5lY3Rpb25zIHF1ZXVlXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgIGZvcih2YXIgaT0wLCBsZW5ndGg9dmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgdmFyIHRoaXNSZXF1ZXN0ID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJbiBvblRvcnJlbnQgbmFjaHRyw6RnbGljaCB3ZWJ0b3JyZW50IHN0cmVhbSBlcnpldWdlbiAgdGhpc1JlcXVlc3Quc3RhcnQ6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSW4gb25Ub3JyZW50ICB3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRDcmVhdGVSZWFkU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRSA+IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gdGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkU7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9uKCdlbmQnLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5jdXJyZW50Q0IgIT09IG51bGwgJiYgdGhpc1JlcXVlc3Quc3RhcnQgPiB0aGlzUmVxdWVzdC5sYXN0RW5kQ3JlYXRlUmVhZFN0cmVhbSAmJiB0aGlzUmVxdWVzdC5zdGFydCA8IHRoaXNSZXF1ZXN0LnZpZGVvRmlsZVNpemUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPj0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gd2ViVG9ycmVudEZpbGUubGVuZ3RoLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgPSB0aGlzUmVxdWVzdC5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS51bnBpcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGlwZSh0aGlzUmVxdWVzdC5jb2xsZWN0b3JTdHJlYW1Gb3JXZWJ0b3JyZW50KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgXHJcbiAgICAgICAgIHZhciBmaWxlTGlrZU9iamVjdCA9IGZ1bmN0aW9uIChwYXRoVG9GaWxlT25YSFJTZXJ2ZXIpe1xyXG4gICAgICAgICAgICB0aGlzLnBhdGhUb0ZpbGVPblhIUlNlcnZlciA9IHBhdGhUb0ZpbGVPblhIUlNlcnZlcjtcclxuICAgICAgICAgfTtcclxuICAgICAgICAgZmlsZUxpa2VPYmplY3QucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbiAob3B0cyl7XHJcbiAgICAgICAgICAgIGlmKG9wdHMuc3RhcnQgPiBTSVpFX09GX1ZJREVPX0ZJTEUpe1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwib3B0cy5zdGFydCA+IFNJWkVfT0ZfVklERU9fRklMRSB0aGVyZSBjYihudWxsLG51bGwpIGV2ZXJ5IHRpbWVcIik7XHJcbiAgICAgICAgICAgICAgIHJldHVybiAobmV3IE11bHRpU3RyZWFtKGZ1bmN0aW9uIChjYil7Y2IobnVsbCwgbnVsbCk7fSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluQ3JpdGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiBjYWxsZWQgY3JlYXRlcmVhZFN0cmVhbSBcIik7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiIG9wdHMuc3RhcnQ6IFwiICsgb3B0cy5zdGFydCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiIG9wdHMuZW5kOiBcIiArIG9wdHMuZW5kKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0aGlzUmVxdWVzdCA9IG5ldyBWaWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyKCsrZ2xvYmFsdmlkZW9zdHJlYW1SZXF1ZXN0TnVtYmVyLCBvcHRzLCB0aGlzKTtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYob3B0cy5lbmQgJiYgIWlzTmFOKG9wdHMuZW5kKSl7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmVuZCA9IG9wdHMuZW5kICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuZW5kID0gU0laRV9PRl9WSURFT19GSUxFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgTXlXcml0ZWFibGVTdHJlYW0gPSBmdW5jdGlvbihoaWdoV2F0ZXJNYXJrKXtcclxuICAgICAgICAgICAgICAgcmVhZGFibGVTdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzLCBoaWdoV2F0ZXJNYXJrKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdXRpbC5pbmhlcml0cyhNeVdyaXRlYWJsZVN0cmVhbSwgcmVhZGFibGVTdHJlYW0uV3JpdGFibGUpO1xyXG4gICAgICAgICAgICBNeVdyaXRlYWJsZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBkb25lKXtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk15V3JpdGVhYmxlU3RyZWFtIF93cml0ZSBpcyBjYWxsZWRcIik7ICAgICAgIFxyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydC10aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgPCBjaHVuay5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiTXlXcml0ZWFibGVTdHJlYW0gX3dyaXRlOiBwdXNoaW5nIHJlY2VpdmVkIGRhdGEgaW4gYW5zd2VyU3RyZWFtXCIpXHJcbiAgICAgICAgICAgICAgICAgIGJ5dGVzVGFrZW5Gcm9tV2ViVG9ycmVudCArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQtdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50KTtcclxuICAgICAgICAgICAgICAgICAgdmFyIHN0cmVhbUhhc01lbW9yeUxlZnQgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChjaHVuay5zbGljZSh0aGlzUmVxdWVzdC5zdGFydC10aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQsIGNodW5rLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydC10aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgaWYoc3RyZWFtSGFzTWVtb3J5TGVmdCl7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAhPT0gbnVsbCAmJiB0aGlzUmVxdWVzdC5zdGFydCA+PSB0aGlzUmVxdWVzdC5lbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCID09PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ub01vcmVEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrRnVuY3Rpb24gPSB0aGlzUmVxdWVzdC5jdXJyZW50Q0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDUwMDAwMDB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhbGxlZCBDQiB3aXRoIGRhdGEgb3V0IG9mIGFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtUmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2tGdW5jdGlvbihudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Quc3RhcnQgKz0gY2h1bmsubGVuZ3RoIC0gKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgLy9jZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSh0aGlzUmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCArPSBjaHVuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCA9IG5ldyBNeVdyaXRlYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMDB9KTtcclxuICAgICAgICAgICAgdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMucHVzaCh0aGlzUmVxdWVzdCk7XHJcblxyXG4gICAgICAgICAgICBpZih3ZWJUb3JyZW50RmlsZSAmJiB0aGVUb3JyZW50LnVwbG9hZGVkIDw9IFVQTE9BRF9MSU1JVCAqIHRoZVRvcnJlbnQuZG93bmxvYWRlZCArIEFERElUSU9OX1RPX1VQTE9BRF9MSU1JVCl7XHJcbiAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJhZnRlciBuZXcgdmlkZW9zdHJlYW1SZXF1ZXN0IGNyZWF0aW5nIGEgY29ycmVzcG9uZGluZyB3ZWJ0b3JyZW50IHN0cmVhbVwiKTtcclxuICAgICAgICAgICAgICAgLy8vL2NvbnNvbGUubG9nKFwib3B0cy5zdGFydDogXCIgKyBvcHRzLnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgLy8vL2NvbnNvbGUubG9nKFwid2ViVG9ycmVudEZpbGUubGVuZ3RoOiBcIiArIHdlYlRvcnJlbnRGaWxlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdmFyIGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID49IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xO1xyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gdGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5sYXN0RW5kQ3JlYXRlUmVhZFN0cmVhbSA9IGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS51bnBpcGUoKTtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbXVsdGkgPSBuZXcgTXVsdGlTdHJlYW0oZnVuY3Rpb24gKGNiKXtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJlYWRhYmxlU3RyZWFtIHJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArIFwiICAgIGRvZXMgYSBjYiByZXF1ZXN0XCIpO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5lbmQgPj0gMCAmJiB0aGlzUmVxdWVzdC5zdGFydCA+PSB0aGlzUmVxdWVzdC5lbmQpe1xyXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIGNiKG51bGwsbnVsbCkgZnJvbSBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpOyBcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QucmVxID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LkNCTnVtYmVyKys7XHJcbiAgICAgICAgICAgICAgIGlmKGNvbnNvbGVDb3VudGVyPDIwKXtcclxuICAgICAgICAgICAgICAgICAgLy8vLy8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiICAgIFwiICsgdGhpc1JlcXVlc3QuQ0JOdW1iZXIgKyBcIi4gY2FsbCBvZiBmdW5jdGlvbihjYikgZnJvbSBcIiArIHZpZGVvc3RyZWFtUmVxdWVzdE51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiICAgIHN0YXJ0OiBcIiArIHRoaXNSZXF1ZXN0LnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPSBjYjtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qubm9Nb3JlRGF0YSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgaWYoIWNlY2tJZkFuc3dlclN0cmVhbVJlYWR5KHRoaXNSZXF1ZXN0KSl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYod2ViVG9ycmVudEZpbGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiTmV3IGNiIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYW5kIEkgc3Vic2VxdWVudGx5IGNyZWF0ZSBhIG5ldyB0b3JyZW50U3RyZWFtIGZvciBpdCBiZWNhdXNlIG5vbiBleGlzdGVkIGJlZm9yZSBmb3IgdGhpcyB2aWRlb3N0cmVhbVJlcXVlc3RcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vLy9jb25zb2xlLmxvZyhcIkFmdGVyIG5ldyBNdWx0aXN0cmVhbS4gdGhpc1JlcXVlc3Quc3RhcnQ6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAvLy8vY29uc29sZS5sb2coXCJ3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID49IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gdGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkU7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5sYXN0RW5kQ3JlYXRlUmVhZFN0cmVhbSA9IGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS51bnBpcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZihkZWxpdmVyeUJ5U2VydmVyICYmIGluQ3JpdGljYWwgJiYgIXRoaXNSZXF1ZXN0LlhIUkNvbmR1Y3RlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbmR1Y3RYSFIodGhpc1JlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiIHRlcm1pbmF0ZSBjcmVhdGVSZWFkU3RyZWFtXCIpO1xyXG4gICAgICAgICAgICB2YXIgZGVzdHJveSA9IG11bHRpLmRlc3Ryb3k7XHJcbiAgICAgICAgICAgIG11bHRpLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QucmVxKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LnJlcS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgZGVzdHJveS5jYWxsKG11bHRpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG11bHRpO1xyXG4gICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgIGZ1bmN0aW9uIGZyZXF1ZW50bHlDaGVja0lmTmV3Q3JlYXRlUmVhZFN0cmVhbU5lY2Vzc2FyeSgpe1xyXG4gICAgICAgICAgICAgICBpZih2aWRlb0NvbXBsZXRlbHlMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgICAgICBpZihteVZpZGVvLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgdmFyIHRpbWVSYW5nZXMgPSBteVZpZGVvLmJ1ZmZlcmVkOyAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRpbWVSYW5nZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICBpZiAobXlWaWRlby5jdXJyZW50VGltZSA+PSB0aW1lUmFuZ2VzLnN0YXJ0KGkpICYmIG15VmlkZW8uY3VycmVudFRpbWUgPD0gdGltZVJhbmdlcy5lbmQoaSkrMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZVJhbmdlcy5lbmQoaSkgLSBteVZpZGVvLmN1cnJlbnRUaW1lIDw9IERPV05MT0FEX0ZST01fUDJQX1RJTUVfUkFOR0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzUmVxdWVzdCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsICYmIHRoaXNSZXF1ZXN0LnN0YXJ0ID4gdGhpc1JlcXVlc3QubGFzdEVuZENyZWF0ZVJlYWRTdHJlYW0gJiYgdGhpc1JlcXVlc3Quc3RhcnQgPCB0aGlzUmVxdWVzdC52aWRlb0ZpbGVTaXplKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID49IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gdGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcInN0YXJ0XCIgOiB0aGlzUmVxdWVzdC5zdGFydCwgXCJlbmRcIiA6IGVuZENyZWF0ZVJlYWRTdHJlYW19KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRXZWJUb3JyZW50ID0gdGhpc1JlcXVlc3Quc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0udW5waXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGlwZSh0aGlzUmVxdWVzdC5jb2xsZWN0b3JTdHJlYW1Gb3JXZWJ0b3JyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnJlcXVlbnRseUNoZWNrSWZOZXdDcmVhdGVSZWFkU3RyZWFtTmVjZXNzYXJ5LCBDSEVDS19JRl9ORVdfQ1JFQVRFX1JFQURTVFJFQU1fTkVDRVNTQVJZX0lOVEVSVkFMKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgZnVuY3Rpb24gY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkodGhpc1JlcXVlc3Qpe1xyXG4gICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiQXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtOiBcIiArIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0pO1xyXG4gICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiSW4gY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkgb2YgdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIgKyAgXCIuIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW06IFwiICsgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSArIFwiICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0I6IFwiICsgdGhpc1JlcXVlc3QuY3VycmVudENCKTtcclxuICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAmJiAoKHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPj0gVEhSRVNIT0xEX0ZPUl9SRVRVUk5JTkdfT0ZfQU5TV0VSX1NUUkVBTSkgfHwgKHRoaXNSZXF1ZXN0LnN0YXJ0ID49IFNJWkVfT0ZfVklERU9fRklMRSkpKXtcclxuICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcImFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtIFJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArIFwiIGFuZCBDQiBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5DQk51bWJlciArIFwiIGdldHMgcmV0dXJuZWRcIik7XHJcbiAgICAgICAgICAgICAgIC8vIC8vLy8vL2NvbnNvbGUubG9nKFwiUmV0dXJpbmcgYW5zd2VyU3RyZWFtIG91dCBvZiBjZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSgpXCIpO1xyXG4gICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtKXtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMH0pO1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgZnVuY3Rpb24gY2hva2VJZk5lY2Vzc2FyeSgpe1xyXG4gICAgICAgICAgICAgICBpZiAodGhlVG9ycmVudCAmJiB0aGVUb3JyZW50LnVwbG9hZGVkID49IHRoZVRvcnJlbnQuZG93bmxvYWRlZCAqIFVQTE9BRF9MSU1JVCArIEFERElUSU9OX1RPX1VQTE9BRF9MSU1JVCkge1xyXG4gICAgICAgICAgICAgICAgICAvKiBtYWNoZSBpY2ggc2Nob24gaW4gZWluZXIgYW5kZXJlbiBmcmVxdWVudCBtZXRob2RlXHJcbiAgICAgICAgICAgICAgICAgIGlmKHZpZGVvQ29tcGxldGVseUxvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoZVRvcnJlbnQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2ViVG9ycmVudENsaWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgZW5kU3RyZWFtaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB3aXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJIGNob2tlZCBhIHBlZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgIHdpcmVzW2ldLmNob2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNob2tlSWZOZWNlc3NhcnksIENIT0tFX0lGX05FQ0VTU0FSWV9JTlRFUlZBTCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNoYXJ0KCl7XHJcbiAgICAgICAgICAgICAgIGlmKGVuZFN0cmVhbWluZyl7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZih0aGVUb3JyZW50ICYmIHdlYlRvcnJlbnRGaWxlKXtcclxuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJXZWJUb3JyZW50LXJlY2VpdmVkXCIpLmlubmVySFRNTCA9IFwid2ViVG9ycmVudEZpbGUubGVuZ3RoOiBcIiArIHdlYlRvcnJlbnRGaWxlLmxlbmd0aCArIFwiXFxuIHRvcnJlbnQuZG93bmxvYWRlZDogXCIgKyB0aGVUb3JyZW50LmRvd25sb2FkZWQgKyBcIlxcbiB0b3JyZW50LnVwbG9hZGVkOiBcIiArIHRoZVRvcnJlbnQudXBsb2FkZWQgKyBcIlxcbiB0b3JyZW50LnByb2dyZXNzOiBcIiArIHRoZVRvcnJlbnQucHJvZ3Jlc3MgKyBcIlxcbiBCeXRlcyByZWNlaXZlZCBmcm9tIHNlcnZlcjogXCIgKyBieXRlc1JlY2VpdmVkRnJvbVNlcnZlciArIFwiXFxuIEJ5dGVzIHRha2VuIGZyb20gc2VydmVyIGRlbGl2ZXJ5OiBcIiArIGJ5dGVzVGFrZW5Gcm9tU2VydmVyICsgXCJcXG4gQnl0ZXMgdGFrZW4gZnJvbSBXZWJUb3JyZW50IGRlbGl2ZXJ5OiBcIiArIGJ5dGVzVGFrZW5Gcm9tV2ViVG9ycmVudDtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBzZXRUaW1lb3V0KHVwZGF0ZUNoYXJ0LCBVUERBVEVfQ0hBUlRfSU5URVJWQUwpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgZnVuY3Rpb24gVmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcihyZWFkU3RyZWFtTnVtYmVyLCBvcHRzLCBzZWxmKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZFN0cmVhbU51bWJlciA9IHJlYWRTdHJlYW1OdW1iZXI7XHJcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBvcHRzLnN0YXJ0IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMub2xkU3RhcnRXZWJUb3JyZW50ID0gLTQyO1xyXG4gICAgICAgICAgICB0aGlzLm9sZFN0YXJ0U2VydmVyID0gLTQyO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDQiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuQ0JOdW1iZXIgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLndlYlRvcnJlbnRTdHJlYW0gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuWEhSQ29uZHVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gLTQyO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGYgPSBzZWxmO1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzVGFrZW5Gcm9tV2ViVG9ycmVudCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNUYWtlbkZyb21TZXJ2ZXIgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm5vTW9yZURhdGEgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZXEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtID0gLTQyO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICBmdW5jdGlvbiBmcmVxdWVudGx5Q2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkoKXtcclxuICAgICAgICAgICAgICAgaWYodmlkZW9Db21wbGV0ZWx5TG9hZGVkKXtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICBjZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSh2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgc2V0VGltZW91dChmcmVxdWVudGx5Q2Vja0lmQW5zd2VyU3RyZWFtUmVhZHksIENIRUNLX0lGX0FOU1dFUlNUUkVBTV9SRUFEWV9JTlRFUlZBTCk7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGZ1bmN0aW9uIGNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoKCl7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjaGVja0lmQnVmZmVyRnVsbEVub3VnaCBpcyBjYWxsZWRcIik7XHJcbiAgICAgICAgICAgICAgIGlmKHZpZGVvQ29tcGxldGVseUxvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlkZW8uZHVyYXRpb246IFwiICsgbXlWaWRlby5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgIGlmKG15VmlkZW8uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgICB2YXIgdGltZVJhbmdlcyA9IG15VmlkZW8uYnVmZmVyZWQ7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHRpbWVSYW5nZXMubGVuZ3RoID49IDEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidGltZVJhbmdlcy5zdGFydCgwKTogXCIgKyB0aW1lUmFuZ2VzLnN0YXJ0KDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInRpbWVSYW5nZXMuZW5kKDApOiBcIiArIHRpbWVSYW5nZXMuZW5kKDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRpbWVSYW5nZXMuc3RhcnQoMCkgPT0gMCAmJiB0aW1lUmFuZ2VzLmVuZCgwKSA9PSBteVZpZGVvLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkluIGNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoOiBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbXBsZXRlbHlMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVuZElmVmlkZW9Mb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGVUb3JyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVuZElmVmlkZW9Mb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGVUb3JyZW50KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlVG9ycmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3ZWJUb3JyZW50Q2xpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFN0cmVhbWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaW5Dcml0aWNhbCA9IHRydWU7ICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRpbWVSYW5nZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcIlRpbWUgcmFuZ2UgbnVtYmVyIFwiICsgaSArIFwiOiBzdGFydChcIiArIHRpbWVSYW5nZXMuc3RhcnQoaSkgKyBcIikgZW5kKFwiICsgdGltZVJhbmdlcy5lbmQoaSkgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmIChteVZpZGVvLmN1cnJlbnRUaW1lID49IHRpbWVSYW5nZXMuc3RhcnQoaSkgJiYgbXlWaWRlby5jdXJyZW50VGltZSA8PSB0aW1lUmFuZ2VzLmVuZChpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZVJhbmdlcy5lbmQoaSkgLSBteVZpZGVvLmN1cnJlbnRUaW1lID49IERPV05MT0FEX0ZST01fU0VSVkVSX1RJTUVfUkFOR0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Dcml0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiSSBzZXQgaW5Dcml0aWNhbCB0byBmYWxzZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYgKGRlbGl2ZXJ5QnlTZXJ2ZXIgJiYgaW5Dcml0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuZ3RoID0gdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnMubGVuZ3RoOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2pdLmN1cnJlbnRDQiAhPT0gbnVsbCAmJiB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tqXS5YSFJDb25kdWN0ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmR1Y3RYSFIodmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcnNbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tJZkJ1ZmZlckZ1bGxFbm91Z2gsIENIRUNLX0lGX0JVRkZFUl9GVUxMX0VOT1VHSF9JTlRFUlZBTCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGZ1bmN0aW9uIGNvbmR1Y3RYSFIodGhpc1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCID09PSBudWxsKXtcclxuICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXNSZXF1ZXN0LlhIUkNvbmR1Y3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciByZXFTdGFydCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICB2YXIgcmVxRW5kID0gcmVxU3RhcnQgKyBYSFJfUkVRVUVTVF9TSVpFO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0LmVuZCA+PSAwICYmIHJlcUVuZCA+IHRoaXNSZXF1ZXN0LmVuZCkge1xyXG4gICAgICAgICAgICAgICByZXFFbmQgPSB0aGlzUmVxdWVzdC5lbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlcVN0YXJ0ID49IHJlcUVuZCkge1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIGNiKG51bGwsbnVsbClcIik7XHJcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzUmVxdWVzdC5jdXJyZW50Q0IobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIGdsYXViZSBpY2ggdW5uw7Z0aWdlciB1bmQvb2RlciBnZWbDpGhybGljaGVyIG3DvGxsXHJcbiAgICAgICAgICAgIGlmIChyZXFTdGFydCA+PSByZXFFbmQpIHtcclxuICAgICAgICAgICAgcmVxID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQihudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoY29uc29sZUNvdW50ZXIgPCAxMDAwMDAwMCkge1xyXG4gICAgICAgICAgICAgICAvLy8vLy8vLy8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiICB2aWRlb1N0cmVhbSBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIgKyBcIiAgQ0IgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuQ0JOdW1iZXIgKyBcIiAgICByZXFTdGFydDogXCIgKyByZXFTdGFydCk7XHJcbiAgICAgICAgICAgICAgIC8vLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgIE11bHRpc3RyZWFtIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlciArIFwiICAgQ0IgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuQ0JOdW1iZXIgKyBcIiAgICByZXFFbmQ6IFwiICsgcmVxRW5kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIFhIUkRhdGFIYW5kbGVyID0gZnVuY3Rpb24gKGNodW5rKXtcclxuICAgICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZEZyb21TZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVhZGFibGVTdHJlYW0gcmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyICsgXCIgcmVjZWl2ZWQgYSBjaHVuayBvZiBsZW5ndGggXCIgKyBjaHVuay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5ub01vcmVEYXRhKXtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0LnN0YXJ0IC0gdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgPCBjaHVuay5sZW5ndGgpeyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBieXRlc1Rha2VuRnJvbVNlcnZlciArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gKz0gY2h1bmsubGVuZ3RoIC0gKHRoaXNSZXF1ZXN0LnN0YXJ0IC0gdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgbXlCdWZmZXIgPSBjaHVuay5zbGljZSh0aGlzUmVxdWVzdC5zdGFydCAtIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0U2VydmVyLCBjaHVuay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSW4gWEhSRGF0YUhhbmRsZXIgICBteUJ1ZmZlci5sZW5ndGg6IFwiICsgbXlCdWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgdmFyIFN0cmVhbUhhc01lbW9yeUxlZnQgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChteUJ1ZmZlcik7ICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIGlmKCFTdHJlYW1IYXNNZW1vcnlMZWZ0KXtcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrRnVuY3Rpb24gPSB0aGlzUmVxdWVzdC5jdXJyZW50Q0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDUwMDAwMDB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhbGxlZCBDQiB3aXRoIGRhdGEgb3V0IG9mIGFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtUmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5yZWFkU3RyZWFtTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2tGdW5jdGlvbihudWxsLCByZXMpOyBcclxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qubm9Nb3JlRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3Quc3RhcnQgPj0gU0laRV9PRl9WSURFT19GSUxFICYmIHRoaXNSZXF1ZXN0LmN1cnJlbnRDQiAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudENCO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50Q0IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiA1MDAwMDAwfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5zdGFydCArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlcik7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgWEhSRW5kID0gZnVuY3Rpb24gKCl7XHJcbiAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSZWFkYWJsZVN0cmVhbSByZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIgKyBcIiBYSFJFbmRcIik7XHJcbiAgICAgICAgICAgICAgIGlmIChjb25zb2xlQ291bnRlciA8IDEwMDAwMDAwMDAwMDApe1xyXG4gICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vY29uc29sZS5sb2coXCJYSFJFbmQgZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QucmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA+IDAgJiYgdGhpc1JlcXVlc3QuY3VycmVudENCICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogNTAwMDAwMH0pO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRDQjtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudENCID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlhIUkVuZDogY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LnJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuWEhSQ29uZHVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgPSByZXFTdGFydDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJBdCBodHRvLmdldCAgIHJlcVN0YXJ0OiBcIiArIHJlcVN0YXJ0ICsgXCIgICAgIHJlcUVuZDogXCIgKyByZXFFbmQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBYSFJPcHRpb25PYmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgIHBhdGg6IHRoaXNSZXF1ZXN0LnNlbGYucGF0aFRvRmlsZU9uWEhSU2VydmVyLFxyXG4gICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgIHJhbmdlOiAnYnl0ZXM9JyArIHJlcVN0YXJ0ICsgJy0nICsgKHJlcUVuZC0xKVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmKFhIUlNlcnZlclVSTCl7XHJcbiAgICAgICAgICAgICAgIFhIUk9wdGlvbk9iamVjdC5ob3N0bmFtZSA9IFhIUlNlcnZlclVSTDtcclxuICAgICAgICAgICAgICAgWEhST3B0aW9uT2JqZWN0LnBvcnQgPSBYSFJfUE9SVDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpc1JlcXVlc3QucmVxID0gaHR0cC5nZXQoWEhST3B0aW9uT2JqZWN0LCBmdW5jdGlvbiAocmVzKXtcclxuICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRSYW5nZSA9IHJlcy5oZWFkZXJzWydjb250ZW50LXJhbmdlJ107XHJcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuZmlsZVNpemUgPSBwYXJzZUludChjb250ZW50UmFuZ2Uuc3BsaXQoJy8nKVsxXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9jb25zb2xlLmxvZyhcIkkgcmV0dXJuIGN1cnJlbnRDQiB3aXRoIGh0dHAgcmVzcG9uc2Ugc3RyZWFtXCIpO1xyXG4gICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy9jb25zb2xlLmxvZyhcImZ1bmN0aW9uKHJlcykgaXMgZXhlY3V0ZWQgZnJvbSByZWFkc3RyZWFtIG51bWJlciBcIiArIGNyZWF0ZVJlYWRTdHJlYW1Db3VudGVyICsgXCIgYW5kIENCIG51bWJlciBcIiArIHRoaXNDQk51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgIHJlcy5vbignZW5kJywgWEhSRW5kKTtcclxuICAgICAgICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgWEhSRGF0YUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZnJlcXVlbnRseUNoZWNrSWZOZXdDcmVhdGVSZWFkU3RyZWFtTmVjZXNzYXJ5KCk7XHJcbiAgICAgICAgIGNob2tlSWZOZWNlc3NhcnkoKTtcclxuICAgICAgICAgdXBkYXRlQ2hhcnQoKTtcclxuICAgICAgICAgZnJlcXVlbnRseUNlY2tJZkFuc3dlclN0cmVhbVJlYWR5KCk7XHJcbiAgICAgICAgIGNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoKCk7XHJcblxyXG4gICAgICAgICAvLy8vLy9jb25zb2xlLmxvZyhcIkkgY2FsbCBWaWRlb3N0cmVhbSBjb25zdHJ1Y3RvclwiKTtcclxuICAgICAgICAgaWYoaGFzaFZhbHVlKXtcclxuICAgICAgICAgICAgVmlkZW9zdHJlYW0obmV3IGZpbGVMaWtlT2JqZWN0KGhhc2hWYWx1ZSksIG15VmlkZW8pO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBWaWRlb3N0cmVhbShuZXcgZmlsZUxpa2VPYmplY3QocGF0aFRvRmlsZU9uWEhSU2VydmVyKSwgbXlWaWRlbyk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGFkZFNpbXBsZVBlZXJJbnN0YW5jZShzaW1wbGVQZWVySW5zdGFuY2UsIG9wdGlvbnMsIGNhbGxiYWNrKXtcclxuICAgICAgICAgLy8gVGhlIG1ldGhvZCBhZGQgYSBzaW1wbGVQZWVyIHRvIHRoZSBXZWJUb3JyZW50IHN3YXJtIGluc3RhbmNlXHJcbiAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICBpZih0aGVUb3JyZW50LmluZm9IYXNoKXtcclxuICAgICAgICAgICAgICAgdGhlVG9ycmVudC5hZGRQZWVyKHNpbXBsZVBlZXJJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGVUb3JyZW50Lm9uKCdpbmZvSGFzaCcsIGZ1bmN0aW9uKCkge3RoZVRvcnJlbnQuYWRkUGVlcihzaW1wbGVQZWVySW5zdGFuY2UpOyBpZihjYWxsYmFjayl7Y2FsbGJhY2soKX19KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcGFpciA9IFtdO1xyXG4gICAgICAgICAgICBwYWlyLnB1c2goc2ltcGxlUGVlckluc3RhbmNlKTtcclxuICAgICAgICAgICAgcGFpci5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgcGVlcnNUb0FkZC5wdXNoKHBhaXIpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfSkoKTtcclxufSIsInZhciBBRERSX1JFID0gL15cXFs/KFteXFxdXSspXFxdPzooXFxkKykkLyAvLyBpcHY0L2lwdjYvaG9zdG5hbWUgKyBwb3J0XG5cbnZhciBjYWNoZSA9IHt9XG5cbi8vIHJlc2V0IGNhY2hlIHdoZW4gaXQgZ2V0cyB0byAxMDAsMDAwIGVsZW1lbnRzICh+IDYwMEtCIG9mIGlwdjQgYWRkcmVzc2VzKVxuLy8gc28gaXQgd2lsbCBub3QgZ3JvdyB0byBjb25zdW1lIGFsbCBtZW1vcnkgaW4gbG9uZy1ydW5uaW5nIHByb2Nlc3Nlc1xudmFyIHNpemUgPSAwXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkclRvSVBQb3J0IChhZGRyKSB7XG4gIGlmIChzaXplID09PSAxMDAwMDApIG1vZHVsZS5leHBvcnRzLnJlc2V0KClcbiAgaWYgKCFjYWNoZVthZGRyXSkge1xuICAgIHZhciBtID0gQUREUl9SRS5leGVjKGFkZHIpXG4gICAgaWYgKCFtKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcjogJyArIGFkZHIpXG4gICAgY2FjaGVbYWRkcl0gPSBbIG1bMV0sIE51bWJlcihtWzJdKSBdXG4gICAgc2l6ZSArPSAxXG4gIH1cbiAgcmV0dXJuIGNhY2hlW2FkZHJdXG59XG5cbm1vZHVsZS5leHBvcnRzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKCkge1xuICBjYWNoZSA9IHt9XG4gIHNpemUgPSAwXG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbmZ1bmN0aW9uIGluaXQgKCkge1xuICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbiAgfVxuXG4gIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxuICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcbn1cblxuaW5pdCgpXG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxuXG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyoqXG4gKiBEZWNvZGVzIGJlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IChvcHRpb25hbClcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kIChvcHRpb25hbClcbiAqIEBwYXJhbSAge1N0cmluZ30gZW5jb2RpbmcgKG9wdGlvbmFsKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGRhdGEsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwpIHtcbiAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgc3RhcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsKSB7XG4gICAgZW5jb2RpbmcgPSBlbmRcbiAgICBlbmQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gIShCdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgPyBuZXcgQnVmZmVyKGRhdGEpXG4gICAgOiBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZGVjb2RlLmJ5dGVzID0gZGVjb2RlLmRhdGEubGVuZ3RoXG5cbiAgcmV0dXJuIGRlY29kZS5uZXh0KClcbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgPSBudWxsXG5kZWNvZGUuZW5jb2RpbmcgPSBudWxsXG5cbmRlY29kZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBzd2l0Y2ggKGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0pIHtcbiAgICBjYXNlIDB4NjQ6XG4gICAgICByZXR1cm4gZGVjb2RlLmRpY3Rpb25hcnkoKVxuICAgIGNhc2UgMHg2QzpcbiAgICAgIHJldHVybiBkZWNvZGUubGlzdCgpXG4gICAgY2FzZSAweDY5OlxuICAgICAgcmV0dXJuIGRlY29kZS5pbnRlZ2VyKClcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRlY29kZS5idWZmZXIoKVxuICB9XG59XG5cbmRlY29kZS5maW5kID0gZnVuY3Rpb24gKGNocikge1xuICB2YXIgaSA9IGRlY29kZS5wb3NpdGlvblxuICB2YXIgYyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICB2YXIgZCA9IGRlY29kZS5kYXRhXG5cbiAgd2hpbGUgKGkgPCBjKSB7XG4gICAgaWYgKGRbaV0gPT09IGNocikgcmV0dXJuIGlcbiAgICBpKytcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBkYXRhOiBNaXNzaW5nIGRlbGltaXRlciBcIicgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoMTYpICsgJ10nXG4gIClcbn1cblxuZGVjb2RlLmRpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7XG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGRpY3QgPSB7fVxuXG4gIHdoaWxlIChkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1KSB7XG4gICAgZGljdFtkZWNvZGUuYnVmZmVyKCldID0gZGVjb2RlLm5leHQoKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gZGljdFxufVxuXG5kZWNvZGUubGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgbHN0ID0gW11cblxuICB3aGlsZSAoZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSkge1xuICAgIGxzdC5wdXNoKGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBsc3Rcbn1cblxuZGVjb2RlLmludGVnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmQgPSBkZWNvZGUuZmluZCgweDY1KVxuICB2YXIgbnVtYmVyID0gZGVjb2RlLmRhdGEudG9TdHJpbmcoJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uICsgMSwgZW5kKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgMTApXG59XG5cbmRlY29kZS5idWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZXAgPSBkZWNvZGUuZmluZCgweDNBKVxuICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoZGVjb2RlLmRhdGEudG9TdHJpbmcoJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXApLCAxMClcbiAgdmFyIGVuZCA9ICsrc2VwICsgbGVuZ3RoXG5cbiAgZGVjb2RlLnBvc2l0aW9uID0gZW5kXG5cbiAgcmV0dXJuIGRlY29kZS5lbmNvZGluZ1xuICAgID8gZGVjb2RlLmRhdGEudG9TdHJpbmcoZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZClcbiAgICA6IGRlY29kZS5kYXRhLnNsaWNlKHNlcCwgZW5kKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUgKGRhdGEsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHZhciBidWZmZXJzID0gW11cbiAgdmFyIHJlc3VsdCA9IG51bGxcblxuICBlbmNvZGUuX2VuY29kZShidWZmZXJzLCBkYXRhKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpXG4gIGVuY29kZS5ieXRlcyA9IHJlc3VsdC5sZW5ndGhcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICByZXN1bHQuY29weShidWZmZXIsIG9mZnNldClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiAoYnVmZmVycywgZGF0YSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVyblxuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgZGF0YSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKGJ1ZmZlcnMsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBlbmNvZGUubnVtYmVyKGJ1ZmZlcnMsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KGJ1ZmZlcnMsIGRhdGEpXG4gICAgICAgIDogZW5jb2RlLmRpY3QoYnVmZmVycywgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBlbmNvZGUubnVtYmVyKGJ1ZmZlcnMsIGRhdGEgPyAxIDogMClcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxudmFyIGJ1ZmZFID0gbmV3IEJ1ZmZlcignZScpXG52YXIgYnVmZkQgPSBuZXcgQnVmZmVyKCdkJylcbnZhciBidWZmTCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgKyAnOicgKyBkYXRhKSlcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uIChidWZmZXJzLCBkYXRhKSB7XG4gIHZhciBtYXhMbyA9IDB4ODAwMDAwMDBcbiAgdmFyIGhpID0gKGRhdGEgLyBtYXhMbykgPDwgMFxuICB2YXIgbG8gPSAoZGF0YSAlIG1heExvKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2gobmV3IEJ1ZmZlcignaScgKyB2YWwgKyAnZScpKVxuXG4gIGlmICh2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQpIHtcbiAgICBlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gdHJ1ZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXQVJOSU5HOiBQb3NzaWJsZSBkYXRhIGNvcnJ1cHRpb24gZGV0ZWN0ZWQgd2l0aCB2YWx1ZSBcIicgKyBkYXRhICsgJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicgKyB2YWwgKyAnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG59XG5cbmVuY29kZS5kaWN0ID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgYnVmZmVycy5wdXNoKGJ1ZmZEKVxuXG4gIHZhciBqID0gMFxuICB2YXIga1xuICAvLyBmaXggZm9yIGlzc3VlICMxMyAtIHNvcnRlZCBkaWN0c1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciAoOyBqIDwga2w7IGorKykge1xuICAgIGsgPSBrZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlcihidWZmZXJzLCBrKVxuICAgIGVuY29kZS5fZW5jb2RlKGJ1ZmZlcnMsIGRhdGFba10pXG4gIH1cblxuICBidWZmZXJzLnB1c2goYnVmZkUpXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgdmFyIGkgPSAwXG4gIHZhciBjID0gZGF0YS5sZW5ndGhcbiAgYnVmZmVycy5wdXNoKGJ1ZmZMKVxuXG4gIGZvciAoOyBpIDwgYzsgaSsrKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoYnVmZmVycywgZGF0YVtpXSlcbiAgfVxuXG4gIGJ1ZmZlcnMucHVzaChidWZmRSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsInZhciBiZW5jb2RlID0gbW9kdWxlLmV4cG9ydHNcblxuYmVuY29kZS5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpXG5iZW5jb2RlLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJylcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBhbW91bnQgb2YgYnl0ZXNcbiAqIG5lZWRlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHZhbHVlXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl8QnVmZmVyfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn0gYnl0ZUNvdW50XG4gKi9cbmJlbmNvZGUuYnl0ZUxlbmd0aCA9IGJlbmNvZGUuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKHZhbHVlKS5sZW5ndGhcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSwgY29tcGFyYXRvciwgbG93LCBoaWdoKSB7XG4gIHZhciBtaWQsIGNtcDtcblxuICBpZihsb3cgPT09IHVuZGVmaW5lZClcbiAgICBsb3cgPSAwO1xuXG4gIGVsc2Uge1xuICAgIGxvdyA9IGxvd3wwO1xuICAgIGlmKGxvdyA8IDAgfHwgbG93ID49IGhheXN0YWNrLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBsb3dlciBib3VuZFwiKTtcbiAgfVxuXG4gIGlmKGhpZ2ggPT09IHVuZGVmaW5lZClcbiAgICBoaWdoID0gaGF5c3RhY2subGVuZ3RoIC0gMTtcblxuICBlbHNlIHtcbiAgICBoaWdoID0gaGlnaHwwO1xuICAgIGlmKGhpZ2ggPCBsb3cgfHwgaGlnaCA+PSBoYXlzdGFjay5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgdXBwZXIgYm91bmRcIik7XG4gIH1cblxuICB3aGlsZShsb3cgPD0gaGlnaCkge1xuICAgIC8qIE5vdGUgdGhhdCBcIihsb3cgKyBoaWdoKSA+Pj4gMVwiIG1heSBvdmVyZmxvdywgYW5kIHJlc3VsdHMgaW4gYSB0eXBlY2FzdFxuICAgICAqIHRvIGRvdWJsZSAod2hpY2ggZ2l2ZXMgdGhlIHdyb25nIHJlc3VsdHMpLiAqL1xuICAgIG1pZCA9IGxvdyArIChoaWdoIC0gbG93ID4+IDEpO1xuICAgIGNtcCA9ICtjb21wYXJhdG9yKGhheXN0YWNrW21pZF0sIG5lZWRsZSwgbWlkLCBoYXlzdGFjayk7XG5cbiAgICAvKiBUb28gbG93LiAqL1xuICAgIGlmKGNtcCA8IDAuMClcbiAgICAgIGxvdyAgPSBtaWQgKyAxO1xuXG4gICAgLyogVG9vIGhpZ2guICovXG4gICAgZWxzZSBpZihjbXAgPiAwLjApXG4gICAgICBoaWdoID0gbWlkIC0gMTtcblxuICAgIC8qIEtleSBmb3VuZC4gKi9cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWlkO1xuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIH5sb3c7XG59XG4iLCJ2YXIgQ29udGFpbmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiA/IEJ1ZmZlciAvL2luIG5vZGUsIHVzZSBidWZmZXJzXHJcblx0XHQ6IHR5cGVvZiBJbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBJbnQ4QXJyYXkgLy9pbiBuZXdlciBicm93c2VycywgdXNlIHdlYmdsIGludDhhcnJheXNcclxuXHRcdDogZnVuY3Rpb24obCl7IHZhciBhID0gbmV3IEFycmF5KGwpOyBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBhW2ldPTA7IH07IC8vZWxzZSwgZG8gc29tZXRoaW5nIHNpbWlsYXJcclxuXHJcbmZ1bmN0aW9uIEJpdEZpZWxkKGRhdGEsIG9wdHMpe1xyXG5cdGlmKCEodGhpcyBpbnN0YW5jZW9mIEJpdEZpZWxkKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBCaXRGaWVsZChkYXRhLCBvcHRzKTtcclxuXHR9XHJcblxyXG5cdGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDApe1xyXG5cdFx0ZGF0YSA9IDA7XHJcblx0fVxyXG5cclxuXHR0aGlzLmdyb3cgPSBvcHRzICYmIChpc0Zpbml0ZShvcHRzLmdyb3cpICYmIGdldEJ5dGVTaXplKG9wdHMuZ3JvdykgfHwgb3B0cy5ncm93KSB8fCAwO1xyXG5cclxuXHRpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCBkYXRhID09PSB1bmRlZmluZWQpe1xyXG5cdFx0ZGF0YSA9IG5ldyBDb250YWluZXIoZ2V0Qnl0ZVNpemUoZGF0YSkpO1xyXG5cdFx0aWYoZGF0YS5maWxsICYmICFkYXRhLl9pc0J1ZmZlcikgZGF0YS5maWxsKDApOyAvLyBjbGVhciBub2RlIGJ1ZmZlcnMgb2YgZ2FyYmFnZVxyXG5cdH1cclxuXHR0aGlzLmJ1ZmZlciA9IGRhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJ5dGVTaXplKG51bSl7XHJcblx0dmFyIG91dCA9IG51bSA+PiAzO1xyXG5cdGlmKG51bSAlIDggIT09IDApIG91dCsrO1xyXG5cdHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbkJpdEZpZWxkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpKXtcclxuXHR2YXIgaiA9IGkgPj4gMztcclxuXHRyZXR1cm4gKGogPCB0aGlzLmJ1ZmZlci5sZW5ndGgpICYmXHJcblx0XHQhISh0aGlzLmJ1ZmZlcltqXSAmICgxMjggPj4gKGkgJSA4KSkpO1xyXG59O1xyXG5cclxuQml0RmllbGQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGIpe1xyXG5cdHZhciBqID0gaSA+PiAzO1xyXG5cdGlmIChiIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEpe1xyXG5cdFx0aWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IGogKyAxKSB0aGlzLl9ncm93KE1hdGgubWF4KGogKyAxLCBNYXRoLm1pbigyICogdGhpcy5idWZmZXIubGVuZ3RoLCB0aGlzLmdyb3cpKSk7XHJcblx0XHQvLyBTZXRcclxuXHRcdHRoaXMuYnVmZmVyW2pdIHw9IDEyOCA+PiAoaSAlIDgpO1xyXG5cdH0gZWxzZSBpZiAoaiA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xyXG5cdFx0Ly8vIENsZWFyXHJcblx0XHR0aGlzLmJ1ZmZlcltqXSAmPSB+KDEyOCA+PiAoaSAlIDgpKTtcclxuXHR9XHJcbn07XHJcblxyXG5CaXRGaWVsZC5wcm90b3R5cGUuX2dyb3cgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgbGVuZ3RoICYmIGxlbmd0aCA8PSB0aGlzLmdyb3cpIHtcclxuXHRcdHZhciBuZXdCdWZmZXIgPSBuZXcgQ29udGFpbmVyKGxlbmd0aCk7XHJcblx0XHRpZiAobmV3QnVmZmVyLmZpbGwpIG5ld0J1ZmZlci5maWxsKDApO1xyXG5cdFx0aWYgKHRoaXMuYnVmZmVyLmNvcHkpIHRoaXMuYnVmZmVyLmNvcHkobmV3QnVmZmVyLCAwKTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRuZXdCdWZmZXJbaV0gPSB0aGlzLmJ1ZmZlcltpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0fVxyXG59O1xyXG5cclxuaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlLmV4cG9ydHMgPSBCaXRGaWVsZDtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBXaXJlXG5cbnZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgQml0RmllbGQgPSByZXF1aXJlKCdiaXRmaWVsZCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2JpdHRvcnJlbnQtcHJvdG9jb2wnKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNwZWVkb21ldGVyID0gcmVxdWlyZSgnc3BlZWRvbWV0ZXInKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciBCSVRGSUVMRF9HUk9XID0gNDAwMDAwXG52YXIgS0VFUF9BTElWRV9USU1FT1VUID0gNTUwMDBcblxudmFyIE1FU1NBR0VfUFJPVE9DT0wgPSBCdWZmZXIuZnJvbSgnXFx1MDAxM0JpdFRvcnJlbnQgcHJvdG9jb2wnKVxudmFyIE1FU1NBR0VfS0VFUF9BTElWRSA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAwXSlcbnZhciBNRVNTQUdFX0NIT0tFID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDBdKVxudmFyIE1FU1NBR0VfVU5DSE9LRSA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAxXSlcbnZhciBNRVNTQUdFX0lOVEVSRVNURUQgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMl0pXG52YXIgTUVTU0FHRV9VTklOVEVSRVNURUQgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwM10pXG5cbnZhciBNRVNTQUdFX1JFU0VSVkVEID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdXG52YXIgTUVTU0FHRV9QT1JUID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIDB4MDksIDB4MDAsIDB4MDBdXG5cbmZ1bmN0aW9uIFJlcXVlc3QgKHBpZWNlLCBvZmZzZXQsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgdGhpcy5waWVjZSA9IHBpZWNlXG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xufVxuXG5pbmhlcml0cyhXaXJlLCBzdHJlYW0uRHVwbGV4KVxuXG5mdW5jdGlvbiBXaXJlICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdpcmUpKSByZXR1cm4gbmV3IFdpcmUoKVxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcylcblxuICB0aGlzLl9kZWJ1Z0lkID0gaGF0KDMyKVxuICB0aGlzLl9kZWJ1ZygnbmV3IHdpcmUnKVxuXG4gIHRoaXMucGVlcklkID0gbnVsbCAvLyByZW1vdGUgcGVlciBpZCAoaGV4IHN0cmluZylcbiAgdGhpcy5wZWVySWRCdWZmZXIgPSBudWxsIC8vIHJlbW90ZSBwZWVyIGlkIChidWZmZXIpXG4gIHRoaXMudHlwZSA9IG51bGwgLy8gY29ubmVjdGlvbiB0eXBlICgnd2VicnRjJywgJ3RjcEluY29taW5nJywgJ3RjcE91dGdvaW5nJywgJ3dlYlNlZWQnKVxuXG4gIHRoaXMuYW1DaG9raW5nID0gdHJ1ZSAvLyBhcmUgd2UgY2hva2luZyB0aGUgcGVlcj9cbiAgdGhpcy5hbUludGVyZXN0ZWQgPSBmYWxzZSAvLyBhcmUgd2UgaW50ZXJlc3RlZCBpbiB0aGUgcGVlcj9cblxuICB0aGlzLnBlZXJDaG9raW5nID0gdHJ1ZSAvLyBpcyB0aGUgcGVlciBjaG9raW5nIHVzP1xuICB0aGlzLnBlZXJJbnRlcmVzdGVkID0gZmFsc2UgLy8gaXMgdGhlIHBlZXIgaW50ZXJlc3RlZCBpbiB1cz9cblxuICAvLyBUaGUgbGFyZ2VzdCB0b3JyZW50IHRoYXQgSSBrbm93IG9mICh0aGUgR2VvY2l0aWVzIGFyY2hpdmUpIGlzIH42NDEgR0IgYW5kIGhhc1xuICAvLyB+NDEsMDAwIHBpZWNlcy4gVGhlcmVmb3JlLCBjYXAgYml0ZmllbGQgdG8gMTB4IGxhcmdlciAoNDAwLDAwMCBiaXRzKSB0byBzdXBwb3J0IGFsbFxuICAvLyBwb3NzaWJsZSB0b3JyZW50cyBidXQgcHJldmVudCBtYWxpY2lvdXMgcGVlcnMgZnJvbSBncm93aW5nIGJpdGZpZWxkIHRvIGZpbGwgbWVtb3J5LlxuICB0aGlzLnBlZXJQaWVjZXMgPSBuZXcgQml0RmllbGQoMCwgeyBncm93OiBCSVRGSUVMRF9HUk9XIH0pXG5cbiAgdGhpcy5wZWVyRXh0ZW5zaW9ucyA9IHt9XG5cbiAgdGhpcy5yZXF1ZXN0cyA9IFtdIC8vIG91dGdvaW5nXG4gIHRoaXMucGVlclJlcXVlc3RzID0gW10gLy8gaW5jb21pbmdcblxuICB0aGlzLmV4dGVuZGVkTWFwcGluZyA9IHt9IC8vIG51bWJlciAtPiBzdHJpbmcsIGV4OiAxIC0+ICd1dF9tZXRhZGF0YSdcbiAgdGhpcy5wZWVyRXh0ZW5kZWRNYXBwaW5nID0ge30gLy8gc3RyaW5nIC0+IG51bWJlciwgZXg6IDkgLT4gJ3V0X21ldGFkYXRhJ1xuXG4gIC8vIFRoZSBleHRlbmRlZCBoYW5kc2hha2UgdG8gc2VuZCwgbWludXMgdGhlIFwibVwiIGZpZWxkLCB3aGljaCBnZXRzIGF1dG9tYXRpY2FsbHlcbiAgLy8gZmlsbGVkIGZyb20gYHRoaXMuZXh0ZW5kZWRNYXBwaW5nYFxuICB0aGlzLmV4dGVuZGVkSGFuZHNoYWtlID0ge31cblxuICB0aGlzLnBlZXJFeHRlbmRlZEhhbmRzaGFrZSA9IHt9IC8vIHJlbW90ZSBwZWVyJ3MgZXh0ZW5kZWQgaGFuZHNoYWtlXG5cbiAgdGhpcy5fZXh0ID0ge30gIC8vIHN0cmluZyAtPiBmdW5jdGlvbiwgZXggJ3V0X21ldGFkYXRhJyAtPiB1dF9tZXRhZGF0YSgpXG4gIHRoaXMuX25leHRFeHQgPSAxXG5cbiAgdGhpcy51cGxvYWRlZCA9IDBcbiAgdGhpcy5kb3dubG9hZGVkID0gMFxuICB0aGlzLnVwbG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuICB0aGlzLmRvd25sb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG5cbiAgdGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwgPSBudWxsXG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gIHRoaXMuX3RpbWVvdXRNcyA9IDBcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlIC8vIHdhcyB0aGUgd2lyZSBlbmRlZCBieSBjYWxsaW5nIGBkZXN0cm95YD9cbiAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZVxuXG4gIHRoaXMuX3BhcnNlclNpemUgPSAwIC8vIG51bWJlciBvZiBuZWVkZWQgYnl0ZXMgdG8gcGFyc2UgbmV4dCBtZXNzYWdlIGZyb20gcmVtb3RlIHBlZXJcbiAgdGhpcy5fcGFyc2VyID0gbnVsbCAvLyBmdW5jdGlvbiB0byBjYWxsIG9uY2UgYHRoaXMuX3BhcnNlclNpemVgIGJ5dGVzIGFyZSBhdmFpbGFibGVcblxuICB0aGlzLl9idWZmZXIgPSBbXSAvLyBpbmNvbXBsZXRlIG1lc3NhZ2UgZGF0YVxuICB0aGlzLl9idWZmZXJTaXplID0gMCAvLyBjYWNoZWQgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gYHRoaXMuX2J1ZmZlcmBcblxuICB0aGlzLm9uKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaClcblxuICB0aGlzLl9wYXJzZUhhbmRzaGFrZSgpXG59XG5cbi8qKlxuICogU2V0IHdoZXRoZXIgdG8gc2VuZCBhIFwia2VlcC1hbGl2ZVwiIHBpbmcgKHNlbnQgZXZlcnkgNTVzKVxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVcbiAqL1xuV2lyZS5wcm90b3R5cGUuc2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVidWcoJ3NldEtlZXBBbGl2ZSAlcycsIGVuYWJsZSlcbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9rZWVwQWxpdmVJbnRlcnZhbClcbiAgaWYgKGVuYWJsZSA9PT0gZmFsc2UpIHJldHVyblxuICBzZWxmLl9rZWVwQWxpdmVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmtlZXBBbGl2ZSgpXG4gIH0sIEtFRVBfQUxJVkVfVElNRU9VVClcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGNvbnNpZGVyaW5nIGEgcmVxdWVzdCB0byBiZSBcInRpbWVkIG91dFwiXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVucmVmIChzaG91bGQgdGhlIHRpbWVyIGJlIHVucmVmJ2Q/IGRlZmF1bHQ6IGZhbHNlKVxuICovXG5XaXJlLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKG1zLCB1bnJlZikge1xuICB0aGlzLl9kZWJ1Zygnc2V0VGltZW91dCBtcz0lZCB1bnJlZj0lcycsIG1zLCB1bnJlZilcbiAgdGhpcy5fY2xlYXJUaW1lb3V0KClcbiAgdGhpcy5fdGltZW91dE1zID0gbXNcbiAgdGhpcy5fdGltZW91dFVucmVmID0gISF1bnJlZlxuICB0aGlzLl91cGRhdGVUaW1lb3V0KClcbn1cblxuV2lyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2RlYnVnKCdkZXN0cm95JylcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG4gIHRoaXMuZW5kKClcbn1cblxuV2lyZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kZWJ1ZygnZW5kJylcbiAgdGhpcy5fb25VbmludGVyZXN0ZWQoKVxuICB0aGlzLl9vbkNob2tlKClcbiAgc3RyZWFtLkR1cGxleC5wcm90b3R5cGUuZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuLyoqXG4gKiBVc2UgdGhlIHNwZWNpZmllZCBwcm90b2NvbCBleHRlbnNpb24uXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gRXh0ZW5zaW9uXG4gKi9cbldpcmUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChFeHRlbnNpb24pIHtcbiAgdmFyIG5hbWUgPSBFeHRlbnNpb24ucHJvdG90eXBlLm5hbWVcbiAgaWYgKCFuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gY2xhc3MgcmVxdWlyZXMgYSBcIm5hbWVcIiBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlJylcbiAgfVxuICB0aGlzLl9kZWJ1ZygndXNlIGV4dGVuc2lvbi5uYW1lPSVzJywgbmFtZSlcblxuICB2YXIgZXh0ID0gdGhpcy5fbmV4dEV4dFxuICB2YXIgaGFuZGxlciA9IG5ldyBFeHRlbnNpb24odGhpcylcblxuICBmdW5jdGlvbiBub29wICgpIHt9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uSGFuZHNoYWtlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlci5vbkhhbmRzaGFrZSA9IG5vb3BcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIub25FeHRlbmRlZEhhbmRzaGFrZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGhhbmRsZXIub25FeHRlbmRlZEhhbmRzaGFrZSA9IG5vb3BcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIub25NZXNzYWdlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlci5vbk1lc3NhZ2UgPSBub29wXG4gIH1cblxuICB0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdID0gbmFtZVxuICB0aGlzLl9leHRbbmFtZV0gPSBoYW5kbGVyXG4gIHRoaXNbbmFtZV0gPSBoYW5kbGVyXG5cbiAgdGhpcy5fbmV4dEV4dCArPSAxXG59XG5cbi8vXG4vLyBPVVRHT0lORyBNRVNTQUdFU1xuLy9cblxuLyoqXG4gKiBNZXNzYWdlIFwia2VlcC1hbGl2ZVwiOiA8bGVuPTAwMDA+XG4gKi9cbldpcmUucHJvdG90eXBlLmtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ2tlZXAtYWxpdmUnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfS0VFUF9BTElWRSlcbn1cblxuLyoqXG4gKiBNZXNzYWdlOiBcImhhbmRzaGFrZVwiIDxwc3RybGVuPjxwc3RyPjxyZXNlcnZlZD48aW5mb19oYXNoPjxwZWVyX2lkPlxuICogQHBhcmFtICB7QnVmZmVyfHN0cmluZ30gaW5mb0hhc2ggKGFzIEJ1ZmZlciBvciAqaGV4KiBzdHJpbmcpXG4gKiBAcGFyYW0gIHtCdWZmZXJ8c3RyaW5nfSBwZWVySWRcbiAqIEBwYXJhbSAge09iamVjdH0gZXh0ZW5zaW9uc1xuICovXG5XaXJlLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucykge1xuICB2YXIgaW5mb0hhc2hCdWZmZXIsIHBlZXJJZEJ1ZmZlclxuICBpZiAodHlwZW9mIGluZm9IYXNoID09PSAnc3RyaW5nJykge1xuICAgIGluZm9IYXNoQnVmZmVyID0gQnVmZmVyLmZyb20oaW5mb0hhc2gsICdoZXgnKVxuICB9IGVsc2Uge1xuICAgIGluZm9IYXNoQnVmZmVyID0gaW5mb0hhc2hcbiAgICBpbmZvSGFzaCA9IGluZm9IYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICB9XG4gIGlmICh0eXBlb2YgcGVlcklkID09PSAnc3RyaW5nJykge1xuICAgIHBlZXJJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBlZXJJZCwgJ2hleCcpXG4gIH0gZWxzZSB7XG4gICAgcGVlcklkQnVmZmVyID0gcGVlcklkXG4gICAgcGVlcklkID0gcGVlcklkQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICB9XG5cbiAgaWYgKGluZm9IYXNoQnVmZmVyLmxlbmd0aCAhPT0gMjAgfHwgcGVlcklkQnVmZmVyLmxlbmd0aCAhPT0gMjApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZm9IYXNoIGFuZCBwZWVySWQgTVVTVCBoYXZlIGxlbmd0aCAyMCcpXG4gIH1cblxuICB0aGlzLl9kZWJ1ZygnaGFuZHNoYWtlIGk9JXMgcD0lcyBleHRzPSVvJywgaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucylcblxuICB2YXIgcmVzZXJ2ZWQgPSBCdWZmZXIuZnJvbShNRVNTQUdFX1JFU0VSVkVEKVxuXG4gIC8vIGVuYWJsZSBleHRlbmRlZCBtZXNzYWdlXG4gIHJlc2VydmVkWzVdIHw9IDB4MTBcblxuICBpZiAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmRodCkgcmVzZXJ2ZWRbN10gfD0gMVxuXG4gIHRoaXMuX3B1c2goQnVmZmVyLmNvbmNhdChbTUVTU0FHRV9QUk9UT0NPTCwgcmVzZXJ2ZWQsIGluZm9IYXNoQnVmZmVyLCBwZWVySWRCdWZmZXJdKSlcbiAgdGhpcy5faGFuZHNoYWtlU2VudCA9IHRydWVcblxuICBpZiAodGhpcy5wZWVyRXh0ZW5zaW9ucy5leHRlbmRlZCAmJiAhdGhpcy5fZXh0ZW5kZWRIYW5kc2hha2VTZW50KSB7XG4gICAgLy8gUGVlcidzIGhhbmRzaGFrZSBpbmRpY2F0ZWQgc3VwcG9ydCBhbHJlYWR5XG4gICAgLy8gKGluY29taW5nIGNvbm5lY3Rpb24pXG4gICAgdGhpcy5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlKClcbiAgfVxufVxuXG4vKiBQZWVyIHN1cHBvcnRzIEJFUC0wMDEwLCBzZW5kIGV4dGVuZGVkIGhhbmRzaGFrZS5cbiAqXG4gKiBUaGlzIGNvbWVzIGFmdGVyIHRoZSAnaGFuZHNoYWtlJyBldmVudCB0byBnaXZlIHRoZSB1c2VyIGEgY2hhbmNlIHRvIHBvcHVsYXRlXG4gKiBgdGhpcy5leHRlbmRlZEhhbmRzaGFrZWAgYW5kIGB0aGlzLmV4dGVuZGVkTWFwcGluZ2AgYmVmb3JlIHRoZSBleHRlbmRlZCBoYW5kc2hha2VcbiAqIGlzIHNlbnQgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICovXG5XaXJlLnByb3RvdHlwZS5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlID0gZnVuY3Rpb24gKCkge1xuICAvLyBDcmVhdGUgZXh0ZW5kZWQgbWVzc2FnZSBvYmplY3QgZnJvbSByZWdpc3RlcmVkIGV4dGVuc2lvbnNcbiAgdmFyIG1zZyA9IGV4dGVuZCh0aGlzLmV4dGVuZGVkSGFuZHNoYWtlKVxuICBtc2cubSA9IHt9XG4gIGZvciAodmFyIGV4dCBpbiB0aGlzLmV4dGVuZGVkTWFwcGluZykge1xuICAgIHZhciBuYW1lID0gdGhpcy5leHRlbmRlZE1hcHBpbmdbZXh0XVxuICAgIG1zZy5tW25hbWVdID0gTnVtYmVyKGV4dClcbiAgfVxuXG4gIC8vIFNlbmQgZXh0ZW5kZWQgaGFuZHNoYWtlXG4gIHRoaXMuZXh0ZW5kZWQoMCwgYmVuY29kZS5lbmNvZGUobXNnKSlcbiAgdGhpcy5fZXh0ZW5kZWRIYW5kc2hha2VTZW50ID0gdHJ1ZVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJjaG9rZVwiOiA8bGVuPTAwMDE+PGlkPTA+XG4gKi9cbldpcmUucHJvdG90eXBlLmNob2tlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbUNob2tpbmcpIHJldHVyblxuICB0aGlzLmFtQ2hva2luZyA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2Nob2tlJylcbiAgdGhpcy5wZWVyUmVxdWVzdHMuc3BsaWNlKDAsIHRoaXMucGVlclJlcXVlc3RzLmxlbmd0aClcbiAgdGhpcy5fcHVzaChNRVNTQUdFX0NIT0tFKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJ1bmNob2tlXCI6IDxsZW49MDAwMT48aWQ9MT5cbiAqL1xuV2lyZS5wcm90b3R5cGUudW5jaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmFtQ2hva2luZykgcmV0dXJuXG4gIHRoaXMuYW1DaG9raW5nID0gZmFsc2VcbiAgdGhpcy5fZGVidWcoJ3VuY2hva2UnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfVU5DSE9LRSlcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwiaW50ZXJlc3RlZFwiOiA8bGVuPTAwMDE+PGlkPTI+XG4gKi9cbldpcmUucHJvdG90eXBlLmludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFtSW50ZXJlc3RlZCkgcmV0dXJuXG4gIHRoaXMuYW1JbnRlcmVzdGVkID0gdHJ1ZVxuICB0aGlzLl9kZWJ1ZygnaW50ZXJlc3RlZCcpXG4gIHRoaXMuX3B1c2goTUVTU0FHRV9JTlRFUkVTVEVEKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJ1bmludGVyZXN0ZWRcIjogPGxlbj0wMDAxPjxpZD0zPlxuICovXG5XaXJlLnByb3RvdHlwZS51bmludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5hbUludGVyZXN0ZWQpIHJldHVyblxuICB0aGlzLmFtSW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCd1bmludGVyZXN0ZWQnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfVU5JTlRFUkVTVEVEKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJoYXZlXCI6IDxsZW49MDAwNT48aWQ9ND48cGllY2UgaW5kZXg+XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKi9cbldpcmUucHJvdG90eXBlLmhhdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdGhpcy5fZGVidWcoJ2hhdmUgJWQnLCBpbmRleClcbiAgdGhpcy5fbWVzc2FnZSg0LCBbaW5kZXhdLCBudWxsKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJiaXRmaWVsZFwiOiA8bGVuPTAwMDErWD48aWQ9NT48Yml0ZmllbGQ+XG4gKiBAcGFyYW0gIHtCaXRGaWVsZHxCdWZmZXJ9IGJpdGZpZWxkXG4gKi9cbldpcmUucHJvdG90eXBlLmJpdGZpZWxkID0gZnVuY3Rpb24gKGJpdGZpZWxkKSB7XG4gIHRoaXMuX2RlYnVnKCdiaXRmaWVsZCcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJpdGZpZWxkKSkgYml0ZmllbGQgPSBiaXRmaWVsZC5idWZmZXJcbiAgdGhpcy5fbWVzc2FnZSg1LCBbXSwgYml0ZmllbGQpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcInJlcXVlc3RcIjogPGxlbj0wMDEzPjxpZD02PjxpbmRleD48YmVnaW4+PGxlbmd0aD5cbiAqIEBwYXJhbSAge251bWJlcn0gICBpbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSAgIG9mZnNldFxuICogQHBhcmFtICB7bnVtYmVyfSAgIGxlbmd0aFxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldpcmUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IGZ1bmN0aW9uICgpIHt9XG4gIGlmICh0aGlzLl9maW5pc2hlZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignd2lyZSBpcyBjbG9zZWQnKSlcbiAgaWYgKHRoaXMucGVlckNob2tpbmcpIHJldHVybiBjYihuZXcgRXJyb3IoJ3BlZXIgaXMgY2hva2luZycpKVxuXG4gIHRoaXMuX2RlYnVnKCdyZXF1ZXN0IGluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQnLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgdGhpcy5yZXF1ZXN0cy5wdXNoKG5ldyBSZXF1ZXN0KGluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2IpKVxuICB0aGlzLl91cGRhdGVUaW1lb3V0KClcbiAgdGhpcy5fbWVzc2FnZSg2LCBbaW5kZXgsIG9mZnNldCwgbGVuZ3RoXSwgbnVsbClcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwicGllY2VcIjogPGxlbj0wMDA5K1g+PGlkPTc+PGluZGV4PjxiZWdpbj48YmxvY2s+XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtICB7QnVmZmVyfSBidWZmZXJcbiAqL1xuV2lyZS5wcm90b3R5cGUucGllY2UgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgYnVmZmVyKSB7XG4gIHRoaXMuX2RlYnVnKCdwaWVjZSBpbmRleD0lZCBvZmZzZXQ9JWQnLCBpbmRleCwgb2Zmc2V0KVxuICB0aGlzLnVwbG9hZGVkICs9IGJ1ZmZlci5sZW5ndGhcbiAgdGhpcy51cGxvYWRTcGVlZChidWZmZXIubGVuZ3RoKVxuICB0aGlzLmVtaXQoJ3VwbG9hZCcsIGJ1ZmZlci5sZW5ndGgpXG4gIHRoaXMuX21lc3NhZ2UoNywgW2luZGV4LCBvZmZzZXRdLCBidWZmZXIpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcImNhbmNlbFwiOiA8bGVuPTAwMTM+PGlkPTg+PGluZGV4PjxiZWdpbj48bGVuZ3RoPlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSAge251bWJlcn0gbGVuZ3RoXG4gKi9cbldpcmUucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdGhpcy5fZGVidWcoJ2NhbmNlbCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICB0aGlzLl9jYWxsYmFjayhcbiAgICBwdWxsKHRoaXMucmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGxlbmd0aCksXG4gICAgbmV3IEVycm9yKCdyZXF1ZXN0IHdhcyBjYW5jZWxsZWQnKSxcbiAgICBudWxsXG4gIClcbiAgdGhpcy5fbWVzc2FnZSg4LCBbaW5kZXgsIG9mZnNldCwgbGVuZ3RoXSwgbnVsbClcbn1cblxuLyoqXG4gKiBNZXNzYWdlOiBcInBvcnRcIiA8bGVuPTAwMDM+PGlkPTk+PGxpc3Rlbi1wb3J0PlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcnRcbiAqL1xuV2lyZS5wcm90b3R5cGUucG9ydCA9IGZ1bmN0aW9uIChwb3J0KSB7XG4gIHRoaXMuX2RlYnVnKCdwb3J0ICVkJywgcG9ydClcbiAgdmFyIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShNRVNTQUdFX1BPUlQpXG4gIG1lc3NhZ2Uud3JpdGVVSW50MTZCRShwb3J0LCA1KVxuICB0aGlzLl9wdXNoKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogTWVzc2FnZTogXCJleHRlbmRlZFwiIDxsZW49MDAwNStYPjxpZD0yMD48ZXh0LW51bWJlcj48cGF5bG9hZD5cbiAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IGV4dFxuICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAqL1xuV2lyZS5wcm90b3R5cGUuZXh0ZW5kZWQgPSBmdW5jdGlvbiAoZXh0LCBvYmopIHtcbiAgdGhpcy5fZGVidWcoJ2V4dGVuZGVkIGV4dD0lcycsIGV4dClcbiAgaWYgKHR5cGVvZiBleHQgPT09ICdzdHJpbmcnICYmIHRoaXMucGVlckV4dGVuZGVkTWFwcGluZ1tleHRdKSB7XG4gICAgZXh0ID0gdGhpcy5wZWVyRXh0ZW5kZWRNYXBwaW5nW2V4dF1cbiAgfVxuICBpZiAodHlwZW9mIGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZXh0SWQgPSBCdWZmZXIuZnJvbShbZXh0XSlcbiAgICB2YXIgYnVmID0gQnVmZmVyLmlzQnVmZmVyKG9iaikgPyBvYmogOiBiZW5jb2RlLmVuY29kZShvYmopXG5cbiAgICB0aGlzLl9tZXNzYWdlKDIwLCBbXSwgQnVmZmVyLmNvbmNhdChbZXh0SWQsIGJ1Zl0pKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGV4dGVuc2lvbjogJyArIGV4dClcbiAgfVxufVxuXG4vKipcbiAqIER1cGxleCBzdHJlYW0gbWV0aG9kLiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHJlbW90ZSBwZWVyIHN0cmVhbSB3YW50cyBkYXRhLiBOby1vcFxuICogc2luY2Ugd2UnbGwganVzdCBwdXNoIGRhdGEgd2hlbmV2ZXIgd2UgZ2V0IGl0LlxuICovXG5XaXJlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICovXG5XaXJlLnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uIChpZCwgbnVtYmVycywgZGF0YSkge1xuICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEgPyBkYXRhLmxlbmd0aCA6IDBcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg1ICsgNCAqIG51bWJlcnMubGVuZ3RoKVxuXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGJ1ZmZlci5sZW5ndGggKyBkYXRhTGVuZ3RoIC0gNCwgMClcbiAgYnVmZmVyWzRdID0gaWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUobnVtYmVyc1tpXSwgNSArIDQgKiBpKVxuICB9XG5cbiAgdGhpcy5fcHVzaChidWZmZXIpXG4gIGlmIChkYXRhKSB0aGlzLl9wdXNoKGRhdGEpXG59XG5cbldpcmUucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm5cbiAgcmV0dXJuIHRoaXMucHVzaChkYXRhKVxufVxuXG4vL1xuLy8gSU5DT01JTkcgTUVTU0FHRVNcbi8vXG5cbldpcmUucHJvdG90eXBlLl9vbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBrZWVwLWFsaXZlJylcbiAgdGhpcy5lbWl0KCdrZWVwLWFsaXZlJylcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGluZm9IYXNoQnVmZmVyLCBwZWVySWRCdWZmZXIsIGV4dGVuc2lvbnMpIHtcbiAgdmFyIGluZm9IYXNoID0gaW5mb0hhc2hCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG4gIHZhciBwZWVySWQgPSBwZWVySWRCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG5cbiAgdGhpcy5fZGVidWcoJ2dvdCBoYW5kc2hha2UgaT0lcyBwPSVzIGV4dHM9JW8nLCBpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuXG4gIHRoaXMucGVlcklkID0gcGVlcklkXG4gIHRoaXMucGVlcklkQnVmZmVyID0gcGVlcklkQnVmZmVyXG4gIHRoaXMucGVlckV4dGVuc2lvbnMgPSBleHRlbnNpb25zXG5cbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuXG4gIHZhciBuYW1lXG4gIGZvciAobmFtZSBpbiB0aGlzLl9leHQpIHtcbiAgICB0aGlzLl9leHRbbmFtZV0ub25IYW5kc2hha2UoaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucylcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLmV4dGVuZGVkICYmIHRoaXMuX2hhbmRzaGFrZVNlbnQgJiZcbiAgICAgICF0aGlzLl9leHRlbmRlZEhhbmRzaGFrZVNlbnQpIHtcbiAgICAvLyBvdXRnb2luZyBjb25uZWN0aW9uXG4gICAgdGhpcy5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlKClcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25DaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVyQ2hva2luZyA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2dvdCBjaG9rZScpXG4gIHRoaXMuZW1pdCgnY2hva2UnKVxuICB3aGlsZSAodGhpcy5yZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLnJlcXVlc3RzLnNoaWZ0KCksIG5ldyBFcnJvcigncGVlciBpcyBjaG9raW5nJyksIG51bGwpXG4gIH1cbn1cblxuV2lyZS5wcm90b3R5cGUuX29uVW5jaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVyQ2hva2luZyA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCdnb3QgdW5jaG9rZScpXG4gIHRoaXMuZW1pdCgndW5jaG9rZScpXG59XG5cbldpcmUucHJvdG90eXBlLl9vbkludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGVlckludGVyZXN0ZWQgPSB0cnVlXG4gIHRoaXMuX2RlYnVnKCdnb3QgaW50ZXJlc3RlZCcpXG4gIHRoaXMuZW1pdCgnaW50ZXJlc3RlZCcpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblVuaW50ZXJlc3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVySW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCdnb3QgdW5pbnRlcmVzdGVkJylcbiAgdGhpcy5lbWl0KCd1bmludGVyZXN0ZWQnKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25IYXZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIGlmICh0aGlzLnBlZXJQaWVjZXMuZ2V0KGluZGV4KSkgcmV0dXJuXG4gIHRoaXMuX2RlYnVnKCdnb3QgaGF2ZSAlZCcsIGluZGV4KVxuXG4gIHRoaXMucGVlclBpZWNlcy5zZXQoaW5kZXgsIHRydWUpXG4gIHRoaXMuZW1pdCgnaGF2ZScsIGluZGV4KVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25CaXRGaWVsZCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5wZWVyUGllY2VzID0gbmV3IEJpdEZpZWxkKGJ1ZmZlcilcbiAgdGhpcy5fZGVidWcoJ2dvdCBiaXRmaWVsZCcpXG4gIHRoaXMuZW1pdCgnYml0ZmllbGQnLCB0aGlzLnBlZXJQaWVjZXMpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblJlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5hbUNob2tpbmcpIHJldHVyblxuICBzZWxmLl9kZWJ1ZygnZ290IHJlcXVlc3QgaW5kZXg9JWQgb2Zmc2V0PSVkIGxlbmd0aD0lZCcsIGluZGV4LCBvZmZzZXQsIGxlbmd0aClcblxuICB2YXIgcmVzcG9uZCA9IGZ1bmN0aW9uIChlcnIsIGJ1ZmZlcikge1xuICAgIGlmIChyZXF1ZXN0ICE9PSBwdWxsKHNlbGYucGVlclJlcXVlc3RzLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpKSByZXR1cm5cbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVidWcoJ2Vycm9yIHNhdGlzZnlpbmcgcmVxdWVzdCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkICglcyknLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGVyci5tZXNzYWdlKVxuICAgIHNlbGYucGllY2UoaW5kZXgsIG9mZnNldCwgYnVmZmVyKVxuICB9XG5cbiAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIHJlc3BvbmQpXG4gIHNlbGYucGVlclJlcXVlc3RzLnB1c2gocmVxdWVzdClcbiAgc2VsZi5lbWl0KCdyZXF1ZXN0JywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCByZXNwb25kKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25QaWVjZSA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBidWZmZXIpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBwaWVjZSBpbmRleD0lZCBvZmZzZXQ9JWQnLCBpbmRleCwgb2Zmc2V0KVxuICB0aGlzLl9jYWxsYmFjayhwdWxsKHRoaXMucmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGJ1ZmZlci5sZW5ndGgpLCBudWxsLCBidWZmZXIpXG4gIHRoaXMuZG93bmxvYWRlZCArPSBidWZmZXIubGVuZ3RoXG4gIHRoaXMuZG93bmxvYWRTcGVlZChidWZmZXIubGVuZ3RoKVxuICB0aGlzLmVtaXQoJ2Rvd25sb2FkJywgYnVmZmVyLmxlbmd0aClcbiAgdGhpcy5lbWl0KCdwaWVjZScsIGluZGV4LCBvZmZzZXQsIGJ1ZmZlcilcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQsIGxlbmd0aCkge1xuICB0aGlzLl9kZWJ1ZygnZ290IGNhbmNlbCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICBwdWxsKHRoaXMucGVlclJlcXVlc3RzLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG4gIHRoaXMuZW1pdCgnY2FuY2VsJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25Qb3J0ID0gZnVuY3Rpb24gKHBvcnQpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBwb3J0ICVkJywgcG9ydClcbiAgdGhpcy5lbWl0KCdwb3J0JywgcG9ydClcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uRXh0ZW5kZWQgPSBmdW5jdGlvbiAoZXh0LCBidWYpIHtcbiAgaWYgKGV4dCA9PT0gMCkge1xuICAgIHZhciBpbmZvXG4gICAgdHJ5IHtcbiAgICAgIGluZm8gPSBiZW5jb2RlLmRlY29kZShidWYpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnaWdub3JpbmcgaW52YWxpZCBleHRlbmRlZCBoYW5kc2hha2U6ICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICAgIH1cblxuICAgIGlmICghaW5mbykgcmV0dXJuXG4gICAgdGhpcy5wZWVyRXh0ZW5kZWRIYW5kc2hha2UgPSBpbmZvXG5cbiAgICB2YXIgbmFtZVxuICAgIGlmICh0eXBlb2YgaW5mby5tID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChuYW1lIGluIGluZm8ubSkge1xuICAgICAgICB0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmdbbmFtZV0gPSBOdW1iZXIoaW5mby5tW25hbWVdLnRvU3RyaW5nKCkpXG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiB0aGlzLl9leHQpIHtcbiAgICAgIGlmICh0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmdbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5fZXh0W25hbWVdLm9uRXh0ZW5kZWRIYW5kc2hha2UodGhpcy5wZWVyRXh0ZW5kZWRIYW5kc2hha2UpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RlYnVnKCdnb3QgZXh0ZW5kZWQgaGFuZHNoYWtlJylcbiAgICB0aGlzLmVtaXQoJ2V4dGVuZGVkJywgJ2hhbmRzaGFrZScsIHRoaXMucGVlckV4dGVuZGVkSGFuZHNoYWtlKVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdKSB7XG4gICAgICBleHQgPSB0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdIC8vIGZyaWVuZGx5IG5hbWUgZm9yIGV4dGVuc2lvblxuICAgICAgaWYgKHRoaXMuX2V4dFtleHRdKSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIGFuIHJlZ2lzdGVyZWQgZXh0ZW5zaW9uIGhhbmRsZXIsIHNvIGNhbGwgaXRcbiAgICAgICAgdGhpcy5fZXh0W2V4dF0ub25NZXNzYWdlKGJ1ZilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGVidWcoJ2dvdCBleHRlbmRlZCBtZXNzYWdlIGV4dD0lcycsIGV4dClcbiAgICB0aGlzLmVtaXQoJ2V4dGVuZGVkJywgZXh0LCBidWYpXG4gIH1cbn1cblxuV2lyZS5wcm90b3R5cGUuX29uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ3JlcXVlc3QgdGltZWQgb3V0JylcbiAgdGhpcy5fY2FsbGJhY2sodGhpcy5yZXF1ZXN0cy5zaGlmdCgpLCBuZXcgRXJyb3IoJ3JlcXVlc3QgaGFzIHRpbWVkIG91dCcpLCBudWxsKVxuICB0aGlzLmVtaXQoJ3RpbWVvdXQnKVxufVxuXG4vKipcbiAqIER1cGxleCBzdHJlYW0gbWV0aG9kLiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHJlbW90ZSBwZWVyIGhhcyBkYXRhIGZvciB1cy4gRGF0YSB0aGF0IHRoZVxuICogcmVtb3RlIHBlZXIgc2VuZHMgZ2V0cyBidWZmZXJlZCAoaS5lLiBub3QgYWN0dWFsbHkgcHJvY2Vzc2VkKSB1bnRpbCB0aGUgcmlnaHQgbnVtYmVyXG4gKiBvZiBieXRlcyBoYXZlIGFycml2ZWQsIGRldGVybWluZWQgYnkgdGhlIGxhc3QgY2FsbCB0byBgdGhpcy5fcGFyc2UobnVtYmVyLCBjYWxsYmFjaylgLlxuICogT25jZSBlbm91Z2ggYnl0ZXMgaGF2ZSBhcnJpdmVkIHRvIHByb2Nlc3MgdGhlIG1lc3NhZ2UsIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICogKGkuZS4gYHRoaXMuX3BhcnNlcmApIGdldHMgY2FsbGVkIHdpdGggdGhlIGZ1bGwgYnVmZmVyIG9mIGRhdGEuXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5XaXJlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuX2J1ZmZlclNpemUgKz0gZGF0YS5sZW5ndGhcbiAgdGhpcy5fYnVmZmVyLnB1c2goZGF0YSlcblxuICB3aGlsZSAodGhpcy5fYnVmZmVyU2l6ZSA+PSB0aGlzLl9wYXJzZXJTaXplKSB7XG4gICAgdmFyIGJ1ZmZlciA9ICh0aGlzLl9idWZmZXIubGVuZ3RoID09PSAxKVxuICAgICAgPyB0aGlzLl9idWZmZXJbMF1cbiAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXIpXG4gICAgdGhpcy5fYnVmZmVyU2l6ZSAtPSB0aGlzLl9wYXJzZXJTaXplXG4gICAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyU2l6ZVxuICAgICAgPyBbYnVmZmVyLnNsaWNlKHRoaXMuX3BhcnNlclNpemUpXVxuICAgICAgOiBbXVxuICAgIHRoaXMuX3BhcnNlcihidWZmZXIuc2xpY2UoMCwgdGhpcy5fcGFyc2VyU2l6ZSkpXG4gIH1cblxuICBjYihudWxsKSAvLyBTaWduYWwgdGhhdCB3ZSdyZSByZWFkeSBmb3IgbW9yZSBkYXRhXG59XG5cbldpcmUucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBlcnIsIGJ1ZmZlcikge1xuICBpZiAoIXJlcXVlc3QpIHJldHVyblxuXG4gIHRoaXMuX2NsZWFyVGltZW91dCgpXG5cbiAgaWYgKCF0aGlzLnBlZXJDaG9raW5nICYmICF0aGlzLl9maW5pc2hlZCkgdGhpcy5fdXBkYXRlVGltZW91dCgpXG4gIHJlcXVlc3QuY2FsbGJhY2soZXJyLCBidWZmZXIpXG59XG5cbldpcmUucHJvdG90eXBlLl9jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fdGltZW91dCkgcmV0dXJuXG5cbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsXG59XG5cbldpcmUucHJvdG90eXBlLl91cGRhdGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl90aW1lb3V0TXMgfHwgIXNlbGYucmVxdWVzdHMubGVuZ3RoIHx8IHNlbGYuX3RpbWVvdXQpIHJldHVyblxuXG4gIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblRpbWVvdXQoKVxuICB9LCBzZWxmLl90aW1lb3V0TXMpXG4gIGlmIChzZWxmLl90aW1lb3V0VW5yZWYgJiYgc2VsZi5fdGltZW91dC51bnJlZikgc2VsZi5fdGltZW91dC51bnJlZigpXG59XG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgbG9jYWwgcGVlciBpcyB3YWl0aW5nIHRvIHJlY2VpdmUgZnJvbSB0aGUgcmVtb3RlIHBlZXJcbiAqIGluIG9yZGVyIHRvIHBhcnNlIGEgY29tcGxldGUgbWVzc2FnZSwgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgZW5vdWdoXG4gKiBieXRlcyBoYXZlIGFycml2ZWQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNpemVcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBwYXJzZXJcbiAqL1xuV2lyZS5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gKHNpemUsIHBhcnNlcikge1xuICB0aGlzLl9wYXJzZXJTaXplID0gc2l6ZVxuICB0aGlzLl9wYXJzZXIgPSBwYXJzZXJcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgYSBtZXNzYWdlLCB0byBkZXRlcm1pbmUgdGhlIGxlbmd0aCBvZiBieXRlcyB0aGF0IG11c3QgYmVcbiAqIHdhaXRlZCBmb3IgaW4gb3JkZXIgdG8gaGF2ZSB0aGUgd2hvbGUgbWVzc2FnZS5cbiAqIEBwYXJhbSAge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbldpcmUucHJvdG90eXBlLl9vbk1lc3NhZ2VMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBidWZmZXIucmVhZFVJbnQzMkJFKDApXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fcGFyc2UobGVuZ3RoLCB0aGlzLl9vbk1lc3NhZ2UpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb25LZWVwQWxpdmUoKVxuICAgIHRoaXMuX3BhcnNlKDQsIHRoaXMuX29uTWVzc2FnZUxlbmd0aClcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBhIG1lc3NhZ2UgZnJvbSB0aGUgcmVtb3RlIHBlZXIuXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGJ1ZmZlclxuICovXG5XaXJlLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB0aGlzLl9wYXJzZSg0LCB0aGlzLl9vbk1lc3NhZ2VMZW5ndGgpXG4gIHN3aXRjaCAoYnVmZmVyWzBdKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRoaXMuX29uQ2hva2UoKVxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB0aGlzLl9vblVuY2hva2UoKVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB0aGlzLl9vbkludGVyZXN0ZWQoKVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB0aGlzLl9vblVuaW50ZXJlc3RlZCgpXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHRoaXMuX29uSGF2ZShidWZmZXIucmVhZFVJbnQzMkJFKDEpKVxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiB0aGlzLl9vbkJpdEZpZWxkKGJ1ZmZlci5zbGljZSgxKSlcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gdGhpcy5fb25SZXF1ZXN0KGJ1ZmZlci5yZWFkVUludDMyQkUoMSksXG4gICAgICAgICAgYnVmZmVyLnJlYWRVSW50MzJCRSg1KSwgYnVmZmVyLnJlYWRVSW50MzJCRSg5KSlcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaWVjZShidWZmZXIucmVhZFVJbnQzMkJFKDEpLFxuICAgICAgICAgIGJ1ZmZlci5yZWFkVUludDMyQkUoNSksIGJ1ZmZlci5zbGljZSg5KSlcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gdGhpcy5fb25DYW5jZWwoYnVmZmVyLnJlYWRVSW50MzJCRSgxKSxcbiAgICAgICAgICBidWZmZXIucmVhZFVJbnQzMkJFKDUpLCBidWZmZXIucmVhZFVJbnQzMkJFKDkpKVxuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiB0aGlzLl9vblBvcnQoYnVmZmVyLnJlYWRVSW50MTZCRSgxKSlcbiAgICBjYXNlIDIwOlxuICAgICAgcmV0dXJuIHRoaXMuX29uRXh0ZW5kZWQoYnVmZmVyLnJlYWRVSW50OCgxKSwgYnVmZmVyLnNsaWNlKDIpKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHVua25vd24gbWVzc2FnZScpXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCd1bmtub3dubWVzc2FnZScsIGJ1ZmZlcilcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fcGFyc2VIYW5kc2hha2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9wYXJzZSgxLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgdmFyIHBzdHJsZW4gPSBidWZmZXIucmVhZFVJbnQ4KDApXG4gICAgc2VsZi5fcGFyc2UocHN0cmxlbiArIDQ4LCBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBoYW5kc2hha2Uuc2xpY2UoMCwgcHN0cmxlbilcbiAgICAgIGlmIChwcm90b2NvbC50b1N0cmluZygpICE9PSAnQml0VG9ycmVudCBwcm90b2NvbCcpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ0Vycm9yOiB3aXJlIG5vdCBzcGVha2luZyBCaXRUb3JyZW50IHByb3RvY29sICglcyknLCBwcm90b2NvbC50b1N0cmluZygpKVxuICAgICAgICBzZWxmLmVuZCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaGFuZHNoYWtlID0gaGFuZHNoYWtlLnNsaWNlKHBzdHJsZW4pXG4gICAgICBzZWxmLl9vbkhhbmRzaGFrZShoYW5kc2hha2Uuc2xpY2UoOCwgMjgpLCBoYW5kc2hha2Uuc2xpY2UoMjgsIDQ4KSwge1xuICAgICAgICBkaHQ6ICEhKGhhbmRzaGFrZVs3XSAmIDB4MDEpLCAvLyBzZWUgYmVwXzAwMDVcbiAgICAgICAgZXh0ZW5kZWQ6ICEhKGhhbmRzaGFrZVs1XSAmIDB4MTApIC8vIHNlZSBiZXBfMDAxMFxuICAgICAgfSlcbiAgICAgIHNlbGYuX3BhcnNlKDQsIHNlbGYuX29uTWVzc2FnZUxlbmd0aClcbiAgICB9KVxuICB9KVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZVxuXG4gIHRoaXMucHVzaChudWxsKSAvLyBzdHJlYW0gY2Fubm90IGJlIGhhbGYgb3Blbiwgc28gc2lnbmFsIHRoZSBlbmQgb2YgaXRcbiAgd2hpbGUgKHRoaXMucmVhZCgpKSB7fSAvLyBjb25zdW1lIGFuZCBkaXNjYXJkIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0gZGF0YVxuXG4gIGNsZWFySW50ZXJ2YWwodGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwpXG4gIHRoaXMuX3BhcnNlKE51bWJlci5NQVhfVkFMVUUsIGZ1bmN0aW9uICgpIHt9KVxuICB0aGlzLnBlZXJSZXF1ZXN0cyA9IFtdXG4gIHdoaWxlICh0aGlzLnJlcXVlc3RzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMucmVxdWVzdHMuc2hpZnQoKSwgbmV3IEVycm9yKCd3aXJlIHdhcyBjbG9zZWQnKSwgbnVsbClcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIGFyZ3NbMF0gPSAnWycgKyB0aGlzLl9kZWJ1Z0lkICsgJ10gJyArIGFyZ3NbMF1cbiAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbn1cblxuZnVuY3Rpb24gcHVsbCAocmVxdWVzdHMsIHBpZWNlLCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlcSA9IHJlcXVlc3RzW2ldXG4gICAgaWYgKHJlcS5waWVjZSAhPT0gcGllY2UgfHwgcmVxLm9mZnNldCAhPT0gb2Zmc2V0IHx8IHJlcS5sZW5ndGggIT09IGxlbmd0aCkgY29udGludWVcblxuICAgIGlmIChpID09PSAwKSByZXF1ZXN0cy5zaGlmdCgpXG4gICAgZWxzZSByZXF1ZXN0cy5zcGxpY2UoaSwgMSlcblxuICAgIHJldHVybiByZXFcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXR0b3JyZW50LXRyYWNrZXInKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxudmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG52YXIgdW5pcSA9IHJlcXVpcmUoJ3VuaXEnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2xpYi9jb21tb24nKVxudmFyIEhUVFBUcmFja2VyID0gcmVxdWlyZSgnLi9saWIvY2xpZW50L2h0dHAtdHJhY2tlcicpIC8vIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG52YXIgVURQVHJhY2tlciA9IHJlcXVpcmUoJy4vbGliL2NsaWVudC91ZHAtdHJhY2tlcicpIC8vIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG52YXIgV2ViU29ja2V0VHJhY2tlciA9IHJlcXVpcmUoJy4vbGliL2NsaWVudC93ZWJzb2NrZXQtdHJhY2tlcicpXG5cbmluaGVyaXRzKENsaWVudCwgRXZlbnRFbWl0dGVyKVxuXG4vKipcbiAqIEJpdFRvcnJlbnQgdHJhY2tlciBjbGllbnQuXG4gKlxuICogRmluZCB0b3JyZW50IHBlZXJzLCB0byBoZWxwIGEgdG9ycmVudCBjbGllbnQgcGFydGljaXBhdGUgaW4gYSB0b3JyZW50IHN3YXJtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBvcHRzLmluZm9IYXNoICAgICAgICAgIHRvcnJlbnQgaW5mbyBoYXNoXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IG9wdHMucGVlcklkICAgICAgICAgICAgcGVlciBpZFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IG9wdHMuYW5ub3VuY2UgIGFubm91bmNlXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5wb3J0ICAgICAgICAgICAgICAgICAgICAgdG9ycmVudCBjbGllbnQgbGlzdGVuaW5nIHBvcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdHMuZ2V0QW5ub3VuY2VPcHRzICAgICAgICBjYWxsYmFjayB0byBwcm92aWRlIGRhdGEgdG8gdHJhY2tlclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucnRjQ29uZmlnICAgICAgICAgICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy53cnRjICAgICAgICAgICAgICAgICAgICAgY3VzdG9tIHdlYnJ0YyBpbXBsICh1c2VmdWwgaW4gbm9kZS5qcylcbiAqL1xuZnVuY3Rpb24gQ2xpZW50IChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgQ2xpZW50KSkgcmV0dXJuIG5ldyBDbGllbnQob3B0cylcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBpZiAoIW9wdHMucGVlcklkKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgcGVlcklkYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGluZm9IYXNoYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5hbm5vdW5jZSkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGFubm91bmNlYCBpcyByZXF1aXJlZCcpXG4gIGlmICghcHJvY2Vzcy5icm93c2VyICYmICFvcHRzLnBvcnQpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBwb3J0YCBpcyByZXF1aXJlZCcpXG5cbiAgLy8gcmVxdWlyZWRcbiAgc2VsZi5wZWVySWQgPSB0eXBlb2Ygb3B0cy5wZWVySWQgPT09ICdzdHJpbmcnXG4gICAgPyBvcHRzLnBlZXJJZFxuICAgIDogb3B0cy5wZWVySWQudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuX3BlZXJJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlbGYucGVlcklkLCAnaGV4JylcbiAgc2VsZi5fcGVlcklkQmluYXJ5ID0gc2VsZi5fcGVlcklkQnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKVxuXG4gIHNlbGYuaW5mb0hhc2ggPSB0eXBlb2Ygb3B0cy5pbmZvSGFzaCA9PT0gJ3N0cmluZydcbiAgICA/IG9wdHMuaW5mb0hhc2hcbiAgICA6IG9wdHMuaW5mb0hhc2gudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuX2luZm9IYXNoQnVmZmVyID0gQnVmZmVyLmZyb20oc2VsZi5pbmZvSGFzaCwgJ2hleCcpXG4gIHNlbGYuX2luZm9IYXNoQmluYXJ5ID0gc2VsZi5faW5mb0hhc2hCdWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpXG5cbiAgc2VsZi5fcG9ydCA9IG9wdHMucG9ydFxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBzZWxmLl9ydGNDb25maWcgPSBvcHRzLnJ0Y0NvbmZpZ1xuICBzZWxmLl93cnRjID0gb3B0cy53cnRjXG4gIHNlbGYuX2dldEFubm91bmNlT3B0cyA9IG9wdHMuZ2V0QW5ub3VuY2VPcHRzXG5cbiAgZGVidWcoJ25ldyBjbGllbnQgJXMnLCBzZWxmLmluZm9IYXNoKVxuXG4gIHZhciB3ZWJydGNTdXBwb3J0ID0gc2VsZi5fd3J0YyAhPT0gZmFsc2UgJiYgKCEhc2VsZi5fd3J0YyB8fCBQZWVyLldFQlJUQ19TVVBQT1JUKVxuXG4gIHZhciBhbm5vdW5jZSA9ICh0eXBlb2Ygb3B0cy5hbm5vdW5jZSA9PT0gJ3N0cmluZycpXG4gICAgPyBbIG9wdHMuYW5ub3VuY2UgXVxuICAgIDogb3B0cy5hbm5vdW5jZSA9PSBudWxsXG4gICAgICA/IFtdXG4gICAgICA6IG9wdHMuYW5ub3VuY2VcblxuICBhbm5vdW5jZSA9IGFubm91bmNlLm1hcChmdW5jdGlvbiAoYW5ub3VuY2VVcmwpIHtcbiAgICBhbm5vdW5jZVVybCA9IGFubm91bmNlVXJsLnRvU3RyaW5nKClcbiAgICBpZiAoYW5ub3VuY2VVcmxbYW5ub3VuY2VVcmwubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGZyb20gdHJhY2tlcnMgdG8gY2F0Y2ggZHVwbGljYXRlc1xuICAgICAgYW5ub3VuY2VVcmwgPSBhbm5vdW5jZVVybC5zdWJzdHJpbmcoMCwgYW5ub3VuY2VVcmwubGVuZ3RoIC0gMSlcbiAgICB9XG4gICAgcmV0dXJuIGFubm91bmNlVXJsXG4gIH0pXG5cbiAgYW5ub3VuY2UgPSB1bmlxKGFubm91bmNlKVxuXG4gIHNlbGYuX3RyYWNrZXJzID0gYW5ub3VuY2VcbiAgICAubWFwKGZ1bmN0aW9uIChhbm5vdW5jZVVybCkge1xuICAgICAgdmFyIHByb3RvY29sID0gdXJsLnBhcnNlKGFubm91bmNlVXJsKS5wcm90b2NvbFxuICAgICAgaWYgKChwcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOicpICYmXG4gICAgICAgICAgdHlwZW9mIEhUVFBUcmFja2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSFRUUFRyYWNrZXIoc2VsZiwgYW5ub3VuY2VVcmwpXG4gICAgICB9IGVsc2UgaWYgKHByb3RvY29sID09PSAndWRwOicgJiYgdHlwZW9mIFVEUFRyYWNrZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVRFBUcmFja2VyKHNlbGYsIGFubm91bmNlVXJsKVxuICAgICAgfSBlbHNlIGlmICgocHJvdG9jb2wgPT09ICd3czonIHx8IHByb3RvY29sID09PSAnd3NzOicpICYmIHdlYnJ0Y1N1cHBvcnQpIHtcbiAgICAgICAgLy8gU2tpcCB3czovLyB0cmFja2VycyBvbiBodHRwczovLyBzaXRlcyBiZWNhdXNlIHRoZXkgdGhyb3cgU2VjdXJpdHlFcnJvclxuICAgICAgICBpZiAocHJvdG9jb2wgPT09ICd3czonICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgbmV4dFRpY2tXYXJuKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHJhY2tlciBwcm90b2NvbDogJyArIGFubm91bmNlVXJsKSlcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0VHJhY2tlcihzZWxmLCBhbm5vdW5jZVVybClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRUaWNrV2FybihuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRyYWNrZXIgcHJvdG9jb2w6ICcgKyBhbm5vdW5jZVVybCkpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tXYXJuIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNjcmFwZSBhIHRyYWNrZXIgZm9yIGFuIGluZm8gaGFzaCB3aXRob3V0IG5lZWRpbmcgdG9cbiAqIGNyZWF0ZSBhIENsaWVudCwgcGFzcyBpdCBhIHBhcnNlZCB0b3JyZW50LCBldGMuIFN1cHBvcnQgc2NyYXBpbmcgYSB0cmFja2VyIGZvciBtdWx0aXBsZVxuICogdG9ycmVudHMgYXQgdGhlIHNhbWUgdGltZS5cbiAqIEBwYXJhbXMge09iamVjdH0gb3B0c1xuICogQHBhcmFtICB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBvcHRzLmluZm9IYXNoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG9wdHMuYW5ub3VuY2VcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5DbGllbnQuc2NyYXBlID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGNiID0gb25jZShjYilcblxuICBpZiAoIW9wdHMuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBpbmZvSGFzaGAgaXMgcmVxdWlyZWQnKVxuICBpZiAoIW9wdHMuYW5ub3VuY2UpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBhbm5vdW5jZWAgaXMgcmVxdWlyZWQnKVxuXG4gIHZhciBjbGllbnRPcHRzID0gZXh0ZW5kKG9wdHMsIHtcbiAgICBpbmZvSGFzaDogQXJyYXkuaXNBcnJheShvcHRzLmluZm9IYXNoKSA/IG9wdHMuaW5mb0hhc2hbMF0gOiBvcHRzLmluZm9IYXNoLFxuICAgIHBlZXJJZDogQnVmZmVyLmZyb20oJzAxMjM0NTY3ODkwMTIzNDU2Nzg5JyksIC8vIGR1bW15IHZhbHVlXG4gICAgcG9ydDogNjg4MSAvLyBkdW1teSB2YWx1ZVxuICB9KVxuXG4gIHZhciBjbGllbnQgPSBuZXcgQ2xpZW50KGNsaWVudE9wdHMpXG4gIGNsaWVudC5vbmNlKCdlcnJvcicsIGNiKVxuXG4gIHZhciBsZW4gPSBBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpID8gb3B0cy5pbmZvSGFzaC5sZW5ndGggOiAxXG4gIHZhciByZXN1bHRzID0ge31cbiAgY2xpZW50Lm9uKCdzY3JhcGUnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGxlbiAtPSAxXG4gICAgcmVzdWx0c1tkYXRhLmluZm9IYXNoXSA9IGRhdGFcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBjbGllbnQuZGVzdHJveSgpXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc3VsdHMpXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2IobnVsbCwgcmVzdWx0c1trZXlzWzBdXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwsIHJlc3VsdHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIG9wdHMuaW5mb0hhc2ggPSBBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpXG4gICAgPyBvcHRzLmluZm9IYXNoLm1hcChmdW5jdGlvbiAoaW5mb0hhc2gpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbmZvSGFzaCwgJ2hleCcpXG4gICAgfSlcbiAgICA6IEJ1ZmZlci5mcm9tKG9wdHMuaW5mb0hhc2gsICdoZXgnKVxuICBjbGllbnQuc2NyYXBlKHsgaW5mb0hhc2g6IG9wdHMuaW5mb0hhc2ggfSlcbiAgcmV0dXJuIGNsaWVudFxufVxuXG4vKipcbiAqIFNlbmQgYSBgc3RhcnRgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdzZW5kIGBzdGFydGAnKVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBvcHRzLmV2ZW50ID0gJ3N0YXJ0ZWQnXG4gIHNlbGYuX2Fubm91bmNlKG9wdHMpXG5cbiAgLy8gc3RhcnQgYW5ub3VuY2luZyBvbiBpbnRlcnZhbHNcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHRyYWNrZXIuc2V0SW50ZXJ2YWwoKVxuICB9KVxufVxuXG4vKipcbiAqIFNlbmQgYSBgc3RvcGAgYW5ub3VuY2UgdG8gdGhlIHRyYWNrZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy51cGxvYWRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmRvd25sb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5udW13YW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NlbmQgYHN0b3BgJylcbiAgb3B0cyA9IHNlbGYuX2RlZmF1bHRBbm5vdW5jZU9wdHMob3B0cylcbiAgb3B0cy5ldmVudCA9ICdzdG9wcGVkJ1xuICBzZWxmLl9hbm5vdW5jZShvcHRzKVxufVxuXG4vKipcbiAqIFNlbmQgYSBgY29tcGxldGVgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubnVtd2FudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmxlZnQgKGlmIG5vdCBzZXQsIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSlcbiAqL1xuQ2xpZW50LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgY29tcGxldGVgJylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cyA9IHNlbGYuX2RlZmF1bHRBbm5vdW5jZU9wdHMob3B0cylcbiAgb3B0cy5ldmVudCA9ICdjb21wbGV0ZWQnXG4gIHNlbGYuX2Fubm91bmNlKG9wdHMpXG59XG5cbi8qKlxuICogU2VuZCBhIGB1cGRhdGVgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubnVtd2FudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmxlZnQgKGlmIG5vdCBzZXQsIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSlcbiAqL1xuQ2xpZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NlbmQgYHVwZGF0ZWAnKVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBpZiAob3B0cy5ldmVudCkgZGVsZXRlIG9wdHMuZXZlbnRcbiAgc2VsZi5fYW5ub3VuY2Uob3B0cylcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5fYW5ub3VuY2UgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIC8vIHRyYWNrZXIgc2hvdWxkIG5vdCBtb2RpZnkgYG9wdHNgIG9iamVjdCwgaXQncyBwYXNzZWQgdG8gYWxsIHRyYWNrZXJzXG4gICAgdHJhY2tlci5hbm5vdW5jZShvcHRzKVxuICB9KVxufVxuXG4vKipcbiAqIFNlbmQgYSBzY3JhcGUgcmVxdWVzdCB0byB0aGUgdHJhY2tlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5DbGllbnQucHJvdG90eXBlLnNjcmFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgc2NyYXBlYCcpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHNlbGYuX3RyYWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrZXIpIHtcbiAgICAvLyB0cmFja2VyIHNob3VsZCBub3QgbW9kaWZ5IGBvcHRzYCBvYmplY3QsIGl0J3MgcGFzc2VkIHRvIGFsbCB0cmFja2Vyc1xuICAgIHRyYWNrZXIuc2NyYXBlKG9wdHMpXG4gIH0pXG59XG5cbkNsaWVudC5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWxNcykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NldEludGVydmFsICVkJywgaW50ZXJ2YWxNcylcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHRyYWNrZXIuc2V0SW50ZXJ2YWwoaW50ZXJ2YWxNcylcbiAgfSlcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgZGVidWcoJ2Rlc3Ryb3knKVxuXG4gIHZhciB0YXNrcyA9IHNlbGYuX3RyYWNrZXJzLm1hcChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHRyYWNrZXIuZGVzdHJveShjYilcbiAgICB9XG4gIH0pXG5cbiAgcGFyYWxsZWwodGFza3MsIGNiKVxuXG4gIHNlbGYuX3RyYWNrZXJzID0gW11cbiAgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzID0gbnVsbFxufVxuXG5DbGllbnQucHJvdG90eXBlLl9kZWZhdWx0QW5ub3VuY2VPcHRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgaWYgKG9wdHMubnVtd2FudCA9PSBudWxsKSBvcHRzLm51bXdhbnQgPSBjb21tb24uREVGQVVMVF9BTk5PVU5DRV9QRUVSU1xuXG4gIGlmIChvcHRzLnVwbG9hZGVkID09IG51bGwpIG9wdHMudXBsb2FkZWQgPSAwXG4gIGlmIChvcHRzLmRvd25sb2FkZWQgPT0gbnVsbCkgb3B0cy5kb3dubG9hZGVkID0gMFxuXG4gIGlmIChzZWxmLl9nZXRBbm5vdW5jZU9wdHMpIG9wdHMgPSBleHRlbmQob3B0cywgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzKCkpXG4gIHJldHVybiBvcHRzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFRyYWNrZXJcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5pbmhlcml0cyhUcmFja2VyLCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIFRyYWNrZXIgKGNsaWVudCwgYW5ub3VuY2VVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG4gIHNlbGYuY2xpZW50ID0gY2xpZW50XG4gIHNlbGYuYW5ub3VuY2VVcmwgPSBhbm5vdW5jZVVybFxuXG4gIHNlbGYuaW50ZXJ2YWwgPSBudWxsXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuVHJhY2tlci5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWxNcykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKGludGVydmFsTXMgPT0gbnVsbCkgaW50ZXJ2YWxNcyA9IHNlbGYuREVGQVVMVF9BTk5PVU5DRV9JTlRFUlZBTFxuXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5pbnRlcnZhbClcblxuICBpZiAoaW50ZXJ2YWxNcykge1xuICAgIHNlbGYuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmFubm91bmNlKHNlbGYuY2xpZW50Ll9kZWZhdWx0QW5ub3VuY2VPcHRzKCkpXG4gICAgfSwgaW50ZXJ2YWxNcylcbiAgICBpZiAoc2VsZi5pbnRlcnZhbC51bnJlZikgc2VsZi5pbnRlcnZhbC51bnJlZigpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhY2tlclxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXR0b3JyZW50LXRyYWNrZXI6d2Vic29ja2V0LXRyYWNrZXInKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG52YXIgU29ja2V0ID0gcmVxdWlyZSgnc2ltcGxlLXdlYnNvY2tldCcpXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKVxudmFyIFRyYWNrZXIgPSByZXF1aXJlKCcuL3RyYWNrZXInKVxuXG4vLyBVc2UgYSBzb2NrZXQgcG9vbCwgc28gdHJhY2tlciBjbGllbnRzIHNoYXJlIFdlYlNvY2tldCBvYmplY3RzIGZvciB0aGUgc2FtZSBzZXJ2ZXIuXG4vLyBJbiBwcmFjdGljZSwgV2ViU29ja2V0cyBhcmUgcHJldHR5IHNsb3cgdG8gZXN0YWJsaXNoLCBzbyB0aGlzIGdpdmVzIGEgbmljZSBwZXJmb3JtYW5jZVxuLy8gYm9vc3QsIGFuZCBzYXZlcyBicm93c2VyIHJlc291cmNlcy5cbnZhciBzb2NrZXRQb29sID0ge31cblxudmFyIFJFQ09OTkVDVF9NSU5JTVVNID0gMTUgKiAxMDAwXG52YXIgUkVDT05ORUNUX01BWElNVU0gPSAzMCAqIDYwICogMTAwMFxudmFyIFJFQ09OTkVDVF9WQVJJQU5DRSA9IDMwICogMTAwMFxudmFyIE9GRkVSX1RJTUVPVVQgPSA1MCAqIDEwMDBcblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhY2tlciwgVHJhY2tlcilcblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhY2tlciAoY2xpZW50LCBhbm5vdW5jZVVybCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgVHJhY2tlci5jYWxsKHNlbGYsIGNsaWVudCwgYW5ub3VuY2VVcmwpXG4gIGRlYnVnKCduZXcgd2Vic29ja2V0IHRyYWNrZXIgJXMnLCBhbm5vdW5jZVVybClcblxuICBzZWxmLnBlZXJzID0ge30gLy8gcGVlcnMgKG9mZmVyIGlkIC0+IHBlZXIpXG4gIHNlbGYuc29ja2V0ID0gbnVsbFxuXG4gIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2VcbiAgc2VsZi5yZXRyaWVzID0gMFxuICBzZWxmLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuXG4gIHNlbGYuX29wZW5Tb2NrZXQoKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5ERUZBVUxUX0FOTk9VTkNFX0lOVEVSVkFMID0gMzAgKiAxMDAwIC8vIDMwIHNlY29uZHNcblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuYW5ub3VuY2UgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkIHx8IHNlbGYucmVjb25uZWN0aW5nKSByZXR1cm5cbiAgaWYgKCFzZWxmLnNvY2tldC5jb25uZWN0ZWQpIHtcbiAgICBzZWxmLnNvY2tldC5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5hbm5vdW5jZShvcHRzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcGFyYW1zID0gZXh0ZW5kKG9wdHMsIHtcbiAgICBhY3Rpb246ICdhbm5vdW5jZScsXG4gICAgaW5mb19oYXNoOiBzZWxmLmNsaWVudC5faW5mb0hhc2hCaW5hcnksXG4gICAgcGVlcl9pZDogc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeVxuICB9KVxuICBpZiAoc2VsZi5fdHJhY2tlcklkKSBwYXJhbXMudHJhY2tlcmlkID0gc2VsZi5fdHJhY2tlcklkXG5cbiAgaWYgKG9wdHMuZXZlbnQgPT09ICdzdG9wcGVkJykge1xuICAgIC8vIERvbid0IGluY2x1ZGUgb2ZmZXJzIHdpdGggJ3N0b3BwZWQnIGV2ZW50XG4gICAgc2VsZi5fc2VuZChwYXJhbXMpXG4gIH0gZWxzZSB7XG4gICAgLy8gTGltaXQgdGhlIG51bWJlciBvZiBvZmZlcnMgdGhhdCBhcmUgZ2VuZXJhdGVkLCBzaW5jZSBpdCBjYW4gYmUgc2xvd1xuICAgIHZhciBudW13YW50ID0gTWF0aC5taW4ob3B0cy5udW13YW50LCA1KVxuXG4gICAgc2VsZi5fZ2VuZXJhdGVPZmZlcnMobnVtd2FudCwgZnVuY3Rpb24gKG9mZmVycykge1xuICAgICAgcGFyYW1zLm51bXdhbnQgPSBudW13YW50XG4gICAgICBwYXJhbXMub2ZmZXJzID0gb2ZmZXJzXG4gICAgICBzZWxmLl9zZW5kKHBhcmFtcylcbiAgICB9KVxuICB9XG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLnNjcmFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQgfHwgc2VsZi5yZWNvbm5lY3RpbmcpIHJldHVyblxuICBpZiAoIXNlbGYuc29ja2V0LmNvbm5lY3RlZCkge1xuICAgIHNlbGYuc29ja2V0Lm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNjcmFwZShvcHRzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgaW5mb0hhc2hlcyA9IChBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpICYmIG9wdHMuaW5mb0hhc2gubGVuZ3RoID4gMClcbiAgICA/IG9wdHMuaW5mb0hhc2gubWFwKGZ1bmN0aW9uIChpbmZvSGFzaCkge1xuICAgICAgcmV0dXJuIGluZm9IYXNoLnRvU3RyaW5nKCdiaW5hcnknKVxuICAgIH0pXG4gICAgOiAob3B0cy5pbmZvSGFzaCAmJiBvcHRzLmluZm9IYXNoLnRvU3RyaW5nKCdiaW5hcnknKSkgfHwgc2VsZi5jbGllbnQuX2luZm9IYXNoQmluYXJ5XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgYWN0aW9uOiAnc2NyYXBlJyxcbiAgICBpbmZvX2hhc2g6IGluZm9IYXNoZXNcbiAgfVxuXG4gIHNlbGYuX3NlbmQocGFyYW1zKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobnVsbClcblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuICBjbGVhckludGVydmFsKHNlbGYuaW50ZXJ2YWwpXG4gIGNsZWFyVGltZW91dChzZWxmLnJlY29ubmVjdFRpbWVyKVxuXG4gIGlmIChzZWxmLnNvY2tldCkge1xuICAgIHNlbGYuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0Jywgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQpXG4gICAgc2VsZi5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzZWxmLl9vblNvY2tldERhdGFCb3VuZClcbiAgICBzZWxmLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzZWxmLl9vblNvY2tldENsb3NlQm91bmQpXG4gICAgc2VsZi5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25Tb2NrZXRFcnJvckJvdW5kKVxuICB9XG5cbiAgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQgPSBudWxsXG4gIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZCA9IG51bGxcbiAgc2VsZi5fb25Tb2NrZXREYXRhQm91bmQgPSBudWxsXG4gIHNlbGYuX29uU29ja2V0Q2xvc2VCb3VuZCA9IG51bGxcblxuICAvLyBEZXN0cm95IHBlZXJzXG4gIGZvciAodmFyIHBlZXJJZCBpbiBzZWxmLnBlZXJzKSB7XG4gICAgdmFyIHBlZXIgPSBzZWxmLnBlZXJzW3BlZXJJZF1cbiAgICBjbGVhclRpbWVvdXQocGVlci50cmFja2VyVGltZW91dClcbiAgICBwZWVyLmRlc3Ryb3koKVxuICB9XG4gIHNlbGYucGVlcnMgPSBudWxsXG5cbiAgaWYgKHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0pIHtcbiAgICBzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdLmNvbnN1bWVycyAtPSAxXG4gIH1cblxuICBpZiAoc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXS5jb25zdW1lcnMgPT09IDApIHtcbiAgICBkZWxldGUgc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXVxuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuc29ja2V0Lm9uKCdlcnJvcicsIG5vb3ApIC8vIGlnbm9yZSBhbGwgZnV0dXJlIGVycm9yc1xuICAgICAgc2VsZi5zb2NrZXQuZGVzdHJveShjYilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBzZWxmLnNvY2tldCA9IG51bGxcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29wZW5Tb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgaWYgKCFzZWxmLnBlZXJzKSBzZWxmLnBlZXJzID0ge31cblxuICBzZWxmLl9vblNvY2tldENvbm5lY3RCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblNvY2tldENvbm5lY3QoKVxuICB9XG4gIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9vblNvY2tldEVycm9yKGVycilcbiAgfVxuICBzZWxmLl9vblNvY2tldERhdGFCb3VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5fb25Tb2NrZXREYXRhKGRhdGEpXG4gIH1cbiAgc2VsZi5fb25Tb2NrZXRDbG9zZUJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uU29ja2V0Q2xvc2UoKVxuICB9XG5cbiAgc2VsZi5zb2NrZXQgPSBzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdXG4gIGlmIChzZWxmLnNvY2tldCkge1xuICAgIHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0uY29uc3VtZXJzICs9IDFcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNvY2tldCA9IHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0gPSBuZXcgU29ja2V0KHNlbGYuYW5ub3VuY2VVcmwpXG4gICAgc2VsZi5zb2NrZXQuY29uc3VtZXJzID0gMVxuICAgIHNlbGYuc29ja2V0Lm9uKCdjb25uZWN0Jywgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQpXG4gIH1cblxuICBzZWxmLnNvY2tldC5vbignZGF0YScsIHNlbGYuX29uU29ja2V0RGF0YUJvdW5kKVxuICBzZWxmLnNvY2tldC5vbignY2xvc2UnLCBzZWxmLl9vblNvY2tldENsb3NlQm91bmQpXG4gIHNlbGYuc29ja2V0Lm9uKCdlcnJvcicsIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZClcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0Q29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgaWYgKHNlbGYucmVjb25uZWN0aW5nKSB7XG4gICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHNlbGYucmV0cmllcyA9IDBcbiAgICBzZWxmLmFubm91bmNlKHNlbGYuY2xpZW50Ll9kZWZhdWx0QW5ub3VuY2VPcHRzKCkpXG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHRyeSB7XG4gICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignSW52YWxpZCB0cmFja2VyIHJlc3BvbnNlJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZGF0YS5hY3Rpb24gPT09ICdhbm5vdW5jZScpIHtcbiAgICBzZWxmLl9vbkFubm91bmNlUmVzcG9uc2UoZGF0YSlcbiAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiA9PT0gJ3NjcmFwZScpIHtcbiAgICBzZWxmLl9vblNjcmFwZVJlc3BvbnNlKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fb25Tb2NrZXRFcnJvcihuZXcgRXJyb3IoJ2ludmFsaWQgYWN0aW9uIGluIFdTIHJlc3BvbnNlOiAnICsgZGF0YS5hY3Rpb24pKVxuICB9XG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLl9vbkFubm91bmNlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoZGF0YS5pbmZvX2hhc2ggIT09IHNlbGYuY2xpZW50Ll9pbmZvSGFzaEJpbmFyeSkge1xuICAgIGRlYnVnKFxuICAgICAgJ2lnbm9yaW5nIHdlYnNvY2tldCBkYXRhIGZyb20gJXMgZm9yICVzIChsb29raW5nIGZvciAlczogcmV1c2VkIHNvY2tldCknLFxuICAgICAgc2VsZi5hbm5vdW5jZVVybCwgY29tbW9uLmJpbmFyeVRvSGV4KGRhdGEuaW5mb19oYXNoKSwgc2VsZi5jbGllbnQuaW5mb0hhc2hcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZGF0YS5wZWVyX2lkICYmIGRhdGEucGVlcl9pZCA9PT0gc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeSkge1xuICAgIC8vIGlnbm9yZSBvZmZlcnMvYW5zd2VycyBmcm9tIHRoaXMgY2xpZW50XG4gICAgcmV0dXJuXG4gIH1cblxuICBkZWJ1ZyhcbiAgICAncmVjZWl2ZWQgJXMgZnJvbSAlcyBmb3IgJXMnLFxuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpLCBzZWxmLmFubm91bmNlVXJsLCBzZWxmLmNsaWVudC5pbmZvSGFzaFxuICApXG5cbiAgdmFyIGZhaWx1cmUgPSBkYXRhWydmYWlsdXJlIHJlYXNvbiddXG4gIGlmIChmYWlsdXJlKSByZXR1cm4gc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcihmYWlsdXJlKSlcblxuICB2YXIgd2FybmluZyA9IGRhdGFbJ3dhcm5pbmcgbWVzc2FnZSddXG4gIGlmICh3YXJuaW5nKSBzZWxmLmNsaWVudC5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKHdhcm5pbmcpKVxuXG4gIHZhciBpbnRlcnZhbCA9IGRhdGEuaW50ZXJ2YWwgfHwgZGF0YVsnbWluIGludGVydmFsJ11cbiAgaWYgKGludGVydmFsKSBzZWxmLnNldEludGVydmFsKGludGVydmFsICogMTAwMClcblxuICB2YXIgdHJhY2tlcklkID0gZGF0YVsndHJhY2tlciBpZCddXG4gIGlmICh0cmFja2VySWQpIHtcbiAgICAvLyBJZiBhYnNlbnQsIGRvIG5vdCBkaXNjYXJkIHByZXZpb3VzIHRyYWNrZXJJZCB2YWx1ZVxuICAgIHNlbGYuX3RyYWNrZXJJZCA9IHRyYWNrZXJJZFxuICB9XG5cbiAgaWYgKGRhdGEuY29tcGxldGUgIT0gbnVsbCkge1xuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgIGFubm91bmNlOiBzZWxmLmFubm91bmNlVXJsLFxuICAgICAgY29tcGxldGU6IGRhdGEuY29tcGxldGUsXG4gICAgICBpbmNvbXBsZXRlOiBkYXRhLmluY29tcGxldGVcbiAgICB9KVxuICB9XG5cbiAgdmFyIHBlZXJcbiAgaWYgKGRhdGEub2ZmZXIgJiYgZGF0YS5wZWVyX2lkKSB7XG4gICAgZGVidWcoJ2NyZWF0aW5nIHBlZXIgKGZyb20gcmVtb3RlIG9mZmVyKScpXG4gICAgcGVlciA9IG5ldyBQZWVyKHtcbiAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgY29uZmlnOiBzZWxmLmNsaWVudC5fcnRjQ29uZmlnLFxuICAgICAgd3J0Yzogc2VsZi5jbGllbnQuX3dydGNcbiAgICB9KVxuICAgIHBlZXIuaWQgPSBjb21tb24uYmluYXJ5VG9IZXgoZGF0YS5wZWVyX2lkKVxuICAgIHBlZXIub25jZSgnc2lnbmFsJywgZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgYWN0aW9uOiAnYW5ub3VuY2UnLFxuICAgICAgICBpbmZvX2hhc2g6IHNlbGYuY2xpZW50Ll9pbmZvSGFzaEJpbmFyeSxcbiAgICAgICAgcGVlcl9pZDogc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeSxcbiAgICAgICAgdG9fcGVlcl9pZDogZGF0YS5wZWVyX2lkLFxuICAgICAgICBhbnN3ZXI6IGFuc3dlcixcbiAgICAgICAgb2ZmZXJfaWQ6IGRhdGEub2ZmZXJfaWRcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLl90cmFja2VySWQpIHBhcmFtcy50cmFja2VyaWQgPSBzZWxmLl90cmFja2VySWRcbiAgICAgIHNlbGYuX3NlbmQocGFyYW1zKVxuICAgIH0pXG4gICAgcGVlci5zaWduYWwoZGF0YS5vZmZlcilcbiAgICBzZWxmLmNsaWVudC5lbWl0KCdwZWVyJywgcGVlcilcbiAgfVxuXG4gIGlmIChkYXRhLmFuc3dlciAmJiBkYXRhLnBlZXJfaWQpIHtcbiAgICB2YXIgb2ZmZXJJZCA9IGNvbW1vbi5iaW5hcnlUb0hleChkYXRhLm9mZmVyX2lkKVxuICAgIHBlZXIgPSBzZWxmLnBlZXJzW29mZmVySWRdXG4gICAgaWYgKHBlZXIpIHtcbiAgICAgIHBlZXIuaWQgPSBjb21tb24uYmluYXJ5VG9IZXgoZGF0YS5wZWVyX2lkKVxuICAgICAgcGVlci5zaWduYWwoZGF0YS5hbnN3ZXIpXG4gICAgICBzZWxmLmNsaWVudC5lbWl0KCdwZWVyJywgcGVlcilcblxuICAgICAgY2xlYXJUaW1lb3V0KHBlZXIudHJhY2tlclRpbWVvdXQpXG4gICAgICBwZWVyLnRyYWNrZXJUaW1lb3V0ID0gbnVsbFxuICAgICAgZGVsZXRlIHNlbGYucGVlcnNbb2ZmZXJJZF1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2dvdCB1bmV4cGVjdGVkIGFuc3dlcjogJyArIEpTT04uc3RyaW5naWZ5KGRhdGEuYW5zd2VyKSlcbiAgICB9XG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU2NyYXBlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGF0YSA9IGRhdGEuZmlsZXMgfHwge31cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ2ludmFsaWQgc2NyYXBlIHJlc3BvbnNlJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGluZm9IYXNoKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gZGF0YVtpbmZvSGFzaF1cbiAgICAvLyBUT0RPOiBvcHRpb25hbGx5IGhhbmRsZSBkYXRhLmZsYWdzLm1pbl9yZXF1ZXN0X2ludGVydmFsXG4gICAgLy8gKHNlcGFyYXRlIGZyb20gYW5ub3VuY2UgaW50ZXJ2YWwpXG4gICAgc2VsZi5jbGllbnQuZW1pdCgnc2NyYXBlJywge1xuICAgICAgYW5ub3VuY2U6IHNlbGYuYW5ub3VuY2VVcmwsXG4gICAgICBpbmZvSGFzaDogY29tbW9uLmJpbmFyeVRvSGV4KGluZm9IYXNoKSxcbiAgICAgIGNvbXBsZXRlOiByZXNwb25zZS5jb21wbGV0ZSxcbiAgICAgIGluY29tcGxldGU6IHJlc3BvbnNlLmluY29tcGxldGUsXG4gICAgICBkb3dubG9hZGVkOiByZXNwb25zZS5kb3dubG9hZGVkXG4gICAgfSlcbiAgfSlcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3koKVxuICBzZWxmLl9zdGFydFJlY29ubmVjdFRpbWVyKClcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3koKVxuICAvLyBlcnJvcnMgd2lsbCBvZnRlbiBoYXBwZW4gaWYgYSB0cmFja2VyIGlzIG9mZmxpbmUsIHNvIGRvbid0IHRyZWF0IGl0IGFzIGZhdGFsXG4gIHNlbGYuY2xpZW50LmVtaXQoJ3dhcm5pbmcnLCBlcnIpXG4gIHNlbGYuX3N0YXJ0UmVjb25uZWN0VGltZXIoKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fc3RhcnRSZWNvbm5lY3RUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBtcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFJFQ09OTkVDVF9WQVJJQU5DRSkgKyBNYXRoLm1pbihNYXRoLnBvdygyLCBzZWxmLnJldHJpZXMpICogUkVDT05ORUNUX01JTklNVU0sIFJFQ09OTkVDVF9NQVhJTVVNKVxuXG4gIHNlbGYucmVjb25uZWN0aW5nID0gdHJ1ZVxuICBjbGVhclRpbWVvdXQoc2VsZi5yZWNvbm5lY3RUaW1lcilcbiAgc2VsZi5yZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmV0cmllcysrXG4gICAgc2VsZi5fb3BlblNvY2tldCgpXG4gIH0sIG1zKVxuICBpZiAoc2VsZi5yZWNvbm5lY3RUaW1lci51bnJlZikgc2VsZi5yZWNvbm5lY3RUaW1lci51bnJlZigpXG5cbiAgZGVidWcoJ3JlY29ubmVjdGluZyBzb2NrZXQgaW4gJXMgbXMnLCBtcylcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHZhciBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKVxuICBkZWJ1Zygnc2VuZCAlcycsIG1lc3NhZ2UpXG4gIHNlbGYuc29ja2V0LnNlbmQobWVzc2FnZSlcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX2dlbmVyYXRlT2ZmZXJzID0gZnVuY3Rpb24gKG51bXdhbnQsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgb2ZmZXJzID0gW11cbiAgZGVidWcoJ2dlbmVyYXRpbmcgJXMgb2ZmZXJzJywgbnVtd2FudClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bXdhbnQ7ICsraSkge1xuICAgIGdlbmVyYXRlT2ZmZXIoKVxuICB9XG4gIGNoZWNrRG9uZSgpXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVPZmZlciAoKSB7XG4gICAgdmFyIG9mZmVySWQgPSBoYXQoMTYwKVxuICAgIGRlYnVnKCdjcmVhdGluZyBwZWVyIChmcm9tIF9nZW5lcmF0ZU9mZmVycyknKVxuICAgIHZhciBwZWVyID0gc2VsZi5wZWVyc1tvZmZlcklkXSA9IG5ldyBQZWVyKHtcbiAgICAgIGluaXRpYXRvcjogdHJ1ZSxcbiAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgY29uZmlnOiBzZWxmLmNsaWVudC5fcnRjQ29uZmlnLFxuICAgICAgd3J0Yzogc2VsZi5jbGllbnQuX3dydGNcbiAgICB9KVxuICAgIHBlZXIub25jZSgnc2lnbmFsJywgZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICBvZmZlcnMucHVzaCh7XG4gICAgICAgIG9mZmVyOiBvZmZlcixcbiAgICAgICAgb2ZmZXJfaWQ6IGNvbW1vbi5oZXhUb0JpbmFyeShvZmZlcklkKVxuICAgICAgfSlcbiAgICAgIGNoZWNrRG9uZSgpXG4gICAgfSlcbiAgICBwZWVyLnRyYWNrZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygndHJhY2tlciB0aW1lb3V0OiBkZXN0cm95aW5nIHBlZXInKVxuICAgICAgcGVlci50cmFja2VyVGltZW91dCA9IG51bGxcbiAgICAgIGRlbGV0ZSBzZWxmLnBlZXJzW29mZmVySWRdXG4gICAgICBwZWVyLmRlc3Ryb3koKVxuICAgIH0sIE9GRkVSX1RJTUVPVVQpXG4gICAgaWYgKHBlZXIudHJhY2tlclRpbWVvdXQudW5yZWYpIHBlZXIudHJhY2tlclRpbWVvdXQudW5yZWYoKVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEb25lICgpIHtcbiAgICBpZiAob2ZmZXJzLmxlbmd0aCA9PT0gbnVtd2FudCkge1xuICAgICAgZGVidWcoJ2dlbmVyYXRlZCAlcyBvZmZlcnMnLCBudW13YW50KVxuICAgICAgY2Iob2ZmZXJzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCIvKipcbiAqIEZ1bmN0aW9ucy9jb25zdGFudHMgbmVlZGVkIGJ5IGJvdGggdGhlIGNsaWVudCBhbmQgc2VydmVyLlxuICovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kL211dGFibGUnKVxuXG5leHBvcnRzLkRFRkFVTFRfQU5OT1VOQ0VfUEVFUlMgPSA1MFxuZXhwb3J0cy5NQVhfQU5OT1VOQ0VfUEVFUlMgPSA4MlxuXG5leHBvcnRzLmJpbmFyeVRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKVxuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICdiaW5hcnknKS50b1N0cmluZygnaGV4Jylcbn1cblxuZXhwb3J0cy5oZXhUb0JpbmFyeSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cilcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAnaGV4JykudG9TdHJpbmcoJ2JpbmFyeScpXG59XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbW1vbi1ub2RlJylcbmV4dGVuZChleHBvcnRzLCBjb25maWcpXG4iLCIvKiBnbG9iYWwgQmxvYiwgRmlsZVJlYWRlciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2JUb0J1ZmZlciAoYmxvYiwgY2IpIHtcbiAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCAhKGJsb2IgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIEJsb2InKVxuICB9XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICBmdW5jdGlvbiBvbkxvYWRFbmQgKGUpIHtcbiAgICByZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZEVuZCwgZmFsc2UpXG4gICAgaWYgKGUuZXJyb3IpIGNiKGUuZXJyb3IpXG4gICAgZWxzZSBjYihudWxsLCBuZXcgQnVmZmVyKHJlYWRlci5yZXN1bHQpKVxuICB9XG5cbiAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBvbkxvYWRFbmQsIGZhbHNlKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbn1cbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCdkZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2s7XG5pbmhlcml0cyhCbG9jaywgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gQmxvY2sgKHNpemUsIG9wdHMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmxvY2spKSByZXR1cm4gbmV3IEJsb2NrKHNpemUsIG9wdHMpO1xuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IHNpemU7XG4gICAgICAgIHNpemUgPSBvcHRzLnNpemU7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemUgfHwgNTEyO1xuICAgIFxuICAgIGlmIChvcHRzLm5vcGFkKSB0aGlzLl96ZXJvUGFkZGluZyA9IGZhbHNlO1xuICAgIGVsc2UgdGhpcy5femVyb1BhZGRpbmcgPSBkZWZpbmVkKG9wdHMuemVyb1BhZGRpbmcsIHRydWUpO1xuICAgIFxuICAgIHRoaXMuX2J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG59XG5cbkJsb2NrLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGJ1ZiwgZW5jLCBuZXh0KSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBidWYubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcmVkLnB1c2goYnVmKTtcbiAgICBcbiAgICB3aGlsZSAodGhpcy5fYnVmZmVyZWRCeXRlcyA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgdmFyIGIgPSBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZmZlcmVkKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSB0aGlzLnNpemU7XG4gICAgICAgIHRoaXMucHVzaChiLnNsaWNlKDAsIHRoaXMuc2l6ZSkpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZCA9IFsgYi5zbGljZSh0aGlzLnNpemUsIGIubGVuZ3RoKSBdO1xuICAgIH1cbiAgICBuZXh0KCk7XG59O1xuXG5CbG9jay5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzICYmIHRoaXMuX3plcm9QYWRkaW5nKSB7XG4gICAgICAgIHZhciB6ZXJvZXMgPSBuZXcgQnVmZmVyKHRoaXMuc2l6ZSAtIHRoaXMuX2J1ZmZlcmVkQnl0ZXMpO1xuICAgICAgICB6ZXJvZXMuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyZWQucHVzaCh6ZXJvZXMpO1xuICAgICAgICB0aGlzLnB1c2goQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXJlZCkpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZCA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMpIHtcbiAgICAgICAgdGhpcy5wdXNoKEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmZmVyZWQpKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnB1c2gobnVsbCk7XG59O1xuIiwiIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcbnZhciBTbG93QnVmZmVyID0gYnVmZmVyLlNsb3dCdWZmZXI7XG52YXIgTUFYX0xFTiA9IGJ1ZmZlci5rTWF4TGVuZ3RoIHx8IDIxNDc0ODM2NDc7XG5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3Qgbm90IGJlIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICB2YXIgZW5jID0gZW5jb2Rpbmc7XG4gIHZhciBfZmlsbCA9IGZpbGw7XG4gIGlmIChfZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICAgIF9maWxsID0gMDtcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgaWYgKHR5cGVvZiBfZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZmlsbEJ1ZiA9IG5ldyBCdWZmZXIoX2ZpbGwsIGVuYyk7XG4gICAgdmFyIGZsZW4gPSBmaWxsQnVmLmxlbmd0aDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBzaXplKSB7XG4gICAgICBidWZbaV0gPSBmaWxsQnVmW2kgJSBmbGVuXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoX2ZpbGwpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xufVxuZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgKCFnbG9iYWwuVWludDhBcnJheSB8fCBVaW50OEFycmF5LmZyb20gIT09IEJ1ZmZlci5mcm9tKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZW5jb2RpbmdPck9mZnNldDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHZhciBsZW4gPSBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAobGVuID4gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcih2YWx1ZS5sZW5ndGgpO1xuICAgIHZhbHVlLmNvcHkob3V0LCAwLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCAnICsgJ0FycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+PSBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHNpemUpO1xufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgIGlmIChyZWFkKGFyciwgYnl0ZU9mZnNldCArIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiAoYnl0ZU9mZnNldCArIGZvdW5kSW5kZXgpICogaW5kZXhTaXplXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7IGkrKykge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwiMTAwXCI6IFwiQ29udGludWVcIixcbiAgXCIxMDFcIjogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gIFwiMTAyXCI6IFwiUHJvY2Vzc2luZ1wiLFxuICBcIjIwMFwiOiBcIk9LXCIsXG4gIFwiMjAxXCI6IFwiQ3JlYXRlZFwiLFxuICBcIjIwMlwiOiBcIkFjY2VwdGVkXCIsXG4gIFwiMjAzXCI6IFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcbiAgXCIyMDRcIjogXCJObyBDb250ZW50XCIsXG4gIFwiMjA1XCI6IFwiUmVzZXQgQ29udGVudFwiLFxuICBcIjIwNlwiOiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICBcIjIwN1wiOiBcIk11bHRpLVN0YXR1c1wiLFxuICBcIjIwOFwiOiBcIkFscmVhZHkgUmVwb3J0ZWRcIixcbiAgXCIyMjZcIjogXCJJTSBVc2VkXCIsXG4gIFwiMzAwXCI6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICBcIjMwMVwiOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gIFwiMzAyXCI6IFwiRm91bmRcIixcbiAgXCIzMDNcIjogXCJTZWUgT3RoZXJcIixcbiAgXCIzMDRcIjogXCJOb3QgTW9kaWZpZWRcIixcbiAgXCIzMDVcIjogXCJVc2UgUHJveHlcIixcbiAgXCIzMDdcIjogXCJUZW1wb3JhcnkgUmVkaXJlY3RcIixcbiAgXCIzMDhcIjogXCJQZXJtYW5lbnQgUmVkaXJlY3RcIixcbiAgXCI0MDBcIjogXCJCYWQgUmVxdWVzdFwiLFxuICBcIjQwMVwiOiBcIlVuYXV0aG9yaXplZFwiLFxuICBcIjQwMlwiOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgXCI0MDNcIjogXCJGb3JiaWRkZW5cIixcbiAgXCI0MDRcIjogXCJOb3QgRm91bmRcIixcbiAgXCI0MDVcIjogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgXCI0MDZcIjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICBcIjQwN1wiOiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDA4XCI6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gIFwiNDA5XCI6IFwiQ29uZmxpY3RcIixcbiAgXCI0MTBcIjogXCJHb25lXCIsXG4gIFwiNDExXCI6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gIFwiNDEyXCI6IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFxuICBcIjQxM1wiOiBcIlBheWxvYWQgVG9vIExhcmdlXCIsXG4gIFwiNDE0XCI6IFwiVVJJIFRvbyBMb25nXCIsXG4gIFwiNDE1XCI6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICBcIjQxNlwiOiBcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVwiLFxuICBcIjQxN1wiOiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICBcIjQxOFwiOiBcIkknbSBhIHRlYXBvdFwiLFxuICBcIjQyMVwiOiBcIk1pc2RpcmVjdGVkIFJlcXVlc3RcIixcbiAgXCI0MjJcIjogXCJVbnByb2Nlc3NhYmxlIEVudGl0eVwiLFxuICBcIjQyM1wiOiBcIkxvY2tlZFwiLFxuICBcIjQyNFwiOiBcIkZhaWxlZCBEZXBlbmRlbmN5XCIsXG4gIFwiNDI1XCI6IFwiVW5vcmRlcmVkIENvbGxlY3Rpb25cIixcbiAgXCI0MjZcIjogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gIFwiNDI4XCI6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDI5XCI6IFwiVG9vIE1hbnkgUmVxdWVzdHNcIixcbiAgXCI0MzFcIjogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBDaHVua1N0b3JlV3JpdGVTdHJlYW1cblxudmFyIEJsb2NrU3RyZWFtID0gcmVxdWlyZSgnYmxvY2stc3RyZWFtMicpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxuaW5oZXJpdHMoQ2h1bmtTdG9yZVdyaXRlU3RyZWFtLCBzdHJlYW0uV3JpdGFibGUpXG5cbmZ1bmN0aW9uIENodW5rU3RvcmVXcml0ZVN0cmVhbSAoc3RvcmUsIGNodW5rTGVuZ3RoLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgQ2h1bmtTdG9yZVdyaXRlU3RyZWFtKSkge1xuICAgIHJldHVybiBuZXcgQ2h1bmtTdG9yZVdyaXRlU3RyZWFtKHN0b3JlLCBjaHVua0xlbmd0aCwgb3B0cylcbiAgfVxuICBzdHJlYW0uV3JpdGFibGUuY2FsbChzZWxmLCBvcHRzKVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIGlmICghc3RvcmUgfHwgIXN0b3JlLnB1dCB8fCAhc3RvcmUuZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGFic3RyYWN0LWNodW5rLXN0b3JlIGNvbXBsaWFudCBzdG9yZScpXG4gIH1cbiAgY2h1bmtMZW5ndGggPSBOdW1iZXIoY2h1bmtMZW5ndGgpXG4gIGlmICghY2h1bmtMZW5ndGgpIHRocm93IG5ldyBFcnJvcignU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBjaHVuayBsZW5ndGgnKVxuXG4gIHNlbGYuX2Jsb2Nrc3RyZWFtID0gbmV3IEJsb2NrU3RyZWFtKGNodW5rTGVuZ3RoLCB7IHplcm9QYWRkaW5nOiBmYWxzZSB9KVxuXG4gIHNlbGYuX2Jsb2Nrc3RyZWFtXG4gICAgLm9uKCdkYXRhJywgb25EYXRhKVxuICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuZGVzdHJveShlcnIpIH0pXG5cbiAgdmFyIGluZGV4ID0gMFxuICBmdW5jdGlvbiBvbkRhdGEgKGNodW5rKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzdG9yZS5wdXQoaW5kZXgsIGNodW5rKVxuICAgIGluZGV4ICs9IDFcbiAgfVxuXG4gIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHsgdGhpcy5fYmxvY2tzdHJlYW0uZW5kKCkgfSlcbn1cblxuQ2h1bmtTdG9yZVdyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB0aGlzLl9ibG9ja3N0cmVhbS53cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKVxufVxuXG5DaHVua1N0b3JlV3JpdGVTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIG51bWJlcnMpIHtcbiAgdmFyIGNsb3Nlc3QgPSBJbmZpbml0eVxuICB2YXIgZGlmZmVyZW5jZSA9IDBcbiAgdmFyIHdpbm5lciA9IG51bGxcblxuICBudW1iZXJzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhIC0gYlxuICB9KVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gbnVtYmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgIFxuICAgIGRpZmZlcmVuY2UgPSBNYXRoLmFicyh0YXJnZXQgLSBudW1iZXJzW2ldKVxuICAgIGlmIChkaWZmZXJlbmNlID49IGNsb3Nlc3QpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNsb3Nlc3QgPSBkaWZmZXJlbmNlXG4gICAgd2lubmVyID0gbnVtYmVyc1tpXVxuICB9XG5cbiAgcmV0dXJuIHdpbm5lclxufVxuIiwidmFyIGlwYWRkciA9IHJlcXVpcmUoJ2lwYWRkci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhY3Qyc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICBzd2l0Y2goYnVmLmxlbmd0aCkge1xuICBjYXNlIDY6XG4gICAgcmV0dXJuIGJ1ZlswXSArIFwiLlwiICsgYnVmWzFdICsgXCIuXCIgKyBidWZbMl0gKyBcIi5cIiArIGJ1ZlszXSArIFwiOlwiICsgYnVmLnJlYWRVSW50MTZCRSg0KTtcbiAgICBicmVhaztcbiAgY2FzZSAxODpcbiAgICB2YXIgaGV4R3JvdXBzID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgaGV4R3JvdXBzLnB1c2goYnVmLnJlYWRVSW50MTZCRShpICogMikudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgdmFyIGhvc3QgPSBpcGFkZHIucGFyc2UoaGV4R3JvdXBzLmpvaW4oXCI6XCIpKS50b1N0cmluZygpO1xuICAgIHJldHVybiBcIltcIiArIGhvc3QgKyBcIl06XCIgKyBidWYucmVhZFVJbnQxNkJFKDE2KTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENvbXBhY3QgSVAvUE9SVCwgSXQgc2hvdWxkIGNvbnRhaW4gNiBvciAxOCBieXRlc1wiKTtcbiAgfVxufTtcblxuY29tcGFjdDJzdHJpbmcubXVsdGkgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmKGJ1Zi5sZW5ndGggJSA2ICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZiBsZW5ndGggaXNuJ3QgbXVsdGlwbGUgb2YgY29tcGFjdCBJUC9QT1JUcyAoNiBieXRlcylcIik7XG5cbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBidWYubGVuZ3RoIC0gMTsgaSA9IGkgKyA2KSB7XG4gICAgb3V0cHV0LnB1c2goY29tcGFjdDJzdHJpbmcoYnVmLnNsaWNlKGksIGkgKyA2KSkpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmNvbXBhY3Qyc3RyaW5nLm11bHRpNiA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYoYnVmLmxlbmd0aCAlIDE4ICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZiBsZW5ndGggaXNuJ3QgbXVsdGlwbGUgb2YgY29tcGFjdCBJUDYvUE9SVHMgKDE4IGJ5dGVzKVwiKTtcblxuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGJ1Zi5sZW5ndGggLSAxOyBpID0gaSArIDE4KSB7XG4gICAgb3V0cHV0LnB1c2goY29tcGFjdDJzdHJpbmcoYnVmLnNsaWNlKGksIGkgKyAxOCkpKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUb3JyZW50XG5tb2R1bGUuZXhwb3J0cy5wYXJzZUlucHV0ID0gcGFyc2VJbnB1dFxuXG5tb2R1bGUuZXhwb3J0cy5hbm5vdW5jZUxpc3QgPSBbXG4gIFsgJ3VkcDovL3RyYWNrZXIub3BlbmJpdHRvcnJlbnQuY29tOjgwJyBdLFxuICBbICd1ZHA6Ly90cmFja2VyLmludGVybmV0d2FycmlvcnMubmV0OjEzMzcnIF0sXG4gIFsgJ3VkcDovL3RyYWNrZXIubGVlY2hlcnMtcGFyYWRpc2Uub3JnOjY5NjknIF0sXG4gIFsgJ3VkcDovL3RyYWNrZXIuY29wcGVyc3VyZmVyLnRrOjY5NjknIF0sXG4gIFsgJ3VkcDovL2V4b2R1cy5kZXN5bmMuY29tOjY5NjknIF0sXG4gIFsgJ3dzczovL3RyYWNrZXIud2VidG9ycmVudC5pbycgXSxcbiAgWyAnd3NzOi8vdHJhY2tlci5idG9ycmVudC54eXonIF0sXG4gIFsgJ3dzczovL3RyYWNrZXIub3BlbndlYnRvcnJlbnQuY29tJyBdLFxuICBbICd3c3M6Ly90cmFja2VyLmZhc3RjYXN0Lm56JyBdXG5dXG5cbnZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgQmxvY2tTdHJlYW0gPSByZXF1aXJlKCdibG9jay1zdHJlYW0yJylcbnZhciBjYWxjUGllY2VMZW5ndGggPSByZXF1aXJlKCdwaWVjZS1sZW5ndGgnKVxudmFyIGNvcmVQYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIEZpbGVSZWFkU3RyZWFtID0gcmVxdWlyZSgnZmlsZXN0cmVhbS9yZWFkJylcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnZmxhdHRlbicpXG52YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgaXNGaWxlID0gcmVxdWlyZSgnaXMtZmlsZScpXG52YXIganVuayA9IHJlcXVpcmUoJ2p1bmsnKVxudmFyIE11bHRpU3RyZWFtID0gcmVxdWlyZSgnbXVsdGlzdHJlYW0nKVxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbnZhciBwYXJhbGxlbCA9IHJlcXVpcmUoJ3J1bi1wYXJhbGxlbCcpXG52YXIgc2hhMSA9IHJlcXVpcmUoJ3NpbXBsZS1zaGExJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG4vKipcbiAqIENyZWF0ZSBhIHRvcnJlbnQuXG4gKiBAcGFyYW0gIHtzdHJpbmd8RmlsZXxGaWxlTGlzdHxCdWZmZXJ8U3RyZWFtfEFycmF5LjxzdHJpbmd8RmlsZXxCdWZmZXJ8U3RyZWFtPn0gaW5wdXRcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0c1xuICogQHBhcmFtICB7c3RyaW5nPX0gb3B0cy5uYW1lXG4gKiBAcGFyYW0gIHtEYXRlPX0gb3B0cy5jcmVhdGlvbkRhdGVcbiAqIEBwYXJhbSAge3N0cmluZz19IG9wdHMuY29tbWVudFxuICogQHBhcmFtICB7c3RyaW5nPX0gb3B0cy5jcmVhdGVkQnlcbiAqIEBwYXJhbSAge2Jvb2xlYW58bnVtYmVyPX0gb3B0cy5wcml2YXRlXG4gKiBAcGFyYW0gIHtudW1iZXI9fSBvcHRzLnBpZWNlTGVuZ3RoXG4gKiBAcGFyYW0gIHtBcnJheS48QXJyYXkuPHN0cmluZz4+PX0gb3B0cy5hbm5vdW5jZUxpc3RcbiAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+PX0gb3B0cy51cmxMaXN0XG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2JcbiAqIEByZXR1cm4ge0J1ZmZlcn0gYnVmZmVyIG9mIC50b3JyZW50IGZpbGUgZGF0YVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb3JyZW50IChpbnB1dCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gY3JlYXRlVG9ycmVudChpbnB1dCwgbnVsbCwgb3B0cylcbiAgb3B0cyA9IG9wdHMgPyBleHRlbmQob3B0cykgOiB7fVxuXG4gIF9wYXJzZUlucHV0KGlucHV0LCBvcHRzLCBmdW5jdGlvbiAoZXJyLCBmaWxlcywgc2luZ2xlRmlsZVRvcnJlbnQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIG9wdHMuc2luZ2xlRmlsZVRvcnJlbnQgPSBzaW5nbGVGaWxlVG9ycmVudFxuICAgIG9uRmlsZXMoZmlsZXMsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUlucHV0IChpbnB1dCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gcGFyc2VJbnB1dChpbnB1dCwgbnVsbCwgb3B0cylcbiAgb3B0cyA9IG9wdHMgPyBleHRlbmQob3B0cykgOiB7fVxuICBfcGFyc2VJbnB1dChpbnB1dCwgb3B0cywgY2IpXG59XG5cbi8qKlxuICogUGFyc2UgaW5wdXQgZmlsZSBhbmQgcmV0dXJuIGZpbGUgaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIF9wYXJzZUlucHV0IChpbnB1dCwgb3B0cywgY2IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHR5cGUnKVxuXG4gIGlmIChpc0ZpbGVMaXN0KGlucHV0KSkgaW5wdXQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbnB1dClcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkgaW5wdXQgPSBbIGlucHV0IF1cblxuICAvLyBJbiBFbGVjdHJvbiwgdXNlIHRoZSB0cnVlIGZpbGUgcGF0aFxuICBpbnB1dCA9IGlucHV0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpc0Jsb2IoaXRlbSkgJiYgdHlwZW9mIGl0ZW0ucGF0aCA9PT0gJ3N0cmluZycpIHJldHVybiBpdGVtLnBhdGhcbiAgICByZXR1cm4gaXRlbVxuICB9KVxuXG4gIC8vIElmIHRoZXJlJ3MganVzdCBvbmUgZmlsZSwgYWxsb3cgdGhlIG5hbWUgdG8gYmUgc2V0IGJ5IGBvcHRzLm5hbWVgXG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJyAmJiAhaW5wdXRbMF0ubmFtZSkgaW5wdXRbMF0ubmFtZSA9IG9wdHMubmFtZVxuXG4gIHZhciBjb21tb25QcmVmaXggPSBudWxsXG4gIGlucHV0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IGl0ZW0uZnVsbFBhdGggfHwgaXRlbS5uYW1lXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBwYXRoID0gJ1Vua25vd24gRmlsZSAnICsgKGkgKyAxKVxuICAgICAgaXRlbS51bmtub3duTmFtZSA9IHRydWVcbiAgICB9XG5cbiAgICBpdGVtLnBhdGggPSBwYXRoLnNwbGl0KCcvJylcblxuICAgIC8vIFJlbW92ZSBpbml0aWFsIHNsYXNoXG4gICAgaWYgKCFpdGVtLnBhdGhbMF0pIHtcbiAgICAgIGl0ZW0ucGF0aC5zaGlmdCgpXG4gICAgfVxuXG4gICAgaWYgKGl0ZW0ucGF0aC5sZW5ndGggPCAyKSB7IC8vIE5vIHJlYWwgcHJlZml4XG4gICAgICBjb21tb25QcmVmaXggPSBudWxsXG4gICAgfSBlbHNlIGlmIChpID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEpIHsgLy8gVGhlIGZpcnN0IGZpbGUgaGFzIGEgcHJlZml4XG4gICAgICBjb21tb25QcmVmaXggPSBpdGVtLnBhdGhbMF1cbiAgICB9IGVsc2UgaWYgKGl0ZW0ucGF0aFswXSAhPT0gY29tbW9uUHJlZml4KSB7IC8vIFRoZSBwcmVmaXggZG9lc24ndCBtYXRjaFxuICAgICAgY29tbW9uUHJlZml4ID0gbnVsbFxuICAgIH1cbiAgfSlcblxuICAvLyByZW1vdmUganVuayBmaWxlc1xuICBpbnB1dCA9IGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHZhciBmaWxlbmFtZSA9IGl0ZW0ucGF0aFtpdGVtLnBhdGgubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gbm90SGlkZGVuKGZpbGVuYW1lKSAmJiBqdW5rLm5vdChmaWxlbmFtZSlcbiAgfSlcblxuICBpZiAoY29tbW9uUHJlZml4KSB7XG4gICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHBhdGhsZXNzID0gKEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSB8fCBpc1JlYWRhYmxlKGl0ZW0pKSAmJiAhaXRlbS5wYXRoXG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIHx8IHBhdGhsZXNzKSByZXR1cm5cbiAgICAgIGl0ZW0ucGF0aC5zaGlmdCgpXG4gICAgfSlcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lICYmIGNvbW1vblByZWZpeCkge1xuICAgIG9wdHMubmFtZSA9IGNvbW1vblByZWZpeFxuICB9XG5cbiAgaWYgKCFvcHRzLm5hbWUpIHtcbiAgICAvLyB1c2UgZmlyc3QgdXNlci1zZXQgZmlsZSBuYW1lXG4gICAgaW5wdXQuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRzLm5hbWUgPSBjb3JlUGF0aC5iYXNlbmFtZShpdGVtKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICghaXRlbS51bmtub3duTmFtZSkge1xuICAgICAgICBvcHRzLm5hbWUgPSBpdGVtLnBhdGhbaXRlbS5wYXRoLmxlbmd0aCAtIDFdXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGlmICghb3B0cy5uYW1lKSB7XG4gICAgb3B0cy5uYW1lID0gJ1VubmFtZWQgVG9ycmVudCAnICsgRGF0ZS5ub3coKVxuICB9XG5cbiAgdmFyIG51bVBhdGhzID0gaW5wdXQucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGl0ZW0pIHtcbiAgICByZXR1cm4gc3VtICsgTnVtYmVyKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJylcbiAgfSwgMClcblxuICB2YXIgaXNTaW5nbGVGaWxlVG9ycmVudCA9IChpbnB1dC5sZW5ndGggPT09IDEpXG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgaW5wdXRbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBmcy5zdGF0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVzeXN0ZW0gcGF0aHMgZG8gbm90IHdvcmsgaW4gdGhlIGJyb3dzZXInKVxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIGEgc2luZ2xlIHBhdGgsIHZlcmlmeSBpdCdzIGEgZmlsZSBiZWZvcmUgZGVjaWRpbmcgdGhpcyBpcyBhIHNpbmdsZVxuICAgIC8vIGZpbGUgdG9ycmVudFxuICAgIGlzRmlsZShpbnB1dFswXSwgZnVuY3Rpb24gKGVyciwgcGF0aElzRmlsZSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlzU2luZ2xlRmlsZVRvcnJlbnQgPSBwYXRoSXNGaWxlXG4gICAgICBwcm9jZXNzSW5wdXQoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzSW5wdXQoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSW5wdXQgKCkge1xuICAgIHBhcmFsbGVsKGlucHV0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgZmlsZSA9IHt9XG5cbiAgICAgICAgaWYgKGlzQmxvYihpdGVtKSkge1xuICAgICAgICAgIGZpbGUuZ2V0U3RyZWFtID0gZ2V0QmxvYlN0cmVhbShpdGVtKVxuICAgICAgICAgIGZpbGUubGVuZ3RoID0gaXRlbS5zaXplXG4gICAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSB7XG4gICAgICAgICAgZmlsZS5nZXRTdHJlYW0gPSBnZXRCdWZmZXJTdHJlYW0oaXRlbSlcbiAgICAgICAgICBmaWxlLmxlbmd0aCA9IGl0ZW0ubGVuZ3RoXG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWFkYWJsZShpdGVtKSkge1xuICAgICAgICAgIGZpbGUuZ2V0U3RyZWFtID0gZ2V0U3RyZWFtU3RyZWFtKGl0ZW0sIGZpbGUpXG4gICAgICAgICAgZmlsZS5sZW5ndGggPSAwXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmcy5zdGF0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVzeXN0ZW0gcGF0aHMgZG8gbm90IHdvcmsgaW4gdGhlIGJyb3dzZXInKVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIga2VlcFJvb3QgPSBudW1QYXRocyA+IDEgfHwgaXNTaW5nbGVGaWxlVG9ycmVudFxuICAgICAgICAgIGdldEZpbGVzKGl0ZW0sIGtlZXBSb290LCBjYilcbiAgICAgICAgICByZXR1cm4gLy8gZWFybHkgcmV0dXJuIVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0eXBlJylcbiAgICAgICAgfVxuICAgICAgICBmaWxlLnBhdGggPSBpdGVtLnBhdGhcbiAgICAgICAgY2IobnVsbCwgZmlsZSlcbiAgICAgIH1cbiAgICB9KSwgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBmaWxlcyA9IGZsYXR0ZW4oZmlsZXMpXG4gICAgICBjYihudWxsLCBmaWxlcywgaXNTaW5nbGVGaWxlVG9ycmVudClcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVzIChwYXRoLCBrZWVwUm9vdCwgY2IpIHtcbiAgdHJhdmVyc2VQYXRoKHBhdGgsIGdldEZpbGVJbmZvLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxlcykpIGZpbGVzID0gZmxhdHRlbihmaWxlcylcbiAgICBlbHNlIGZpbGVzID0gWyBmaWxlcyBdXG5cbiAgICBwYXRoID0gY29yZVBhdGgubm9ybWFsaXplKHBhdGgpXG4gICAgaWYgKGtlZXBSb290KSB7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBwYXRoLmxhc3RJbmRleE9mKGNvcmVQYXRoLnNlcCkgKyAxKVxuICAgIH1cbiAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdICE9PSBjb3JlUGF0aC5zZXApIHBhdGggKz0gY29yZVBhdGguc2VwXG5cbiAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBmaWxlLmdldFN0cmVhbSA9IGdldEZpbGVQYXRoU3RyZWFtKGZpbGUucGF0aClcbiAgICAgIGZpbGUucGF0aCA9IGZpbGUucGF0aC5yZXBsYWNlKHBhdGgsICcnKS5zcGxpdChjb3JlUGF0aC5zZXApXG4gICAgfSlcbiAgICBjYihudWxsLCBmaWxlcylcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZUluZm8gKHBhdGgsIGNiKSB7XG4gIGNiID0gb25jZShjYilcbiAgZnMuc3RhdChwYXRoLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIGxlbmd0aDogc3RhdC5zaXplLFxuICAgICAgcGF0aDogcGF0aFxuICAgIH1cbiAgICBjYihudWxsLCBpbmZvKVxuICB9KVxufVxuXG5mdW5jdGlvbiB0cmF2ZXJzZVBhdGggKHBhdGgsIGZuLCBjYikge1xuICBmcy5yZWFkZGlyKHBhdGgsIGZ1bmN0aW9uIChlcnIsIGVudHJpZXMpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRU5PVERJUicpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBmaWxlXG4gICAgICBmbihwYXRoLCBjYilcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgLy8gcmVhbCBlcnJvclxuICAgICAgY2IoZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIGEgZm9sZGVyXG4gICAgICBwYXJhbGxlbChlbnRyaWVzLmZpbHRlcihub3RIaWRkZW4pLmZpbHRlcihqdW5rLm5vdCkubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgdHJhdmVyc2VQYXRoKGNvcmVQYXRoLmpvaW4ocGF0aCwgZW50cnkpLCBmbiwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pLCBjYilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5vdEhpZGRlbiAoZmlsZSkge1xuICByZXR1cm4gZmlsZVswXSAhPT0gJy4nXG59XG5cbmZ1bmN0aW9uIGdldFBpZWNlTGlzdCAoZmlsZXMsIHBpZWNlTGVuZ3RoLCBjYikge1xuICBjYiA9IG9uY2UoY2IpXG4gIHZhciBwaWVjZXMgPSBbXVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIHZhciBzdHJlYW1zID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIGZpbGUuZ2V0U3RyZWFtXG4gIH0pXG5cbiAgdmFyIHJlbWFpbmluZ0hhc2hlcyA9IDBcbiAgdmFyIHBpZWNlTnVtID0gMFxuICB2YXIgZW5kZWQgPSBmYWxzZVxuXG4gIHZhciBtdWx0aXN0cmVhbSA9IG5ldyBNdWx0aVN0cmVhbShzdHJlYW1zKVxuICB2YXIgYmxvY2tzdHJlYW0gPSBuZXcgQmxvY2tTdHJlYW0ocGllY2VMZW5ndGgsIHsgemVyb1BhZGRpbmc6IGZhbHNlIH0pXG5cbiAgbXVsdGlzdHJlYW0ub24oJ2Vycm9yJywgb25FcnJvcilcblxuICBtdWx0aXN0cmVhbVxuICAgIC5waXBlKGJsb2Nrc3RyZWFtKVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2VuZCcsIG9uRW5kKVxuICAgIC5vbignZXJyb3InLCBvbkVycm9yKVxuXG4gIGZ1bmN0aW9uIG9uRGF0YSAoY2h1bmspIHtcbiAgICBsZW5ndGggKz0gY2h1bmsubGVuZ3RoXG5cbiAgICB2YXIgaSA9IHBpZWNlTnVtXG4gICAgc2hhMShjaHVuaywgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHBpZWNlc1tpXSA9IGhhc2hcbiAgICAgIHJlbWFpbmluZ0hhc2hlcyAtPSAxXG4gICAgICBtYXliZURvbmUoKVxuICAgIH0pXG4gICAgcmVtYWluaW5nSGFzaGVzICs9IDFcbiAgICBwaWVjZU51bSArPSAxXG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZCAoKSB7XG4gICAgZW5kZWQgPSB0cnVlXG4gICAgbWF5YmVEb25lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IgKGVycikge1xuICAgIGNsZWFudXAoKVxuICAgIGNiKGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIG11bHRpc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgYmxvY2tzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpXG4gICAgYmxvY2tzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKVxuICAgIGJsb2Nrc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gIH1cblxuICBmdW5jdGlvbiBtYXliZURvbmUgKCkge1xuICAgIGlmIChlbmRlZCAmJiByZW1haW5pbmdIYXNoZXMgPT09IDApIHtcbiAgICAgIGNsZWFudXAoKVxuICAgICAgY2IobnVsbCwgbmV3IEJ1ZmZlcihwaWVjZXMuam9pbignJyksICdoZXgnKSwgbGVuZ3RoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkZpbGVzIChmaWxlcywgb3B0cywgY2IpIHtcbiAgdmFyIGFubm91bmNlTGlzdCA9IG9wdHMuYW5ub3VuY2VMaXN0XG5cbiAgaWYgKCFhbm5vdW5jZUxpc3QpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMuYW5ub3VuY2UgPT09ICdzdHJpbmcnKSBhbm5vdW5jZUxpc3QgPSBbIFsgb3B0cy5hbm5vdW5jZSBdIF1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdHMuYW5ub3VuY2UpKSB7XG4gICAgICBhbm5vdW5jZUxpc3QgPSBvcHRzLmFubm91bmNlLm1hcChmdW5jdGlvbiAodSkgeyByZXR1cm4gWyB1IF0gfSlcbiAgICB9XG4gIH1cblxuICBpZiAoIWFubm91bmNlTGlzdCkgYW5ub3VuY2VMaXN0ID0gW11cblxuICBpZiAoZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFID09PSAnc3RyaW5nJykge1xuICAgICAgYW5ub3VuY2VMaXN0LnB1c2goWyBbIGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFIF0gXSlcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UpKSB7XG4gICAgICBhbm5vdW5jZUxpc3QgPSBhbm5vdW5jZUxpc3QuY29uY2F0KGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFLm1hcChmdW5jdGlvbiAodSkge1xuICAgICAgICByZXR1cm4gWyB1IF1cbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gbm8gdHJhY2tlcnMgc3BlY2lmaWVkLCB1c2Ugc29tZSByZWFzb25hYmxlIGRlZmF1bHRzXG4gIGlmIChvcHRzLmFubm91bmNlID09PSB1bmRlZmluZWQgJiYgb3B0cy5hbm5vdW5jZUxpc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGFubm91bmNlTGlzdCA9IGFubm91bmNlTGlzdC5jb25jYXQobW9kdWxlLmV4cG9ydHMuYW5ub3VuY2VMaXN0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzLnVybExpc3QgPT09ICdzdHJpbmcnKSBvcHRzLnVybExpc3QgPSBbIG9wdHMudXJsTGlzdCBdXG5cbiAgdmFyIHRvcnJlbnQgPSB7XG4gICAgaW5mbzoge1xuICAgICAgbmFtZTogb3B0cy5uYW1lXG4gICAgfSxcbiAgICAnY3JlYXRpb24gZGF0ZSc6IE1hdGguY2VpbCgoTnVtYmVyKG9wdHMuY3JlYXRpb25EYXRlKSB8fCBEYXRlLm5vdygpKSAvIDEwMDApLFxuICAgIGVuY29kaW5nOiAnVVRGLTgnXG4gIH1cblxuICBpZiAoYW5ub3VuY2VMaXN0Lmxlbmd0aCAhPT0gMCkge1xuICAgIHRvcnJlbnQuYW5ub3VuY2UgPSBhbm5vdW5jZUxpc3RbMF1bMF1cbiAgICB0b3JyZW50Wydhbm5vdW5jZS1saXN0J10gPSBhbm5vdW5jZUxpc3RcbiAgfVxuXG4gIGlmIChvcHRzLmNvbW1lbnQgIT09IHVuZGVmaW5lZCkgdG9ycmVudC5jb21tZW50ID0gb3B0cy5jb21tZW50XG5cbiAgaWYgKG9wdHMuY3JlYXRlZEJ5ICE9PSB1bmRlZmluZWQpIHRvcnJlbnRbJ2NyZWF0ZWQgYnknXSA9IG9wdHMuY3JlYXRlZEJ5XG5cbiAgaWYgKG9wdHMucHJpdmF0ZSAhPT0gdW5kZWZpbmVkKSB0b3JyZW50LmluZm8ucHJpdmF0ZSA9IE51bWJlcihvcHRzLnByaXZhdGUpXG5cbiAgLy8gXCJzc2wtY2VydFwiIGtleSBpcyBmb3IgU1NMIHRvcnJlbnRzLCBzZWU6XG4gIC8vICAgLSBodHRwOi8vYmxvZy5saWJ0b3JyZW50Lm9yZy8yMDEyLzAxL2JpdHRvcnJlbnQtb3Zlci1zc2wvXG4gIC8vICAgLSBodHRwOi8vd3d3LmxpYnRvcnJlbnQub3JnL21hbnVhbC1yZWYuaHRtbCNzc2wtdG9ycmVudHNcbiAgLy8gICAtIGh0dHA6Ly93d3cubGlidG9ycmVudC5vcmcvcmVmZXJlbmNlLUNyZWF0ZV9Ub3JyZW50cy5odG1sXG4gIGlmIChvcHRzLnNzbENlcnQgIT09IHVuZGVmaW5lZCkgdG9ycmVudC5pbmZvWydzc2wtY2VydCddID0gb3B0cy5zc2xDZXJ0XG5cbiAgaWYgKG9wdHMudXJsTGlzdCAhPT0gdW5kZWZpbmVkKSB0b3JyZW50Wyd1cmwtbGlzdCddID0gb3B0cy51cmxMaXN0XG5cbiAgdmFyIHBpZWNlTGVuZ3RoID0gb3B0cy5waWVjZUxlbmd0aCB8fCBjYWxjUGllY2VMZW5ndGgoZmlsZXMucmVkdWNlKHN1bUxlbmd0aCwgMCkpXG4gIHRvcnJlbnQuaW5mb1sncGllY2UgbGVuZ3RoJ10gPSBwaWVjZUxlbmd0aFxuXG4gIGdldFBpZWNlTGlzdChmaWxlcywgcGllY2VMZW5ndGgsIGZ1bmN0aW9uIChlcnIsIHBpZWNlcywgdG9ycmVudExlbmd0aCkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgdG9ycmVudC5pbmZvLnBpZWNlcyA9IHBpZWNlc1xuXG4gICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgZGVsZXRlIGZpbGUuZ2V0U3RyZWFtXG4gICAgfSlcblxuICAgIGlmIChvcHRzLnNpbmdsZUZpbGVUb3JyZW50KSB7XG4gICAgICB0b3JyZW50LmluZm8ubGVuZ3RoID0gdG9ycmVudExlbmd0aFxuICAgIH0gZWxzZSB7XG4gICAgICB0b3JyZW50LmluZm8uZmlsZXMgPSBmaWxlc1xuICAgIH1cblxuICAgIGNiKG51bGwsIGJlbmNvZGUuZW5jb2RlKHRvcnJlbnQpKVxuICB9KVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdG9yIHRvIHN1bSBmaWxlIGxlbmd0aHNcbiAqIEBwYXJhbSAge251bWJlcn0gc3VtXG4gKiBAcGFyYW0gIHtPYmplY3R9IGZpbGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc3VtTGVuZ3RoIChzdW0sIGZpbGUpIHtcbiAgcmV0dXJuIHN1bSArIGZpbGUubGVuZ3RoXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBXM0MgYEJsb2JgIG9iamVjdCAod2hpY2ggYEZpbGVgIGluaGVyaXRzIGZyb20pXG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQmxvYiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgQmxvYlxufVxuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVzNDIGBGaWxlTGlzdGAgb2JqZWN0XG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmlsZUxpc3QgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIEZpbGVMaXN0ID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEZpbGVMaXN0XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBub2RlIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBgRmlsZWAgdG8gYSBsYXp5IHJlYWRhYmxlIHN0cmVhbS5cbiAqIEBwYXJhbSAge0ZpbGV8QmxvYn0gZmlsZVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEJsb2JTdHJlYW0gKGZpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEZpbGVSZWFkU3RyZWFtKGZpbGUpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgYEJ1ZmZlcmAgdG8gYSBsYXp5IHJlYWRhYmxlIHN0cmVhbS5cbiAqIEBwYXJhbSAge0J1ZmZlcn0gYnVmZmVyXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0QnVmZmVyU3RyZWFtIChidWZmZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goKVxuICAgIHMuZW5kKGJ1ZmZlcilcbiAgICByZXR1cm4gc1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIGZpbGUgcGF0aCB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsZVBhdGhTdHJlYW0gKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoKVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHJlYWRhYmxlIHN0cmVhbSB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLiBBZGRzIGluc3RydW1lbnRhdGlvbiB0byB0cmFja1xuICogdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgc3RyZWFtIGFuZCBzZXQgYGZpbGUubGVuZ3RoYC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJlYW19IHN0cmVhbVxuICogQHBhcmFtICB7T2JqZWN0fSBmaWxlXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyZWFtU3RyZWFtIChyZWFkYWJsZSwgZmlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb3VudGVyID0gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oKVxuICAgIGNvdW50ZXIuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChidWYsIGVuYywgZG9uZSkge1xuICAgICAgZmlsZS5sZW5ndGggKz0gYnVmLmxlbmd0aFxuICAgICAgdGhpcy5wdXNoKGJ1ZilcbiAgICAgIGRvbmUoKVxuICAgIH1cbiAgICByZWFkYWJsZS5waXBlKGNvdW50ZXIpXG4gICAgcmV0dXJuIGNvdW50ZXJcbiAgfVxufVxuIiwidmFyIGJlbmNvZGUgPSBtb2R1bGUuZXhwb3J0c1xuXG5iZW5jb2RlLmVuY29kZSA9IHJlcXVpcmUoICcuL2xpYi9lbmNvZGUnIClcbmJlbmNvZGUuZGVjb2RlID0gcmVxdWlyZSggJy4vbGliL2RlY29kZScgKVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGFtb3VudCBvZiBieXRlc1xuICogbmVlZGVkIHRvIGVuY29kZSB0aGUgZ2l2ZW4gdmFsdWVcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcnxCb29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfSBieXRlQ291bnRcbiAqL1xuYmVuY29kZS5ieXRlTGVuZ3RoID0gYmVuY29kZS5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKCB2YWx1ZSApLmxlbmd0aFxufVxuIiwidmFyIERpY3QgPSByZXF1aXJlKFwiLi9kaWN0XCIpXG5cbi8qKlxuICogRGVjb2RlcyBiZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcn0gZGF0YVxuICogQHBhcmFtICB7TnVtYmVyfSBzdGFydCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGVuY29kaW5nIChvcHRpb25hbClcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKCBkYXRhLCBzdGFydCwgZW5kLCBlbmNvZGluZyApIHtcbiAgXG4gIGlmKCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBzdGFydFxuICAgIHN0YXJ0ID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGlmKCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gZW5kXG4gICAgZW5kID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gISggQnVmZmVyLmlzQnVmZmVyKGRhdGEpIClcbiAgICA/IG5ldyBCdWZmZXIoIGRhdGEgKVxuICAgIDogZGF0YS5zbGljZSggc3RhcnQsIGVuZCApXG4gIFxuICBkZWNvZGUuYnl0ZXMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgXG4gIHJldHVybiBkZWNvZGUubmV4dCgpXG5cbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgICAgID0gbnVsbFxuZGVjb2RlLmVuY29kaW5nID0gbnVsbFxuXG5kZWNvZGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gIHN3aXRjaCggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSApIHtcbiAgICBjYXNlIDB4NjQ6IHJldHVybiBkZWNvZGUuZGljdGlvbmFyeSgpOyBicmVha1xuICAgIGNhc2UgMHg2QzogcmV0dXJuIGRlY29kZS5saXN0KCk7IGJyZWFrXG4gICAgY2FzZSAweDY5OiByZXR1cm4gZGVjb2RlLmludGVnZXIoKTsgYnJlYWtcbiAgICBkZWZhdWx0OiAgIHJldHVybiBkZWNvZGUuYnVmZmVyKCk7IGJyZWFrXG4gIH1cblxufVxuXG5kZWNvZGUuZmluZCA9IGZ1bmN0aW9uKCBjaHIgKSB7XG5cbiAgdmFyIGkgPSBkZWNvZGUucG9zaXRpb25cbiAgdmFyIGMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgdmFyIGQgPSBkZWNvZGUuZGF0YVxuXG4gIHdoaWxlKCBpIDwgYyApIHtcbiAgICBpZiggZFtpXSA9PT0gY2hyIClcbiAgICAgIHJldHVybiBpXG4gICAgaSsrXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0ludmFsaWQgZGF0YTogTWlzc2luZyBkZWxpbWl0ZXIgXCInICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaHIgKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoIDE2ICkgKyAnXSdcbiAgKVxuXG59XG5cbmRlY29kZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgZGljdCA9IG5ldyBEaWN0KClcblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBkaWN0LmJpbmFyeVNldChkZWNvZGUuYnVmZmVyKCksIGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBkaWN0XG5cbn1cblxuZGVjb2RlLmxpc3QgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBsc3QgPSBbXVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGxzdC5wdXNoKCBkZWNvZGUubmV4dCgpIClcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGxzdFxuXG59XG5cbmRlY29kZS5pbnRlZ2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGVuZCAgICA9IGRlY29kZS5maW5kKCAweDY1IClcbiAgdmFyIG51bWJlciA9IGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24gKyAxLCBlbmQgKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KCBudW1iZXIsIDEwIClcblxufVxuXG5kZWNvZGUuYnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNlcCAgICA9IGRlY29kZS5maW5kKCAweDNBIClcbiAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXAgKSwgMTAgKVxuICB2YXIgZW5kICAgID0gKytzZXAgKyBsZW5ndGhcblxuICBkZWNvZGUucG9zaXRpb24gPSBlbmRcblxuICByZXR1cm4gZGVjb2RlLmVuY29kaW5nXG4gICAgPyBkZWNvZGUuZGF0YS50b1N0cmluZyggZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZCApXG4gICAgOiBkZWNvZGUuZGF0YS5zbGljZSggc2VwLCBlbmQgKVxuXG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlXG4iLCJ2YXIgRGljdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGljdCgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBbXSxcbiAgfSlcbn1cblxuRGljdC5wcm90b3R5cGUuYmluYXJ5S2V5cyA9IGZ1bmN0aW9uIGJpbmFyeUtleXMoKSB7XG4gIHJldHVybiB0aGlzLl9rZXlzLnNsaWNlKClcbn1cblxuRGljdC5wcm90b3R5cGUuYmluYXJ5U2V0ID0gZnVuY3Rpb24gYmluYXJ5U2V0KGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fa2V5cy5wdXNoKGtleSlcblxuICB0aGlzW2tleV0gPSB2YWx1ZVxufVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUoIGRhdGEsIGJ1ZmZlciwgb2Zmc2V0ICkge1xuICBcbiAgdmFyIGJ1ZmZlcnMgPSBbXVxuICB2YXIgcmVzdWx0ID0gbnVsbFxuICBcbiAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGEgKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KCBidWZmZXJzIClcbiAgZW5jb2RlLmJ5dGVzID0gcmVzdWx0Lmxlbmd0aFxuICBcbiAgaWYoIEJ1ZmZlci5pc0J1ZmZlciggYnVmZmVyICkgKSB7XG4gICAgcmVzdWx0LmNvcHkoIGJ1ZmZlciwgb2Zmc2V0IClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRcbiAgXG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBpZiggQnVmZmVyLmlzQnVmZmVyKGRhdGEpICkge1xuICAgIGJ1ZmZlcnMucHVzaChuZXcgQnVmZmVyKGRhdGEubGVuZ3RoICsgJzonKSlcbiAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2goIHR5cGVvZiBkYXRhICkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBkYXRhIClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlcbiAgICAgICAgPyBlbmNvZGUubGlzdCggYnVmZmVycywgZGF0YSApXG4gICAgICAgIDogZW5jb2RlLmRpY3QoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgPyAxIDogMCApXG4gICAgICBicmVha1xuICB9XG5cbn1cblxudmFyIGJ1ZmZfZSA9IG5ldyBCdWZmZXIoJ2UnKVxuICAsIGJ1ZmZfZCA9IG5ldyBCdWZmZXIoJ2QnKVxuICAsIGJ1ZmZfbCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKEJ1ZmZlci5ieXRlTGVuZ3RoKCBkYXRhICkgKyAnOicgKyBkYXRhKSApXG59XG5cbmVuY29kZS5udW1iZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcbiAgdmFyIG1heExvID0gMHg4MDAwMDAwMFxuICB2YXIgaGkgPSAoIGRhdGEgLyBtYXhMbyApIDw8IDBcbiAgdmFyIGxvID0gKCBkYXRhICUgbWF4TG8gICkgPDwgMFxuICB2YXIgdmFsID0gaGkgKiBtYXhMbyArIGxvXG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKCAnaScgKyB2YWwgKyAnZScgKSlcblxuICBpZiggdmFsICE9PSBkYXRhICYmICFlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkICkge1xuICAgIGVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSB0cnVlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dBUk5JTkc6IFBvc3NpYmxlIGRhdGEgY29ycnVwdGlvbiBkZXRlY3RlZCB3aXRoIHZhbHVlIFwiJytkYXRhKydcIjonLFxuICAgICAgJ0JlbmNvZGluZyBvbmx5IGRlZmluZXMgc3VwcG9ydCBmb3IgaW50ZWdlcnMsIHZhbHVlIHdhcyBjb252ZXJ0ZWQgdG8gXCInK3ZhbCsnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG5cbn1cblxuZW5jb2RlLmRpY3QgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZCApXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG4gIC8vIGZpeCBmb3IgaXNzdWUgIzEzIC0gc29ydGVkIGRpY3RzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGRhdGEgKS5zb3J0KClcbiAgdmFyIGtsID0ga2V5cy5sZW5ndGhcblxuICBmb3IoIDsgaiA8IGtsIDsgaisrKSB7XG4gICAgaz1rZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlciggYnVmZmVycywgayApXG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFba10gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxufVxuXG5lbmNvZGUubGlzdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIHZhciBpID0gMCwgaiA9IDFcbiAgdmFyIGMgPSBkYXRhLmxlbmd0aFxuICBidWZmZXJzLnB1c2goIGJ1ZmZfbCApXG5cbiAgZm9yKCA7IGkgPCBjOyBpKysgKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFbaV0gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxuXG59XG5cbi8vIEV4cG9zZVxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbn07XG4iLCJ2YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDaGlsZFByb2Nlc3MgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gM1xufTtcblxudmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG5cdGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG5cdGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcblxuXHR2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cdHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblx0dmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCAob3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlKTtcblx0dmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCAob3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlKTtcblxuXHR2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcblx0fTtcblxuXHR2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHR3cml0YWJsZSA9IGZhbHNlO1xuXHRcdGlmICghcmVhZGFibGUpIGNhbGxiYWNrKCk7XG5cdH07XG5cblx0dmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVhZGFibGUgPSBmYWxzZTtcblx0XHRpZiAoIXdyaXRhYmxlKSBjYWxsYmFjaygpO1xuXHR9O1xuXG5cdHZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkge1xuXHRcdGNhbGxiYWNrKGV4aXRDb2RlID8gbmV3IEVycm9yKCdleGl0ZWQgd2l0aCBlcnJvciBjb2RlOiAnICsgZXhpdENvZGUpIDogbnVsbCk7XG5cdH07XG5cblx0dmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocmVhZGFibGUgJiYgIShycyAmJiBycy5lbmRlZCkpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0XHRpZiAod3JpdGFibGUgJiYgISh3cyAmJiB3cy5lbmRlZCkpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0fTtcblxuXHR2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0c3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHR9O1xuXG5cdGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuXHRcdHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtcblx0XHRlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdzKSB7IC8vIGxlZ2FjeSBzdHJlYW1zXG5cdFx0c3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0fVxuXG5cdGlmIChpc0NoaWxkUHJvY2VzcyhzdHJlYW0pKSBzdHJlYW0ub24oJ2V4aXQnLCBvbmV4aXQpO1xuXG5cdHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuXHRzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0aWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuXHRzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uZXhpdCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNhbGxiYWNrKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJ2YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgcmVFeHRlbnNpb24gPSAvXi4qXFwuKFxcdyspJC87XG52YXIgdG9CdWZmZXIgPSByZXF1aXJlKCd0eXBlZGFycmF5LXRvLWJ1ZmZlcicpO1xuXG5mdW5jdGlvbiBGaWxlUmVhZFN0cmVhbShmaWxlLCBvcHRzKSB7XG4gIHZhciByZWFkU3RyZWFtID0gdGhpcztcbiAgaWYgKCEgKHRoaXMgaW5zdGFuY2VvZiBGaWxlUmVhZFN0cmVhbSkpIHtcbiAgICByZXR1cm4gbmV3IEZpbGVSZWFkU3RyZWFtKGZpbGUsIG9wdHMpO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIC8vIGluaGVyaXQgcmVhZGFibGVcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAvLyBzYXZlIHRoZSByZWFkIG9mZnNldFxuICB0aGlzLl9vZmZzZXQgPSAwO1xuICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICB0aGlzLl9maWxlID0gZmlsZTtcbiAgdGhpcy5fc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgdGhpcy5fY2h1bmtTaXplID0gb3B0cy5jaHVua1NpemUgfHwgTWF0aC5tYXgodGhpcy5fc2l6ZSAvIDEwMDAsIDIwMCAqIDEwMjQpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgcmVhZGVyXG4gIHRoaXMucmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAvLyBnZW5lcmF0ZSB0aGUgaGVhZGVyIGJsb2NrcyB0aGF0IHdlIHdpbGwgc2VuZCBhcyBwYXJ0IG9mIHRoZSBpbml0aWFsIHBheWxvYWRcbiAgdGhpcy5fZ2VuZXJhdGVIZWFkZXJCbG9ja3MoZmlsZSwgb3B0cywgZnVuY3Rpb24oZXJyLCBibG9ja3MpIHtcbiAgICAvLyBpZiB3ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciwgZW1pdCBpdFxuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG5cbiAgICAvLyBwdXNoIHRoZSBoZWFkZXIgYmxvY2tzIG91dCB0byB0aGUgc3RyZWFtXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2tzKSkge1xuICAgICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHJlYWRTdHJlYW0ucHVzaChibG9jayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZWFkU3RyZWFtLl9yZWFkeSA9IHRydWU7XG4gICAgcmVhZFN0cmVhbS5lbWl0KCdfcmVhZHknKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEZpbGVSZWFkU3RyZWFtLCBSZWFkYWJsZSk7XG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVSZWFkU3RyZWFtO1xuXG5GaWxlUmVhZFN0cmVhbS5wcm90b3R5cGUuX2dlbmVyYXRlSGVhZGVyQmxvY2tzID0gZnVuY3Rpb24oZmlsZSwgb3B0cywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgW10pO1xufTtcblxuRmlsZVJlYWRTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmVhZHkpIHtcbiAgICB0aGlzLm9uY2UoJ19yZWFkeScsIHRoaXMuX3JlYWQuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWFkU3RyZWFtID0gdGhpcztcbiAgdmFyIHJlYWRlciA9IHRoaXMucmVhZGVyO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgdmFyIGVuZE9mZnNldCA9IHRoaXMuX29mZnNldCArIHRoaXMuX2NodW5rU2l6ZTtcbiAgaWYgKGVuZE9mZnNldCA+IHRoaXMuX3NpemUpIGVuZE9mZnNldCA9IHRoaXMuX3NpemU7XG5cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSB0aGlzLl9zaXplKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5wdXNoKG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cGRhdGUgdGhlIHN0cmVhbSBvZmZzZXRcbiAgICByZWFkU3RyZWFtLl9vZmZzZXQgPSBlbmRPZmZzZXQ7XG5cbiAgICAvLyBnZXQgdGhlIGRhdGEgY2h1bmtcbiAgICByZWFkU3RyZWFtLnB1c2godG9CdWZmZXIocmVhZGVyLnJlc3VsdCkpO1xuICB9XG4gIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIHJlYWRlci5lcnJvcik7XG4gIH1cblxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIodGhpcy5fZmlsZS5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSk7XG59O1xuXG5GaWxlUmVhZFN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9maWxlID0gbnVsbDtcbiAgaWYgKHRoaXMucmVhZGVyKSB7XG4gICAgdGhpcy5yZWFkZXIub25sb2FkID0gbnVsbDtcbiAgICB0aGlzLnJlYWRlci5vbmVycm9yID0gbnVsbDtcbiAgICB0cnkgeyB0aGlzLnJlYWRlci5hYm9ydCgpOyB9IGNhdGNoIChlKSB7fTtcbiAgfVxuICB0aGlzLnJlYWRlciA9IG51bGw7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsYXR0ZW4obGlzdCwgZGVwdGgpIHtcbiAgZGVwdGggPSAodHlwZW9mIGRlcHRoID09ICdudW1iZXInKSA/IGRlcHRoIDogSW5maW5pdHk7XG5cbiAgaWYgKCFkZXB0aCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICByZXR1cm4gbGlzdC5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIF9mbGF0dGVuKGxpc3QsIDEpO1xuXG4gIGZ1bmN0aW9uIF9mbGF0dGVuKGxpc3QsIGQpIHtcbiAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaXRlbSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgJiYgZCA8IGRlcHRoKSB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KF9mbGF0dGVuKGl0ZW0sIGQgKyAxKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoaXRlbSk7XG4gICAgICB9XG4gICAgfSwgW10pO1xuICB9XG59O1xuIiwiLy8gb3JpZ2luYWxseSBwdWxsZWQgb3V0IG9mIHNpbXBsZS1wZWVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QnJvd3NlclJUQyAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGxcbiAgdmFyIHdydGMgPSB7XG4gICAgUlRDUGVlckNvbm5lY3Rpb246IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbixcbiAgICBSVENTZXNzaW9uRGVzY3JpcHRpb246IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gfHxcbiAgICAgIHdpbmRvdy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgd2luZG93LndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbixcbiAgICBSVENJY2VDYW5kaWRhdGU6IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93Lm1velJUQ0ljZUNhbmRpZGF0ZSB8fFxuICAgICAgd2luZG93LndlYmtpdFJUQ0ljZUNhbmRpZGF0ZVxuICB9XG4gIGlmICghd3J0Yy5SVENQZWVyQ29ubmVjdGlvbikgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHdydGNcbn1cbiIsInZhciBoYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlKSB7XG4gICAgaWYgKCFiYXNlKSBiYXNlID0gMTY7XG4gICAgaWYgKGJpdHMgPT09IHVuZGVmaW5lZCkgYml0cyA9IDEyODtcbiAgICBpZiAoYml0cyA8PSAwKSByZXR1cm4gJzAnO1xuICAgIFxuICAgIHZhciBkaWdpdHMgPSBNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzKSkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICBmb3IgKHZhciBpID0gMjsgZGlnaXRzID09PSBJbmZpbml0eTsgaSAqPSAyKSB7XG4gICAgICAgIGRpZ2l0cyA9IE1hdGgubG9nKE1hdGgucG93KDIsIGJpdHMgLyBpKSkgLyBNYXRoLmxvZyhiYXNlKSAqIGk7XG4gICAgfVxuICAgIFxuICAgIHZhciByZW0gPSBkaWdpdHMgLSBNYXRoLmZsb29yKGRpZ2l0cyk7XG4gICAgXG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5mbG9vcihkaWdpdHMpOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgcmVzID0geCArIHJlcztcbiAgICB9XG4gICAgXG4gICAgaWYgKHJlbSkge1xuICAgICAgICB2YXIgYiA9IE1hdGgucG93KGJhc2UsIHJlbSk7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYikudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIFxuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChyZXMsIGJhc2UpO1xuICAgIGlmIChwYXJzZWQgIT09IEluZmluaXR5ICYmIHBhcnNlZCA+PSBNYXRoLnBvdygyLCBiaXRzKSkge1xuICAgICAgICByZXR1cm4gaGF0KGJpdHMsIGJhc2UpXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIHJlcztcbn07XG5cbmhhdC5yYWNrID0gZnVuY3Rpb24gKGJpdHMsIGJhc2UsIGV4cGFuZEJ5KSB7XG4gICAgdmFyIGZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGl0ZXJzID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGl0ZXJzICsrID4gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kQnkpIGJpdHMgKz0gZXhwYW5kQnk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IElEIGNvbGxpc2lvbnMsIHVzZSBtb3JlIGJpdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaWQgPSBoYXQoYml0cywgYmFzZSk7XG4gICAgICAgIH0gd2hpbGUgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhdHMsIGlkKSk7XG4gICAgICAgIFxuICAgICAgICBoYXRzW2lkXSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIHZhciBoYXRzID0gZm4uaGF0cyA9IHt9O1xuICAgIFxuICAgIGZuLmdldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gZm4uaGF0c1tpZF07XG4gICAgfTtcbiAgICBcbiAgICBmbi5zZXQgPSBmdW5jdGlvbiAoaWQsIHZhbHVlKSB7XG4gICAgICAgIGZuLmhhdHNbaWRdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIFxuICAgIGZuLmJpdHMgPSBiaXRzIHx8IDEyODtcbiAgICBmbi5iYXNlID0gYmFzZSB8fCAxNjtcbiAgICByZXR1cm4gZm47XG59O1xuIiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbnZhciBodHRwcyA9IG1vZHVsZS5leHBvcnRzO1xuXG5mb3IgKHZhciBrZXkgaW4gaHR0cCkge1xuICAgIGlmIChodHRwLmhhc093blByb3BlcnR5KGtleSkpIGh0dHBzW2tleV0gPSBodHRwW2tleV07XG59O1xuXG5odHRwcy5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgcGFyYW1zLnNjaGVtZSA9ICdodHRwcyc7XG4gICAgcGFyYW1zLnByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgcmV0dXJuIGh0dHAucmVxdWVzdC5jYWxsKHRoaXMsIHBhcmFtcywgY2IpO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEltbWVkaWF0ZVN0b3JlXG5cbmZ1bmN0aW9uIEltbWVkaWF0ZVN0b3JlIChzdG9yZSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW1tZWRpYXRlU3RvcmUpKSByZXR1cm4gbmV3IEltbWVkaWF0ZVN0b3JlKHN0b3JlKVxuXG4gIHRoaXMuc3RvcmUgPSBzdG9yZVxuICB0aGlzLmNodW5rTGVuZ3RoID0gc3RvcmUuY2h1bmtMZW5ndGhcblxuICBpZiAoIXRoaXMuc3RvcmUgfHwgIXRoaXMuc3RvcmUuZ2V0IHx8ICF0aGlzLnN0b3JlLnB1dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhYnN0cmFjdC1jaHVuay1zdG9yZSBjb21wbGlhbnQnKVxuICB9XG5cbiAgdGhpcy5tZW0gPSBbXVxufVxuXG5JbW1lZGlhdGVTdG9yZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGluZGV4LCBidWYsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLm1lbVtpbmRleF0gPSBidWZcbiAgc2VsZi5zdG9yZS5wdXQoaW5kZXgsIGJ1ZiwgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYubWVtW2luZGV4XSA9IG51bGxcbiAgICBpZiAoY2IpIGNiKGVycilcbiAgfSlcbn1cblxuSW1tZWRpYXRlU3RvcmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCwgb3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5nZXQoaW5kZXgsIG51bGwsIG9wdHMpXG5cbiAgdmFyIHN0YXJ0ID0gKG9wdHMgJiYgb3B0cy5vZmZzZXQpIHx8IDBcbiAgdmFyIGVuZCA9IG9wdHMgJiYgb3B0cy5sZW5ndGggJiYgKHN0YXJ0ICsgb3B0cy5sZW5ndGgpXG5cbiAgdmFyIGJ1ZiA9IHRoaXMubWVtW2luZGV4XVxuICBpZiAoYnVmKSByZXR1cm4gbmV4dFRpY2soY2IsIG51bGwsIG9wdHMgPyBidWYuc2xpY2Uoc3RhcnQsIGVuZCkgOiBidWYpXG5cbiAgdGhpcy5zdG9yZS5nZXQoaW5kZXgsIG9wdHMsIGNiKVxufVxuXG5JbW1lZGlhdGVTdG9yZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdGhpcy5zdG9yZS5jbG9zZShjYilcbn1cblxuSW1tZWRpYXRlU3RvcmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdGhpcy5zdG9yZS5kZXN0cm95KGNiKVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGVyciwgdmFsKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikgY2IoZXJyLCB2YWwpXG4gIH0pXG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGV4cGFuZElQdjYsIGlwYWRkciwgaXB2NFBhcnQsIGlwdjRSZWdleGVzLCBpcHY2UGFydCwgaXB2NlJlZ2V4ZXMsIG1hdGNoQ0lEUiwgcm9vdDtcblxuICBpcGFkZHIgPSB7fTtcblxuICByb290ID0gdGhpcztcblxuICBpZiAoKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaXBhZGRyO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ2lwYWRkciddID0gaXBhZGRyO1xuICB9XG5cbiAgbWF0Y2hDSURSID0gZnVuY3Rpb24oZmlyc3QsIHNlY29uZCwgcGFydFNpemUsIGNpZHJCaXRzKSB7XG4gICAgdmFyIHBhcnQsIHNoaWZ0O1xuICAgIGlmIChmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogY2Fubm90IG1hdGNoIENJRFIgZm9yIG9iamVjdHMgd2l0aCBkaWZmZXJlbnQgbGVuZ3Roc1wiKTtcbiAgICB9XG4gICAgcGFydCA9IDA7XG4gICAgd2hpbGUgKGNpZHJCaXRzID4gMCkge1xuICAgICAgc2hpZnQgPSBwYXJ0U2l6ZSAtIGNpZHJCaXRzO1xuICAgICAgaWYgKHNoaWZ0IDwgMCkge1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RbcGFydF0gPj4gc2hpZnQgIT09IHNlY29uZFtwYXJ0XSA+PiBzaGlmdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaWRyQml0cyAtPSBwYXJ0U2l6ZTtcbiAgICAgIHBhcnQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgaXBhZGRyLnN1Ym5ldE1hdGNoID0gZnVuY3Rpb24oYWRkcmVzcywgcmFuZ2VMaXN0LCBkZWZhdWx0TmFtZSkge1xuICAgIHZhciByYW5nZU5hbWUsIHJhbmdlU3VibmV0cywgc3VibmV0LCBfaSwgX2xlbjtcbiAgICBpZiAoZGVmYXVsdE5hbWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdE5hbWUgPSAndW5pY2FzdCc7XG4gICAgfVxuICAgIGZvciAocmFuZ2VOYW1lIGluIHJhbmdlTGlzdCkge1xuICAgICAgcmFuZ2VTdWJuZXRzID0gcmFuZ2VMaXN0W3JhbmdlTmFtZV07XG4gICAgICBpZiAocmFuZ2VTdWJuZXRzWzBdICYmICEocmFuZ2VTdWJuZXRzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHJhbmdlU3VibmV0cyA9IFtyYW5nZVN1Ym5ldHNdO1xuICAgICAgfVxuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSByYW5nZVN1Ym5ldHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgc3VibmV0ID0gcmFuZ2VTdWJuZXRzW19pXTtcbiAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2guYXBwbHkoYWRkcmVzcywgc3VibmV0KSkge1xuICAgICAgICAgIHJldHVybiByYW5nZU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHROYW1lO1xuICB9O1xuXG4gIGlwYWRkci5JUHY0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElQdjQob2N0ZXRzKSB7XG4gICAgICB2YXIgb2N0ZXQsIF9pLCBfbGVuO1xuICAgICAgaWYgKG9jdGV0cy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBpcHY0IG9jdGV0IGNvdW50IHNob3VsZCBiZSA0XCIpO1xuICAgICAgfVxuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvY3RldHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb2N0ZXQgPSBvY3RldHNbX2ldO1xuICAgICAgICBpZiAoISgoMCA8PSBvY3RldCAmJiBvY3RldCA8PSAyNTUpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogaXB2NCBvY3RldCBzaG91bGQgZml0IGluIDggYml0c1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vY3RldHMgPSBvY3RldHM7XG4gICAgfVxuXG4gICAgSVB2NC5wcm90b3R5cGUua2luZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdpcHY0JztcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9jdGV0cy5qb2luKFwiLlwiKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9jdGV0cy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgY2lkclJhbmdlKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmIChjaWRyUmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgICBfcmVmID0gb3RoZXIsIG90aGVyID0gX3JlZlswXSwgY2lkclJhbmdlID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlci5raW5kKCkgIT09ICdpcHY0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGNhbm5vdCBtYXRjaCBpcHY0IGFkZHJlc3Mgd2l0aCBub24taXB2NCBvbmVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hDSURSKHRoaXMub2N0ZXRzLCBvdGhlci5vY3RldHMsIDgsIGNpZHJSYW5nZSk7XG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLlNwZWNpYWxSYW5nZXMgPSB7XG4gICAgICB1bnNwZWNpZmllZDogW1tuZXcgSVB2NChbMCwgMCwgMCwgMF0pLCA4XV0sXG4gICAgICBicm9hZGNhc3Q6IFtbbmV3IElQdjQoWzI1NSwgMjU1LCAyNTUsIDI1NV0pLCAzMl1dLFxuICAgICAgbXVsdGljYXN0OiBbW25ldyBJUHY0KFsyMjQsIDAsIDAsIDBdKSwgNF1dLFxuICAgICAgbGlua0xvY2FsOiBbW25ldyBJUHY0KFsxNjksIDI1NCwgMCwgMF0pLCAxNl1dLFxuICAgICAgbG9vcGJhY2s6IFtbbmV3IElQdjQoWzEyNywgMCwgMCwgMF0pLCA4XV0sXG4gICAgICBcInByaXZhdGVcIjogW1tuZXcgSVB2NChbMTAsIDAsIDAsIDBdKSwgOF0sIFtuZXcgSVB2NChbMTcyLCAxNiwgMCwgMF0pLCAxMl0sIFtuZXcgSVB2NChbMTkyLCAxNjgsIDAsIDBdKSwgMTZdXSxcbiAgICAgIHJlc2VydmVkOiBbW25ldyBJUHY0KFsxOTIsIDAsIDAsIDBdKSwgMjRdLCBbbmV3IElQdjQoWzE5MiwgMCwgMiwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMTkyLCA4OCwgOTksIDBdKSwgMjRdLCBbbmV3IElQdjQoWzE5OCwgNTEsIDEwMCwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMjAzLCAwLCAxMTMsIDBdKSwgMjRdLCBbbmV3IElQdjQoWzI0MCwgMCwgMCwgMF0pLCA0XV1cbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuc3VibmV0TWF0Y2godGhpcywgdGhpcy5TcGVjaWFsUmFuZ2VzKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUudG9JUHY0TWFwcGVkQWRkcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlKFwiOjpmZmZmOlwiICsgKHRoaXMudG9TdHJpbmcoKSkpO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS5wcmVmaXhMZW5ndGhGcm9tU3VibmV0TWFzayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNpZHIsIGksIG9jdGV0LCBzdG9wLCB6ZXJvcywgemVyb3RhYmxlLCBfaTtcbiAgICAgIHplcm90YWJsZSA9IHtcbiAgICAgICAgMDogOCxcbiAgICAgICAgMTI4OiA3LFxuICAgICAgICAxOTI6IDYsXG4gICAgICAgIDIyNDogNSxcbiAgICAgICAgMjQwOiA0LFxuICAgICAgICAyNDg6IDMsXG4gICAgICAgIDI1MjogMixcbiAgICAgICAgMjU0OiAxLFxuICAgICAgICAyNTU6IDBcbiAgICAgIH07XG4gICAgICBjaWRyID0gMDtcbiAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IF9pID0gMzsgX2kgPj0gMDsgaSA9IF9pICs9IC0xKSB7XG4gICAgICAgIG9jdGV0ID0gdGhpcy5vY3RldHNbaV07XG4gICAgICAgIGlmIChvY3RldCBpbiB6ZXJvdGFibGUpIHtcbiAgICAgICAgICB6ZXJvcyA9IHplcm90YWJsZVtvY3RldF07XG4gICAgICAgICAgaWYgKHN0b3AgJiYgemVyb3MgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoemVyb3MgIT09IDgpIHtcbiAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaWRyICs9IHplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMzIgLSBjaWRyO1xuICAgIH07XG5cbiAgICByZXR1cm4gSVB2NDtcblxuICB9KSgpO1xuXG4gIGlwdjRQYXJ0ID0gXCIoMD9cXFxcZCt8MHhbYS1mMC05XSspXCI7XG5cbiAgaXB2NFJlZ2V4ZXMgPSB7XG4gICAgZm91ck9jdGV0OiBuZXcgUmVnRXhwKFwiXlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIiRcIiwgJ2knKSxcbiAgICBsb25nVmFsdWU6IG5ldyBSZWdFeHAoXCJeXCIgKyBpcHY0UGFydCArIFwiJFwiLCAnaScpXG4gIH07XG5cbiAgaXBhZGRyLklQdjQucGFyc2VyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoLCBwYXJzZUludEF1dG8sIHBhcnQsIHNoaWZ0LCB2YWx1ZTtcbiAgICBwYXJzZUludEF1dG8gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmdbMF0gPT09IFwiMFwiICYmIHN0cmluZ1sxXSAhPT0gXCJ4XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY0UmVnZXhlcy5mb3VyT2N0ZXQpKSB7XG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gbWF0Y2guc2xpY2UoMSwgNik7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcnQgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnNlSW50QXV0byhwYXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLmxvbmdWYWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VJbnRBdXRvKG1hdGNoWzFdKTtcbiAgICAgIGlmICh2YWx1ZSA+IDB4ZmZmZmZmZmYgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogYWRkcmVzcyBvdXRzaWRlIGRlZmluZWQgcmFuZ2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChzaGlmdCA9IF9pID0gMDsgX2kgPD0gMjQ7IHNoaWZ0ID0gX2kgKz0gOCkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goKHZhbHVlID4+IHNoaWZ0KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpLnJldmVyc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5JUHY2ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElQdjYocGFydHMpIHtcbiAgICAgIHZhciBpLCBwYXJ0LCBfaSwgX2osIF9sZW4sIF9yZWY7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxNikge1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIGZvciAoaSA9IF9pID0gMDsgX2kgPD0gMTQ7IGkgPSBfaSArPSAyKSB7XG4gICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKChwYXJ0c1tpXSA8PCA4KSB8IHBhcnRzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogaXB2NiBwYXJ0IGNvdW50IHNob3VsZCBiZSA4IG9yIDE2XCIpO1xuICAgICAgfVxuICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICBmb3IgKF9qID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaiA8IF9sZW47IF9qKyspIHtcbiAgICAgICAgcGFydCA9IF9yZWZbX2pdO1xuICAgICAgICBpZiAoISgoMCA8PSBwYXJ0ICYmIHBhcnQgPD0gMHhmZmZmKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGlwdjYgcGFydCBzaG91bGQgZml0IGluIDE2IGJpdHNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBJUHY2LnByb3RvdHlwZS5raW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ2lwdjYnO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbXBhY3RTdHJpbmdQYXJ0cywgcGFydCwgcHVzaFBhcnQsIHN0YXRlLCBzdHJpbmdQYXJ0cywgX2ksIF9sZW47XG4gICAgICBzdHJpbmdQYXJ0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcnQgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnQudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgY29tcGFjdFN0cmluZ1BhcnRzID0gW107XG4gICAgICBwdXNoUGFydCA9IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhY3RTdHJpbmdQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgfTtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc3RyaW5nUGFydHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFydCA9IHN0cmluZ1BhcnRzW19pXTtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgcHVzaFBhcnQoJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHVzaFBhcnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2hQYXJ0KHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKHBhcnQgIT09ICcwJykge1xuICAgICAgICAgICAgICBwdXNoUGFydCgnJyk7XG4gICAgICAgICAgICAgIHB1c2hQYXJ0KHBhcnQpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBwdXNoUGFydChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAyKSB7XG4gICAgICAgIHB1c2hQYXJ0KCcnKTtcbiAgICAgICAgcHVzaFBhcnQoJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbXBhY3RTdHJpbmdQYXJ0cy5qb2luKFwiOlwiKTtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBieXRlcywgcGFydCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBieXRlcyA9IFtdO1xuICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICBieXRlcy5wdXNoKHBhcnQgPj4gOCk7XG4gICAgICAgIGJ5dGVzLnB1c2gocGFydCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b05vcm1hbGl6ZWRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJ0O1xuICAgICAgcmV0dXJuICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLnBhcnRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwYXJ0ID0gX3JlZltfaV07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChwYXJ0LnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkuam9pbihcIjpcIik7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ob3RoZXIsIGNpZHJSYW5nZSkge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICBpZiAoY2lkclJhbmdlID09PSB2b2lkIDApIHtcbiAgICAgICAgX3JlZiA9IG90aGVyLCBvdGhlciA9IF9yZWZbMF0sIGNpZHJSYW5nZSA9IF9yZWZbMV07XG4gICAgICB9XG4gICAgICBpZiAob3RoZXIua2luZCgpICE9PSAnaXB2NicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBjYW5ub3QgbWF0Y2ggaXB2NiBhZGRyZXNzIHdpdGggbm9uLWlwdjYgb25lXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoQ0lEUih0aGlzLnBhcnRzLCBvdGhlci5wYXJ0cywgMTYsIGNpZHJSYW5nZSk7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLlNwZWNpYWxSYW5nZXMgPSB7XG4gICAgICB1bnNwZWNpZmllZDogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDEyOF0sXG4gICAgICBsaW5rTG9jYWw6IFtuZXcgSVB2NihbMHhmZTgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDEwXSxcbiAgICAgIG11bHRpY2FzdDogW25ldyBJUHY2KFsweGZmMDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgOF0sXG4gICAgICBsb29wYmFjazogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAxXSksIDEyOF0sXG4gICAgICB1bmlxdWVMb2NhbDogW25ldyBJUHY2KFsweGZjMDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgN10sXG4gICAgICBpcHY0TWFwcGVkOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDB4ZmZmZiwgMCwgMF0pLCA5Nl0sXG4gICAgICByZmM2MTQ1OiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDB4ZmZmZiwgMCwgMCwgMF0pLCA5Nl0sXG4gICAgICByZmM2MDUyOiBbbmV3IElQdjYoWzB4NjQsIDB4ZmY5YiwgMCwgMCwgMCwgMCwgMCwgMF0pLCA5Nl0sXG4gICAgICAnNnRvNCc6IFtuZXcgSVB2NihbMHgyMDAyLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDE2XSxcbiAgICAgIHRlcmVkbzogW25ldyBJUHY2KFsweDIwMDEsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMzJdLFxuICAgICAgcmVzZXJ2ZWQ6IFtbbmV3IElQdjYoWzB4MjAwMSwgMHhkYjgsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMzJdXVxuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlwYWRkci5zdWJuZXRNYXRjaCh0aGlzLCB0aGlzLlNwZWNpYWxSYW5nZXMpO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS5pc0lQdjRNYXBwZWRBZGRyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZSgpID09PSAnaXB2NE1hcHBlZCc7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvSVB2NEFkZHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoaWdoLCBsb3csIF9yZWY7XG4gICAgICBpZiAoIXRoaXMuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdHJ5aW5nIHRvIGNvbnZlcnQgYSBnZW5lcmljIGlwdjYgYWRkcmVzcyB0byBpcHY0XCIpO1xuICAgICAgfVxuICAgICAgX3JlZiA9IHRoaXMucGFydHMuc2xpY2UoLTIpLCBoaWdoID0gX3JlZlswXSwgbG93ID0gX3JlZlsxXTtcbiAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjQoW2hpZ2ggPj4gOCwgaGlnaCAmIDB4ZmYsIGxvdyA+PiA4LCBsb3cgJiAweGZmXSk7XG4gICAgfTtcblxuICAgIHJldHVybiBJUHY2O1xuXG4gIH0pKCk7XG5cbiAgaXB2NlBhcnQgPSBcIig/OlswLTlhLWZdKzo6PykrXCI7XG5cbiAgaXB2NlJlZ2V4ZXMgPSB7XG4gICAgXCJuYXRpdmVcIjogbmV3IFJlZ0V4cChcIl4oOjopPyhcIiArIGlwdjZQYXJ0ICsgXCIpPyhbMC05YS1mXSspPyg6Oik/JFwiLCAnaScpLFxuICAgIHRyYW5zaXRpb25hbDogbmV3IFJlZ0V4cCgoXCJeKCg/OlwiICsgaXB2NlBhcnQgKyBcIil8KD86OjopKD86XCIgKyBpcHY2UGFydCArIFwiKT8pXCIpICsgKFwiXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiJFwiKSwgJ2knKVxuICB9O1xuXG4gIGV4cGFuZElQdjYgPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7XG4gICAgdmFyIGNvbG9uQ291bnQsIGxhc3RDb2xvbiwgcGFydCwgcmVwbGFjZW1lbnQsIHJlcGxhY2VtZW50Q291bnQ7XG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCc6OicpICE9PSBzdHJpbmcubGFzdEluZGV4T2YoJzo6JykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2xvbkNvdW50ID0gMDtcbiAgICBsYXN0Q29sb24gPSAtMTtcbiAgICB3aGlsZSAoKGxhc3RDb2xvbiA9IHN0cmluZy5pbmRleE9mKCc6JywgbGFzdENvbG9uICsgMSkpID49IDApIHtcbiAgICAgIGNvbG9uQ291bnQrKztcbiAgICB9XG4gICAgaWYgKHN0cmluZy5zdWJzdHIoMCwgMikgPT09ICc6OicpIHtcbiAgICAgIGNvbG9uQ291bnQtLTtcbiAgICB9XG4gICAgaWYgKHN0cmluZy5zdWJzdHIoLTIsIDIpID09PSAnOjonKSB7XG4gICAgICBjb2xvbkNvdW50LS07XG4gICAgfVxuICAgIGlmIChjb2xvbkNvdW50ID4gcGFydHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXBsYWNlbWVudENvdW50ID0gcGFydHMgLSBjb2xvbkNvdW50O1xuICAgIHJlcGxhY2VtZW50ID0gJzonO1xuICAgIHdoaWxlIChyZXBsYWNlbWVudENvdW50LS0pIHtcbiAgICAgIHJlcGxhY2VtZW50ICs9ICcwOic7XG4gICAgfVxuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKCc6OicsIHJlcGxhY2VtZW50KTtcbiAgICBpZiAoc3RyaW5nWzBdID09PSAnOicpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKTtcbiAgICB9XG4gICAgaWYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICc6Jykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmID0gc3RyaW5nLnNwbGl0KFwiOlwiKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSkoKTtcbiAgfTtcblxuICBpcGFkZHIuSVB2Ni5wYXJzZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2gsIG9jdGV0LCBvY3RldHMsIHBhcnRzLCBfaSwgX2xlbjtcbiAgICBpZiAoc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzWyduYXRpdmUnXSkpIHtcbiAgICAgIHJldHVybiBleHBhbmRJUHY2KHN0cmluZywgOCk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY2UmVnZXhlc1sndHJhbnNpdGlvbmFsJ10pKSB7XG4gICAgICBwYXJ0cyA9IGV4cGFuZElQdjYobWF0Y2hbMV0uc2xpY2UoMCwgLTEpLCA2KTtcbiAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICBvY3RldHMgPSBbcGFyc2VJbnQobWF0Y2hbMl0pLCBwYXJzZUludChtYXRjaFszXSksIHBhcnNlSW50KG1hdGNoWzRdKSwgcGFyc2VJbnQobWF0Y2hbNV0pXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvY3RldHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBvY3RldCA9IG9jdGV0c1tfaV07XG4gICAgICAgICAgaWYgKCEoKDAgPD0gb2N0ZXQgJiYgb2N0ZXQgPD0gMjU1KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKG9jdGV0c1swXSA8PCA4IHwgb2N0ZXRzWzFdKTtcbiAgICAgICAgcGFydHMucHVzaChvY3RldHNbMl0gPDwgOCB8IG9jdGV0c1szXSk7XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQuaXNJUHY0ID0gaXBhZGRyLklQdjYuaXNJUHY2ID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VyKHN0cmluZykgIT09IG51bGw7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQuaXNWYWxpZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBlO1xuICAgIHRyeSB7XG4gICAgICBuZXcgdGhpcyh0aGlzLnBhcnNlcihzdHJpbmcpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLklQdjYuaXNWYWxpZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBlO1xuICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSBcInN0cmluZ1wiICYmIHN0cmluZy5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyB0aGlzKHRoaXMucGFyc2VyKHN0cmluZykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2NC5wYXJzZSA9IGlwYWRkci5JUHY2LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHBhcnRzO1xuICAgIHBhcnRzID0gdGhpcy5wYXJzZXIoc3RyaW5nKTtcbiAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBpcCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMocGFydHMpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY0LnBhcnNlQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBtYXNrTGVuZ3RoLCBtYXRjaDtcbiAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oLispXFwvKFxcZCspJC8pKSB7XG4gICAgICBtYXNrTGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgaWYgKG1hc2tMZW5ndGggPj0gMCAmJiBtYXNrTGVuZ3RoIDw9IDMyKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5wYXJzZShtYXRjaFsxXSksIG1hc2tMZW5ndGhdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHN0cmluZyBpcyBub3QgZm9ybWF0dGVkIGxpa2UgYW4gSVB2NCBDSURSIHJhbmdlXCIpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY2LnBhcnNlQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBtYXNrTGVuZ3RoLCBtYXRjaDtcbiAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oLispXFwvKFxcZCspJC8pKSB7XG4gICAgICBtYXNrTGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgaWYgKG1hc2tMZW5ndGggPj0gMCAmJiBtYXNrTGVuZ3RoIDw9IDEyOCkge1xuICAgICAgICByZXR1cm4gW3RoaXMucGFyc2UobWF0Y2hbMV0pLCBtYXNrTGVuZ3RoXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBzdHJpbmcgaXMgbm90IGZvcm1hdHRlZCBsaWtlIGFuIElQdjYgQ0lEUiByYW5nZVwiKTtcbiAgfTtcblxuICBpcGFkZHIuaXNWYWxpZCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBpcGFkZHIuSVB2Ni5pc1ZhbGlkKHN0cmluZykgfHwgaXBhZGRyLklQdjQuaXNWYWxpZChzdHJpbmcpO1xuICB9O1xuXG4gIGlwYWRkci5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmIChpcGFkZHIuSVB2Ni5pc1ZhbGlkKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5wYXJzZShzdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXBhZGRyLklQdjQuaXNWYWxpZChzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLklQdjQucGFyc2Uoc3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0aGUgYWRkcmVzcyBoYXMgbmVpdGhlciBJUHY2IG5vciBJUHY0IGZvcm1hdFwiKTtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLnBhcnNlQ0lEUiA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaXBhZGRyLklQdjYucGFyc2VDSURSKHN0cmluZyk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY0LnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdGhlIGFkZHJlc3MgaGFzIG5laXRoZXIgSVB2NiBub3IgSVB2NCBDSURSIGZvcm1hdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLmZyb21CeXRlQXJyYXkgPSBmdW5jdGlvbihieXRlcykge1xuICAgIHZhciBsZW5ndGg7XG4gICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjQoYnl0ZXMpO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSAxNikge1xuICAgICAgcmV0dXJuIG5ldyBpcGFkZHIuSVB2NihieXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogdGhlIGJpbmFyeSBpbnB1dCBpcyBuZWl0aGVyIGFuIElQdjYgbm9yIElQdjQgYWRkcmVzc1wiKTtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLnByb2Nlc3MgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgYWRkcjtcbiAgICBhZGRyID0gdGhpcy5wYXJzZShzdHJpbmcpO1xuICAgIGlmIChhZGRyLmtpbmQoKSA9PT0gJ2lwdjYnICYmIGFkZHIuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICByZXR1cm4gYWRkci50b0lQdjRBZGRyZXNzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRyO1xuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIChjKSAyMDE2IEFyaSBQb3JhZCAoQGFyaXBvcmFkKSA8aHR0cDovL2FyaXBvcmFkLmNvbT4uIExpY2Vuc2U6IGFyaXBvcmFkLm1pdC1saWNlbnNlLm9yZyAqL1xuXG4vLyBQYXJ0aWFsbHkgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NDA0OS8xOTI4NDg0LCBhbmQgZnJvbSBhbm90aGVyIFNPIGFuc3dlciwgd2hpY2ggdG9sZCBtZSB0aGF0IHRoZSBoaWdoZXN0XG4vLyBjaGFyIGNvZGUgdGhhdCdzIGFzY2lpIGlzIDEyNywgYnV0IEkgY2FuJ3QgZmluZCB0aGUgbGluayBmb3IuIFNvcnJ5LlxuXG52YXIgTUFYX0FTQ0lJX0NIQVJfQ09ERSA9IDEyNztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FzY2lpKHN0cikge1xuICBmb3IgKHZhciBpID0gMCwgc3RyTGVuID0gc3RyLmxlbmd0aDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpID4gTUFYX0FTQ0lJX0NIQVJfQ09ERSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBCdWZmZXJcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ZpbGUocGF0aCwgY2Ipe1xuICBpZighY2IpcmV0dXJuIGlzRmlsZVN5bmMocGF0aCk7XG5cbiAgZnMuc3RhdChwYXRoLCBmdW5jdGlvbihlcnIsIHN0YXRzKXtcbiAgICBpZihlcnIpcmV0dXJuIGNiKGVycik7XG4gICAgcmV0dXJuIGNiKG51bGwsIHN0YXRzLmlzRmlsZSgpKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gaXNGaWxlU3luYztcblxuZnVuY3Rpb24gaXNGaWxlU3luYyhwYXRoKXtcbiAgcmV0dXJuIGZzLmV4aXN0c1N5bmMocGF0aCkgJiYgZnMuc3RhdFN5bmMocGF0aCkuaXNGaWxlKCk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyAgICAgID0gaXNUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkuc3RyaWN0ID0gaXNTdHJpY3RUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkubG9vc2UgID0gaXNMb29zZVR5cGVkQXJyYXlcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIG5hbWVzID0ge1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MTZBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgICAgaXNTdHJpY3RUeXBlZEFycmF5KGFycilcbiAgICB8fCBpc0xvb3NlVHlwZWRBcnJheShhcnIpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGFyciBpbnN0YW5jZW9mIEludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBJbnQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuICApXG59XG5cbmZ1bmN0aW9uIGlzTG9vc2VUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gbmFtZXNbdG9TdHJpbmcuY2FsbChhcnIpXVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIC8vIEFsbFxuLy8gL15ucG0tZGVidWdcXC5sb2ckLywgICAvLyBucG0gZXJyb3IgbG9nXG4vLyAvXlxcLi4qXFwuc3dwJC8sICAgICAgICAvLyB2aW0gc3RhdGVcbi8vIC8vIE9TIFhcbi8vIC9eXFwuRFNfU3RvcmUkLywgICAgICAgLy8gc3RvcmVzIGN1c3RvbSBmb2xkZXIgYXR0cmlidXRlc1xuLy8gL15cXC5BcHBsZURvdWJsZSQvLCAgICAvLyBzdG9yZXMgYWRkaXRpb25hbCBmaWxlIHJlc291cmNlc1xuLy8gL15cXC5MU092ZXJyaWRlJC8sICAgICAvLyBjb250YWlucyB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgYXBwIHRvIGJlIHVzZWRcbi8vIC9eSWNvbltcXHJcXD9dPy8sICAgICAgIC8vIGN1c3RvbSBGaW5kZXIgaWNvblxuLy8gL15cXC5fLiovLCAgICAgICAgICAgICAvLyB0aHVtYm5haWxcbi8vIC9eXFwuU3BvdGxpZ2h0LVYxMDAkLywgIC8vIGZpbGUgdGhhdCBtaWdodCBhcHBlYXIgb24gZXh0ZXJuYWwgZGlza1xuLy8gL1xcLlRyYXNoZXMvLCAgICAgICAgICAvLyBmaWxlIHRoYXQgbWlnaHQgYXBwZWFyIG9uIGV4dGVybmFsIGRpc2tcbi8vIC9eX19NQUNPU1gkLywgICAgICAgICAvLyByZXNvdXJjZSBmb3JrXG4vLyAvLyBMaW51eFxuLy8gL34kLywgICAgICAgICAgICAgICAgIC8vIGJhY2t1cCBmaWxlXG4vLyAvLyBXaW5kb3dzXG4vLyAvXlRodW1ic1xcLmRiJC8sICAgICAgIC8vIGltYWdlIGZpbGUgY2FjaGVcbi8vIC9eZWh0aHVtYnNcXC5kYiQvLCAgICAgLy8gZm9sZGVyIGNvbmZpZyBmaWxlXG4vLyAvXkRlc2t0b3BcXC5pbmkkLyAgICAgIC8vIHN0b3JlcyBjdXN0b20gZm9sZGVyIGF0dHJpYnV0ZXNcblxuZXhwb3J0cy5yZSA9IC9ebnBtLWRlYnVnXFwubG9nJHxeXFwuLipcXC5zd3AkfF5cXC5EU19TdG9yZSR8XlxcLkFwcGxlRG91YmxlJHxeXFwuTFNPdmVycmlkZSR8Xkljb25bXFxyXFw/XT98XlxcLl8uKnxeXFwuU3BvdGxpZ2h0LVYxMDAkfFxcLlRyYXNoZXN8Xl9fTUFDT1NYJHx+JHxeVGh1bWJzXFwuZGIkfF5laHRodW1ic1xcLmRiJHxeRGVza3RvcFxcLmluaSQvO1xuXG5leHBvcnRzLmlzID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG5cdHJldHVybiBleHBvcnRzLnJlLnRlc3QoZmlsZW5hbWUpO1xufTtcblxuZXhwb3J0cy5ub3QgPSBleHBvcnRzLmlzbnQgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcblx0cmV0dXJuICFleHBvcnRzLmlzKGZpbGVuYW1lKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1hZ25ldFVSSURlY29kZVxubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gbWFnbmV0VVJJRGVjb2RlXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSBtYWduZXRVUklFbmNvZGVcblxudmFyIGJhc2UzMiA9IHJlcXVpcmUoJ3RoaXJ0eS10d28nKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciB1bmlxID0gcmVxdWlyZSgndW5pcScpXG5cbi8qKlxuICogUGFyc2UgYSBtYWduZXQgVVJJIGFuZCByZXR1cm4gYW4gb2JqZWN0IG9mIGtleXMvdmFsdWVzXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmlcbiAqIEByZXR1cm4ge09iamVjdH0gcGFyc2VkIHVyaVxuICovXG5mdW5jdGlvbiBtYWduZXRVUklEZWNvZGUgKHVyaSkge1xuICB2YXIgcmVzdWx0ID0ge31cblxuICAvLyBTdXBwb3J0ICdtYWduZXQ6JyBhbmQgJ3N0cmVhbS1tYWduZXQ6JyB1cmlzXG4gIHZhciBkYXRhID0gdXJpLnNwbGl0KCdtYWduZXQ6PycpWzFdXG5cbiAgdmFyIHBhcmFtcyA9IChkYXRhICYmIGRhdGEubGVuZ3RoID49IDApXG4gICAgPyBkYXRhLnNwbGl0KCcmJylcbiAgICA6IFtdXG5cbiAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIGtleXZhbCA9IHBhcmFtLnNwbGl0KCc9JylcblxuICAgIC8vIFRoaXMga2V5dmFsIGlzIGludmFsaWQsIHNraXAgaXRcbiAgICBpZiAoa2V5dmFsLmxlbmd0aCAhPT0gMikgcmV0dXJuXG5cbiAgICB2YXIga2V5ID0ga2V5dmFsWzBdXG4gICAgdmFyIHZhbCA9IGtleXZhbFsxXVxuXG4gICAgLy8gQ2xlYW4gdXAgdG9ycmVudCBuYW1lXG4gICAgaWYgKGtleSA9PT0gJ2RuJykgdmFsID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbCkucmVwbGFjZSgvXFwrL2csICcgJylcblxuICAgIC8vIEFkZHJlc3MgdHJhY2tlciAodHIpLCBleGFjdCBzb3VyY2UgKHhzKSwgYW5kIGFjY2VwdGFibGUgc291cmNlIChhcykgYXJlIGVuY29kZWRcbiAgICAvLyBVUklzLCBzbyBkZWNvZGUgdGhlbVxuICAgIGlmIChrZXkgPT09ICd0cicgfHwga2V5ID09PSAneHMnIHx8IGtleSA9PT0gJ2FzJyB8fCBrZXkgPT09ICd3cycpIHtcbiAgICAgIHZhbCA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGtleXdvcmRzIGFzIGFuIGFycmF5XG4gICAgaWYgKGtleSA9PT0gJ2t0JykgdmFsID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbCkuc3BsaXQoJysnKVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIHJlcGVhdGVkIHBhcmFtZXRlcnMsIHJldHVybiBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICBpZiAocmVzdWx0W2tleV0pIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbGQgPSByZXN1bHRba2V5XVxuICAgICAgICByZXN1bHRba2V5XSA9IFtvbGQsIHZhbF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWxcbiAgICB9XG4gIH0pXG5cbiAgLy8gQ29udmVuaWVuY2UgcHJvcGVydGllcyBmb3IgcGFyaXR5IHdpdGggYHBhcnNlLXRvcnJlbnQtZmlsZWAgbW9kdWxlXG4gIHZhciBtXG4gIGlmIChyZXN1bHQueHQpIHtcbiAgICB2YXIgeHRzID0gQXJyYXkuaXNBcnJheShyZXN1bHQueHQpID8gcmVzdWx0Lnh0IDogWyByZXN1bHQueHQgXVxuICAgIHh0cy5mb3JFYWNoKGZ1bmN0aW9uICh4dCkge1xuICAgICAgaWYgKChtID0geHQubWF0Y2goL151cm46YnRpaDooLns0MH0pLykpKSB7XG4gICAgICAgIHJlc3VsdC5pbmZvSGFzaCA9IG1bMV0udG9Mb3dlckNhc2UoKVxuICAgICAgfSBlbHNlIGlmICgobSA9IHh0Lm1hdGNoKC9edXJuOmJ0aWg6KC57MzJ9KS8pKSkge1xuICAgICAgICB2YXIgZGVjb2RlZFN0ciA9IGJhc2UzMi5kZWNvZGUobVsxXSlcbiAgICAgICAgcmVzdWx0LmluZm9IYXNoID0gbmV3IEJ1ZmZlcihkZWNvZGVkU3RyLCAnYmluYXJ5JykudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBpZiAocmVzdWx0LmluZm9IYXNoKSByZXN1bHQuaW5mb0hhc2hCdWZmZXIgPSBuZXcgQnVmZmVyKHJlc3VsdC5pbmZvSGFzaCwgJ2hleCcpXG5cbiAgaWYgKHJlc3VsdC5kbikgcmVzdWx0Lm5hbWUgPSByZXN1bHQuZG5cbiAgaWYgKHJlc3VsdC5rdCkgcmVzdWx0LmtleXdvcmRzID0gcmVzdWx0Lmt0XG5cbiAgaWYgKHR5cGVvZiByZXN1bHQudHIgPT09ICdzdHJpbmcnKSByZXN1bHQuYW5ub3VuY2UgPSBbIHJlc3VsdC50ciBdXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0LnRyKSkgcmVzdWx0LmFubm91bmNlID0gcmVzdWx0LnRyXG4gIGVsc2UgcmVzdWx0LmFubm91bmNlID0gW11cblxuICByZXN1bHQudXJsTGlzdCA9IFtdXG4gIGlmICh0eXBlb2YgcmVzdWx0LmFzID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHJlc3VsdC5hcykpIHtcbiAgICByZXN1bHQudXJsTGlzdCA9IHJlc3VsdC51cmxMaXN0LmNvbmNhdChyZXN1bHQuYXMpXG4gIH1cbiAgaWYgKHR5cGVvZiByZXN1bHQud3MgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkocmVzdWx0LndzKSkge1xuICAgIHJlc3VsdC51cmxMaXN0ID0gcmVzdWx0LnVybExpc3QuY29uY2F0KHJlc3VsdC53cylcbiAgfVxuXG4gIHVuaXEocmVzdWx0LmFubm91bmNlKVxuICB1bmlxKHJlc3VsdC51cmxMaXN0KVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gbWFnbmV0VVJJRW5jb2RlIChvYmopIHtcbiAgb2JqID0gZXh0ZW5kKG9iaikgLy8gY2xvbmUgb2JqLCBzbyB3ZSBjYW4gbXV0YXRlIGl0XG5cbiAgLy8gc3VwcG9ydCB1c2luZyBjb252ZW5pZW5jZSBuYW1lcywgaW4gYWRkaXRpb24gdG8gc3BlYyBuYW1lc1xuICAvLyAoZXhhbXBsZTogYGluZm9IYXNoYCBmb3IgYHh0YCwgYG5hbWVgIGZvciBgZG5gKVxuICBpZiAob2JqLmluZm9IYXNoQnVmZmVyKSBvYmoueHQgPSAndXJuOmJ0aWg6JyArIG9iai5pbmZvSGFzaEJ1ZmZlci50b1N0cmluZygnaGV4JylcbiAgaWYgKG9iai5pbmZvSGFzaCkgb2JqLnh0ID0gJ3VybjpidGloOicgKyBvYmouaW5mb0hhc2hcbiAgaWYgKG9iai5uYW1lKSBvYmouZG4gPSBvYmoubmFtZVxuICBpZiAob2JqLmtleXdvcmRzKSBvYmoua3QgPSBvYmoua2V5d29yZHNcbiAgaWYgKG9iai5hbm5vdW5jZSkgb2JqLnRyID0gb2JqLmFubm91bmNlXG4gIGlmIChvYmoudXJsTGlzdCkge1xuICAgIG9iai53cyA9IG9iai51cmxMaXN0XG4gICAgZGVsZXRlIG9iai5hc1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICdtYWduZXQ6PydcbiAgT2JqZWN0LmtleXMob2JqKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleS5sZW5ndGggPT09IDJcbiAgICB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KG9ialtrZXldKSA/IG9ialtrZXldIDogWyBvYmpba2V5XSBdXG4gICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBqKSB7XG4gICAgICAgIGlmICgoaSA+IDAgfHwgaiA+IDApICYmIChrZXkgIT09ICdrdCcgfHwgaiA9PT0gMCkpIHJlc3VsdCArPSAnJidcblxuICAgICAgICBpZiAoa2V5ID09PSAnZG4nKSB2YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsKS5yZXBsYWNlKC8lMjAvZywgJysnKVxuICAgICAgICBpZiAoa2V5ID09PSAndHInIHx8IGtleSA9PT0gJ3hzJyB8fCBrZXkgPT09ICdhcycgfHwga2V5ID09PSAnd3MnKSB7XG4gICAgICAgICAgdmFsID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbClcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAna3QnKSB2YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsKVxuXG4gICAgICAgIGlmIChrZXkgPT09ICdrdCcgJiYgaiA+IDApIHJlc3VsdCArPSAnKycgKyB2YWxcbiAgICAgICAgZWxzZSByZXN1bHQgKz0ga2V5ICsgJz0nICsgdmFsXG4gICAgICB9KVxuICAgIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBNZWRpYUVsZW1lbnRXcmFwcGVyXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIHRvQXJyYXlCdWZmZXIgPSByZXF1aXJlKCd0by1hcnJheWJ1ZmZlcicpXG5cbnZhciBNZWRpYVNvdXJjZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NZWRpYVNvdXJjZVxuXG52YXIgREVGQVVMVF9CVUZGRVJfRFVSQVRJT04gPSA2MCAvLyBzZWNvbmRzXG5cbmZ1bmN0aW9uIE1lZGlhRWxlbWVudFdyYXBwZXIgKGVsZW0sIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBNZWRpYUVsZW1lbnRXcmFwcGVyKSkgcmV0dXJuIG5ldyBNZWRpYUVsZW1lbnRXcmFwcGVyKGVsZW0sIG9wdHMpXG5cbiAgaWYgKCFNZWRpYVNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKCd3ZWIgYnJvd3NlciBsYWNrcyBNZWRpYVNvdXJjZSBzdXBwb3J0JylcblxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBzZWxmLl9idWZmZXJEdXJhdGlvbiA9IG9wdHMuYnVmZmVyRHVyYXRpb24gfHwgREVGQVVMVF9CVUZGRVJfRFVSQVRJT05cbiAgc2VsZi5fZWxlbSA9IGVsZW1cbiAgc2VsZi5fbWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKVxuICBzZWxmLl9zdHJlYW1zID0gW11cbiAgc2VsZi5kZXRhaWxlZEVycm9yID0gbnVsbFxuXG4gIHNlbGYuX2Vycm9ySGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9lbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fZXJyb3JIYW5kbGVyKVxuICAgIHZhciBzdHJlYW1zID0gc2VsZi5fc3RyZWFtcy5zbGljZSgpXG4gICAgc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KHNlbGYuX2VsZW0uZXJyb3IpXG4gICAgfSlcbiAgfVxuICBzZWxmLl9lbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fZXJyb3JIYW5kbGVyKVxuXG4gIHNlbGYuX2VsZW0uc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoc2VsZi5fbWVkaWFTb3VyY2UpXG59XG5cbi8qXG4gKiBgb2JqYCBjYW4gYmUgYSBwcmV2aW91cyB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uXG4gKiBvciBhIHN0cmluZ1xuICovXG5NZWRpYUVsZW1lbnRXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVXcml0ZVN0cmVhbSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgcmV0dXJuIG5ldyBNZWRpYVNvdXJjZVN0cmVhbShzZWxmLCBvYmopXG59XG5cbi8qXG4gKiBVc2UgdG8gdHJpZ2dlciBhbiBlcnJvciBvbiB0aGUgdW5kZXJseWluZyBtZWRpYSBlbGVtZW50XG4gKi9cbk1lZGlhRWxlbWVudFdyYXBwZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICAvLyBiZSBjYXJlZnVsIG5vdCB0byBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGRldGFpbGVkRXJyb3IgdmFsdWVzXG4gIGlmICghc2VsZi5kZXRhaWxlZEVycm9yKSB7XG4gICAgc2VsZi5kZXRhaWxlZEVycm9yID0gZXJyXG4gIH1cbiAgdHJ5IHtcbiAgICBzZWxmLl9tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgnZGVjb2RlJylcbiAgfSBjYXRjaCAoZXJyKSB7fVxufVxuXG5pbmhlcml0cyhNZWRpYVNvdXJjZVN0cmVhbSwgc3RyZWFtLldyaXRhYmxlKVxuXG5mdW5jdGlvbiBNZWRpYVNvdXJjZVN0cmVhbSAod3JhcHBlciwgb2JqKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbChzZWxmKVxuXG4gIHNlbGYuX3dyYXBwZXIgPSB3cmFwcGVyXG4gIHNlbGYuX2VsZW0gPSB3cmFwcGVyLl9lbGVtXG4gIHNlbGYuX21lZGlhU291cmNlID0gd3JhcHBlci5fbWVkaWFTb3VyY2VcbiAgc2VsZi5fYWxsU3RyZWFtcyA9IHdyYXBwZXIuX3N0cmVhbXNcbiAgc2VsZi5fYWxsU3RyZWFtcy5wdXNoKHNlbGYpXG4gIHNlbGYuX2J1ZmZlckR1cmF0aW9uID0gd3JhcHBlci5fYnVmZmVyRHVyYXRpb25cbiAgc2VsZi5fc291cmNlQnVmZmVyID0gbnVsbFxuXG4gIHNlbGYuX29wZW5IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uU291cmNlT3BlbigpXG4gIH1cbiAgc2VsZi5fZmxvd0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fZmxvdygpXG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWxmLl90eXBlID0gb2JqXG4gICAgLy8gTmVlZCB0byBjcmVhdGUgYSBuZXcgc291cmNlQnVmZmVyXG4gICAgaWYgKHNlbGYuX21lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgc2VsZi5fY3JlYXRlU291cmNlQnVmZmVyKClcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fbWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHNlbGYuX29wZW5IYW5kbGVyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChvYmouX3NvdXJjZUJ1ZmZlciA9PT0gbnVsbCkge1xuICAgIG9iai5kZXN0cm95KClcbiAgICBzZWxmLl90eXBlID0gb2JqLl90eXBlIC8vIFRoZSBvbGQgc3RyZWFtIHdhcyBjcmVhdGVkIGJ1dCBoYXNuJ3QgZmluaXNoZWQgaW5pdGlhbGl6aW5nXG4gICAgc2VsZi5fbWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHNlbGYuX29wZW5IYW5kbGVyKVxuICB9IGVsc2UgaWYgKG9iai5fc291cmNlQnVmZmVyKSB7XG4gICAgb2JqLmRlc3Ryb3koKVxuICAgIHNlbGYuX3R5cGUgPSBvYmouX3R5cGVcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIgPSBvYmouX3NvdXJjZUJ1ZmZlciAvLyBDb3B5IG92ZXIgdGhlIG9sZCBzb3VyY2VCdWZmZXJcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXJndW1lbnQgdG8gTWVkaWFFbGVtZW50V3JhcHBlci5jcmVhdGVXcml0ZVN0cmVhbSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgcHJldmlvdXMgc3RyZWFtIHJldHVybmVkIGZyb20gdGhhdCBmdW5jdGlvbicpXG4gIH1cblxuICBzZWxmLl9lbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCBzZWxmLl9mbG93SGFuZGxlcilcblxuICBzZWxmLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl93cmFwcGVyLmVycm9yKGVycilcbiAgfSlcblxuICBzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzZWxmLl9maW5pc2hlZCA9IHRydWVcbiAgICBpZiAoc2VsZi5fYWxsU3RyZWFtcy5ldmVyeShmdW5jdGlvbiAob3RoZXIpIHsgcmV0dXJuIG90aGVyLl9maW5pc2hlZCB9KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5fbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgIH1cbiAgfSlcbn1cblxuTWVkaWFTb3VyY2VTdHJlYW0ucHJvdG90eXBlLl9vblNvdXJjZU9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuX21lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBzZWxmLl9vcGVuSGFuZGxlcilcbiAgc2VsZi5fY3JlYXRlU291cmNlQnVmZmVyKClcbn1cblxuTWVkaWFTb3VyY2VTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuICAvLyBSZW1vdmUgZnJvbSBhbGxTdHJlYW1zXG4gIHNlbGYuX2FsbFN0cmVhbXMuc3BsaWNlKHNlbGYuX2FsbFN0cmVhbXMuaW5kZXhPZihzZWxmKSwgMSlcblxuICBzZWxmLl9tZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2VsZi5fb3BlbkhhbmRsZXIpXG4gIHNlbGYuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHNlbGYuX2Zsb3dIYW5kbGVyKVxuICBpZiAoc2VsZi5fc291cmNlQnVmZmVyKSB7XG4gICAgc2VsZi5fc291cmNlQnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHNlbGYuX2Zsb3dIYW5kbGVyKVxuICAgIGlmIChzZWxmLl9tZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHNlbGYuX3NvdXJjZUJ1ZmZlci5hYm9ydCgpXG4gICAgfVxuICB9XG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgc2VsZi5lbWl0KCdjbG9zZScpXG59XG5cbk1lZGlhU291cmNlU3RyZWFtLnByb3RvdHlwZS5fY3JlYXRlU291cmNlQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBpZiAoTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKHNlbGYuX3R5cGUpKSB7XG4gICAgc2VsZi5fc291cmNlQnVmZmVyID0gc2VsZi5fbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKHNlbGYuX3R5cGUpXG4gICAgc2VsZi5fc291cmNlQnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHNlbGYuX2Zsb3dIYW5kbGVyKVxuICAgIGlmIChzZWxmLl9jYikge1xuICAgICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRlc3Ryb3kobmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkJykpXG4gIH1cbn1cblxuTWVkaWFTb3VyY2VTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAoIXNlbGYuX3NvdXJjZUJ1ZmZlcikge1xuICAgIHNlbGYuX2NiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHNlbGYuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHNlbGYuX3NvdXJjZUJ1ZmZlci51cGRhdGluZykge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBlbmQgYnVmZmVyIHdoaWxlIHNvdXJjZSBidWZmZXIgdXBkYXRpbmcnKSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgc2VsZi5fc291cmNlQnVmZmVyLmFwcGVuZEJ1ZmZlcih0b0FycmF5QnVmZmVyKGNodW5rKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gYXBwZW5kQnVmZmVyIGNhbiB0aHJvdyBmb3IgYSBudW1iZXIgb2YgcmVhc29ucywgbW9zdCBub3RhYmx5IHdoZW4gdGhlIGRhdGFcbiAgICAvLyBiZWluZyBhcHBlbmRlZCBpcyBpbnZhbGlkIG9yIGlmIGFwcGVuZEJ1ZmZlciBpcyBjYWxsZWQgYWZ0ZXIgYW5vdGhlciBlcnJvclxuICAgIC8vIGFscmVhZHkgb2NjdXJyZWQgb24gdGhlIG1lZGlhIGVsZW1lbnQuIEluIENocm9tZSwgdGhlcmUgbWF5IGJlIHVzZWZ1bCBkZWJ1Z2dpbmdcbiAgICAvLyBpbmZvIGluIGNocm9tZTovL21lZGlhLWludGVybmFsc1xuICAgIHNlbGYuZGVzdHJveShlcnIpXG4gICAgcmV0dXJuXG4gIH1cbiAgc2VsZi5fY2IgPSBjYlxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX2Zsb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChzZWxmLmRlc3Ryb3llZCB8fCAhc2VsZi5fc291cmNlQnVmZmVyIHx8IHNlbGYuX3NvdXJjZUJ1ZmZlci51cGRhdGluZykge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHNlbGYuX21lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgIC8vIGNoZWNrIGJ1ZmZlciBzaXplXG4gICAgaWYgKHNlbGYuX2dldEJ1ZmZlckR1cmF0aW9uKCkgPiBzZWxmLl9idWZmZXJEdXJhdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuX2NiKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICBzZWxmLl9jYiA9IG51bGxcbiAgICBjYigpXG4gIH1cbn1cblxuLy8gVE9ETzogaWYgemVybyBhY3R1YWxseSB3b3JrcyBpbiBhbGwgYnJvd3NlcnMsIHJlbW92ZSB0aGUgbG9naWMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYmVsb3dcbnZhciBFUFNJTE9OID0gMFxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX2dldEJ1ZmZlckR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgYnVmZmVyZWQgPSBzZWxmLl9zb3VyY2VCdWZmZXIuYnVmZmVyZWRcbiAgdmFyIGN1cnJlbnRUaW1lID0gc2VsZi5fZWxlbS5jdXJyZW50VGltZVxuICB2YXIgYnVmZmVyRW5kID0gLTEgLy8gZW5kIG9mIHRoZSBidWZmZXJcbiAgLy8gVGhpcyBpcyBhIGxpdHRsZSBvdmVyIGNvbXBsZXggYmVjYXVzZSBzb21lIGJyb3dzZXJzIHNlZW0gdG8gc2VwYXJhdGUgdGhlXG4gIC8vIGJ1ZmZlcmVkIHJlZ2lvbiBpbnRvIG11bHRpcGxlIHNlY3Rpb25zIHdpdGggc2xpZ2h0IGdhcHMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnQgPSBidWZmZXJlZC5zdGFydChpKVxuICAgIHZhciBlbmQgPSBidWZmZXJlZC5lbmQoaSkgKyBFUFNJTE9OXG5cbiAgICBpZiAoc3RhcnQgPiBjdXJyZW50VGltZSkge1xuICAgICAgLy8gUmVhY2hlZCBwYXN0IHRoZSBqb2luZWQgYnVmZmVyXG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAoYnVmZmVyRW5kID49IDAgfHwgY3VycmVudFRpbWUgPD0gZW5kKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgc3RhcnQvY29udGludWF0aW9uIG9mIHRoZSBqb2luZWQgYnVmZmVyXG4gICAgICBidWZmZXJFbmQgPSBlbmRcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyZWRUaW1lID0gYnVmZmVyRW5kIC0gY3VycmVudFRpbWVcbiAgaWYgKGJ1ZmZlcmVkVGltZSA8IDApIHtcbiAgICBidWZmZXJlZFRpbWUgPSAwXG4gIH1cblxuICByZXR1cm4gYnVmZmVyZWRUaW1lXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2VcblxuZnVuY3Rpb24gU3RvcmFnZSAoY2h1bmtMZW5ndGgsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0b3JhZ2UpKSByZXR1cm4gbmV3IFN0b3JhZ2UoY2h1bmtMZW5ndGgsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdGhpcy5jaHVua0xlbmd0aCA9IE51bWJlcihjaHVua0xlbmd0aClcbiAgaWYgKCF0aGlzLmNodW5rTGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjaHVuayBsZW5ndGgnKVxuXG4gIHRoaXMuY2h1bmtzID0gW11cbiAgdGhpcy5jbG9zZWQgPSBmYWxzZVxuICB0aGlzLmxlbmd0aCA9IE51bWJlcihvcHRzLmxlbmd0aCkgfHwgSW5maW5pdHlcblxuICBpZiAodGhpcy5sZW5ndGggIT09IEluZmluaXR5KSB7XG4gICAgdGhpcy5sYXN0Q2h1bmtMZW5ndGggPSAodGhpcy5sZW5ndGggJSB0aGlzLmNodW5rTGVuZ3RoKSB8fCB0aGlzLmNodW5rTGVuZ3RoXG4gICAgdGhpcy5sYXN0Q2h1bmtJbmRleCA9IE1hdGguY2VpbCh0aGlzLmxlbmd0aCAvIHRoaXMuY2h1bmtMZW5ndGgpIC0gMVxuICB9XG59XG5cblN0b3JhZ2UucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChpbmRleCwgYnVmLCBjYikge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdTdG9yYWdlIGlzIGNsb3NlZCcpKVxuXG4gIHZhciBpc0xhc3RDaHVuayA9IChpbmRleCA9PT0gdGhpcy5sYXN0Q2h1bmtJbmRleClcbiAgaWYgKGlzTGFzdENodW5rICYmIGJ1Zi5sZW5ndGggIT09IHRoaXMubGFzdENodW5rTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGNiLCBuZXcgRXJyb3IoJ0xhc3QgY2h1bmsgbGVuZ3RoIG11c3QgYmUgJyArIHRoaXMubGFzdENodW5rTGVuZ3RoKSlcbiAgfVxuICBpZiAoIWlzTGFzdENodW5rICYmIGJ1Zi5sZW5ndGggIT09IHRoaXMuY2h1bmtMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignQ2h1bmsgbGVuZ3RoIG11c3QgYmUgJyArIHRoaXMuY2h1bmtMZW5ndGgpKVxuICB9XG4gIHRoaXMuY2h1bmtzW2luZGV4XSA9IGJ1ZlxuICBuZXh0VGljayhjYiwgbnVsbClcbn1cblxuU3RvcmFnZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmdldChpbmRleCwgbnVsbCwgb3B0cylcbiAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignU3RvcmFnZSBpcyBjbG9zZWQnKSlcbiAgdmFyIGJ1ZiA9IHRoaXMuY2h1bmtzW2luZGV4XVxuICBpZiAoIWJ1ZikgcmV0dXJuIG5leHRUaWNrKGNiLCBuZXcgRXJyb3IoJ0NodW5rIG5vdCBmb3VuZCcpKVxuICBpZiAoIW9wdHMpIHJldHVybiBuZXh0VGljayhjYiwgbnVsbCwgYnVmKVxuICB2YXIgb2Zmc2V0ID0gb3B0cy5vZmZzZXQgfHwgMFxuICB2YXIgbGVuID0gb3B0cy5sZW5ndGggfHwgKGJ1Zi5sZW5ndGggLSBvZmZzZXQpXG4gIG5leHRUaWNrKGNiLCBudWxsLCBidWYuc2xpY2Uob2Zmc2V0LCBsZW4gKyBvZmZzZXQpKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5jbG9zZSA9IFN0b3JhZ2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignU3RvcmFnZSBpcyBjbG9zZWQnKSlcbiAgdGhpcy5jbG9zZWQgPSB0cnVlXG4gIHRoaXMuY2h1bmtzID0gbnVsbFxuICBuZXh0VGljayhjYiwgbnVsbClcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBlcnIsIHZhbCkge1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIGNiKGVyciwgdmFsKVxuICB9KVxufVxuIiwiLy8gVGhpcyBpcyBhbiBpbnRlbnRpb25hbGx5IHJlY3Vyc2l2ZSByZXF1aXJlLiBJIGRvbid0IGxpa2UgaXQgZWl0aGVyLlxudmFyIEJveCA9IHJlcXVpcmUoJy4vaW5kZXgnKVxudmFyIERlc2NyaXB0b3IgPSByZXF1aXJlKCcuL2Rlc2NyaXB0b3InKVxuXG52YXIgVElNRV9PRkZTRVQgPSAyMDgyODQ0ODAwMDAwXG5cbi8qXG5UT0RPOlxudGVzdCB0aGVzZVxuYWRkIG5ldyBib3ggdmVyc2lvbnNcbiovXG5cbi8vIFRoZXNlIGhhdmUgJ3ZlcnNpb24nIGFuZCAnZmxhZ3MnIGZpZWxkcyBpbiB0aGUgaGVhZGVyc1xuZXhwb3J0cy5mdWxsQm94ZXMgPSB7fVxudmFyIGZ1bGxCb3hlcyA9IFtcbiAgJ212aGQnLFxuICAndGtoZCcsXG4gICdtZGhkJyxcbiAgJ3ZtaGQnLFxuICAnc21oZCcsXG4gICdzdHNkJyxcbiAgJ2VzZHMnLFxuICAnc3RzeicsXG4gICdzdGNvJyxcbiAgJ3N0c3MnLFxuICAnc3R0cycsXG4gICdjdHRzJyxcbiAgJ3N0c2MnLFxuICAnZHJlZicsXG4gICdlbHN0JyxcbiAgJ2hkbHInLFxuICAnbWVoZCcsXG4gICd0cmV4JyxcbiAgJ21maGQnLFxuICAndGZoZCcsXG4gICd0ZmR0JyxcbiAgJ3RydW4nXG5dXG5mdWxsQm94ZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBleHBvcnRzLmZ1bGxCb3hlc1t0eXBlXSA9IHRydWVcbn0pXG5cbmV4cG9ydHMuZnR5cCA9IHt9XG5leHBvcnRzLmZ0eXAuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuZnR5cC5lbmNvZGluZ0xlbmd0aChib3gpKVxuICB2YXIgYnJhbmRzID0gYm94LmNvbXBhdGlibGVCcmFuZHMgfHwgW11cbiAgYnVmLndyaXRlKGJveC5icmFuZCwgMCwgNCwgJ2FzY2lpJylcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmJyYW5kVmVyc2lvbiwgNClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBicmFuZHMubGVuZ3RoOyBpKyspIGJ1Zi53cml0ZShicmFuZHNbaV0sIDggKyAoaSAqIDQpLCA0LCAnYXNjaWknKVxuICBleHBvcnRzLmZ0eXAuZW5jb2RlLmJ5dGVzID0gOCArIGJyYW5kcy5sZW5ndGggKiA0XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuZnR5cC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIGJyYW5kID0gYnVmLnRvU3RyaW5nKCdhc2NpaScsIDAsIDQpXG4gIHZhciB2ZXJzaW9uID0gYnVmLnJlYWRVSW50MzJCRSg0KVxuICB2YXIgY29tcGF0aWJsZUJyYW5kcyA9IFtdXG4gIGZvciAodmFyIGkgPSA4OyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSBjb21wYXRpYmxlQnJhbmRzLnB1c2goYnVmLnRvU3RyaW5nKCdhc2NpaScsIGksIGkgKyA0KSlcbiAgcmV0dXJuIHtcbiAgICBicmFuZDogYnJhbmQsXG4gICAgYnJhbmRWZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGNvbXBhdGlibGVCcmFuZHM6IGNvbXBhdGlibGVCcmFuZHNcbiAgfVxufVxuZXhwb3J0cy5mdHlwLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOCArIChib3guY29tcGF0aWJsZUJyYW5kcyB8fCBbXSkubGVuZ3RoICogNFxufVxuXG5leHBvcnRzLm12aGQgPSB7fVxuZXhwb3J0cy5tdmhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig5NilcbiAgd3JpdGVEYXRlKGJveC5jdGltZSB8fCBuZXcgRGF0ZSgpLCBidWYsIDApXG4gIHdyaXRlRGF0ZShib3gubXRpbWUgfHwgbmV3IERhdGUoKSwgYnVmLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShib3gudGltZVNjYWxlIHx8IDAsIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kdXJhdGlvbiB8fCAwLCAxMilcbiAgd3JpdGVGaXhlZDMyKGJveC5wcmVmZXJyZWRSYXRlIHx8IDAsIGJ1ZiwgMTYpXG4gIHdyaXRlRml4ZWQxNihib3gucHJlZmVycmVkVm9sdW1lIHx8IDAsIGJ1ZiwgMjApXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAyMiwgMzIpXG4gIHdyaXRlTWF0cml4KGJveC5tYXRyaXgsIGJ1ZiwgMzIpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5wcmV2aWV3VGltZSB8fCAwLCA2OClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnByZXZpZXdEdXJhdGlvbiB8fCAwLCA3MilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnBvc3RlclRpbWUgfHwgMCwgNzYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zZWxlY3Rpb25UaW1lIHx8IDAsIDgwKVxuICBidWYud3JpdGVVSW50MzJCRShib3guc2VsZWN0aW9uRHVyYXRpb24gfHwgMCwgODQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5jdXJyZW50VGltZSB8fCAwLCA4OClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94Lm5leHRUcmFja0lkIHx8IDAsIDkyKVxuICBleHBvcnRzLm12aGQuZW5jb2RlLmJ5dGVzID0gOTZcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5tdmhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGN0aW1lOiByZWFkRGF0ZShidWYsIDApLFxuICAgIG10aW1lOiByZWFkRGF0ZShidWYsIDQpLFxuICAgIHRpbWVTY2FsZTogYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBkdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSgxMiksXG4gICAgcHJlZmVycmVkUmF0ZTogcmVhZEZpeGVkMzIoYnVmLCAxNiksXG4gICAgcHJlZmVycmVkVm9sdW1lOiByZWFkRml4ZWQxNihidWYsIDIwKSxcbiAgICBtYXRyaXg6IHJlYWRNYXRyaXgoYnVmLnNsaWNlKDMyLCA2OCkpLFxuICAgIHByZXZpZXdUaW1lOiBidWYucmVhZFVJbnQzMkJFKDY4KSxcbiAgICBwcmV2aWV3RHVyYXRpb246IGJ1Zi5yZWFkVUludDMyQkUoNzIpLFxuICAgIHBvc3RlclRpbWU6IGJ1Zi5yZWFkVUludDMyQkUoNzYpLFxuICAgIHNlbGVjdGlvblRpbWU6IGJ1Zi5yZWFkVUludDMyQkUoODApLFxuICAgIHNlbGVjdGlvbkR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDg0KSxcbiAgICBjdXJyZW50VGltZTogYnVmLnJlYWRVSW50MzJCRSg4OCksXG4gICAgbmV4dFRyYWNrSWQ6IGJ1Zi5yZWFkVUludDMyQkUoOTIpXG4gIH1cbn1cbmV4cG9ydHMubXZoZC5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDk2XG59XG5cbmV4cG9ydHMudGtoZCA9IHt9XG5leHBvcnRzLnRraGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDgwKVxuICB3cml0ZURhdGUoYm94LmN0aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgMClcbiAgd3JpdGVEYXRlKGJveC5tdGltZSB8fCBuZXcgRGF0ZSgpLCBidWYsIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja0lkIHx8IDAsIDgpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAxMiwgMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kdXJhdGlvbiB8fCAwLCAxNilcbiAgd3JpdGVSZXNlcnZlZChidWYsIDIwLCAyOClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LmxheWVyIHx8IDAsIDI4KVxuICBidWYud3JpdGVVSW50MTZCRShib3guYWx0ZXJuYXRlR3JvdXAgfHwgMCwgMzApXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC52b2x1bWUgfHwgMCwgMzIpXG4gIHdyaXRlTWF0cml4KGJveC5tYXRyaXgsIGJ1ZiwgMzYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja1dpZHRoIHx8IDAsIDcyKVxuICBidWYud3JpdGVVSW50MzJCRShib3gudHJhY2tIZWlnaHQgfHwgMCwgNzYpXG4gIGV4cG9ydHMudGtoZC5lbmNvZGUuYnl0ZXMgPSA4MFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnRraGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgY3RpbWU6IHJlYWREYXRlKGJ1ZiwgMCksXG4gICAgbXRpbWU6IHJlYWREYXRlKGJ1ZiwgNCksXG4gICAgdHJhY2tJZDogYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBkdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSgxNiksXG4gICAgbGF5ZXI6IGJ1Zi5yZWFkVUludDE2QkUoMjgpLFxuICAgIGFsdGVybmF0ZUdyb3VwOiBidWYucmVhZFVJbnQxNkJFKDMwKSxcbiAgICB2b2x1bWU6IGJ1Zi5yZWFkVUludDE2QkUoMzIpLFxuICAgIG1hdHJpeDogcmVhZE1hdHJpeChidWYuc2xpY2UoMzYsIDcyKSksXG4gICAgdHJhY2tXaWR0aDogYnVmLnJlYWRVSW50MzJCRSg3MiksXG4gICAgdHJhY2tIZWlnaHQ6IGJ1Zi5yZWFkVUludDMyQkUoNzYpXG4gIH1cbn1cbmV4cG9ydHMudGtoZC5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDgwXG59XG5cbmV4cG9ydHMubWRoZCA9IHt9XG5leHBvcnRzLm1kaGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDIwKVxuICB3cml0ZURhdGUoYm94LmN0aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgMClcbiAgd3JpdGVEYXRlKGJveC5tdGltZSB8fCBuZXcgRGF0ZSgpLCBidWYsIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50aW1lU2NhbGUgfHwgMCwgOClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmR1cmF0aW9uIHx8IDAsIDEyKVxuICBidWYud3JpdGVVSW50MTZCRShib3gubGFuZ3VhZ2UgfHwgMCwgMTYpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5xdWFsaXR5IHx8IDAsIDE4KVxuICBleHBvcnRzLm1kaGQuZW5jb2RlLmJ5dGVzID0gMjBcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5tZGhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGN0aW1lOiByZWFkRGF0ZShidWYsIDApLFxuICAgIG10aW1lOiByZWFkRGF0ZShidWYsIDQpLFxuICAgIHRpbWVTY2FsZTogYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBkdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSgxMiksXG4gICAgbGFuZ3VhZ2U6IGJ1Zi5yZWFkVUludDE2QkUoMTYpLFxuICAgIHF1YWxpdHk6IGJ1Zi5yZWFkVUludDE2QkUoMTgpXG4gIH1cbn1cbmV4cG9ydHMubWRoZC5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDIwXG59XG5cbmV4cG9ydHMudm1oZCA9IHt9XG5leHBvcnRzLnZtaGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDgpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5ncmFwaGljc01vZGUgfHwgMCwgMClcbiAgdmFyIG9wY29sb3IgPSBib3gub3Bjb2xvciB8fCBbMCwgMCwgMF1cbiAgYnVmLndyaXRlVUludDE2QkUob3Bjb2xvclswXSwgMilcbiAgYnVmLndyaXRlVUludDE2QkUob3Bjb2xvclsxXSwgNClcbiAgYnVmLndyaXRlVUludDE2QkUob3Bjb2xvclsyXSwgNilcbiAgZXhwb3J0cy52bWhkLmVuY29kZS5ieXRlcyA9IDhcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy52bWhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGdyYXBoaWNzTW9kZTogYnVmLnJlYWRVSW50MTZCRSgwKSxcbiAgICBvcGNvbG9yOiBbYnVmLnJlYWRVSW50MTZCRSgyKSwgYnVmLnJlYWRVSW50MTZCRSg0KSwgYnVmLnJlYWRVSW50MTZCRSg2KV1cbiAgfVxufVxuZXhwb3J0cy52bWhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOFxufVxuXG5leHBvcnRzLnNtaGQgPSB7fVxuZXhwb3J0cy5zbWhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuICBidWYud3JpdGVVSW50MTZCRShib3guYmFsYW5jZSB8fCAwLCAwKVxuICB3cml0ZVJlc2VydmVkKGJ1ZiwgMiwgNClcbiAgZXhwb3J0cy5zbWhkLmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zbWhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGJhbGFuY2U6IGJ1Zi5yZWFkVUludDE2QkUoMClcbiAgfVxufVxuZXhwb3J0cy5zbWhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNFxufVxuXG5leHBvcnRzLnN0c2QgPSB7fVxuZXhwb3J0cy5zdHNkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcihleHBvcnRzLnN0c2QuZW5jb2RpbmdMZW5ndGgoYm94KSlcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIHZhciBwdHIgPSA0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaV1cbiAgICBCb3guZW5jb2RlKGVudHJ5LCBidWYsIHB0cilcbiAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICB9XG5cbiAgZXhwb3J0cy5zdHNkLmVuY29kZS5ieXRlcyA9IHB0clxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnN0c2QuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuICB2YXIgcHRyID0gNFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgZW50cnkgPSBCb3guZGVjb2RlKGJ1ZiwgcHRyLCBlbmQpXG4gICAgZW50cmllc1tpXSA9IGVudHJ5XG4gICAgcHRyICs9IGVudHJ5Lmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuc3RzZC5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIHRvdGFsU2l6ZSA9IDRcbiAgaWYgKCFib3guZW50cmllcykgcmV0dXJuIHRvdGFsU2l6ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5lbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdG90YWxTaXplICs9IEJveC5lbmNvZGluZ0xlbmd0aChib3guZW50cmllc1tpXSlcbiAgfVxuICByZXR1cm4gdG90YWxTaXplXG59XG5cbmV4cG9ydHMuYXZjMSA9IGV4cG9ydHMuVmlzdWFsU2FtcGxlRW50cnkgPSB7fVxuZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAwLCA2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guZGF0YVJlZmVyZW5jZUluZGV4IHx8IDAsIDYpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCA4LCAyNClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LndpZHRoIHx8IDAsIDI0KVxuICBidWYud3JpdGVVSW50MTZCRShib3guaGVpZ2h0IHx8IDAsIDI2KVxuICBidWYud3JpdGVVSW50MzJCRShib3guaFJlc29sdXRpb24gfHwgMHg0ODAwMDAsIDI4KVxuICBidWYud3JpdGVVSW50MzJCRShib3gudlJlc29sdXRpb24gfHwgMHg0ODAwMDAsIDMyKVxuICB3cml0ZVJlc2VydmVkKGJ1ZiwgMzYsIDQwKVxuICBidWYud3JpdGVVSW50MTZCRShib3guZnJhbWVDb3VudCB8fCAxLCA0MClcbiAgdmFyIGNvbXByZXNzb3JOYW1lID0gYm94LmNvbXByZXNzb3JOYW1lIHx8ICcnXG4gIHZhciBuYW1lTGVuID0gTWF0aC5taW4oY29tcHJlc3Nvck5hbWUubGVuZ3RoLCAzMSlcbiAgYnVmLndyaXRlVUludDgobmFtZUxlbiwgNDIpXG4gIGJ1Zi53cml0ZShjb21wcmVzc29yTmFtZSwgNDMsIG5hbWVMZW4sICd1dGY4JylcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LmRlcHRoIHx8IDB4MTgsIDc0KVxuICBidWYud3JpdGVJbnQxNkJFKC0xLCA3NilcblxuICB2YXIgcHRyID0gNzhcbiAgdmFyIGNoaWxkcmVuID0gYm94LmNoaWxkcmVuIHx8IFtdXG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgQm94LmVuY29kZShjaGlsZCwgYnVmLCBwdHIpXG4gICAgcHRyICs9IEJveC5lbmNvZGUuYnl0ZXNcbiAgfSlcbiAgZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5lbmNvZGUuYnl0ZXMgPSBwdHJcbn1cbmV4cG9ydHMuVmlzdWFsU2FtcGxlRW50cnkuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIGxlbmd0aCA9IGVuZCAtIG9mZnNldFxuICB2YXIgbmFtZUxlbiA9IE1hdGgubWluKGJ1Zi5yZWFkVUludDgoNDIpLCAzMSlcbiAgdmFyIGJveCA9IHtcbiAgICBkYXRhUmVmZXJlbmNlSW5kZXg6IGJ1Zi5yZWFkVUludDE2QkUoNiksXG4gICAgd2lkdGg6IGJ1Zi5yZWFkVUludDE2QkUoMjQpLFxuICAgIGhlaWdodDogYnVmLnJlYWRVSW50MTZCRSgyNiksXG4gICAgaFJlc29sdXRpb246IGJ1Zi5yZWFkVUludDMyQkUoMjgpLFxuICAgIHZSZXNvbHV0aW9uOiBidWYucmVhZFVJbnQzMkJFKDMyKSxcbiAgICBmcmFtZUNvdW50OiBidWYucmVhZFVJbnQxNkJFKDQwKSxcbiAgICBjb21wcmVzc29yTmFtZTogYnVmLnRvU3RyaW5nKCd1dGY4JywgNDMsIDQzICsgbmFtZUxlbiksXG4gICAgZGVwdGg6IGJ1Zi5yZWFkVUludDE2QkUoNzQpLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG5cbiAgdmFyIHB0ciA9IDc4XG4gIHdoaWxlIChsZW5ndGggLSBwdHIgPj0gOCkge1xuICAgIHZhciBjaGlsZCA9IEJveC5kZWNvZGUoYnVmLCBwdHIsIGxlbmd0aClcbiAgICBib3guY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICBib3hbY2hpbGQudHlwZV0gPSBjaGlsZFxuICAgIHB0ciArPSBjaGlsZC5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBib3hcbn1cbmV4cG9ydHMuVmlzdWFsU2FtcGxlRW50cnkuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHZhciBsZW4gPSA3OFxuICB2YXIgY2hpbGRyZW4gPSBib3guY2hpbGRyZW4gfHwgW11cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBsZW4gKz0gQm94LmVuY29kaW5nTGVuZ3RoKGNoaWxkKVxuICB9KVxuICByZXR1cm4gbGVuXG59XG5cbmV4cG9ydHMuYXZjQyA9IHt9XG5leHBvcnRzLmF2Y0MuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBCdWZmZXIoYm94LmJ1ZmZlci5sZW5ndGgpXG5cbiAgYm94LmJ1ZmZlci5jb3B5KGJ1ZilcbiAgZXhwb3J0cy5hdmNDLmVuY29kZS5ieXRlcyA9IGJveC5idWZmZXIubGVuZ3RoXG59XG5leHBvcnRzLmF2Y0MuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldCwgZW5kKVxuXG4gIHJldHVybiB7XG4gICAgbWltZUNvZGVjOiBidWYudG9TdHJpbmcoJ2hleCcsIDEsIDQpLFxuICAgIGJ1ZmZlcjogbmV3IEJ1ZmZlcihidWYpXG4gIH1cbn1cbmV4cG9ydHMuYXZjQy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIGJveC5idWZmZXIubGVuZ3RoXG59XG5cbmV4cG9ydHMubXA0YSA9IGV4cG9ydHMuQXVkaW9TYW1wbGVFbnRyeSA9IHt9XG5leHBvcnRzLkF1ZGlvU2FtcGxlRW50cnkuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuQXVkaW9TYW1wbGVFbnRyeS5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAwLCA2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guZGF0YVJlZmVyZW5jZUluZGV4IHx8IDAsIDYpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCA4LCAxNilcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LmNoYW5uZWxDb3VudCB8fCAyLCAxNilcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LnNhbXBsZVNpemUgfHwgMTYsIDE4KVxuICB3cml0ZVJlc2VydmVkKGJ1ZiwgMjAsIDI0KVxuICBidWYud3JpdGVVSW50MzJCRShib3guc2FtcGxlUmF0ZSB8fCAwLCAyNClcblxuICB2YXIgcHRyID0gMjhcbiAgdmFyIGNoaWxkcmVuID0gYm94LmNoaWxkcmVuIHx8IFtdXG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgQm94LmVuY29kZShjaGlsZCwgYnVmLCBwdHIpXG4gICAgcHRyICs9IEJveC5lbmNvZGUuYnl0ZXNcbiAgfSlcbiAgZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmVuY29kZS5ieXRlcyA9IHB0clxufVxuZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgZW5kKSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQsIGVuZClcbiAgdmFyIGxlbmd0aCA9IGVuZCAtIG9mZnNldFxuICB2YXIgYm94ID0ge1xuICAgIGRhdGFSZWZlcmVuY2VJbmRleDogYnVmLnJlYWRVSW50MTZCRSg2KSxcbiAgICBjaGFubmVsQ291bnQ6IGJ1Zi5yZWFkVUludDE2QkUoMTYpLFxuICAgIHNhbXBsZVNpemU6IGJ1Zi5yZWFkVUludDE2QkUoMTgpLFxuICAgIHNhbXBsZVJhdGU6IGJ1Zi5yZWFkVUludDMyQkUoMjQpLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG5cbiAgdmFyIHB0ciA9IDI4XG4gIHdoaWxlIChsZW5ndGggLSBwdHIgPj0gOCkge1xuICAgIHZhciBjaGlsZCA9IEJveC5kZWNvZGUoYnVmLCBwdHIsIGxlbmd0aClcbiAgICBib3guY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICBib3hbY2hpbGQudHlwZV0gPSBjaGlsZFxuICAgIHB0ciArPSBjaGlsZC5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBib3hcbn1cbmV4cG9ydHMuQXVkaW9TYW1wbGVFbnRyeS5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIGxlbiA9IDI4XG4gIHZhciBjaGlsZHJlbiA9IGJveC5jaGlsZHJlbiB8fCBbXVxuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGxlbiArPSBCb3guZW5jb2RpbmdMZW5ndGgoY2hpbGQpXG4gIH0pXG4gIHJldHVybiBsZW5cbn1cblxuZXhwb3J0cy5lc2RzID0ge31cbmV4cG9ydHMuZXNkcy5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IEJ1ZmZlcihib3guYnVmZmVyLmxlbmd0aClcblxuICBib3guYnVmZmVyLmNvcHkoYnVmLCAwKVxuICBleHBvcnRzLmVzZHMuZW5jb2RlLmJ5dGVzID0gYm94LmJ1ZmZlci5sZW5ndGhcbn1cbmV4cG9ydHMuZXNkcy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0LCBlbmQpXG5cbiAgdmFyIGRlc2MgPSBEZXNjcmlwdG9yLkRlc2NyaXB0b3IuZGVjb2RlKGJ1ZiwgMCwgYnVmLmxlbmd0aClcbiAgdmFyIGVzZCA9IChkZXNjLnRhZ05hbWUgPT09ICdFU0Rlc2NyaXB0b3InKSA/IGRlc2MgOiB7fVxuICB2YXIgZGNkID0gZXNkLkRlY29kZXJDb25maWdEZXNjcmlwdG9yIHx8IHt9XG4gIHZhciBvdGkgPSBkY2Qub3RpIHx8IDBcbiAgdmFyIGRzaSA9IGRjZC5EZWNvZGVyU3BlY2lmaWNJbmZvXG4gIHZhciBhdWRpb0NvbmZpZyA9IGRzaSA/IChkc2kuYnVmZmVyLnJlYWRVSW50OCgwKSAmIDB4ZjgpID4+IDMgOiAwXG5cbiAgdmFyIG1pbWVDb2RlYyA9IG51bGxcbiAgaWYgKG90aSkge1xuICAgIG1pbWVDb2RlYyA9IG90aS50b1N0cmluZygxNilcbiAgICBpZiAoYXVkaW9Db25maWcpIHtcbiAgICAgIG1pbWVDb2RlYyArPSAnLicgKyBhdWRpb0NvbmZpZ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWltZUNvZGVjOiBtaW1lQ29kZWMsXG4gICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1Zi5zbGljZSgwKSlcbiAgfVxufVxuZXhwb3J0cy5lc2RzLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gYm94LmJ1ZmZlci5sZW5ndGhcbn1cblxuLy8gVE9ETzogaW50ZWdyYXRlIHRoZSB0d28gdmVyc2lvbnMgaW4gYSBzYW5lciB3YXlcbmV4cG9ydHMuc3RzeiA9IHt9XG5leHBvcnRzLnN0c3ouZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IEJ1ZmZlcihleHBvcnRzLnN0c3ouZW5jb2RpbmdMZW5ndGgoYm94KSlcblxuICBidWYud3JpdGVVSW50MzJCRSgwLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzLmxlbmd0aCwgNClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLCBpICogNCArIDgpXG4gIH1cblxuICBleHBvcnRzLnN0c3ouZW5jb2RlLmJ5dGVzID0gOCArIGVudHJpZXMubGVuZ3RoICogNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnN0c3ouZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHZhciBzaXplID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSg0KVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICBlbnRyaWVzW2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNCArIDgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJpZXNbaV0gPSBzaXplXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuc3Rzei5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDggKyBib3guZW50cmllcy5sZW5ndGggKiA0XG59XG5cbmV4cG9ydHMuc3RzcyA9XG5leHBvcnRzLnN0Y28gPSB7fVxuZXhwb3J0cy5zdGNvLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBlbnRyaWVzID0gYm94LmVudHJpZXMgfHwgW11cbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3Rjby5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0sIGkgKiA0ICsgNClcbiAgfVxuXG4gIGV4cG9ydHMuc3Rjby5lbmNvZGUuYnl0ZXMgPSA0ICsgZW50cmllcy5sZW5ndGggKiA0XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3Rjby5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICBlbnRyaWVzW2ldID0gYnVmLnJlYWRVSW50MzJCRShpICogNCArIDQpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdGNvLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDRcbn1cblxuZXhwb3J0cy5zdHRzID0ge31cbmV4cG9ydHMuc3R0cy5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcihleHBvcnRzLnN0dHMuZW5jb2RpbmdMZW5ndGgoYm94KSlcblxuICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzLmxlbmd0aCwgMClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHRyID0gaSAqIDggKyA0XG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXS5jb3VudCB8fCAwLCBwdHIpXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXS5kdXJhdGlvbiB8fCAwLCBwdHIgKyA0KVxuICB9XG5cbiAgZXhwb3J0cy5zdHRzLmVuY29kZS5ieXRlcyA9IDQgKyBib3guZW50cmllcy5sZW5ndGggKiA4XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3R0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgcHRyID0gaSAqIDggKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIGNvdW50OiBidWYucmVhZFVJbnQzMkJFKHB0ciksXG4gICAgICBkdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRShwdHIgKyA0KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50cmllczogZW50cmllc1xuICB9XG59XG5leHBvcnRzLnN0dHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0ICsgYm94LmVudHJpZXMubGVuZ3RoICogOFxufVxuXG5leHBvcnRzLmN0dHMgPSB7fVxuZXhwb3J0cy5jdHRzLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBlbnRyaWVzID0gYm94LmVudHJpZXMgfHwgW11cbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuY3R0cy5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogOCArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmNvdW50IHx8IDAsIHB0cilcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmNvbXBvc2l0aW9uT2Zmc2V0IHx8IDAsIHB0ciArIDQpXG4gIH1cblxuICBleHBvcnRzLmN0dHMuZW5jb2RlLmJ5dGVzID0gNCArIGVudHJpZXMubGVuZ3RoICogOFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLmN0dHMuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiA4ICsgNFxuICAgIGVudHJpZXNbaV0gPSB7XG4gICAgICBjb3VudDogYnVmLnJlYWRVSW50MzJCRShwdHIpLFxuICAgICAgY29tcG9zaXRpb25PZmZzZXQ6IGJ1Zi5yZWFkSW50MzJCRShwdHIgKyA0KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50cmllczogZW50cmllc1xuICB9XG59XG5leHBvcnRzLmN0dHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0ICsgYm94LmVudHJpZXMubGVuZ3RoICogOFxufVxuXG5leHBvcnRzLnN0c2MgPSB7fVxuZXhwb3J0cy5zdHNjLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBlbnRyaWVzID0gYm94LmVudHJpZXMgfHwgW11cbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3RzYy5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogMTIgKyA0XG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXS5maXJzdENodW5rIHx8IDAsIHB0cilcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLnNhbXBsZXNQZXJDaHVuayB8fCAwLCBwdHIgKyA0KVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uc2FtcGxlRGVzY3JpcHRpb25JZCB8fCAwLCBwdHIgKyA4KVxuICB9XG5cbiAgZXhwb3J0cy5zdHNjLmVuY29kZS5ieXRlcyA9IDQgKyBlbnRyaWVzLmxlbmd0aCAqIDEyXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3RzYy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgcHRyID0gaSAqIDEyICsgNFxuICAgIGVudHJpZXNbaV0gPSB7XG4gICAgICBmaXJzdENodW5rOiBidWYucmVhZFVJbnQzMkJFKHB0ciksXG4gICAgICBzYW1wbGVzUGVyQ2h1bms6IGJ1Zi5yZWFkVUludDMyQkUocHRyICsgNCksXG4gICAgICBzYW1wbGVEZXNjcmlwdGlvbklkOiBidWYucmVhZFVJbnQzMkJFKHB0ciArIDgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuc3RzYy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiAxMlxufVxuXG5leHBvcnRzLmRyZWYgPSB7fVxuZXhwb3J0cy5kcmVmLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcihleHBvcnRzLmRyZWYuZW5jb2RpbmdMZW5ndGgoYm94KSlcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIHZhciBwdHIgPSA0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaV1cbiAgICB2YXIgc2l6ZSA9IChlbnRyeS5idWYgPyBlbnRyeS5idWYubGVuZ3RoIDogMCkgKyA0ICsgNFxuXG4gICAgYnVmLndyaXRlVUludDMyQkUoc2l6ZSwgcHRyKVxuICAgIHB0ciArPSA0XG5cbiAgICBidWYud3JpdGUoZW50cnkudHlwZSwgcHRyLCA0LCAnYXNjaWknKVxuICAgIHB0ciArPSA0XG5cbiAgICBpZiAoZW50cnkuYnVmKSB7XG4gICAgICBlbnRyeS5idWYuY29weShidWYsIHB0cilcbiAgICAgIHB0ciArPSBlbnRyeS5idWYubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5kcmVmLmVuY29kZS5ieXRlcyA9IHB0clxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLmRyZWYuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcbiAgdmFyIHB0ciA9IDRcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgdmFyIHNpemUgPSBidWYucmVhZFVJbnQzMkJFKHB0cilcbiAgICB2YXIgdHlwZSA9IGJ1Zi50b1N0cmluZygnYXNjaWknLCBwdHIgKyA0LCBwdHIgKyA4KVxuICAgIHZhciB0bXAgPSBidWYuc2xpY2UocHRyICsgOCwgcHRyICsgc2l6ZSlcbiAgICBwdHIgKz0gc2l6ZVxuXG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBidWY6IHRtcFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50cmllczogZW50cmllc1xuICB9XG59XG5leHBvcnRzLmRyZWYuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHZhciB0b3RhbFNpemUgPSA0XG4gIGlmICghYm94LmVudHJpZXMpIHJldHVybiB0b3RhbFNpemVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3guZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBib3guZW50cmllc1tpXS5idWZcbiAgICB0b3RhbFNpemUgKz0gKGJ1ZiA/IGJ1Zi5sZW5ndGggOiAwKSArIDQgKyA0XG4gIH1cbiAgcmV0dXJuIHRvdGFsU2l6ZVxufVxuXG5leHBvcnRzLmVsc3QgPSB7fVxuZXhwb3J0cy5lbHN0LmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBlbnRyaWVzID0gYm94LmVudHJpZXMgfHwgW11cbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuZWxzdC5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogMTIgKyA0XG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXS50cmFja0R1cmF0aW9uIHx8IDAsIHB0cilcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLm1lZGlhVGltZSB8fCAwLCBwdHIgKyA0KVxuICAgIHdyaXRlRml4ZWQzMihlbnRyaWVzW2ldLm1lZGlhUmF0ZSB8fCAwLCBidWYsIHB0ciArIDgpXG4gIH1cblxuICBleHBvcnRzLmVsc3QuZW5jb2RlLmJ5dGVzID0gNCArIGVudHJpZXMubGVuZ3RoICogMTJcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5lbHN0LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogMTIgKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIHRyYWNrRHVyYXRpb246IGJ1Zi5yZWFkVUludDMyQkUocHRyKSxcbiAgICAgIG1lZGlhVGltZTogYnVmLnJlYWRJbnQzMkJFKHB0ciArIDQpLFxuICAgICAgbWVkaWFSYXRlOiByZWFkRml4ZWQzMihidWYsIHB0ciArIDgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuZWxzdC5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiAxMlxufVxuXG5leHBvcnRzLmhkbHIgPSB7fVxuZXhwb3J0cy5oZGxyLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcihleHBvcnRzLmhkbHIuZW5jb2RpbmdMZW5ndGgoYm94KSlcblxuICB2YXIgbGVuID0gMjEgKyAoYm94Lm5hbWUgfHwgJycpLmxlbmd0aFxuICBidWYuZmlsbCgwLCAwLCBsZW4pXG5cbiAgYnVmLndyaXRlKGJveC5oYW5kbGVyVHlwZSB8fCAnJywgNCwgNCwgJ2FzY2lpJylcbiAgd3JpdGVTdHJpbmcoYm94Lm5hbWUgfHwgJycsIGJ1ZiwgMjApXG5cbiAgZXhwb3J0cy5oZGxyLmVuY29kZS5ieXRlcyA9IGxlblxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLmhkbHIuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyVHlwZTogYnVmLnRvU3RyaW5nKCdhc2NpaScsIDQsIDgpLFxuICAgIG5hbWU6IHJlYWRTdHJpbmcoYnVmLCAyMCwgZW5kKVxuICB9XG59XG5leHBvcnRzLmhkbHIuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiAyMSArIChib3gubmFtZSB8fCAnJykubGVuZ3RoXG59XG5cbmV4cG9ydHMubWVoZCA9IHt9XG5leHBvcnRzLm1laGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDQpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmZyYWdtZW50RHVyYXRpb24gfHwgMCwgMClcbiAgZXhwb3J0cy5tZWhkLmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5tZWhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGZyYWdtZW50RHVyYXRpb246IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgfVxufVxuZXhwb3J0cy5tZWhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNFxufVxuXG5leHBvcnRzLnRyZXggPSB7fVxuZXhwb3J0cy50cmV4LmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcigyMClcblxuICBidWYud3JpdGVVSW50MzJCRShib3gudHJhY2tJZCB8fCAwLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShib3guZGVmYXVsdFNhbXBsZURlc2NyaXB0aW9uSW5kZXggfHwgMCwgNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmRlZmF1bHRTYW1wbGVEdXJhdGlvbiB8fCAwLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShib3guZGVmYXVsdFNhbXBsZVNpemUgfHwgMCwgMTIpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kZWZhdWx0U2FtcGxlRmxhZ3MgfHwgMCwgMTYpXG4gIGV4cG9ydHMudHJleC5lbmNvZGUuYnl0ZXMgPSAyMFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnRyZXguZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgdHJhY2tJZDogYnVmLnJlYWRVSW50MzJCRSgwKSxcbiAgICBkZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleDogYnVmLnJlYWRVSW50MzJCRSg0KSxcbiAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb246IGJ1Zi5yZWFkVUludDMyQkUoOCksXG4gICAgZGVmYXVsdFNhbXBsZVNpemU6IGJ1Zi5yZWFkVUludDMyQkUoMTIpLFxuICAgIGRlZmF1bHRTYW1wbGVGbGFnczogYnVmLnJlYWRVSW50MzJCRSgxNilcbiAgfVxufVxuZXhwb3J0cy50cmV4LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gMjBcbn1cblxuZXhwb3J0cy5tZmhkID0ge31cbmV4cG9ydHMubWZoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoNClcblxuICBidWYud3JpdGVVSW50MzJCRShib3guc2VxdWVuY2VOdW1iZXIgfHwgMCwgMClcbiAgZXhwb3J0cy5tZmhkLmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5tZmhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICByZXR1cm4ge1xuICAgIHNlcXVlbmNlTnVtYmVyOiBidWYucmVhZFVpbnQzMkJFKDApXG4gIH1cbn1cbmV4cG9ydHMubWZoZC5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDRcbn1cblxuZXhwb3J0cy50ZmhkID0ge31cbmV4cG9ydHMudGZoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRyYWNrSWQsIDApXG4gIGV4cG9ydHMudGZoZC5lbmNvZGUuYnl0ZXMgPSA0XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudGZoZC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgLy8gVE9ETzogdGhpc1xufVxuZXhwb3J0cy50ZmhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICAvLyBUT0RPOiB0aGlzIGlzIHdyb25nIVxuICByZXR1cm4gNFxufVxuXG5leHBvcnRzLnRmZHQgPSB7fVxuZXhwb3J0cy50ZmR0LmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5iYXNlTWVkaWFEZWNvZGVUaW1lIHx8IDAsIDApXG4gIGV4cG9ydHMudGZkdC5lbmNvZGUuYnl0ZXMgPSA0XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudGZkdC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgLy8gVE9ETzogdGhpc1xufVxuZXhwb3J0cy50ZmR0LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNFxufVxuXG5leHBvcnRzLnRydW4gPSB7fVxuZXhwb3J0cy50cnVuLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig4ICsgYm94LmVudHJpZXMubGVuZ3RoICogMTYpXG5cbiAgLy8gVE9ETzogdGhpcyBpcyB3cm9uZ1xuICBidWYud3JpdGVVSW50MzJCRShib3guZW50cmllcy5sZW5ndGgsIDApXG4gIGJ1Zi53cml0ZUludDMyQkUoYm94LmRhdGFPZmZzZXQsIDQpXG4gIHZhciBwdHIgPSA4XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94LmVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZW50cnkgPSBib3guZW50cmllc1tpXVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJ5LnNhbXBsZUR1cmF0aW9uLCBwdHIpXG4gICAgcHRyICs9IDRcblxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJ5LnNhbXBsZVNpemUsIHB0cilcbiAgICBwdHIgKz0gNFxuXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlRmxhZ3MsIHB0cilcbiAgICBwdHIgKz0gNFxuXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0LCBwdHIpXG4gICAgcHRyICs9IDRcbiAgfVxuICBleHBvcnRzLnRydW4uZW5jb2RlLmJ5dGVzID0gcHRyXG59XG5leHBvcnRzLnRydW4uZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIFRPRE86IHRoaXNcbn1cbmV4cG9ydHMudHJ1bi5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgLy8gVE9ETzogdGhpcyBpcyB3cm9uZ1xuICByZXR1cm4gOCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDE2XG59XG5cbmV4cG9ydHMubWRhdCA9IHt9XG5leHBvcnRzLm1kYXQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKGJveC5idWZmZXIpIHtcbiAgICBib3guYnVmZmVyLmNvcHkoYnVmLCBvZmZzZXQpXG4gICAgZXhwb3J0cy5tZGF0LmVuY29kZS5ieXRlcyA9IGJveC5idWZmZXIubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5tZGF0LmVuY29kZS5ieXRlcyA9IGV4cG9ydHMubWRhdC5lbmNvZGluZ0xlbmd0aChib3gpXG4gIH1cbn1cbmV4cG9ydHMubWRhdC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB7XG4gICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuZXhwb3J0cy5tZGF0LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gYm94LmJ1ZmZlciA/IGJveC5idWZmZXIubGVuZ3RoIDogYm94LmNvbnRlbnRMZW5ndGhcbn1cblxuZnVuY3Rpb24gd3JpdGVSZXNlcnZlZCAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIGJ1ZltpXSA9IDBcbn1cblxuZnVuY3Rpb24gd3JpdGVEYXRlIChkYXRlLCBidWYsIG9mZnNldCkge1xuICBidWYud3JpdGVVSW50MzJCRShNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSArIFRJTUVfT0ZGU0VUKSAvIDEwMDApLCBvZmZzZXQpXG59XG5cbi8vIFRPRE86IHRoaW5rIHNvbWV0aGluZyBpcyB3cm9uZyBoZXJlXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIgKG51bSwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmLndyaXRlVUludDE2QkUoTWF0aC5mbG9vcihudW0pICUgKDI1NiAqIDI1NiksIG9mZnNldClcbiAgYnVmLndyaXRlVUludDE2QkUoTWF0aC5mbG9vcihudW0gKiAyNTYgKiAyNTYpICUgKDI1NiAqIDI1NiksIG9mZnNldCArIDIpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQxNiAobnVtLCBidWYsIG9mZnNldCkge1xuICBidWZbb2Zmc2V0XSA9IE1hdGguZmxvb3IobnVtKSAlIDI1NlxuICBidWZbb2Zmc2V0ICsgMV0gPSBNYXRoLmZsb29yKG51bSAqIDI1NikgJSAyNTZcbn1cblxuZnVuY3Rpb24gd3JpdGVNYXRyaXggKGxpc3QsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmICghbGlzdCkgbGlzdCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZUZpeGVkMzIobGlzdFtpXSwgYnVmLCBvZmZzZXQgKyBpICogNClcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmluZyAoc3RyLCBidWYsIG9mZnNldCkge1xuICB2YXIgc3RyQnVmZmVyID0gbmV3IEJ1ZmZlcihzdHIsICd1dGY4JylcbiAgc3RyQnVmZmVyLmNvcHkoYnVmLCBvZmZzZXQpXG4gIGJ1ZltvZmZzZXQgKyBzdHJCdWZmZXIubGVuZ3RoXSA9IDBcbn1cblxuZnVuY3Rpb24gcmVhZE1hdHJpeCAoYnVmKSB7XG4gIHZhciBsaXN0ID0gbmV3IEFycmF5KGJ1Zi5sZW5ndGggLyA0KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0gPSByZWFkRml4ZWQzMihidWYsIGkgKiA0KVxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiByZWFkRGF0ZSAoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0KSAqIDEwMDAgLSBUSU1FX09GRlNFVClcbn1cblxuZnVuY3Rpb24gcmVhZEZpeGVkMzIgKGJ1Ziwgb2Zmc2V0KSB7XG4gIHJldHVybiBidWYucmVhZFVJbnQxNkJFKG9mZnNldCkgKyBidWYucmVhZFVJbnQxNkJFKG9mZnNldCArIDIpIC8gKDI1NiAqIDI1Nilcbn1cblxuZnVuY3Rpb24gcmVhZEZpeGVkMTYgKGJ1Ziwgb2Zmc2V0KSB7XG4gIHJldHVybiBidWZbb2Zmc2V0XSArIGJ1ZltvZmZzZXQgKyAxXSAvIDI1NlxufVxuXG5mdW5jdGlvbiByZWFkU3RyaW5nIChidWYsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChidWZbb2Zmc2V0ICsgaV0gPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBvZmZzZXQsIG9mZnNldCArIGkpXG59XG4iLCJ2YXIgdGFnVG9OYW1lID0ge1xuICAweDAzOiAnRVNEZXNjcmlwdG9yJyxcbiAgMHgwNDogJ0RlY29kZXJDb25maWdEZXNjcmlwdG9yJyxcbiAgMHgwNTogJ0RlY29kZXJTcGVjaWZpY0luZm8nLFxuICAweDA2OiAnU0xDb25maWdEZXNjcmlwdG9yJ1xufVxuXG5leHBvcnRzLkRlc2NyaXB0b3IgPSB7fVxuZXhwb3J0cy5EZXNjcmlwdG9yLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRhZyA9IGJ1Zi5yZWFkVUludDgoc3RhcnQpXG4gIHZhciBwdHIgPSBzdGFydCArIDFcbiAgdmFyIGxlbkJ5dGVcbiAgdmFyIGxlbiA9IDBcbiAgZG8ge1xuICAgIGxlbkJ5dGUgPSBidWYucmVhZFVJbnQ4KHB0cisrKVxuICAgIGxlbiA9IChsZW4gPDwgNykgfCAobGVuQnl0ZSAmIDB4N2YpXG4gIH0gd2hpbGUgKGxlbkJ5dGUgJiAweDgwKVxuXG4gIHZhciBvYmpcbiAgdmFyIHRhZ05hbWUgPSB0YWdUb05hbWVbdGFnXSAvLyBNYXkgYmUgdW5kZWZpbmVkOyB0aGF0J3Mgb2tcbiAgaWYgKGV4cG9ydHNbdGFnTmFtZV0pIHtcbiAgICBvYmogPSBleHBvcnRzW3RhZ05hbWVdLmRlY29kZShidWYsIHB0ciwgZW5kKVxuICB9IGVsc2Uge1xuICAgIG9iaiA9IHtcbiAgICAgIGJ1ZmZlcjogbmV3IEJ1ZmZlcihidWYuc2xpY2UocHRyLCBwdHIgKyBsZW4pKVxuICAgIH1cbiAgfVxuXG4gIG9iai50YWcgPSB0YWdcbiAgb2JqLnRhZ05hbWUgPSB0YWdOYW1lXG4gIG9iai5sZW5ndGggPSAocHRyIC0gc3RhcnQpICsgbGVuXG4gIG9iai5jb250ZW50c0xlbiA9IGxlblxuICByZXR1cm4gb2JqXG59XG5cbmV4cG9ydHMuRGVzY3JpcHRvckFycmF5ID0ge31cbmV4cG9ydHMuRGVzY3JpcHRvckFycmF5LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHB0ciA9IHN0YXJ0XG4gIHZhciBvYmogPSB7fVxuICB3aGlsZSAocHRyICsgMiA8PSBlbmQpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGV4cG9ydHMuRGVzY3JpcHRvci5kZWNvZGUoYnVmLCBwdHIsIGVuZClcbiAgICBwdHIgKz0gZGVzY3JpcHRvci5sZW5ndGhcbiAgICB2YXIgdGFnTmFtZSA9IHRhZ1RvTmFtZVtkZXNjcmlwdG9yLnRhZ10gfHwgKCdEZXNjcmlwdG9yJyArIGRlc2NyaXB0b3IudGFnKVxuICAgIG9ialt0YWdOYW1lXSA9IGRlc2NyaXB0b3JcbiAgfVxuICByZXR1cm4gb2JqXG59XG5cbmV4cG9ydHMuRVNEZXNjcmlwdG9yID0ge31cbmV4cG9ydHMuRVNEZXNjcmlwdG9yLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGZsYWdzID0gYnVmLnJlYWRVSW50OChzdGFydCArIDIpXG4gIHZhciBwdHIgPSBzdGFydCArIDNcbiAgaWYgKGZsYWdzICYgMHg4MCkge1xuICAgIHB0ciArPSAyXG4gIH1cbiAgaWYgKGZsYWdzICYgMHg0MCkge1xuICAgIHZhciBsZW4gPSBidWYucmVhZFVJbnQ4KHB0cilcbiAgICBwdHIgKz0gbGVuICsgMVxuICB9XG4gIGlmIChmbGFncyAmIDB4MjApIHtcbiAgICBwdHIgKz0gMlxuICB9XG4gIHJldHVybiBleHBvcnRzLkRlc2NyaXB0b3JBcnJheS5kZWNvZGUoYnVmLCBwdHIsIGVuZClcbn1cblxuZXhwb3J0cy5EZWNvZGVyQ29uZmlnRGVzY3JpcHRvciA9IHt9XG5leHBvcnRzLkRlY29kZXJDb25maWdEZXNjcmlwdG9yLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIG90aSA9IGJ1Zi5yZWFkVUludDgoc3RhcnQpXG4gIHZhciBvYmogPSBleHBvcnRzLkRlc2NyaXB0b3JBcnJheS5kZWNvZGUoYnVmLCBzdGFydCArIDEzLCBlbmQpXG4gIG9iai5vdGkgPSBvdGlcbiAgcmV0dXJuIG9ialxufVxuIiwiLy8gdmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgdWludDY0YmUgPSByZXF1aXJlKCd1aW50NjRiZScpXG5cbnZhciBib3hlcyA9IHJlcXVpcmUoJy4vYm94ZXMnKVxuXG52YXIgVUlOVDMyX01BWCA9IDQyOTQ5NjcyOTVcblxudmFyIEJveCA9IGV4cG9ydHNcblxuLypcbiAqIExpc3RzIHRoZSBwcm9wZXIgb3JkZXIgZm9yIGJveGVzIGluc2lkZSBjb250YWluZXJzLlxuICogRml2ZS1jaGFyYWN0ZXIgbmFtZXMgZW5kaW5nIGluICdzJyBpbmRpY2F0ZSBhcnJheXMgaW5zdGVhZCBvZiBzaW5nbGUgZWxlbWVudHMuXG4gKi9cbnZhciBjb250YWluZXJzID0gZXhwb3J0cy5jb250YWluZXJzID0ge1xuICAnbW9vdic6IFsnbXZoZCcsICdtZXRhJywgJ3RyYWtzJywgJ212ZXgnXSxcbiAgJ3RyYWsnOiBbJ3RraGQnLCAndHJlZicsICd0cmdyJywgJ2VkdHMnLCAnbWV0YScsICdtZGlhJywgJ3VkdGEnXSxcbiAgJ2VkdHMnOiBbJ2Vsc3QnXSxcbiAgJ21kaWEnOiBbJ21kaGQnLCAnaGRscicsICdlbG5nJywgJ21pbmYnXSxcbiAgJ21pbmYnOiBbJ3ZtaGQnLCAnc21oZCcsICdobWhkJywgJ3N0aGQnLCAnbm1oZCcsICdkaW5mJywgJ3N0YmwnXSxcbiAgJ2RpbmYnOiBbJ2RyZWYnXSxcbiAgJ3N0YmwnOiBbJ3N0c2QnLCAnc3R0cycsICdjdHRzJywgJ2NzbGcnLCAnc3RzYycsICdzdHN6JywgJ3N0ejInLCAnc3RjbycsICdjbzY0JywgJ3N0c3MnLCAnc3RzaCcsICdwYWRiJywgJ3N0ZHAnLCAnc2R0cCcsICdzYmdwcycsICdzZ3BkcycsICdzdWJzcycsICdzYWl6cycsICdzYWlvcyddLFxuICAnbXZleCc6IFsnbWVoZCcsICd0cmV4cycsICdsZXZhJ10sXG4gICdtb29mJzogWydtZmhkJywgJ21ldGEnLCAndHJhZnMnXSxcbiAgJ3RyYWYnOiBbJ3RmaGQnLCAndHJ1bicsICdzYmdwcycsICdzZ3BkcycsICdzdWJzcycsICdzYWl6cycsICdzYWlvcycsICd0ZmR0JywgJ21ldGEnXVxufVxuXG5Cb3guZW5jb2RlID0gZnVuY3Rpb24gKG9iaiwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgQm94LmVuY29kaW5nTGVuZ3RoKG9iaikgLy8gc2V0cyBldmVyeSBsZXZlbCBhcHByb3ByaWF0ZWx5XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIGJ1ZmZlciA9IGJ1ZmZlciB8fCBuZXcgQnVmZmVyKG9iai5sZW5ndGgpXG4gIHJldHVybiBCb3guX2VuY29kZShvYmosIGJ1ZmZlciwgb2Zmc2V0KVxufVxuXG5Cb3guX2VuY29kZSA9IGZ1bmN0aW9uIChvYmosIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHZhciB0eXBlID0gb2JqLnR5cGVcbiAgdmFyIGxlbiA9IG9iai5sZW5ndGhcbiAgaWYgKGxlbiA+IFVJTlQzMl9NQVgpIHtcbiAgICBsZW4gPSAxXG4gIH1cbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpXG4gIGJ1ZmZlci53cml0ZShvYmoudHlwZSwgb2Zmc2V0ICsgNCwgNCwgJ2FzY2lpJylcbiAgdmFyIHB0ciA9IG9mZnNldCArIDhcbiAgaWYgKGxlbiA9PT0gMSkge1xuICAgIHVpbnQ2NGJlLmVuY29kZShvYmoubGVuZ3RoLCBidWZmZXIsIHB0cilcbiAgICBwdHIgKz0gOFxuICB9XG4gIGlmIChib3hlcy5mdWxsQm94ZXNbdHlwZV0pIHtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShvYmouZmxhZ3MgfHwgMCwgcHRyKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG9iai52ZXJzaW9uIHx8IDAsIHB0cilcbiAgICBwdHIgKz0gNFxuICB9XG5cbiAgaWYgKGNvbnRhaW5lcnNbdHlwZV0pIHtcbiAgICB2YXIgY29udGVudHMgPSBjb250YWluZXJzW3R5cGVdXG4gICAgY29udGVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUeXBlKSB7XG4gICAgICBpZiAoY2hpbGRUeXBlLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICB2YXIgZW50cnkgPSBvYmpbY2hpbGRUeXBlXSB8fCBbXVxuICAgICAgICBjaGlsZFR5cGUgPSBjaGlsZFR5cGUuc3Vic3RyKDAsIDQpXG4gICAgICAgIGVudHJ5LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgQm94Ll9lbmNvZGUoY2hpbGQsIGJ1ZmZlciwgcHRyKVxuICAgICAgICAgIHB0ciArPSBCb3guZW5jb2RlLmJ5dGVzXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKG9ialtjaGlsZFR5cGVdKSB7XG4gICAgICAgIEJveC5fZW5jb2RlKG9ialtjaGlsZFR5cGVdLCBidWZmZXIsIHB0cilcbiAgICAgICAgcHRyICs9IEJveC5lbmNvZGUuYnl0ZXNcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChvYmoub3RoZXJCb3hlcykge1xuICAgICAgb2JqLm90aGVyQm94ZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgQm94Ll9lbmNvZGUoY2hpbGQsIGJ1ZmZlciwgcHRyKVxuICAgICAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm94ZXNbdHlwZV0pIHtcbiAgICB2YXIgZW5jb2RlID0gYm94ZXNbdHlwZV0uZW5jb2RlXG4gICAgZW5jb2RlKG9iaiwgYnVmZmVyLCBwdHIpXG4gICAgcHRyICs9IGVuY29kZS5ieXRlc1xuICB9IGVsc2UgaWYgKG9iai5idWZmZXIpIHtcbiAgICB2YXIgYnVmID0gb2JqLmJ1ZmZlclxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcHRyKVxuICAgIHB0ciArPSBvYmouYnVmZmVyLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRWl0aGVyIGB0eXBlYCBtdXN0IGJlIHNldCB0byBhIGtub3duIHR5cGUgKG5vdFxcJycgKyB0eXBlICsgJ1xcJykgb3IgYGJ1ZmZlcmAgbXVzdCBiZSBzZXQnKVxuICB9XG5cbiAgQm94LmVuY29kZS5ieXRlcyA9IHB0ciAtIG9mZnNldFxuICAvLyBhc3NlcnQuZXF1YWwocHRyIC0gb2Zmc2V0LCBvYmoubGVuZ3RoLCAnRXJyb3IgZW5jb2RpbmcgXFwnJyArIHR5cGUgKyAnXFwnOiB3cm90ZSAnICsgcHRyIC0gb2Zmc2V0ICsgJyBieXRlcywgZXhwZWN0aW5nICcgKyBvYmoubGVuZ3RoKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8qXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB0eXBlYCBhbmQgYHNpemVgIGZpZWxkcyxcbiAqIG9yIGlmIHRoZXJlIGlzbid0IGVub3VnaCBkYXRhLCByZXR1cm5zIHRoZSB0b3RhbFxuICogbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0byByZWFkIHRoZSBoZWFkZXJzXG4gKi9cbkJveC5yZWFkSGVhZGVycyA9IGZ1bmN0aW9uIChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IGVuZCB8fCBidWZmZXIubGVuZ3RoXG4gIGlmIChlbmQgLSBzdGFydCA8IDgpIHtcbiAgICByZXR1cm4gOFxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUoc3RhcnQpXG4gIHZhciB0eXBlID0gYnVmZmVyLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0ICsgNCwgc3RhcnQgKyA4KVxuICB2YXIgcHRyID0gc3RhcnQgKyA4XG5cbiAgaWYgKGxlbiA9PT0gMSkge1xuICAgIGlmIChlbmQgLSBzdGFydCA8IDE2KSB7XG4gICAgICByZXR1cm4gMTZcbiAgICB9XG5cbiAgICBsZW4gPSB1aW50NjRiZS5kZWNvZGUoYnVmZmVyLCBwdHIpXG4gICAgcHRyICs9IDhcbiAgfVxuXG4gIHZhciB2ZXJzaW9uXG4gIHZhciBmbGFnc1xuICBpZiAoYm94ZXMuZnVsbEJveGVzW3R5cGVdKSB7XG4gICAgdmVyc2lvbiA9IGJ1ZmZlci5yZWFkVUludDgocHRyKVxuICAgIGZsYWdzID0gYnVmZmVyLnJlYWRVSW50MzJCRShwdHIpICYgMHhmZmZmZmZcbiAgICBwdHIgKz0gNFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IGxlbixcbiAgICBoZWFkZXJzTGVuOiBwdHIgLSBzdGFydCxcbiAgICBjb250ZW50TGVuOiBsZW4gLSAocHRyIC0gc3RhcnQpLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBmbGFnczogZmxhZ3NcbiAgfVxufVxuXG5Cb3guZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgZW5kID0gZW5kIHx8IGJ1ZmZlci5sZW5ndGhcbiAgdmFyIGhlYWRlcnMgPSBCb3gucmVhZEhlYWRlcnMoYnVmZmVyLCBzdGFydCwgZW5kKVxuICBpZiAoIWhlYWRlcnMgfHwgaGVhZGVycy5sZW5ndGggPiBlbmQgLSBzdGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YSB0b28gc2hvcnQnKVxuICB9XG5cbiAgcmV0dXJuIEJveC5kZWNvZGVXaXRob3V0SGVhZGVycyhoZWFkZXJzLCBidWZmZXIsIHN0YXJ0ICsgaGVhZGVycy5oZWFkZXJzTGVuLCBzdGFydCArIGhlYWRlcnMubGVuZ3RoKVxufVxuXG5Cb3guZGVjb2RlV2l0aG91dEhlYWRlcnMgPSBmdW5jdGlvbiAoaGVhZGVycywgYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBlbmQgPSBlbmQgfHwgYnVmZmVyLmxlbmd0aFxuICB2YXIgdHlwZSA9IGhlYWRlcnMudHlwZVxuICB2YXIgb2JqID0ge31cbiAgaWYgKGNvbnRhaW5lcnNbdHlwZV0pIHtcbiAgICBvYmoub3RoZXJCb3hlcyA9IFtdXG4gICAgdmFyIGNvbnRlbnRzID0gY29udGFpbmVyc1t0eXBlXVxuICAgIHZhciBwdHIgPSBzdGFydFxuICAgIHdoaWxlIChlbmQgLSBwdHIgPj0gOCkge1xuICAgICAgdmFyIGNoaWxkID0gQm94LmRlY29kZShidWZmZXIsIHB0ciwgZW5kKVxuICAgICAgcHRyICs9IGNoaWxkLmxlbmd0aFxuICAgICAgaWYgKGNvbnRlbnRzLmluZGV4T2YoY2hpbGQudHlwZSkgPj0gMCkge1xuICAgICAgICBvYmpbY2hpbGQudHlwZV0gPSBjaGlsZFxuICAgICAgfSBlbHNlIGlmIChjb250ZW50cy5pbmRleE9mKGNoaWxkLnR5cGUgKyAncycpID49IDApIHtcbiAgICAgICAgdmFyIGNoaWxkVHlwZSA9IGNoaWxkLnR5cGUgKyAncydcbiAgICAgICAgdmFyIGVudHJ5ID0gb2JqW2NoaWxkVHlwZV0gPSBvYmpbY2hpbGRUeXBlXSB8fCBbXVxuICAgICAgICBlbnRyeS5wdXNoKGNoaWxkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqLm90aGVyQm94ZXMucHVzaChjaGlsZClcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYm94ZXNbdHlwZV0pIHtcbiAgICB2YXIgZGVjb2RlID0gYm94ZXNbdHlwZV0uZGVjb2RlXG4gICAgb2JqID0gZGVjb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBvYmouYnVmZmVyID0gbmV3IEJ1ZmZlcihidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBvYmoubGVuZ3RoID0gaGVhZGVycy5sZW5ndGhcbiAgb2JqLmNvbnRlbnRMZW4gPSBoZWFkZXJzLmNvbnRlbnRMZW5cbiAgb2JqLnR5cGUgPSBoZWFkZXJzLnR5cGVcbiAgb2JqLnZlcnNpb24gPSBoZWFkZXJzLnZlcnNpb25cbiAgb2JqLmZsYWdzID0gaGVhZGVycy5mbGFnc1xuICByZXR1cm4gb2JqXG59XG5cbkJveC5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHR5cGUgPSBvYmoudHlwZVxuXG4gIHZhciBsZW4gPSA4XG4gIGlmIChib3hlcy5mdWxsQm94ZXNbdHlwZV0pIHtcbiAgICBsZW4gKz0gNFxuICB9XG5cbiAgaWYgKGNvbnRhaW5lcnNbdHlwZV0pIHtcbiAgICB2YXIgY29udGVudHMgPSBjb250YWluZXJzW3R5cGVdXG4gICAgY29udGVudHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUeXBlKSB7XG4gICAgICBpZiAoY2hpbGRUeXBlLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICB2YXIgZW50cnkgPSBvYmpbY2hpbGRUeXBlXSB8fCBbXVxuICAgICAgICBjaGlsZFR5cGUgPSBjaGlsZFR5cGUuc3Vic3RyKDAsIDQpXG4gICAgICAgIGVudHJ5LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgY2hpbGQudHlwZSA9IGNoaWxkVHlwZVxuICAgICAgICAgIGxlbiArPSBCb3guZW5jb2RpbmdMZW5ndGgoY2hpbGQpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKG9ialtjaGlsZFR5cGVdKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG9ialtjaGlsZFR5cGVdXG4gICAgICAgIGNoaWxkLnR5cGUgPSBjaGlsZFR5cGVcbiAgICAgICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChvYmoub3RoZXJCb3hlcykge1xuICAgICAgb2JqLm90aGVyQm94ZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2UgaWYgKGJveGVzW3R5cGVdKSB7XG4gICAgbGVuICs9IGJveGVzW3R5cGVdLmVuY29kaW5nTGVuZ3RoKG9iailcbiAgfSBlbHNlIGlmIChvYmouYnVmZmVyKSB7XG4gICAgbGVuICs9IG9iai5idWZmZXIubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgYHR5cGVgIG11c3QgYmUgc2V0IHRvIGEga25vd24gdHlwZSAobm90XFwnJyArIHR5cGUgKyAnXFwnKSBvciBgYnVmZmVyYCBtdXN0IGJlIHNldCcpXG4gIH1cblxuICBpZiAobGVuID4gVUlOVDMyX01BWCkge1xuICAgIGxlbiArPSA4XG4gIH1cblxuICBvYmoubGVuZ3RoID0gbGVuXG4gIHJldHVybiBsZW5cbn1cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG5leHRFdmVudCA9IHJlcXVpcmUoJ25leHQtZXZlbnQnKVxudmFyIEJveCA9IHJlcXVpcmUoJ21wNC1ib3gtZW5jb2RpbmcnKVxuXG52YXIgRU1QVFkgPSBuZXcgQnVmZmVyKDApXG5cbm1vZHVsZS5leHBvcnRzID0gRGVjb2RlclxuXG5mdW5jdGlvbiBEZWNvZGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlY29kZXIpKSByZXR1cm4gbmV3IERlY29kZXIoKVxuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLl9wZW5kaW5nID0gMFxuICB0aGlzLl9taXNzaW5nID0gMFxuICB0aGlzLl9idWYgPSBudWxsXG4gIHRoaXMuX3N0ciA9IG51bGxcbiAgdGhpcy5fY2IgPSBudWxsXG4gIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gIHRoaXMuX3dyaXRlQnVmZmVyID0gbnVsbFxuICB0aGlzLl93cml0ZUNiID0gbnVsbFxuXG4gIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gIHRoaXMuX2tpY2soKVxufVxuXG5pbmhlcml0cyhEZWNvZGVyLCBzdHJlYW0uV3JpdGFibGUpXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRGVjb2Rlci5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYywgbmV4dCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB2YXIgZHJhaW5lZCA9ICF0aGlzLl9zdHIgfHwgIXRoaXMuX3N0ci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW5cblxuICB3aGlsZSAoZGF0YS5sZW5ndGggJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKCF0aGlzLl9taXNzaW5nKSB7XG4gICAgICB0aGlzLl93cml0ZUJ1ZmZlciA9IGRhdGFcbiAgICAgIHRoaXMuX3dyaXRlQ2IgPSBuZXh0XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY29uc3VtZWQgPSBkYXRhLmxlbmd0aCA8IHRoaXMuX21pc3NpbmcgPyBkYXRhLmxlbmd0aCA6IHRoaXMuX21pc3NpbmdcbiAgICBpZiAodGhpcy5fYnVmKSBkYXRhLmNvcHkodGhpcy5fYnVmLCB0aGlzLl9idWYubGVuZ3RoIC0gdGhpcy5fbWlzc2luZylcbiAgICBlbHNlIGlmICh0aGlzLl9zdHIpIGRyYWluZWQgPSB0aGlzLl9zdHIud3JpdGUoY29uc3VtZWQgPT09IGRhdGEubGVuZ3RoID8gZGF0YSA6IGRhdGEuc2xpY2UoMCwgY29uc3VtZWQpKVxuXG4gICAgdGhpcy5fbWlzc2luZyAtPSBjb25zdW1lZFxuXG4gICAgaWYgKCF0aGlzLl9taXNzaW5nKSB7XG4gICAgICB2YXIgYnVmID0gdGhpcy5fYnVmXG4gICAgICB2YXIgY2IgPSB0aGlzLl9jYlxuICAgICAgdmFyIHN0cmVhbSA9IHRoaXMuX3N0clxuXG4gICAgICB0aGlzLl9idWYgPSB0aGlzLl9jYiA9IHRoaXMuX3N0ciA9IHRoaXMuX29uZHJhaW4gPSBudWxsXG4gICAgICBkcmFpbmVkID0gdHJ1ZVxuXG4gICAgICBpZiAoc3RyZWFtKSBzdHJlYW0uZW5kKClcbiAgICAgIGlmIChjYikgY2IoYnVmKVxuICAgIH1cblxuICAgIGRhdGEgPSBjb25zdW1lZCA9PT0gZGF0YS5sZW5ndGggPyBFTVBUWSA6IGRhdGEuc2xpY2UoY29uc3VtZWQpXG4gIH1cblxuICBpZiAodGhpcy5fcGVuZGluZyAmJiAhdGhpcy5fbWlzc2luZykge1xuICAgIHRoaXMuX3dyaXRlQnVmZmVyID0gZGF0YVxuICAgIHRoaXMuX3dyaXRlQ2IgPSBuZXh0XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZHJhaW5lZCkgbmV4dCgpXG4gIGVsc2UgdGhpcy5fb25kcmFpbihuZXh0KVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5fYnVmZmVyID0gZnVuY3Rpb24gKHNpemUsIGNiKSB7XG4gIHRoaXMuX21pc3NpbmcgPSBzaXplXG4gIHRoaXMuX2J1ZiA9IG5ldyBCdWZmZXIoc2l6ZSlcbiAgdGhpcy5fY2IgPSBjYlxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5fc3RyZWFtID0gZnVuY3Rpb24gKHNpemUsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9taXNzaW5nID0gc2l6ZVxuICB0aGlzLl9zdHIgPSBuZXcgTWVkaWFEYXRhKHRoaXMpXG4gIHRoaXMuX29uZHJhaW4gPSBuZXh0RXZlbnQodGhpcy5fc3RyLCAnZHJhaW4nKVxuICB0aGlzLl9wZW5kaW5nKytcbiAgdGhpcy5fc3RyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fcGVuZGluZy0tXG4gICAgc2VsZi5fa2ljaygpXG4gIH0pXG4gIHRoaXMuX2NiID0gY2JcbiAgcmV0dXJuIHRoaXMuX3N0clxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5fcmVhZEJveCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGJ1ZmZlckhlYWRlcnMoOClcblxuICBmdW5jdGlvbiBidWZmZXJIZWFkZXJzIChsZW4sIGJ1Zikge1xuICAgIHNlbGYuX2J1ZmZlcihsZW4sIGZ1bmN0aW9uIChhZGRpdGlvbmFsQnVmKSB7XG4gICAgICBpZiAoYnVmKSB7XG4gICAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmLCBhZGRpdGlvbmFsQnVmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmID0gYWRkaXRpb25hbEJ1ZlxuICAgICAgfVxuICAgICAgdmFyIGhlYWRlcnMgPSBCb3gucmVhZEhlYWRlcnMoYnVmKVxuICAgICAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSAnbnVtYmVyJykge1xuICAgICAgICBidWZmZXJIZWFkZXJzKGhlYWRlcnMgLSBidWYubGVuZ3RoLCBidWYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9wZW5kaW5nKytcbiAgICAgICAgc2VsZi5faGVhZGVycyA9IGhlYWRlcnNcbiAgICAgICAgc2VsZi5lbWl0KCdib3gnLCBoZWFkZXJzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuRGVjb2Rlci5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl9oZWFkZXJzKSB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UgYWZ0ZXIgXFwnYm94XFwnIGlzIGVtaXR0ZWQnKVxuICB2YXIgaGVhZGVycyA9IHNlbGYuX2hlYWRlcnNcbiAgc2VsZi5faGVhZGVycyA9IG51bGxcblxuICByZXR1cm4gc2VsZi5fc3RyZWFtKGhlYWRlcnMuY29udGVudExlbiwgbnVsbClcbn1cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuX2hlYWRlcnMpIHRocm93IG5ldyBFcnJvcigndGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgb25jZSBhZnRlciBcXCdib3hcXCcgaXMgZW1pdHRlZCcpXG4gIHZhciBoZWFkZXJzID0gc2VsZi5faGVhZGVyc1xuICBzZWxmLl9oZWFkZXJzID0gbnVsbFxuXG4gIHNlbGYuX2J1ZmZlcihoZWFkZXJzLmNvbnRlbnRMZW4sIGZ1bmN0aW9uIChidWYpIHtcbiAgICB2YXIgYm94ID0gQm94LmRlY29kZVdpdGhvdXRIZWFkZXJzKGhlYWRlcnMsIGJ1ZilcbiAgICBjYihib3gpXG4gICAgc2VsZi5fcGVuZGluZy0tXG4gICAgc2VsZi5fa2ljaygpXG4gIH0pXG59XG5cbkRlY29kZXIucHJvdG90eXBlLmlnbm9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5faGVhZGVycykgdGhyb3cgbmV3IEVycm9yKCd0aGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIGFmdGVyIFxcJ2JveFxcJyBpcyBlbWl0dGVkJylcbiAgdmFyIGhlYWRlcnMgPSBzZWxmLl9oZWFkZXJzXG4gIHNlbGYuX2hlYWRlcnMgPSBudWxsXG5cbiAgdGhpcy5fbWlzc2luZyA9IGhlYWRlcnMuY29udGVudExlblxuICB0aGlzLl9jYiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wZW5kaW5nLS1cbiAgICBzZWxmLl9raWNrKClcbiAgfVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5fa2ljayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3BlbmRpbmcpIHJldHVyblxuICBpZiAoIXRoaXMuX2J1ZiAmJiAhdGhpcy5fc3RyKSB0aGlzLl9yZWFkQm94KClcbiAgaWYgKHRoaXMuX3dyaXRlQnVmZmVyKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLl93cml0ZUNiXG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuX3dyaXRlQnVmZmVyXG4gICAgdGhpcy5fd3JpdGVCdWZmZXIgPSBudWxsXG4gICAgdGhpcy5fd3JpdGVDYiA9IG51bGxcbiAgICB0aGlzLl93cml0ZShidWZmZXIsIG51bGwsIG5leHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gTWVkaWFEYXRhIChwYXJlbnQpIHtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgc3RyZWFtLlBhc3NUaHJvdWdoLmNhbGwodGhpcylcbn1cblxuaW5oZXJpdHMoTWVkaWFEYXRhLCBzdHJlYW0uUGFzc1Rocm91Z2gpXG5cbk1lZGlhRGF0YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX3BhcmVudC5kZXN0cm95KGVycilcbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG4iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCb3ggPSByZXF1aXJlKCdtcDQtYm94LWVuY29kaW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyXG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gRW5jb2RlciAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFbmNvZGVyKSkgcmV0dXJuIG5ldyBFbmNvZGVyKClcbiAgc3RyZWFtLlJlYWRhYmxlLmNhbGwodGhpcylcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgdGhpcy5fcmVhZGluZyA9IGZhbHNlXG4gIHRoaXMuX3N0cmVhbSA9IG51bGxcbiAgdGhpcy5fZHJhaW4gPSBudWxsXG4gIHRoaXMuX3dhbnQgPSBmYWxzZVxuICB0aGlzLl9vbnJlYWRhYmxlID0gb25yZWFkYWJsZVxuICB0aGlzLl9vbmVuZCA9IG9uZW5kXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZnVuY3Rpb24gb25yZWFkYWJsZSAoKSB7XG4gICAgaWYgKCFzZWxmLl93YW50KSByZXR1cm5cbiAgICBzZWxmLl93YW50ID0gZmFsc2VcbiAgICBzZWxmLl9yZWFkKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kICgpIHtcbiAgICBzZWxmLl9zdHJlYW0gPSBudWxsXG4gIH1cbn1cblxuaW5oZXJpdHMoRW5jb2Rlciwgc3RyZWFtLlJlYWRhYmxlKVxuXG5FbmNvZGVyLnByb3RvdHlwZS5tZWRpYURhdGEgPVxuRW5jb2Rlci5wcm90b3R5cGUubWRhdCA9IGZ1bmN0aW9uIChzaXplLCBjYikge1xuICB2YXIgc3RyZWFtID0gbmV3IE1lZGlhRGF0YSh0aGlzKVxuICB0aGlzLmJveCh7dHlwZTogJ21kYXQnLCBjb250ZW50TGVuZ3RoOiBzaXplLCBlbmNvZGVCdWZmZXJMZW46IDgsIHN0cmVhbTogc3RyZWFtfSwgY2IpXG4gIHJldHVybiBzdHJlYW1cbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuYm94ID0gZnVuY3Rpb24gKGJveCwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSBub29wXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignRW5jb2RlciBpcyBkZXN0cm95ZWQnKSlcblxuICB2YXIgYnVmXG4gIGlmIChib3guZW5jb2RlQnVmZmVyTGVuKSB7XG4gICAgYnVmID0gbmV3IEJ1ZmZlcihib3guZW5jb2RlQnVmZmVyTGVuKVxuICB9XG4gIGlmIChib3guc3RyZWFtKSB7XG4gICAgYm94LmJ1ZmZlciA9IG51bGxcbiAgICBidWYgPSBCb3guZW5jb2RlKGJveCwgYnVmKVxuICAgIHRoaXMucHVzaChidWYpXG4gICAgdGhpcy5fc3RyZWFtID0gYm94LnN0cmVhbVxuICAgIHRoaXMuX3N0cmVhbS5vbigncmVhZGFibGUnLCB0aGlzLl9vbnJlYWRhYmxlKVxuICAgIHRoaXMuX3N0cmVhbS5vbignZW5kJywgdGhpcy5fb25lbmQpXG4gICAgdGhpcy5fc3RyZWFtLm9uKCdlbmQnLCBjYilcbiAgICB0aGlzLl9mb3J3YXJkKClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBCb3guZW5jb2RlKGJveCwgYnVmKVxuICAgIHZhciBkcmFpbmVkID0gdGhpcy5wdXNoKGJ1ZilcbiAgICBpZiAoZHJhaW5lZCkgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgdGhpcy5fZHJhaW4gPSBjYlxuICB9XG59XG5cbkVuY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICBpZiAodGhpcy5fc3RyZWFtICYmIHRoaXMuX3N0cmVhbS5kZXN0cm95KSB0aGlzLl9zdHJlYW0uZGVzdHJveSgpXG4gIHRoaXMuX3N0cmVhbSA9IG51bGxcbiAgaWYgKHRoaXMuX2RyYWluKSB7XG4gICAgdmFyIGNiID0gdGhpcy5fZHJhaW5cbiAgICB0aGlzLl9kcmFpbiA9IG51bGxcbiAgICBjYihlcnIpXG4gIH1cbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cbkVuY29kZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnB1c2gobnVsbClcbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuX2ZvcndhcmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fc3RyZWFtKSByZXR1cm5cblxuICB3aGlsZSAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuX3N0cmVhbS5yZWFkKClcblxuICAgIGlmICghYnVmKSB7XG4gICAgICB0aGlzLl93YW50ID0gISF0aGlzLl9zdHJlYW1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghdGhpcy5wdXNoKGJ1ZikpIHJldHVyblxuICB9XG59XG5cbkVuY29kZXIucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcmVhZGluZyB8fCB0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX3JlYWRpbmcgPSB0cnVlXG5cbiAgaWYgKHRoaXMuX3N0cmVhbSkgdGhpcy5fZm9yd2FyZCgpXG4gIGlmICh0aGlzLl9kcmFpbikge1xuICAgIHZhciBkcmFpbiA9IHRoaXMuX2RyYWluXG4gICAgdGhpcy5fZHJhaW4gPSBudWxsXG4gICAgZHJhaW4oKVxuICB9XG5cbiAgdGhpcy5fcmVhZGluZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIE1lZGlhRGF0YSAocGFyZW50KSB7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHN0cmVhbS5QYXNzVGhyb3VnaC5jYWxsKHRoaXMpXG59XG5cbmluaGVyaXRzKE1lZGlhRGF0YSwgc3RyZWFtLlBhc3NUaHJvdWdoKVxuXG5NZWRpYURhdGEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICB0aGlzLl9wYXJlbnQuZGVzdHJveShlcnIpXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuIiwiZXhwb3J0cy5kZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpXG5leHBvcnRzLmVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJylcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gTXVsdGlTdHJlYW1cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbmluaGVyaXRzKE11bHRpU3RyZWFtLCBzdHJlYW0uUmVhZGFibGUpXG5cbmZ1bmN0aW9uIE11bHRpU3RyZWFtIChzdHJlYW1zLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNdWx0aVN0cmVhbSkpIHJldHVybiBuZXcgTXVsdGlTdHJlYW0oc3RyZWFtcywgb3B0cylcbiAgc3RyZWFtLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgdGhpcy5fZHJhaW5lZCA9IGZhbHNlXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxuICB0aGlzLl9jdXJyZW50ID0gbnVsbFxuICB0aGlzLl9xdWV1ZSA9ICh0eXBlb2Ygc3RyZWFtcyA9PT0gJ2Z1bmN0aW9uJyA/IHN0cmVhbXMgOiBzdHJlYW1zLm1hcCh0b1N0cmVhbXMyKSlcblxuICB0aGlzLl9uZXh0KClcbn1cblxuTXVsdGlTdHJlYW0ub2JqID0gZnVuY3Rpb24gKHN0cmVhbXMpIHtcbiAgcmV0dXJuIG5ldyBNdWx0aVN0cmVhbShzdHJlYW1zLCB7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0pXG59XG5cbk11bHRpU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbk11bHRpU3RyZWFtLnByb3RvdHlwZS5fZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2ZvcndhcmRpbmcgfHwgIXRoaXMuX2RyYWluZWQgfHwgIXRoaXMuX2N1cnJlbnQpIHJldHVyblxuICB0aGlzLl9mb3J3YXJkaW5nID0gdHJ1ZVxuXG4gIHZhciBjaHVua1xuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY3VycmVudC5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgdGhpcy5fZHJhaW5lZCA9IHRoaXMucHVzaChjaHVuaylcbiAgfVxuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxufVxuXG5NdWx0aVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgaWYgKHRoaXMuX2N1cnJlbnQgJiYgdGhpcy5fY3VycmVudC5kZXN0cm95KSB0aGlzLl9jdXJyZW50LmRlc3Ryb3koKVxuICBpZiAodHlwZW9mIHRoaXMuX3F1ZXVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fcXVldWUuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICBpZiAoc3RyZWFtLmRlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KClcbiAgICB9KVxuICB9XG5cbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cbk11bHRpU3RyZWFtLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2N1cnJlbnQgPSBudWxsXG5cbiAgaWYgKHR5cGVvZiBzZWxmLl9xdWV1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuX3F1ZXVlKGZ1bmN0aW9uIChlcnIsIHN0cmVhbSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZGVzdHJveShlcnIpXG4gICAgICBzZWxmLl9nb3ROZXh0U3RyZWFtKHRvU3RyZWFtczIoc3RyZWFtKSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHZhciBzdHJlYW0gPSBzZWxmLl9xdWV1ZS5zaGlmdCgpXG4gICAgaWYgKHR5cGVvZiBzdHJlYW0gPT09ICdmdW5jdGlvbicpIHN0cmVhbSA9IHRvU3RyZWFtczIoc3RyZWFtKCkpXG4gICAgc2VsZi5fZ290TmV4dFN0cmVhbShzdHJlYW0pXG4gIH1cbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9nb3ROZXh0U3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoIXN0cmVhbSkge1xuICAgIHNlbGYucHVzaChudWxsKVxuICAgIHNlbGYuZGVzdHJveSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmLl9jdXJyZW50ID0gc3RyZWFtXG4gIHNlbGYuX2ZvcndhcmQoKVxuXG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlKVxuICBzdHJlYW0ub24oJ2VuZCcsIG9uRW5kKVxuICBzdHJlYW0ub24oJ2Vycm9yJywgb25FcnJvcilcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgZnVuY3Rpb24gb25SZWFkYWJsZSAoKSB7XG4gICAgc2VsZi5fZm9yd2FyZCgpXG4gIH1cblxuICBmdW5jdGlvbiBvbkNsb3NlICgpIHtcbiAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgc2VsZi5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZCAoKSB7XG4gICAgc2VsZi5fY3VycmVudCA9IG51bGxcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgb25SZWFkYWJsZSlcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKVxuICAgIHNlbGYuX25leHQoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgc2VsZi5kZXN0cm95KGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmVhbXMyIChzKSB7XG4gIGlmICghcyB8fCB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJyB8fCBzLl9yZWFkYWJsZVN0YXRlKSByZXR1cm4gc1xuXG4gIHZhciB3cmFwID0gbmV3IHN0cmVhbS5SZWFkYWJsZSgpLndyYXAocylcbiAgaWYgKHMuZGVzdHJveSkge1xuICAgIHdyYXAuZGVzdHJveSA9IHMuZGVzdHJveS5iaW5kKHMpXG4gIH1cbiAgcmV0dXJuIHdyYXBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbmV4dEV2ZW50XG5cbmZ1bmN0aW9uIG5leHRFdmVudCAoZW1pdHRlciwgbmFtZSkge1xuICB2YXIgbmV4dCA9IG51bGxcbiAgZW1pdHRlci5vbihuYW1lLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghbmV4dCkgcmV0dXJuXG4gICAgdmFyIGZuID0gbmV4dFxuICAgIG5leHQgPSBudWxsXG4gICAgZm4oZGF0YSlcbiAgfSlcblxuICByZXR1cm4gZnVuY3Rpb24gKG9uY2UpIHtcbiAgICBuZXh0ID0gb25jZVxuICB9XG59XG4iLCJ2YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5Jylcbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KG9uY2UpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZCkgcmV0dXJuIGYudmFsdWVcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRlY29kZVRvcnJlbnRGaWxlXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVUb3JyZW50RmlsZVxubW9kdWxlLmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlVG9ycmVudEZpbGVcblxudmFyIGJlbmNvZGUgPSByZXF1aXJlKCdiZW5jb2RlJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgc2hhMSA9IHJlcXVpcmUoJ3NpbXBsZS1zaGExJylcbnZhciB1bmlxID0gcmVxdWlyZSgndW5pcScpXG5cbi8qKlxuICogUGFyc2UgYSB0b3JyZW50LiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSB0b3JyZW50IGlzIG1pc3NpbmcgcmVxdWlyZWQgZmllbGRzLlxuICogQHBhcmFtICB7QnVmZmVyfE9iamVjdH0gdG9ycmVudFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgcGFyc2VkIHRvcnJlbnRcbiAqL1xuZnVuY3Rpb24gZGVjb2RlVG9ycmVudEZpbGUgKHRvcnJlbnQpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3JyZW50KSkge1xuICAgIHRvcnJlbnQgPSBiZW5jb2RlLmRlY29kZSh0b3JyZW50KVxuICB9XG5cbiAgLy8gc2FuaXR5IGNoZWNrXG4gIGVuc3VyZSh0b3JyZW50LmluZm8sICdpbmZvJylcbiAgZW5zdXJlKHRvcnJlbnQuaW5mb1snbmFtZS51dGYtOCddIHx8IHRvcnJlbnQuaW5mby5uYW1lLCAnaW5mby5uYW1lJylcbiAgZW5zdXJlKHRvcnJlbnQuaW5mb1sncGllY2UgbGVuZ3RoJ10sICdpbmZvW1xcJ3BpZWNlIGxlbmd0aFxcJ10nKVxuICBlbnN1cmUodG9ycmVudC5pbmZvLnBpZWNlcywgJ2luZm8ucGllY2VzJylcblxuICBpZiAodG9ycmVudC5pbmZvLmZpbGVzKSB7XG4gICAgdG9ycmVudC5pbmZvLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIGVuc3VyZSh0eXBlb2YgZmlsZS5sZW5ndGggPT09ICdudW1iZXInLCAnaW5mby5maWxlc1swXS5sZW5ndGgnKVxuICAgICAgZW5zdXJlKGZpbGVbJ3BhdGgudXRmLTgnXSB8fCBmaWxlLnBhdGgsICdpbmZvLmZpbGVzWzBdLnBhdGgnKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZW5zdXJlKHR5cGVvZiB0b3JyZW50LmluZm8ubGVuZ3RoID09PSAnbnVtYmVyJywgJ2luZm8ubGVuZ3RoJylcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB7fVxuICByZXN1bHQuaW5mbyA9IHRvcnJlbnQuaW5mb1xuICByZXN1bHQuaW5mb0J1ZmZlciA9IGJlbmNvZGUuZW5jb2RlKHRvcnJlbnQuaW5mbylcbiAgcmVzdWx0LmluZm9IYXNoID0gc2hhMS5zeW5jKHJlc3VsdC5pbmZvQnVmZmVyKVxuICByZXN1bHQuaW5mb0hhc2hCdWZmZXIgPSBuZXcgQnVmZmVyKHJlc3VsdC5pbmZvSGFzaCwgJ2hleCcpXG5cbiAgcmVzdWx0Lm5hbWUgPSAodG9ycmVudC5pbmZvWyduYW1lLnV0Zi04J10gfHwgdG9ycmVudC5pbmZvLm5hbWUpLnRvU3RyaW5nKClcblxuICBpZiAodG9ycmVudC5pbmZvLnByaXZhdGUgIT09IHVuZGVmaW5lZCkgcmVzdWx0LnByaXZhdGUgPSAhIXRvcnJlbnQuaW5mby5wcml2YXRlXG5cbiAgaWYgKHRvcnJlbnRbJ2NyZWF0aW9uIGRhdGUnXSkgcmVzdWx0LmNyZWF0ZWQgPSBuZXcgRGF0ZSh0b3JyZW50WydjcmVhdGlvbiBkYXRlJ10gKiAxMDAwKVxuICBpZiAodG9ycmVudFsnY3JlYXRlZCBieSddKSByZXN1bHQuY3JlYXRlZEJ5ID0gdG9ycmVudFsnY3JlYXRlZCBieSddLnRvU3RyaW5nKClcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnQuY29tbWVudCkpIHJlc3VsdC5jb21tZW50ID0gdG9ycmVudC5jb21tZW50LnRvU3RyaW5nKClcblxuICAvLyBhbm5vdW5jZSBhbmQgYW5ub3VuY2UtbGlzdCB3aWxsIGJlIG1pc3NpbmcgaWYgbWV0YWRhdGEgZmV0Y2hlZCB2aWEgdXRfbWV0YWRhdGFcbiAgcmVzdWx0LmFubm91bmNlID0gW11cbiAgaWYgKHRvcnJlbnRbJ2Fubm91bmNlLWxpc3QnXSAmJiB0b3JyZW50Wydhbm5vdW5jZS1saXN0J10ubGVuZ3RoKSB7XG4gICAgdG9ycmVudFsnYW5ub3VuY2UtbGlzdCddLmZvckVhY2goZnVuY3Rpb24gKHVybHMpIHtcbiAgICAgIHVybHMuZm9yRWFjaChmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJlc3VsdC5hbm5vdW5jZS5wdXNoKHVybC50b1N0cmluZygpKVxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHRvcnJlbnQuYW5ub3VuY2UpIHtcbiAgICByZXN1bHQuYW5ub3VuY2UucHVzaCh0b3JyZW50LmFubm91bmNlLnRvU3RyaW5nKCkpXG4gIH1cblxuICAvLyBoYW5kbGUgdXJsLWxpc3QgKEJFUDE5IC8gd2ViIHNlZWRpbmcpXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodG9ycmVudFsndXJsLWxpc3QnXSkpIHtcbiAgICAvLyBzb21lIGNsaWVudHMgc2V0IHVybC1saXN0IHRvIGVtcHR5IHN0cmluZ1xuICAgIHRvcnJlbnRbJ3VybC1saXN0J10gPSB0b3JyZW50Wyd1cmwtbGlzdCddLmxlbmd0aCA+IDBcbiAgICAgID8gWyB0b3JyZW50Wyd1cmwtbGlzdCddIF1cbiAgICAgIDogW11cbiAgfVxuICByZXN1bHQudXJsTGlzdCA9ICh0b3JyZW50Wyd1cmwtbGlzdCddIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHVybCkge1xuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKVxuICB9KVxuXG4gIHVuaXEocmVzdWx0LmFubm91bmNlKVxuICB1bmlxKHJlc3VsdC51cmxMaXN0KVxuXG4gIHZhciBmaWxlcyA9IHRvcnJlbnQuaW5mby5maWxlcyB8fCBbIHRvcnJlbnQuaW5mbyBdXG4gIHJlc3VsdC5maWxlcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSwgaSkge1xuICAgIHZhciBwYXJ0cyA9IFtdLmNvbmNhdChyZXN1bHQubmFtZSwgZmlsZVsncGF0aC51dGYtOCddIHx8IGZpbGUucGF0aCB8fCBbXSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcC50b1N0cmluZygpXG4gICAgfSlcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aC5qb2luLmFwcGx5KG51bGwsIFtwYXRoLnNlcF0uY29uY2F0KHBhcnRzKSkuc2xpY2UoMSksXG4gICAgICBuYW1lOiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSxcbiAgICAgIGxlbmd0aDogZmlsZS5sZW5ndGgsXG4gICAgICBvZmZzZXQ6IGZpbGVzLnNsaWNlKDAsIGkpLnJlZHVjZShzdW1MZW5ndGgsIDApXG4gICAgfVxuICB9KVxuXG4gIHJlc3VsdC5sZW5ndGggPSBmaWxlcy5yZWR1Y2Uoc3VtTGVuZ3RoLCAwKVxuXG4gIHZhciBsYXN0RmlsZSA9IHJlc3VsdC5maWxlc1tyZXN1bHQuZmlsZXMubGVuZ3RoIC0gMV1cblxuICByZXN1bHQucGllY2VMZW5ndGggPSB0b3JyZW50LmluZm9bJ3BpZWNlIGxlbmd0aCddXG4gIHJlc3VsdC5sYXN0UGllY2VMZW5ndGggPSAoKGxhc3RGaWxlLm9mZnNldCArIGxhc3RGaWxlLmxlbmd0aCkgJSByZXN1bHQucGllY2VMZW5ndGgpIHx8IHJlc3VsdC5waWVjZUxlbmd0aFxuICByZXN1bHQucGllY2VzID0gc3BsaXRQaWVjZXModG9ycmVudC5pbmZvLnBpZWNlcylcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQ29udmVydCBhIHBhcnNlZCB0b3JyZW50IG9iamVjdCBiYWNrIGludG8gYSAudG9ycmVudCBmaWxlIGJ1ZmZlci5cbiAqIEBwYXJhbSAge09iamVjdH0gcGFyc2VkIHBhcnNlZCB0b3JyZW50XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVRvcnJlbnRGaWxlIChwYXJzZWQpIHtcbiAgdmFyIHRvcnJlbnQgPSB7XG4gICAgaW5mbzogcGFyc2VkLmluZm9cbiAgfVxuXG4gIHRvcnJlbnRbJ2Fubm91bmNlLWxpc3QnXSA9IChwYXJzZWQuYW5ub3VuY2UgfHwgW10pLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKCF0b3JyZW50LmFubm91bmNlKSB0b3JyZW50LmFubm91bmNlID0gdXJsXG4gICAgdXJsID0gbmV3IEJ1ZmZlcih1cmwsICd1dGY4JylcbiAgICByZXR1cm4gWyB1cmwgXVxuICB9KVxuXG4gIHRvcnJlbnRbJ3VybC1saXN0J10gPSBwYXJzZWQudXJsTGlzdCB8fCBbXVxuXG4gIGlmIChwYXJzZWQuY3JlYXRlZCkge1xuICAgIHRvcnJlbnRbJ2NyZWF0aW9uIGRhdGUnXSA9IChwYXJzZWQuY3JlYXRlZC5nZXRUaW1lKCkgLyAxMDAwKSB8IDBcbiAgfVxuXG4gIGlmIChwYXJzZWQuY3JlYXRlZEJ5KSB7XG4gICAgdG9ycmVudFsnY3JlYXRlZCBieSddID0gcGFyc2VkLmNyZWF0ZWRCeVxuICB9XG5cbiAgaWYgKHBhcnNlZC5jb21tZW50KSB7XG4gICAgdG9ycmVudC5jb21tZW50ID0gcGFyc2VkLmNvbW1lbnRcbiAgfVxuXG4gIHJldHVybiBiZW5jb2RlLmVuY29kZSh0b3JyZW50KVxufVxuXG5mdW5jdGlvbiBzdW1MZW5ndGggKHN1bSwgZmlsZSkge1xuICByZXR1cm4gc3VtICsgZmlsZS5sZW5ndGhcbn1cblxuZnVuY3Rpb24gc3BsaXRQaWVjZXMgKGJ1Zikge1xuICB2YXIgcGllY2VzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDIwKSB7XG4gICAgcGllY2VzLnB1c2goYnVmLnNsaWNlKGksIGkgKyAyMCkudG9TdHJpbmcoJ2hleCcpKVxuICB9XG4gIHJldHVybiBwaWVjZXNcbn1cblxuZnVuY3Rpb24gZW5zdXJlIChib29sLCBmaWVsZE5hbWUpIHtcbiAgaWYgKCFib29sKSB0aHJvdyBuZXcgRXJyb3IoJ1RvcnJlbnQgaXMgbWlzc2luZyByZXF1aXJlZCBmaWVsZDogJyArIGZpZWxkTmFtZSlcbn1cbiIsInZhciBEaWN0ID0gcmVxdWlyZShcIi4vZGljdFwiKVxuXG4vKipcbiAqIERlY29kZXMgYmVuY29kZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7TnVtYmVyfSBlbmQgKG9wdGlvbmFsKVxuICogQHBhcmFtICB7U3RyaW5nfSBlbmNvZGluZyAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtPYmplY3R8QXJyYXl8QnVmZmVyfFN0cmluZ3xOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZSggZGF0YSwgc3RhcnQsIGVuZCwgZW5jb2RpbmcgKSB7XG4gIFxuICBpZiggdHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICBzdGFydCA9IHVuZGVmaW5lZFxuICB9XG4gIFxuICBpZiggdHlwZW9mIGVuZCAhPT0gJ251bWJlcicgJiYgZW5jb2RpbmcgPT0gbnVsbCApIHtcbiAgICBlbmNvZGluZyA9IGVuZFxuICAgIGVuZCA9IHVuZGVmaW5lZFxuICB9XG4gIFxuICBkZWNvZGUucG9zaXRpb24gPSAwXG4gIGRlY29kZS5lbmNvZGluZyA9IGVuY29kaW5nIHx8IG51bGxcblxuICBkZWNvZGUuZGF0YSA9ICEoIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSApXG4gICAgPyBuZXcgQnVmZmVyKCBkYXRhIClcbiAgICA6IGRhdGEuc2xpY2UoIHN0YXJ0LCBlbmQgKVxuICBcbiAgZGVjb2RlLmJ5dGVzID0gZGVjb2RlLmRhdGEubGVuZ3RoXG4gIFxuICByZXR1cm4gZGVjb2RlLm5leHQoKVxuXG59XG5cbmRlY29kZS5ieXRlcyA9IDBcbmRlY29kZS5wb3NpdGlvbiA9IDBcbmRlY29kZS5kYXRhICAgICA9IG51bGxcbmRlY29kZS5lbmNvZGluZyA9IG51bGxcblxuZGVjb2RlLm5leHQgPSBmdW5jdGlvbigpIHtcblxuICBzd2l0Y2goIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gKSB7XG4gICAgY2FzZSAweDY0OiByZXR1cm4gZGVjb2RlLmRpY3Rpb25hcnkoKTsgYnJlYWtcbiAgICBjYXNlIDB4NkM6IHJldHVybiBkZWNvZGUubGlzdCgpOyBicmVha1xuICAgIGNhc2UgMHg2OTogcmV0dXJuIGRlY29kZS5pbnRlZ2VyKCk7IGJyZWFrXG4gICAgZGVmYXVsdDogICByZXR1cm4gZGVjb2RlLmJ1ZmZlcigpOyBicmVha1xuICB9XG5cbn1cblxuZGVjb2RlLmZpbmQgPSBmdW5jdGlvbiggY2hyICkge1xuXG4gIHZhciBpID0gZGVjb2RlLnBvc2l0aW9uXG4gIHZhciBjID0gZGVjb2RlLmRhdGEubGVuZ3RoXG4gIHZhciBkID0gZGVjb2RlLmRhdGFcblxuICB3aGlsZSggaSA8IGMgKSB7XG4gICAgaWYoIGRbaV0gPT09IGNociApXG4gICAgICByZXR1cm4gaVxuICAgIGkrK1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdJbnZhbGlkIGRhdGE6IE1pc3NpbmcgZGVsaW1pdGVyIFwiJyArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSggY2hyICkgKyAnXCIgWzB4JyArXG4gICAgY2hyLnRvU3RyaW5nKCAxNiApICsgJ10nXG4gIClcblxufVxuXG5kZWNvZGUuZGljdGlvbmFyeSA9IGZ1bmN0aW9uKCkge1xuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGRpY3QgPSBuZXcgRGljdCgpXG5cbiAgd2hpbGUoIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gIT09IDB4NjUgKSB7XG4gICAgZGljdC5iaW5hcnlTZXQoZGVjb2RlLmJ1ZmZlcigpLCBkZWNvZGUubmV4dCgpKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gZGljdFxuXG59XG5cbmRlY29kZS5saXN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgbHN0ID0gW11cblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBsc3QucHVzaCggZGVjb2RlLm5leHQoKSApXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBsc3RcblxufVxuXG5kZWNvZGUuaW50ZWdlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBlbmQgICAgPSBkZWNvZGUuZmluZCggMHg2NSApXG4gIHZhciBudW1iZXIgPSBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uICsgMSwgZW5kIClcblxuICBkZWNvZGUucG9zaXRpb24gKz0gZW5kICsgMSAtIGRlY29kZS5wb3NpdGlvblxuXG4gIHJldHVybiBwYXJzZUludCggbnVtYmVyLCAxMCApXG5cbn1cblxuZGVjb2RlLmJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzZXAgICAgPSBkZWNvZGUuZmluZCggMHgzQSApXG4gIHZhciBsZW5ndGggPSBwYXJzZUludCggZGVjb2RlLmRhdGEudG9TdHJpbmcoICdhc2NpaScsIGRlY29kZS5wb3NpdGlvbiwgc2VwICksIDEwIClcbiAgdmFyIGVuZCAgICA9ICsrc2VwICsgbGVuZ3RoXG5cbiAgZGVjb2RlLnBvc2l0aW9uID0gZW5kXG5cbiAgcmV0dXJuIGRlY29kZS5lbmNvZGluZ1xuICAgID8gZGVjb2RlLmRhdGEudG9TdHJpbmcoIGRlY29kZS5lbmNvZGluZywgc2VwLCBlbmQgKVxuICAgIDogZGVjb2RlLmRhdGEuc2xpY2UoIHNlcCwgZW5kIClcblxufVxuXG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUoIGRhdGEsIGJ1ZmZlciwgb2Zmc2V0ICkge1xuICBcbiAgdmFyIGJ1ZmZlcnMgPSBbXVxuICB2YXIgcmVzdWx0ID0gbnVsbFxuICBcbiAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGEgKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KCBidWZmZXJzIClcbiAgZW5jb2RlLmJ5dGVzID0gcmVzdWx0Lmxlbmd0aFxuICBcbiAgaWYoIEJ1ZmZlci5pc0J1ZmZlciggYnVmZmVyICkgKSB7XG4gICAgcmVzdWx0LmNvcHkoIGJ1ZmZlciwgb2Zmc2V0IClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRcbiAgXG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBpZiggQnVmZmVyLmlzQnVmZmVyKGRhdGEpICkge1xuICAgIGJ1ZmZlcnMucHVzaChuZXcgQnVmZmVyKGRhdGEubGVuZ3RoICsgJzonKSlcbiAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2goIHR5cGVvZiBkYXRhICkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBkYXRhIClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlcbiAgICAgICAgPyBlbmNvZGUubGlzdCggYnVmZmVycywgZGF0YSApXG4gICAgICAgIDogZW5jb2RlLmRpY3QoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGVuY29kZS5udW1iZXIoIGJ1ZmZlcnMsIGRhdGEgPyAxIDogMCApXG4gICAgICBicmVha1xuICB9XG5cbn1cblxudmFyIGJ1ZmZfZSA9IG5ldyBCdWZmZXIoJ2UnKVxuICAsIGJ1ZmZfZCA9IG5ldyBCdWZmZXIoJ2QnKVxuICAsIGJ1ZmZfbCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKEJ1ZmZlci5ieXRlTGVuZ3RoKCBkYXRhICkgKyAnOicgKyBkYXRhKSApXG59XG5cbmVuY29kZS5udW1iZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcbiAgdmFyIG1heExvID0gMHg4MDAwMDAwMFxuICB2YXIgaGkgPSAoIGRhdGEgLyBtYXhMbyApIDw8IDBcbiAgdmFyIGxvID0gKCBkYXRhICUgbWF4TG8gICkgPDwgMFxuICB2YXIgdmFsID0gaGkgKiBtYXhMbyArIGxvXG5cbiAgYnVmZmVycy5wdXNoKCBuZXcgQnVmZmVyKCAnaScgKyB2YWwgKyAnZScgKSlcblxuICBpZiggdmFsICE9PSBkYXRhICYmICFlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkICkge1xuICAgIGVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSB0cnVlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dBUk5JTkc6IFBvc3NpYmxlIGRhdGEgY29ycnVwdGlvbiBkZXRlY3RlZCB3aXRoIHZhbHVlIFwiJytkYXRhKydcIjonLFxuICAgICAgJ0JlbmNvZGluZyBvbmx5IGRlZmluZXMgc3VwcG9ydCBmb3IgaW50ZWdlcnMsIHZhbHVlIHdhcyBjb252ZXJ0ZWQgdG8gXCInK3ZhbCsnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG5cbn1cblxuZW5jb2RlLmRpY3QgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZCApXG5cbiAgdmFyIGogPSAwXG4gIHZhciBrXG4gIC8vIGZpeCBmb3IgaXNzdWUgIzEzIC0gc29ydGVkIGRpY3RzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGRhdGEgKS5zb3J0KClcbiAgdmFyIGtsID0ga2V5cy5sZW5ndGhcblxuICBmb3IoIDsgaiA8IGtsIDsgaisrKSB7XG4gICAgaz1rZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlciggYnVmZmVycywgayApXG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFba10gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxufVxuXG5lbmNvZGUubGlzdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIHZhciBpID0gMCwgaiA9IDFcbiAgdmFyIGMgPSBkYXRhLmxlbmd0aFxuICBidWZmZXJzLnB1c2goIGJ1ZmZfbCApXG5cbiAgZm9yKCA7IGkgPCBjOyBpKysgKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoIGJ1ZmZlcnMsIGRhdGFbaV0gKVxuICB9XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2UgKVxuXG59XG5cbi8vIEV4cG9zZVxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsIi8qIGdsb2JhbCBCbG9iICovXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VUb3JyZW50XG5tb2R1bGUuZXhwb3J0cy5yZW1vdGUgPSBwYXJzZVRvcnJlbnRSZW1vdGVcblxudmFyIGJsb2JUb0J1ZmZlciA9IHJlcXVpcmUoJ2Jsb2ItdG8tYnVmZmVyJylcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgZ2V0ID0gcmVxdWlyZSgnc2ltcGxlLWdldCcpXG52YXIgbWFnbmV0ID0gcmVxdWlyZSgnbWFnbmV0LXVyaScpXG52YXIgcGFyc2VUb3JyZW50RmlsZSA9IHJlcXVpcmUoJ3BhcnNlLXRvcnJlbnQtZmlsZScpXG5cbm1vZHVsZS5leHBvcnRzLnRvTWFnbmV0VVJJID0gbWFnbmV0LmVuY29kZVxubW9kdWxlLmV4cG9ydHMudG9Ub3JyZW50RmlsZSA9IHBhcnNlVG9ycmVudEZpbGUuZW5jb2RlXG5cbi8qKlxuICogUGFyc2UgYSB0b3JyZW50IGlkZW50aWZpZXIgKG1hZ25ldCB1cmksIC50b3JyZW50IGZpbGUsIGluZm8gaGFzaClcbiAqIEBwYXJhbSAge3N0cmluZ3xCdWZmZXJ8T2JqZWN0fSB0b3JyZW50SWRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VUb3JyZW50ICh0b3JyZW50SWQpIHtcbiAgaWYgKHR5cGVvZiB0b3JyZW50SWQgPT09ICdzdHJpbmcnICYmIC9eKHN0cmVhbS0pP21hZ25ldDovLnRlc3QodG9ycmVudElkKSkge1xuICAgIC8vIG1hZ25ldCB1cmkgKHN0cmluZylcbiAgICByZXR1cm4gbWFnbmV0KHRvcnJlbnRJZClcbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9ycmVudElkID09PSAnc3RyaW5nJyAmJiAoL15bYS1mMC05XXs0MH0kL2kudGVzdCh0b3JyZW50SWQpIHx8IC9eW2EtejItN117MzJ9JC9pLnRlc3QodG9ycmVudElkKSkpIHtcbiAgICAvLyBpbmZvIGhhc2ggKGhleC9iYXNlLTMyIHN0cmluZylcbiAgICByZXR1cm4gbWFnbmV0KCdtYWduZXQ6P3h0PXVybjpidGloOicgKyB0b3JyZW50SWQpXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnRJZCkgJiYgdG9ycmVudElkLmxlbmd0aCA9PT0gMjApIHtcbiAgICAvLyBpbmZvIGhhc2ggKGJ1ZmZlcilcbiAgICByZXR1cm4gbWFnbmV0KCdtYWduZXQ6P3h0PXVybjpidGloOicgKyB0b3JyZW50SWQudG9TdHJpbmcoJ2hleCcpKVxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3JyZW50SWQpKSB7XG4gICAgLy8gLnRvcnJlbnQgZmlsZSAoYnVmZmVyKVxuICAgIHJldHVybiBwYXJzZVRvcnJlbnRGaWxlKHRvcnJlbnRJZCkgLy8gbWlnaHQgdGhyb3dcbiAgfSBlbHNlIGlmICh0b3JyZW50SWQgJiYgdG9ycmVudElkLmluZm9IYXNoKSB7XG4gICAgLy8gcGFyc2VkIHRvcnJlbnQgKGZyb20gYHBhcnNlLXRvcnJlbnRgLCBgcGFyc2UtdG9ycmVudC1maWxlYCwgb3IgYG1hZ25ldC11cmlgKVxuICAgIGlmICghdG9ycmVudElkLmFubm91bmNlKSB0b3JyZW50SWQuYW5ub3VuY2UgPSBbXVxuICAgIGlmICh0eXBlb2YgdG9ycmVudElkLmFubm91bmNlID09PSAnc3RyaW5nJykge1xuICAgICAgdG9ycmVudElkLmFubm91bmNlID0gWyB0b3JyZW50SWQuYW5ub3VuY2UgXVxuICAgIH1cbiAgICBpZiAoIXRvcnJlbnRJZC51cmxMaXN0KSB0b3JyZW50SWQudXJsTGlzdCA9IFtdXG4gICAgcmV0dXJuIHRvcnJlbnRJZFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9ycmVudFJlbW90ZSAodG9ycmVudElkLCBjYikge1xuICB2YXIgcGFyc2VkVG9ycmVudFxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgRnVuY3Rpb24nKVxuXG4gIHRyeSB7XG4gICAgcGFyc2VkVG9ycmVudCA9IHBhcnNlVG9ycmVudCh0b3JyZW50SWQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElmIHRvcnJlbnQgZmFpbHMgdG8gcGFyc2UsIGl0IGNvdWxkIGJlIGEgQmxvYiwgaHR0cC9odHRwcyBVUkwgb3JcbiAgICAvLyBmaWxlc3lzdGVtIHBhdGgsIHNvIGRvbid0IGNvbnNpZGVyIGl0IGFuIGVycm9yIHlldC5cbiAgfVxuXG4gIGlmIChwYXJzZWRUb3JyZW50ICYmIHBhcnNlZFRvcnJlbnQuaW5mb0hhc2gpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIHBhcnNlZFRvcnJlbnQpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChpc0Jsb2IodG9ycmVudElkKSkge1xuICAgIGJsb2JUb0J1ZmZlcih0b3JyZW50SWQsIGZ1bmN0aW9uIChlcnIsIHRvcnJlbnRCdWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihuZXcgRXJyb3IoJ0Vycm9yIGNvbnZlcnRpbmcgQmxvYjogJyArIGVyci5tZXNzYWdlKSlcbiAgICAgIHBhcnNlT3JUaHJvdyh0b3JyZW50QnVmKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGdldCA9PT0gJ2Z1bmN0aW9uJyAmJiAvXmh0dHBzPzovLnRlc3QodG9ycmVudElkKSkge1xuICAgIC8vIGh0dHAsIG9yIGh0dHBzIHVybCB0byB0b3JyZW50IGZpbGVcbiAgICBnZXQuY29uY2F0KHtcbiAgICAgIHVybDogdG9ycmVudElkLFxuICAgICAgaGVhZGVyczogeyAndXNlci1hZ2VudCc6ICdXZWJUb3JyZW50IChodHRwOi8vd2VidG9ycmVudC5pbyknIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMsIHRvcnJlbnRCdWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihuZXcgRXJyb3IoJ0Vycm9yIGRvd25sb2FkaW5nIHRvcnJlbnQ6ICcgKyBlcnIubWVzc2FnZSkpXG4gICAgICBwYXJzZU9yVGhyb3codG9ycmVudEJ1ZilcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBmcy5yZWFkRmlsZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdG9ycmVudElkID09PSAnc3RyaW5nJykge1xuICAgIC8vIGFzc3VtZSBpdCdzIGEgZmlsZXN5c3RlbSBwYXRoXG4gICAgZnMucmVhZEZpbGUodG9ycmVudElkLCBmdW5jdGlvbiAoZXJyLCB0b3JyZW50QnVmKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IobmV3IEVycm9yKCdJbnZhbGlkIHRvcnJlbnQgaWRlbnRpZmllcicpKVxuICAgICAgcGFyc2VPclRocm93KHRvcnJlbnRCdWYpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPclRocm93ICh0b3JyZW50QnVmKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFRvcnJlbnQgPSBwYXJzZVRvcnJlbnQodG9ycmVudEJ1ZilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuICAgIGlmIChwYXJzZWRUb3JyZW50ICYmIHBhcnNlZFRvcnJlbnQuaW5mb0hhc2gpIGNiKG51bGwsIHBhcnNlZFRvcnJlbnQpXG4gICAgZWxzZSBjYihuZXcgRXJyb3IoJ0ludmFsaWQgdG9ycmVudCBpZGVudGlmaWVyJykpXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFczQyBgQmxvYmAgb3IgYEZpbGVgIG9iamVjdFxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Jsb2IgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEJsb2Jcbn1cblxuLy8gV29ya2Fyb3VuZCBCcm93c2VyaWZ5IHYxMyBidWdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9ub2RlLWJyb3dzZXJpZnkvaXNzdWVzLzE0ODNcbjsoZnVuY3Rpb24gKCkgeyBCdWZmZXIoMCkgfSkoKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCJ2YXIgY2xvc2VzdCA9IHJlcXVpcmUoJ2Nsb3Nlc3QtdG8nKVxuXG4vLyBDcmVhdGUgYSByYW5nZSBmcm9tIDE2a2LigJM0bWJcbnZhciBzaXplcyA9IFtdXG5mb3IgKHZhciBpID0gMTQ7IGkgPD0gMjI7IGkrKykge1xuICBzaXplcy5wdXNoKE1hdGgucG93KDIsIGkpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcmV0dXJuIGNsb3Nlc3QoXG4gICAgc2l6ZSAvIE1hdGgucG93KDIsIDEwKSwgc2l6ZXMgXG4gIClcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIGVvcyA9IHJlcXVpcmUoJ2VuZC1vZi1zdHJlYW0nKVxudmFyIGZzID0gcmVxdWlyZSgnZnMnKSAvLyB3ZSBvbmx5IG5lZWQgZnMgdG8gZ2V0IHRoZSBSZWFkU3RyZWFtIGFuZCBXcml0ZVN0cmVhbSBwcm90b3R5cGVzXG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxudmFyIGlzRm4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG52YXIgaXNGUyA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgcmV0dXJuIChzdHJlYW0gaW5zdGFuY2VvZiAoZnMuUmVhZFN0cmVhbSB8fCBub29wKSB8fCBzdHJlYW0gaW5zdGFuY2VvZiAoZnMuV3JpdGVTdHJlYW0gfHwgbm9vcCkpICYmIGlzRm4oc3RyZWFtLmNsb3NlKVxufVxuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiBpc0ZuKHN0cmVhbS5hYm9ydClcbn1cblxudmFyIGRlc3Ryb3llciA9IGZ1bmN0aW9uIChzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICB2YXIgY2xvc2VkID0gZmFsc2VcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gIH0pXG5cbiAgZW9zKHN0cmVhbSwge3JlYWRhYmxlOiByZWFkaW5nLCB3cml0YWJsZTogd3JpdGluZ30sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGNsb3NlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gIH0pXG5cbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuXG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgaWYgKGlzRlMoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5jbG9zZSgpIC8vIHVzZSBjbG9zZSBmb3IgZnMgc3RyZWFtcyB0byBhdm9pZCBmZCBsZWFrc1xuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpIC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNGbihzdHJlYW0uZGVzdHJveSkpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpXG5cbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVycm9yKCdzdHJlYW0gd2FzIGRlc3Ryb3llZCcpKVxuICB9XG59XG5cbnZhciBjYWxsID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZuKClcbn1cblxudmFyIHBpcGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0bylcbn1cblxudmFyIHB1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHJlYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB2YXIgY2FsbGJhY2sgPSBpc0ZuKHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSB8fCBub29wKSAmJiBzdHJlYW1zLnBvcCgpIHx8IG5vb3BcblxuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF1cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdwdW1wIHJlcXVpcmVzIHR3byBzdHJlYW1zIHBlciBtaW5pbXVtJylcblxuICB2YXIgZXJyb3JcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIHZhciB3cml0aW5nID0gaSA+IDBcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnJcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm5cbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGNhbGxiYWNrKGVycm9yKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHVtcFxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwidmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIgb2Zmc2V0ID0gMFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChvZmZzZXQgPT09IGxpc3QubGVuZ3RoKSByZXR1cm4gbnVsbFxuXG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoIC0gb2Zmc2V0XG4gICAgdmFyIGkgPSAoTWF0aC5yYW5kb20oKSAqIGxlbikgfCAwXG4gICAgdmFyIGVsID0gbGlzdFtvZmZzZXQgKyBpXVxuXG4gICAgdmFyIHRtcCA9IGxpc3Rbb2Zmc2V0XVxuICAgIGxpc3Rbb2Zmc2V0XSA9IGVsXG4gICAgbGlzdFtvZmZzZXQgKyBpXSA9IHRtcFxuICAgIG9mZnNldCsrXG5cbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGl0ZXJhdGVcbiIsIi8qXG5JbnN0YW5jZSBvZiB3cml0YWJsZSBzdHJlYW0uXG5cbmNhbGwgLmdldChsZW5ndGgpIG9yIC5kaXNjYXJkKGxlbmd0aCkgdG8gZ2V0IGEgc3RyZWFtIChyZWxhdGl2ZSB0byB0aGUgbGFzdCBlbmQpXG5cbmVtaXRzICdzdGFsbGVkJyBvbmNlIGV2ZXJ5dGhpbmcgaXMgd3JpdHRlblxuXG5cbiovXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVNsaWNlU3RyZWFtXG5cbmluaGVyaXRzKFJhbmdlU2xpY2VTdHJlYW0sIHN0cmVhbS5Xcml0YWJsZSlcblxuZnVuY3Rpb24gUmFuZ2VTbGljZVN0cmVhbSAob2Zmc2V0KSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoIShzZWxmIGluc3RhbmNlb2YgUmFuZ2VTbGljZVN0cmVhbSkpIHJldHVybiBuZXcgUmFuZ2VTbGljZVN0cmVhbShvZmZzZXQpXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuXHRzZWxmLl9xdWV1ZSA9IFtdXG5cdHNlbGYuX3Bvc2l0aW9uID0gb2Zmc2V0IHx8IDBcblx0c2VsZi5fY2IgPSBudWxsXG5cdHNlbGYuX2J1ZmZlciA9IG51bGxcblx0c2VsZi5fb3V0ID0gbnVsbFxufVxuXG5SYW5nZVNsaWNlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgZHJhaW5lZCA9IHRydWVcblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGlmIChzZWxmLmRlc3Ryb3llZCkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gV2FpdCBmb3IgbW9yZSBxdWV1ZSBlbnRyaWVzXG5cdFx0aWYgKHNlbGYuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0c2VsZi5fYnVmZmVyID0gY2h1bmtcblx0XHRcdHNlbGYuX2NiID0gY2Jcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHNlbGYuX2J1ZmZlciA9IG51bGxcblx0XHR2YXIgY3VyclJhbmdlID0gc2VsZi5fcXVldWVbMF1cblx0XHQvLyBSZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgY2h1bmssIHdoYXQgZGF0YSBkbyB3ZSBuZWVkP1xuXHRcdHZhciB3cml0ZVN0YXJ0ID0gTWF0aC5tYXgoY3VyclJhbmdlLnN0YXJ0IC0gc2VsZi5fcG9zaXRpb24sIDApXG5cdFx0dmFyIHdyaXRlRW5kID0gY3VyclJhbmdlLmVuZCAtIHNlbGYuX3Bvc2l0aW9uXG5cblx0XHQvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHRocm93IGl0IGFsbCBhd2F5XG5cdFx0aWYgKHdyaXRlU3RhcnQgPj0gY2h1bmsubGVuZ3RoKSB7XG5cdFx0XHRzZWxmLl9wb3NpdGlvbiArPSBjaHVuay5sZW5ndGhcblx0XHRcdHJldHVybiBjYihudWxsKVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXNlIGl0IGFsbFxuXHRcdHZhciB0b1dyaXRlXG5cdFx0aWYgKHdyaXRlRW5kID4gY2h1bmsubGVuZ3RoKSB7XG5cdFx0XHRzZWxmLl9wb3NpdGlvbiArPSBjaHVuay5sZW5ndGhcblx0XHRcdGlmICh3cml0ZVN0YXJ0ID09PSAwKSB7XG5cdFx0XHRcdHRvV3JpdGUgPSBjaHVua1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9Xcml0ZSA9IGNodW5rLnNsaWNlKHdyaXRlU3RhcnQpXG5cdFx0XHR9XG5cdFx0XHRkcmFpbmVkID0gY3VyclJhbmdlLnN0cmVhbS53cml0ZSh0b1dyaXRlKSAmJiBkcmFpbmVkXG5cdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHNlbGYuX3Bvc2l0aW9uICs9IHdyaXRlRW5kXG5cdFx0aWYgKHdyaXRlU3RhcnQgPT09IDAgJiYgd3JpdGVFbmQgPT09IGNodW5rLmxlbmd0aCkge1xuXHRcdFx0dG9Xcml0ZSA9IGNodW5rXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvV3JpdGUgPSBjaHVuay5zbGljZSh3cml0ZVN0YXJ0LCB3cml0ZUVuZClcblx0XHR9XG5cdFx0ZHJhaW5lZCA9IGN1cnJSYW5nZS5zdHJlYW0ud3JpdGUodG9Xcml0ZSkgJiYgZHJhaW5lZFxuXHRcdGlmIChjdXJyUmFuZ2UubGFzdCkge1xuXHRcdFx0Y3VyclJhbmdlLnN0cmVhbS5lbmQoKVxuXHRcdH1cblx0XHRjaHVuayA9IGNodW5rLnNsaWNlKHdyaXRlRW5kKVxuXHRcdHNlbGYuX3F1ZXVlLnNoaWZ0KClcblx0fVxuXG5cdGlmIChkcmFpbmVkKSB7XG5cdFx0Y2IobnVsbClcblx0fSBlbHNlIHtcblx0XHRjdXJyUmFuZ2Uuc3RyZWFtLm9uY2UoJ2RyYWluJywgY2IuYmluZChudWxsLCBudWxsKSlcblx0fVxufVxuXG5SYW5nZVNsaWNlU3RyZWFtLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChyYW5nZXMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gbnVsbFxuXG5cdGlmICghKHJhbmdlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdHJhbmdlcyA9IFtyYW5nZXNdXG5cdH1cblxuXHR2YXIgc3RyID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpXG5cblx0cmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlLCBpKSB7XG5cdFx0c2VsZi5fcXVldWUucHVzaCh7XG5cdFx0XHRzdGFydDogcmFuZ2Uuc3RhcnQsXG5cdFx0XHRlbmQ6IHJhbmdlLmVuZCxcblx0XHRcdHN0cmVhbTogc3RyLFxuXHRcdFx0bGFzdDogaSA9PT0gKHJhbmdlcy5sZW5ndGggLSAxKVxuXHRcdH0pXG5cdH0pXG5cdGlmIChzZWxmLl9idWZmZXIpIHtcblx0XHRzZWxmLl93cml0ZShzZWxmLl9idWZmZXIsIG51bGwsIHNlbGYuX2NiKVxuXHR9XG5cblx0cmV0dXJuIHN0clxufVxuXG5SYW5nZVNsaWNlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblx0c2VsZi5kZXN0cm95ZWQgPSB0cnVlXG5cblx0aWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBoYXNQcmVwZW5kTGlzdGVuZXIgPSB0eXBlb2YgRUUucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICBpZiAoaGFzUHJlcGVuZExpc3RlbmVyKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZVxuICAvLyBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAvLyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGUgdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWxcbiAgLy8gaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXQgPSBudWxsO2Vsc2UgaWYgKG9iamVjdE1vZGUpIHJldCA9IGxpc3Quc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpIHJldCA9IGxpc3Quam9pbignJyk7ZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldCA9IGxpc3RbMF07ZWxzZSByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCA9ICcnO2Vsc2UgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgX2J1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgX2J1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKSByZXQgKz0gX2J1Zi5zbGljZSgwLCBjcHkpO2Vsc2UgX2J1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgX2J1Zi5sZW5ndGgpIGxpc3RbMF0gPSBfYnVmLnNsaWNlKGNweSk7ZWxzZSBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG4gIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxuICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3dcbiAgLy8gaWYgaXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59IiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbn1cbiIsImV4cG9ydHMucmVuZGVyID0gcmVuZGVyXG5leHBvcnRzLmFwcGVuZCA9IGFwcGVuZFxudmFyIG1pbWUgPSBleHBvcnRzLm1pbWUgPSByZXF1aXJlKCcuL2xpYi9taW1lLmpzb24nKVxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdyZW5kZXItbWVkaWEnKVxudmFyIGlzQXNjaWkgPSByZXF1aXJlKCdpcy1hc2NpaScpXG52YXIgTWVkaWFFbGVtZW50V3JhcHBlciA9IHJlcXVpcmUoJ21lZGlhc291cmNlJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgc3RyZWFtVG9CbG9iVVJMID0gcmVxdWlyZSgnc3RyZWFtLXRvLWJsb2ItdXJsJylcbnZhciB2aWRlb3N0cmVhbSA9IHJlcXVpcmUoJ3ZpZGVvc3RyZWFtJylcblxudmFyIFZJREVPU1RSRUFNX0VYVFMgPSBbICcubXA0JywgJy5tNHYnLCAnLm00YScgXVxuXG52YXIgTUVESUFTT1VSQ0VfVklERU9fRVhUUyA9IFsgJy5tcDQnLCAnLm00dicsICcud2VibScsICcubWt2JyBdXG52YXIgTUVESUFTT1VSQ0VfQVVESU9fRVhUUyA9IFsgJy5tNGEnLCAnLm1wMycgXVxudmFyIE1FRElBU09VUkNFX0VYVFMgPSBNRURJQVNPVVJDRV9WSURFT19FWFRTLmNvbmNhdChNRURJQVNPVVJDRV9BVURJT19FWFRTKVxuXG52YXIgQVVESU9fRVhUUyA9IFsgJy53YXYnLCAnLmFhYycsICcub2dnJywgJy5vZ2EnIF1cbnZhciBJTUFHRV9FWFRTID0gWyAnLmpwZycsICcuanBlZycsICcucG5nJywgJy5naWYnLCAnLmJtcCcgXVxudmFyIElGUkFNRV9FWFRTID0gWyAnLmNzcycsICcuaHRtbCcsICcuanMnLCAnLm1kJywgJy5wZGYnLCAnLnR4dCcgXVxuXG52YXIgTWVkaWFTb3VyY2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWVkaWFTb3VyY2VcblxuZnVuY3Rpb24gcmVuZGVyIChmaWxlLCBlbGVtLCBjYikge1xuICB2YWxpZGF0ZUZpbGUoZmlsZSlcbiAgaWYgKHR5cGVvZiBlbGVtID09PSAnc3RyaW5nJykgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbSlcblxuICByZW5kZXJNZWRpYShmaWxlLCBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIGlmIChlbGVtLm5vZGVOYW1lICE9PSB0YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKGZpbGUubmFtZSkudG9Mb3dlckNhc2UoKVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgcmVuZGVyIFwiJyArIGV4dG5hbWUgKyAnXCIgaW5zaWRlIGEgXCInICtcbiAgICAgICAgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICsgJ1wiIGVsZW1lbnQsIGV4cGVjdGVkIFwiJyArIHRhZ05hbWUgKyAnXCInXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1cbiAgfSwgY2IpXG59XG5cbmZ1bmN0aW9uIGFwcGVuZCAoZmlsZSwgcm9vdEVsZW0sIGNiKSB7XG4gIGlmICghY2IpIGNiID0gZnVuY3Rpb24gKCkge31cbiAgdmFsaWRhdGVGaWxlKGZpbGUpXG4gIGlmICh0eXBlb2Ygcm9vdEVsZW0gPT09ICdzdHJpbmcnKSByb290RWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdEVsZW0pXG5cbiAgaWYgKHJvb3RFbGVtICYmIChyb290RWxlbS5ub2RlTmFtZSA9PT0gJ1ZJREVPJyB8fCByb290RWxlbS5ub2RlTmFtZSA9PT0gJ0FVRElPJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2aWRlby9hdWRpbyBub2RlIGFyZ3VtZW50LiBBcmd1bWVudCBtdXN0IGJlIHJvb3QgZWxlbWVudCB0aGF0ICcgK1xuICAgICAgJ3ZpZGVvL2F1ZGlvIHRhZyB3aWxsIGJlIGFwcGVuZGVkIHRvLidcbiAgICApXG4gIH1cblxuICByZW5kZXJNZWRpYShmaWxlLCBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIGlmICh0YWdOYW1lID09PSAndmlkZW8nIHx8IHRhZ05hbWUgPT09ICdhdWRpbycpIHJldHVybiBjcmVhdGVNZWRpYSh0YWdOYW1lKVxuICAgIGVsc2UgcmV0dXJuIGNyZWF0ZUVsZW0odGFnTmFtZSlcbiAgfSwgZnVuY3Rpb24gKGVyciwgZWxlbSkge1xuICAgIGlmIChlcnIgJiYgZWxlbSkgZWxlbS5yZW1vdmUoKVxuICAgIGNiKGVyciwgZWxlbSlcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVNZWRpYSAodGFnTmFtZSkge1xuICAgIHZhciBlbGVtID0gY3JlYXRlRWxlbSh0YWdOYW1lKVxuICAgIGVsZW0uY29udHJvbHMgPSB0cnVlXG4gICAgZWxlbS5hdXRvcGxheSA9IHRydWVcbiAgICByb290RWxlbS5hcHBlbmRDaGlsZChlbGVtKVxuICAgIHJldHVybiBlbGVtXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtICh0YWdOYW1lKSB7XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgcm9vdEVsZW0uYXBwZW5kQ2hpbGQoZWxlbSlcbiAgICByZXR1cm4gZWxlbVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1lZGlhIChmaWxlLCBnZXRFbGVtLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IGZ1bmN0aW9uICgpIHt9XG4gIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKGZpbGUubmFtZSkudG9Mb3dlckNhc2UoKVxuICB2YXIgY3VycmVudFRpbWUgPSAwXG4gIHZhciBlbGVtXG5cbiAgaWYgKE1FRElBU09VUkNFX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVyTWVkaWFTb3VyY2UoKVxuICB9IGVsc2UgaWYgKEFVRElPX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVyQXVkaW8oKVxuICB9IGVsc2UgaWYgKElNQUdFX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVySW1hZ2UoKVxuICB9IGVsc2UgaWYgKElGUkFNRV9FWFRTLmluZGV4T2YoZXh0bmFtZSkgPj0gMCkge1xuICAgIHJlbmRlcklmcmFtZSgpXG4gIH0gZWxzZSB7XG4gICAgdHJ5UmVuZGVySWZyYW1lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlck1lZGlhU291cmNlICgpIHtcbiAgICB2YXIgdGFnTmFtZSA9IE1FRElBU09VUkNFX1ZJREVPX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwID8gJ3ZpZGVvJyA6ICdhdWRpbydcblxuICAgIGlmIChNZWRpYVNvdXJjZSkge1xuICAgICAgaWYgKFZJREVPU1RSRUFNX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgICAgIHVzZVZpZGVvc3RyZWFtKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVzZU1lZGlhU291cmNlKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXNlQmxvYlVSTCgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlVmlkZW9zdHJlYW0gKCkge1xuICAgICAgZGVidWcoJ1VzZSBgdmlkZW9zdHJlYW1gIHBhY2thZ2UgZm9yICcgKyBmaWxlLm5hbWUpXG4gICAgICBwcmVwYXJlRWxlbSgpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZmFsbGJhY2tUb01lZGlhU291cmNlKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBvbkxvYWRTdGFydClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICAgIHZpZGVvc3RyZWFtKGZpbGUsIGVsZW0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlTWVkaWFTb3VyY2UgKCkge1xuICAgICAgZGVidWcoJ1VzZSBNZWRpYVNvdXJjZSBBUEkgZm9yICcgKyBmaWxlLm5hbWUpXG4gICAgICBwcmVwYXJlRWxlbSgpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZmFsbGJhY2tUb0Jsb2JVUkwpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuXG4gICAgICB2YXIgd3JhcHBlciA9IG5ldyBNZWRpYUVsZW1lbnRXcmFwcGVyKGVsZW0pXG4gICAgICB2YXIgd3JpdGFibGUgPSB3cmFwcGVyLmNyZWF0ZVdyaXRlU3RyZWFtKGdldENvZGVjKGZpbGUubmFtZSkpXG4gICAgICBmaWxlLmNyZWF0ZVJlYWRTdHJlYW0oKS5waXBlKHdyaXRhYmxlKVxuXG4gICAgICBpZiAoY3VycmVudFRpbWUpIGVsZW0uY3VycmVudFRpbWUgPSBjdXJyZW50VGltZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVzZUJsb2JVUkwgKCkge1xuICAgICAgZGVidWcoJ1VzZSBCbG9iIFVSTCBmb3IgJyArIGZpbGUubmFtZSlcbiAgICAgIHByZXBhcmVFbGVtKClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYXRhbEVycm9yKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBvbkxvYWRTdGFydClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICAgIGdldEJsb2JVUkwoZmlsZSwgZnVuY3Rpb24gKGVyciwgdXJsKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBmYXRhbEVycm9yKGVycilcbiAgICAgICAgZWxlbS5zcmMgPSB1cmxcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lKSBlbGVtLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmFsbGJhY2tUb01lZGlhU291cmNlIChlcnIpIHtcbiAgICAgIGRlYnVnKCd2aWRlb3N0cmVhbSBlcnJvcjogZmFsbGJhY2sgdG8gTWVkaWFTb3VyY2UgQVBJOiAlbycsIGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvTWVkaWFTb3VyY2UpXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXkpXG5cbiAgICAgIHVzZU1lZGlhU291cmNlKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWxsYmFja1RvQmxvYlVSTCAoZXJyKSB7XG4gICAgICBkZWJ1ZygnTWVkaWFTb3VyY2UgQVBJIGVycm9yOiBmYWxsYmFjayB0byBCbG9iIFVSTDogJW8nLCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZmFsbGJhY2tUb0Jsb2JVUkwpXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXkpXG5cbiAgICAgIHVzZUJsb2JVUkwoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVFbGVtICgpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICBlbGVtID0gZ2V0RWxlbSh0YWdOYW1lKVxuXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBlbGVtLmN1cnJlbnRUaW1lXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyQXVkaW8gKCkge1xuICAgIGVsZW0gPSBnZXRFbGVtKCdhdWRpbycpXG4gICAgZ2V0QmxvYlVSTChmaWxlLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBmYXRhbEVycm9yKGVycilcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYXRhbEVycm9yKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBvbkxvYWRTdGFydClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICAgIGVsZW0uc3JjID0gdXJsXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTG9hZFN0YXJ0ICgpIHtcbiAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgIGVsZW0ucGxheSgpXG4gIH1cblxuICBmdW5jdGlvbiBvbkNhblBsYXkgKCkge1xuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICBjYihudWxsLCBlbGVtKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVySW1hZ2UgKCkge1xuICAgIGVsZW0gPSBnZXRFbGVtKCdpbWcnKVxuICAgIGdldEJsb2JVUkwoZmlsZSwgZnVuY3Rpb24gKGVyciwgdXJsKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZmF0YWxFcnJvcihlcnIpXG4gICAgICBlbGVtLnNyYyA9IHVybFxuICAgICAgZWxlbS5hbHQgPSBmaWxlLm5hbWVcbiAgICAgIGNiKG51bGwsIGVsZW0pXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlcklmcmFtZSAoKSB7XG4gICAgZWxlbSA9IGdldEVsZW0oJ2lmcmFtZScpXG5cbiAgICBnZXRCbG9iVVJMKGZpbGUsIGZ1bmN0aW9uIChlcnIsIHVybCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGZhdGFsRXJyb3IoZXJyKVxuICAgICAgZWxlbS5zcmMgPSB1cmxcbiAgICAgIGlmIChleHRuYW1lICE9PSAnLnBkZicpIGVsZW0uc2FuZGJveCA9ICdhbGxvdy1mb3JtcyBhbGxvdy1zY3JpcHRzJ1xuICAgICAgY2IobnVsbCwgZWxlbSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5UmVuZGVySWZyYW1lICgpIHtcbiAgICBkZWJ1ZygnVW5rbm93biBmaWxlIGV4dGVuc2lvbiBcIiVzXCIgLSB3aWxsIGF0dGVtcHQgdG8gcmVuZGVyIGludG8gaWZyYW1lJywgZXh0bmFtZSlcblxuICAgIHZhciBzdHIgPSAnJ1xuICAgIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7IHN0YXJ0OiAwLCBlbmQ6IDEwMDAgfSlcbiAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc3RyICs9IGNodW5rXG4gICAgICB9KVxuICAgICAgLm9uKCdlbmQnLCBkb25lKVxuICAgICAgLm9uKCdlcnJvcicsIGNiKVxuXG4gICAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgICBpZiAoaXNBc2NpaShzdHIpKSB7XG4gICAgICAgIGRlYnVnKCdGaWxlIGV4dGVuc2lvbiBcIiVzXCIgYXBwZWFycyBhc2NpaSwgc28gd2lsbCByZW5kZXIuJywgZXh0bmFtZSlcbiAgICAgICAgcmVuZGVySWZyYW1lKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdGaWxlIGV4dGVuc2lvbiBcIiVzXCIgYXBwZWFycyBub24tYXNjaWksIHdpbGwgbm90IHJlbmRlci4nLCBleHRuYW1lKVxuICAgICAgICBjYihuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZSBcIicgKyBleHRuYW1lICsgJ1wiOiBDYW5ub3QgYXBwZW5kIHRvIERPTScpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZhdGFsRXJyb3IgKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gJ0Vycm9yIHJlbmRlcmluZyBmaWxlIFwiJyArIGZpbGUubmFtZSArICdcIjogJyArIGVyci5tZXNzYWdlXG4gICAgZGVidWcoZXJyLm1lc3NhZ2UpXG4gICAgY2IoZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJsb2JVUkwgKGZpbGUsIGNiKSB7XG4gIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKGZpbGUubmFtZSkudG9Mb3dlckNhc2UoKVxuICBzdHJlYW1Ub0Jsb2JVUkwoZmlsZS5jcmVhdGVSZWFkU3RyZWFtKCksIG1pbWVbZXh0bmFtZV0sIGNiKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbGUgKGZpbGUpIHtcbiAgaWYgKGZpbGUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlsZSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKVxuICB9XG4gIGlmICh0eXBlb2YgZmlsZS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIGZpbGUubmFtZSBwcm9wZXJ0eScpXG4gIH1cbiAgaWYgKHR5cGVvZiBmaWxlLmNyZWF0ZVJlYWRTdHJlYW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBmaWxlLmNyZWF0ZVJlYWRTdHJlYW0gcHJvcGVydHknKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvZGVjIChuYW1lKSB7XG4gIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKG5hbWUpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHtcbiAgICAnLm00YSc6ICdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wNGEuNDAuNVwiJyxcbiAgICAnLm00dic6ICd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNjQwMDI5LCBtcDRhLjQwLjVcIicsXG4gICAgJy5ta3YnOiAndmlkZW8vd2VibTsgY29kZWNzPVwiYXZjMS42NDAwMjksIG1wNGEuNDAuNVwiJyxcbiAgICAnLm1wMyc6ICdhdWRpby9tcGVnJyxcbiAgICAnLm1wNCc6ICd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNjQwMDI5LCBtcDRhLjQwLjVcIicsXG4gICAgJy53ZWJtJzogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZvcmJpcywgdnA4XCInXG4gIH1bZXh0bmFtZV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIuM2dwXCI6IFwidmlkZW8vM2dwcFwiLFxuICBcIi5hYWNcIjogXCJhdWRpby9hYWNcIixcbiAgXCIuYWlmXCI6IFwiYXVkaW8veC1haWZmXCIsXG4gIFwiLmFpZmZcIjogXCJhdWRpby94LWFpZmZcIixcbiAgXCIuYXRvbVwiOiBcImFwcGxpY2F0aW9uL2F0b20reG1sXCIsXG4gIFwiLmF2aVwiOiBcInZpZGVvL3gtbXN2aWRlb1wiLFxuICBcIi5ibXBcIjogXCJpbWFnZS9ibXBcIixcbiAgXCIuYnoyXCI6IFwiYXBwbGljYXRpb24veC1iemlwMlwiLFxuICBcIi5jb25mXCI6IFwidGV4dC9wbGFpblwiLFxuICBcIi5jc3NcIjogXCJ0ZXh0L2Nzc1wiLFxuICBcIi5jc3ZcIjogXCJ0ZXh0L2NzdlwiLFxuICBcIi5kaWZmXCI6IFwidGV4dC94LWRpZmZcIixcbiAgXCIuZG9jXCI6IFwiYXBwbGljYXRpb24vbXN3b3JkXCIsXG4gIFwiLmZsdlwiOiBcInZpZGVvL3gtZmx2XCIsXG4gIFwiLmdpZlwiOiBcImltYWdlL2dpZlwiLFxuICBcIi5nelwiOiBcImFwcGxpY2F0aW9uL3gtZ3ppcFwiLFxuICBcIi5odG1cIjogXCJ0ZXh0L2h0bWxcIixcbiAgXCIuaHRtbFwiOiBcInRleHQvaHRtbFwiLFxuICBcIi5pY29cIjogXCJpbWFnZS92bmQubWljcm9zb2Z0Lmljb25cIixcbiAgXCIuaWNzXCI6IFwidGV4dC9jYWxlbmRhclwiLFxuICBcIi5pc29cIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgXCIuamFyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwiLmpwZWdcIjogXCJpbWFnZS9qcGVnXCIsXG4gIFwiLmpwZ1wiOiBcImltYWdlL2pwZWdcIixcbiAgXCIuanNcIjogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIsXG4gIFwiLmpzb25cIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIFwiLmxlc3NcIjogXCJ0ZXh0L2Nzc1wiLFxuICBcIi5sb2dcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiLm0zdVwiOiBcImF1ZGlvL3gtbXBlZ3VybFwiLFxuICBcIi5tNGFcIjogXCJhdWRpby9tcDRcIixcbiAgXCIubTR2XCI6IFwidmlkZW8vbXA0XCIsXG4gIFwiLm1hbmlmZXN0XCI6IFwidGV4dC9jYWNoZS1tYW5pZmVzdFwiLFxuICBcIi5tYXJrZG93blwiOiBcInRleHQveC1tYXJrZG93blwiLFxuICBcIi5tYXRobWxcIjogXCJhcHBsaWNhdGlvbi9tYXRobWwreG1sXCIsXG4gIFwiLm1kXCI6IFwidGV4dC94LW1hcmtkb3duXCIsXG4gIFwiLm1pZFwiOiBcImF1ZGlvL21pZGlcIixcbiAgXCIubWlkaVwiOiBcImF1ZGlvL21pZGlcIixcbiAgXCIubW92XCI6IFwidmlkZW8vcXVpY2t0aW1lXCIsXG4gIFwiLm1wM1wiOiBcImF1ZGlvL21wZWdcIixcbiAgXCIubXA0XCI6IFwidmlkZW8vbXA0XCIsXG4gIFwiLm1wNHZcIjogXCJ2aWRlby9tcDRcIixcbiAgXCIubXBlZ1wiOiBcInZpZGVvL21wZWdcIixcbiAgXCIubXBnXCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIi5vZHBcIjogXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvblwiLFxuICBcIi5vZHNcIjogXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0XCIsXG4gIFwiLm9kdFwiOiBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dFwiLFxuICBcIi5vZ2FcIjogXCJhdWRpby9vZ2dcIixcbiAgXCIub2dnXCI6IFwiYXBwbGljYXRpb24vb2dnXCIsXG4gIFwiLnBkZlwiOiBcImFwcGxpY2F0aW9uL3BkZlwiLFxuICBcIi5wbmdcIjogXCJpbWFnZS9wbmdcIixcbiAgXCIucHBzXCI6IFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnRcIixcbiAgXCIucHB0XCI6IFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnRcIixcbiAgXCIucHNcIjogXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCIsXG4gIFwiLnBzZFwiOiBcImltYWdlL3ZuZC5hZG9iZS5waG90b3Nob3BcIixcbiAgXCIucXRcIjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgXCIucmFyXCI6IFwiYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZFwiLFxuICBcIi5yZGZcIjogXCJhcHBsaWNhdGlvbi9yZGYreG1sXCIsXG4gIFwiLnJzc1wiOiBcImFwcGxpY2F0aW9uL3Jzcyt4bWxcIixcbiAgXCIucnRmXCI6IFwiYXBwbGljYXRpb24vcnRmXCIsXG4gIFwiLnN2Z1wiOiBcImltYWdlL3N2Zyt4bWxcIixcbiAgXCIuc3ZnelwiOiBcImltYWdlL3N2Zyt4bWxcIixcbiAgXCIuc3dmXCI6IFwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIixcbiAgXCIudGFyXCI6IFwiYXBwbGljYXRpb24veC10YXJcIixcbiAgXCIudGJ6XCI6IFwiYXBwbGljYXRpb24veC1iemlwLWNvbXByZXNzZWQtdGFyXCIsXG4gIFwiLnRleHRcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiLnRpZlwiOiBcImltYWdlL3RpZmZcIixcbiAgXCIudGlmZlwiOiBcImltYWdlL3RpZmZcIixcbiAgXCIudG9ycmVudFwiOiBcImFwcGxpY2F0aW9uL3gtYml0dG9ycmVudFwiLFxuICBcIi50dGZcIjogXCJhcHBsaWNhdGlvbi94LWZvbnQtdHRmXCIsXG4gIFwiLnR4dFwiOiBcInRleHQvcGxhaW5cIixcbiAgXCIud2F2XCI6IFwiYXVkaW8vd2F2XCIsXG4gIFwiLndlYm1cIjogXCJ2aWRlby93ZWJtXCIsXG4gIFwiLndtYVwiOiBcImF1ZGlvL3gtbXMtd21hXCIsXG4gIFwiLndtdlwiOiBcInZpZGVvL3gtbXMtd212XCIsXG4gIFwiLnhsc1wiOiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiLFxuICBcIi54bWxcIjogXCJhcHBsaWNhdGlvbi94bWxcIixcbiAgXCIueWFtbFwiOiBcInRleHQveWFtbFwiLFxuICBcIi55bWxcIjogXCJ0ZXh0L3lhbWxcIixcbiAgXCIuemlwXCI6IFwiYXBwbGljYXRpb24vemlwXCJcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhc2tzLCBsaW1pdCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKVxuICB2YXIgcmVzdWx0cywgbGVuLCBwZW5kaW5nLCBrZXlzLCBpc0Vycm9yZWRcbiAgdmFyIGlzU3luYyA9IHRydWVcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICByZXN1bHRzID0gW11cbiAgICBwZW5kaW5nID0gbGVuID0gdGFza3MubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHRhc2tzKVxuICAgIHJlc3VsdHMgPSB7fVxuICAgIHBlbmRpbmcgPSBsZW4gPSBrZXlzLmxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIGlmIChjYikgY2IoZXJyLCByZXN1bHRzKVxuICAgICAgY2IgPSBudWxsXG4gICAgfVxuICAgIGlmIChpc1N5bmMpIHByb2Nlc3MubmV4dFRpY2soZW5kKVxuICAgIGVsc2UgZW5kKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2ggKGksIGVyciwgcmVzdWx0KSB7XG4gICAgcmVzdWx0c1tpXSA9IHJlc3VsdFxuICAgIGlmIChlcnIpIGlzRXJyb3JlZCA9IHRydWVcbiAgICBpZiAoLS1wZW5kaW5nID09PSAwIHx8IGVycikge1xuICAgICAgZG9uZShlcnIpXG4gICAgfSBlbHNlIGlmICghaXNFcnJvcmVkICYmIG5leHQgPCBsZW4pIHtcbiAgICAgIHZhciBrZXlcbiAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgIGtleSA9IGtleXNbbmV4dF1cbiAgICAgICAgbmV4dCArPSAxXG4gICAgICAgIHRhc2tzW2tleV0oZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goa2V5LCBlcnIsIHJlc3VsdCkgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IG5leHRcbiAgICAgICAgbmV4dCArPSAxXG4gICAgICAgIHRhc2tzW2tleV0oZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goa2V5LCBlcnIsIHJlc3VsdCkgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dCA9IGxpbWl0XG4gIGlmICghcGVuZGluZykge1xuICAgIC8vIGVtcHR5XG4gICAgZG9uZShudWxsKVxuICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAvLyBvYmplY3RcbiAgICBrZXlzLnNvbWUoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgICAgaWYgKGkgPT09IGxpbWl0IC0gMSkgcmV0dXJuIHRydWUgLy8gZWFybHkgcmV0dXJuXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBhcnJheVxuICAgIHRhc2tzLnNvbWUoZnVuY3Rpb24gKHRhc2ssIGkpIHtcbiAgICAgIHRhc2soZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goaSwgZXJyLCByZXN1bHQpIH0pXG4gICAgICBpZiAoaSA9PT0gbGltaXQgLSAxKSByZXR1cm4gdHJ1ZSAvLyBlYXJseSByZXR1cm5cbiAgICB9KVxuICB9XG5cbiAgaXNTeW5jID0gZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhc2tzLCBjYikge1xuICB2YXIgcmVzdWx0cywgcGVuZGluZywga2V5c1xuICB2YXIgaXNTeW5jID0gdHJ1ZVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhc2tzKSkge1xuICAgIHJlc3VsdHMgPSBbXVxuICAgIHBlbmRpbmcgPSB0YXNrcy5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModGFza3MpXG4gICAgcmVzdWx0cyA9IHt9XG4gICAgcGVuZGluZyA9IGtleXMubGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgaWYgKGNiKSBjYihlcnIsIHJlc3VsdHMpXG4gICAgICBjYiA9IG51bGxcbiAgICB9XG4gICAgaWYgKGlzU3luYykgcHJvY2Vzcy5uZXh0VGljayhlbmQpXG4gICAgZWxzZSBlbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gZWFjaCAoaSwgZXJyLCByZXN1bHQpIHtcbiAgICByZXN1bHRzW2ldID0gcmVzdWx0XG4gICAgaWYgKC0tcGVuZGluZyA9PT0gMCB8fCBlcnIpIHtcbiAgICAgIGRvbmUoZXJyKVxuICAgIH1cbiAgfVxuXG4gIGlmICghcGVuZGluZykge1xuICAgIC8vIGVtcHR5XG4gICAgZG9uZShudWxsKVxuICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAvLyBvYmplY3RcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gYXJyYXlcbiAgICB0YXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrLCBpKSB7XG4gICAgICB0YXNrKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyBlYWNoKGksIGVyciwgcmVzdWx0KSB9KVxuICAgIH0pXG4gIH1cblxuICBpc1N5bmMgPSBmYWxzZVxufVxuIiwiLypcbiAqIFJ1c2hhLCBhIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsXG4gKiBhcyBkZWZpbmVkIGluIEZJUFMgUFVCIDE4MC0xLCB0dW5lZCBmb3IgaGlnaCBwZXJmb3JtYW5jZSB3aXRoIGxhcmdlIGlucHV0cy5cbiAqIChodHRwOi8vZ2l0aHViLmNvbS9zcmlqcy9ydXNoYSlcbiAqXG4gKiBJbnNwaXJlZCBieSBQYXVsIEpvaG5zdG9ucyBpbXBsZW1lbnRhdGlvbiAoaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIFNhbSBSaWpzIChodHRwOi8vYXdlc2FtLmRlKS5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UgYXMgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuICogSU4gVEhFIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciB1dGlsID0ge1xuICAgICAgICAgICAgZ2V0RGF0YVR5cGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdidWZmZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3ZpZXcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdibG9iJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgLy8gVGhlIFJ1c2hhIG9iamVjdCBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBsb3ctbGV2ZWwgUnVzaGFDb3JlLlxuICAgIC8vIEl0IHByb3ZpZGVzIG1lYW5zIG9mIGNvbnZlcnRpbmcgZGlmZmVyZW50IGlucHV0cyB0byB0aGVcbiAgICAvLyBmb3JtYXQgYWNjZXB0ZWQgYnkgUnVzaGFDb3JlIGFzIHdlbGwgYXMgb3RoZXIgdXRpbGl0eSBtZXRob2RzLlxuICAgIGZ1bmN0aW9uIFJ1c2hhKGNodW5rU2l6ZSkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIC8vIFByaXZhdGUgb2JqZWN0IHN0cnVjdHVyZS5cbiAgICAgICAgdmFyIHNlbGYkMiA9IHsgZmlsbDogMCB9O1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBidWZmZXIgdGhhdCB0aGUgc2hhMSByb3V0aW5lIHVzZXNcbiAgICAgICAgLy8gaW5jbHVkaW5nIHRoZSBwYWRkaW5nLlxuICAgICAgICB2YXIgcGFkbGVuID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICAgICAgZm9yIChsZW4gKz0gOTsgbGVuICUgNjQgPiAwOyBsZW4gKz0gMSk7XG4gICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFkWmVyb2VzID0gZnVuY3Rpb24gKGJpbiwgbGVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVuID4+IDI7IGkgPCBiaW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYmluW2ldID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhZERhdGEgPSBmdW5jdGlvbiAoYmluLCBjaHVua0xlbiwgbXNnTGVuKSB7XG4gICAgICAgICAgICBiaW5bY2h1bmtMZW4gPj4gMl0gfD0gMTI4IDw8IDI0IC0gKGNodW5rTGVuICUgNCA8PCAzKTtcbiAgICAgICAgICAgIGJpblsoKGNodW5rTGVuID4+IDIpICsgMiAmIH4xNSkgKyAxNF0gPSBtc2dMZW4gPj4gMjk7XG4gICAgICAgICAgICBiaW5bKChjaHVua0xlbiA+PiAyKSArIDIgJiB+MTUpICsgMTVdID0gbXNnTGVuIDw8IDM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbnZlcnQgYSBiaW5hcnkgc3RyaW5nIGFuZCB3cml0ZSBpdCB0byB0aGUgaGVhcC5cbiAgICAgICAgLy8gQSBiaW5hcnkgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIG9ubHkgY29udGFpbiBjaGFyIGNvZGVzIDwgMjU2LlxuICAgICAgICB2YXIgY29udlN0ciA9IGZ1bmN0aW9uIChIOCwgSDMyLCBzdGFydCwgbGVuLCBvZmYpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSB0aGlzLCBpLCBvbSA9IG9mZiAlIDQsIGxtID0gbGVuICUgNCwgaiA9IGxlbiAtIGxtO1xuICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvbSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMyB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMiB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDEgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMik7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gb207IGkgPCBqOyBpID0gaSArIDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgSDMyW29mZiArIGkgPj4gMl0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIGkpIDw8IDI0IHwgc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBpICsgMSkgPDwgMTYgfCBzdHIuY2hhckNvZGVBdChzdGFydCArIGkgKyAyKSA8PCA4IHwgc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBpICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGxtKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDEgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaiArIDIpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAyIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIGogKyAxKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMyB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCBhIGJ1ZmZlciBvciBhcnJheSBhbmQgd3JpdGUgaXQgdG8gdGhlIGhlYXAuXG4gICAgICAgIC8vIFRoZSBidWZmZXIgb3IgYXJyYXkgaXMgZXhwZWN0ZWQgdG8gb25seSBjb250YWluIGVsZW1lbnRzIDwgMjU2LlxuICAgICAgICB2YXIgY29udkJ1ZiA9IGZ1bmN0aW9uIChIOCwgSDMyLCBzdGFydCwgbGVuLCBvZmYpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSB0aGlzLCBpLCBvbSA9IG9mZiAlIDQsIGxtID0gbGVuICUgNCwgaiA9IGxlbiAtIGxtO1xuICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvbSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMyB8IDBdID0gYnVmW3N0YXJ0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDIgfCAwXSA9IGJ1ZltzdGFydCArIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMSB8IDBdID0gYnVmW3N0YXJ0ICsgMl07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgfCAwXSA9IGJ1ZltzdGFydCArIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDQgLSBvbTsgaSA8IGo7IGkgPSBpICs9IDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgSDMyW29mZiArIGkgPj4gMl0gPSBidWZbc3RhcnQgKyBpXSA8PCAyNCB8IGJ1ZltzdGFydCArIGkgKyAxXSA8PCAxNiB8IGJ1ZltzdGFydCArIGkgKyAyXSA8PCA4IHwgYnVmW3N0YXJ0ICsgaSArIDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChsbSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAxIHwgMF0gPSBidWZbc3RhcnQgKyBqICsgMl07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDIgfCAwXSA9IGJ1ZltzdGFydCArIGogKyAxXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMyB8IDBdID0gYnVmW3N0YXJ0ICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb252QmxvYiA9IGZ1bmN0aW9uIChIOCwgSDMyLCBzdGFydCwgbGVuLCBvZmYpIHtcbiAgICAgICAgICAgIHZhciBibG9iID0gdGhpcywgaSwgb20gPSBvZmYgJSA0LCBsbSA9IGxlbiAlIDQsIGogPSBsZW4gLSBsbTtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYi5zbGljZShzdGFydCwgc3RhcnQgKyBsZW4pKSk7XG4gICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9tKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAzIHwgMF0gPSBidWZbMF07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAyIHwgMF0gPSBidWZbMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAxIHwgMF0gPSBidWZbMl07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgfCAwXSA9IGJ1ZlszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSA0IC0gb207IGkgPCBqOyBpID0gaSArPSA0IHwgMCkge1xuICAgICAgICAgICAgICAgIEgzMltvZmYgKyBpID4+IDJdID0gYnVmW2ldIDw8IDI0IHwgYnVmW2kgKyAxXSA8PCAxNiB8IGJ1ZltpICsgMl0gPDwgOCB8IGJ1ZltpICsgM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGxtKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDEgfCAwXSA9IGJ1ZltqICsgMl07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDIgfCAwXSA9IGJ1ZltqICsgMV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDMgfCAwXSA9IGJ1ZltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnZGbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHV0aWwuZ2V0RGF0YVR5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZTdHIuYmluZChkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udkJ1Zi5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udkJ1Zi5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QnVmLmJpbmQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICAgICAgY2FzZSAndmlldyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZCdWYuYmluZChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QmxvYi5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2xpY2UgPSBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHV0aWwuZ2V0RGF0YVR5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICAgICBjYXNlICd2aWV3JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5idWZmZXIuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCBhbiBBcnJheUJ1ZmZlciBpbnRvIGl0cyBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICAgIHZhciBoZXggPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBpLCB4LCBoZXhfdGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnLCByZXMgPSBbXSwgYmluYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gYmluYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gaGV4X3RhYi5jaGFyQXQoeCA+PiA0ICYgMTUpICsgaGV4X3RhYi5jaGFyQXQoeCA+PiAwICYgMTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNlaWxIZWFwU2l6ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNtLmpzIHNwZWMgc2F5czpcbiAgICAgICAgICAgIC8vIFRoZSBoZWFwIG9iamVjdCdzIGJ5dGVMZW5ndGggbXVzdCBiZSBlaXRoZXJcbiAgICAgICAgICAgIC8vIDJebiBmb3IgbiBpbiBbMTIsIDI0KSBvciAyXjI0ICogbiBmb3IgbiDiiaUgMS5cbiAgICAgICAgICAgIC8vIEFsc28sIGJ5dGVMZW5ndGhzIHNtYWxsZXIgdGhhbiAyXjE2IGFyZSBkZXByZWNhdGVkLlxuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICAvLyBJZiB2IGlzIHNtYWxsZXIgdGhhbiAyXjE2LCB0aGUgc21hbGxlc3QgcG9zc2libGUgc29sdXRpb25cbiAgICAgICAgICAgIC8vIGlzIDJeMTYuXG4gICAgICAgICAgICBpZiAodiA8PSA2NTUzNilcbiAgICAgICAgICAgICAgICByZXR1cm4gNjU1MzY7XG4gICAgICAgICAgICAvLyBJZiB2IDwgMl4yNCwgd2Ugcm91bmQgdXAgdG8gMl5uLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHJvdW5kIHVwIHRvIDJeMjQgKiBuLlxuICAgICAgICAgICAgaWYgKHYgPCAxNjc3NzIxNikge1xuICAgICAgICAgICAgICAgIGZvciAocCA9IDE7IHAgPCB2OyBwID0gcCA8PCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChwID0gMTY3NzcyMTY7IHAgPCB2OyBwICs9IDE2Nzc3MjE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMgdG8gYSBuZXcgY2FwYWNpdHkuXG4gICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIGlmIChzaXplICUgNjQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaHVuayBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxMjggYml0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmJDIubWF4Q2h1bmtMZW4gPSBzaXplO1xuICAgICAgICAgICAgc2VsZiQyLnBhZE1heENodW5rTGVuID0gcGFkbGVuKHNpemUpO1xuICAgICAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIGhlYXAgaXMgdGhlIHN1bSBvZjpcbiAgICAgICAgICAgIC8vIDEuIFRoZSBwYWRkZWQgaW5wdXQgbWVzc2FnZSBzaXplXG4gICAgICAgICAgICAvLyAyLiBUaGUgZXh0ZW5kZWQgc3BhY2UgdGhlIGFsZ29yaXRobSBuZWVkcyAoMzIwIGJ5dGUpXG4gICAgICAgICAgICAvLyAzLiBUaGUgMTYwIGJpdCBzdGF0ZSB0aGUgYWxnb3JpdG0gdXNlc1xuICAgICAgICAgICAgc2VsZiQyLmhlYXAgPSBuZXcgQXJyYXlCdWZmZXIoY2VpbEhlYXBTaXplKHNlbGYkMi5wYWRNYXhDaHVua0xlbiArIDMyMCArIDIwKSk7XG4gICAgICAgICAgICBzZWxmJDIuaDMyID0gbmV3IEludDMyQXJyYXkoc2VsZiQyLmhlYXApO1xuICAgICAgICAgICAgc2VsZiQyLmg4ID0gbmV3IEludDhBcnJheShzZWxmJDIuaGVhcCk7XG4gICAgICAgICAgICBzZWxmJDIuY29yZSA9IG5ldyBSdXNoYS5fY29yZSh7XG4gICAgICAgICAgICAgICAgSW50MzJBcnJheTogSW50MzJBcnJheSxcbiAgICAgICAgICAgICAgICBEYXRhVmlldzogRGF0YVZpZXdcbiAgICAgICAgICAgIH0sIHt9LCBzZWxmJDIuaGVhcCk7XG4gICAgICAgICAgICBzZWxmJDIuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWluaXRpYWxpemV0aGUgZGF0YXN0cnVjdHVyZXMgYWNjb3JkaW5nXG4gICAgICAgIC8vIHRvIGEgY2h1bmsgc2l5emUuXG4gICAgICAgIGluaXQoY2h1bmtTaXplIHx8IDY0ICogMTAyNCk7XG4gICAgICAgIHZhciBpbml0U3RhdGUgPSBmdW5jdGlvbiAoaGVhcCwgcGFkTXNnTGVuKSB7XG4gICAgICAgICAgICB2YXIgaW8gPSBuZXcgSW50MzJBcnJheShoZWFwLCBwYWRNc2dMZW4gKyAzMjAsIDUpO1xuICAgICAgICAgICAgaW9bMF0gPSAxNzMyNTg0MTkzO1xuICAgICAgICAgICAgaW9bMV0gPSAtMjcxNzMzODc5O1xuICAgICAgICAgICAgaW9bMl0gPSAtMTczMjU4NDE5NDtcbiAgICAgICAgICAgIGlvWzNdID0gMjcxNzMzODc4O1xuICAgICAgICAgICAgaW9bNF0gPSAtMTAwOTU4OTc3NjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhZENodW5rID0gZnVuY3Rpb24gKGNodW5rTGVuLCBtc2dMZW4pIHtcbiAgICAgICAgICAgIHZhciBwYWRDaHVua0xlbiA9IHBhZGxlbihjaHVua0xlbik7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBJbnQzMkFycmF5KHNlbGYkMi5oZWFwLCAwLCBwYWRDaHVua0xlbiA+PiAyKTtcbiAgICAgICAgICAgIHBhZFplcm9lcyh2aWV3LCBjaHVua0xlbik7XG4gICAgICAgICAgICBwYWREYXRhKHZpZXcsIGNodW5rTGVuLCBtc2dMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHBhZENodW5rTGVuO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXcml0ZSBkYXRhIHRvIHRoZSBoZWFwLlxuICAgICAgICB2YXIgd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgY2h1bmtPZmZzZXQsIGNodW5rTGVuKSB7XG4gICAgICAgICAgICBjb252Rm4oZGF0YSkoc2VsZiQyLmg4LCBzZWxmJDIuaDMyLCBjaHVua09mZnNldCwgY2h1bmtMZW4sIDApO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBjYWxsIHRoZSBSdXNoYUNvcmUsXG4gICAgICAgIC8vIGFzc3VtaW5nIGFuIGlucHV0IGJ1ZmZlciBvZiBsZW5ndGggbGVuICogNC5cbiAgICAgICAgdmFyIGNvcmVDYWxsID0gZnVuY3Rpb24gKGRhdGEsIGNodW5rT2Zmc2V0LCBjaHVua0xlbiwgbXNnTGVuLCBmaW5hbGl6ZSkge1xuICAgICAgICAgICAgdmFyIHBhZENodW5rTGVuID0gY2h1bmtMZW47XG4gICAgICAgICAgICBpZiAoZmluYWxpemUpIHtcbiAgICAgICAgICAgICAgICBwYWRDaHVua0xlbiA9IHBhZENodW5rKGNodW5rTGVuLCBtc2dMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGUoZGF0YSwgY2h1bmtPZmZzZXQsIGNodW5rTGVuKTtcbiAgICAgICAgICAgIHNlbGYkMi5jb3JlLmhhc2gocGFkQ2h1bmtMZW4sIHNlbGYkMi5wYWRNYXhDaHVua0xlbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRSYXdEaWdlc3QgPSBmdW5jdGlvbiAoaGVhcCwgcGFkTWF4Q2h1bmtMZW4pIHtcbiAgICAgICAgICAgIHZhciBpbyA9IG5ldyBJbnQzMkFycmF5KGhlYXAsIHBhZE1heENodW5rTGVuICsgMzIwLCA1KTtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgSW50MzJBcnJheSg1KTtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgRGF0YVZpZXcob3V0LmJ1ZmZlcik7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoMCwgaW9bMF0sIGZhbHNlKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMig0LCBpb1sxXSwgZmFsc2UpO1xuICAgICAgICAgICAgYXJyLnNldEludDMyKDgsIGlvWzJdLCBmYWxzZSk7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoMTIsIGlvWzNdLCBmYWxzZSk7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoMTYsIGlvWzRdLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGhhc2ggZGlnZXN0IGFzIGFuIGFycmF5IG9mIDUgMzJiaXQgaW50ZWdlcnMuXG4gICAgICAgIHZhciByYXdEaWdlc3QgPSB0aGlzLnJhd0RpZ2VzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnTGVuID0gc3RyLmJ5dGVMZW5ndGggfHwgc3RyLmxlbmd0aCB8fCBzdHIuc2l6ZSB8fCAwO1xuICAgICAgICAgICAgICAgIGluaXRTdGF0ZShzZWxmJDIuaGVhcCwgc2VsZiQyLnBhZE1heENodW5rTGVuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSAwLCBjaHVua0xlbiA9IHNlbGYkMi5tYXhDaHVua0xlbiwgbGFzdDtcbiAgICAgICAgICAgICAgICBmb3IgKGNodW5rT2Zmc2V0ID0gMDsgbXNnTGVuID4gY2h1bmtPZmZzZXQgKyBjaHVua0xlbjsgY2h1bmtPZmZzZXQgKz0gY2h1bmtMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29yZUNhbGwoc3RyLCBjaHVua09mZnNldCwgY2h1bmtMZW4sIG1zZ0xlbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3JlQ2FsbChzdHIsIGNodW5rT2Zmc2V0LCBtc2dMZW4gLSBjaHVua09mZnNldCwgbXNnTGVuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmF3RGlnZXN0KHNlbGYkMi5oZWFwLCBzZWxmJDIucGFkTWF4Q2h1bmtMZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIGRpZ2VzdCBhbmQgZGlnZXN0RnJvbSogaW50ZXJmYWNlIHJldHVybnMgdGhlIGhhc2ggZGlnZXN0XG4gICAgICAgIC8vIGFzIGEgaGV4IHN0cmluZy5cbiAgICAgICAgdGhpcy5kaWdlc3QgPSB0aGlzLmRpZ2VzdEZyb21TdHJpbmcgPSB0aGlzLmRpZ2VzdEZyb21CdWZmZXIgPSB0aGlzLmRpZ2VzdEZyb21BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXgocmF3RGlnZXN0KHN0cikuYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgO1xuICAgIC8vIFRoZSBsb3ctbGV2ZWwgUnVzaENvcmUgbW9kdWxlIHByb3ZpZGVzIHRoZSBoZWFydCBvZiBSdXNoYSxcbiAgICAvLyBhIGhpZ2gtc3BlZWQgc2hhMSBpbXBsZW1lbnRhdGlvbiB3b3JraW5nIG9uIGFuIEludDMyQXJyYXkgaGVhcC5cbiAgICAvLyBBdCBmaXJzdCBnbGFuY2UsIHRoZSBpbXBsZW1lbnRhdGlvbiBzZWVtcyBjb21wbGljYXRlZCwgaG93ZXZlclxuICAgIC8vIHdpdGggdGhlIFNIQTEgc3BlYyBhdCBoYW5kLCBpdCBpcyBvYnZpb3VzIHRoaXMgYWxtb3N0IGEgdGV4dGJvb2tcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiB0aGF0IGhhcyBhIGZldyBmdW5jdGlvbnMgaGFuZC1pbmxpbmVkIGFuZCBhIGZldyBsb29wc1xuICAgIC8vIGhhbmQtdW5yb2xsZWQuXG4gICAgUnVzaGEuX2NvcmUgPSBmdW5jdGlvbiBSdXNoYUNvcmUoc3RkbGliLCBmb3JlaWduLCBoZWFwKSB7XG4gICAgICAgICd1c2UgYXNtJztcbiAgICAgICAgdmFyIEggPSBuZXcgc3RkbGliLkludDMyQXJyYXkoaGVhcCk7XG4gICAgICAgIGZ1bmN0aW9uIGhhc2goaywgeCkge1xuICAgICAgICAgICAgLy8gayBpbiBieXRlc1xuICAgICAgICAgICAgayA9IGsgfCAwO1xuICAgICAgICAgICAgeCA9IHggfCAwO1xuICAgICAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgeTAgPSAwLCB6MCA9IDAsIHkxID0gMCwgejEgPSAwLCB5MiA9IDAsIHoyID0gMCwgeTMgPSAwLCB6MyA9IDAsIHk0ID0gMCwgejQgPSAwLCB0MCA9IDAsIHQxID0gMDtcbiAgICAgICAgICAgIHkwID0gSFt4ICsgMzIwID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHkxID0gSFt4ICsgMzI0ID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHkyID0gSFt4ICsgMzI4ID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHkzID0gSFt4ICsgMzMyID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHk0ID0gSFt4ICsgMzM2ID4+IDJdIHwgMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChpIHwgMCkgPCAoayB8IDApOyBpID0gaSArIDY0IHwgMCkge1xuICAgICAgICAgICAgICAgIHowID0geTA7XG4gICAgICAgICAgICAgICAgejEgPSB5MTtcbiAgICAgICAgICAgICAgICB6MiA9IHkyO1xuICAgICAgICAgICAgICAgIHozID0geTM7XG4gICAgICAgICAgICAgICAgejQgPSB5NDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyAoaiB8IDApIDwgNjQ7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSBIW2kgKyBqID4+IDJdIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxICYgeTIgfCB+eTEgJiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApICsgMTUxODUwMDI0OSB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2sgKyBqID4+IDJdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyA2NCB8IDA7IChqIHwgMCkgPCAoayArIDgwIHwgMCk7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pIDw8IDEgfCAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pID4+PiAzMTtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxICYgeTIgfCB+eTEgJiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApICsgMTUxODUwMDI0OSB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDgwIHwgMDsgKGogfCAwKSA8IChrICsgMTYwIHwgMCk7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pIDw8IDEgfCAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pID4+PiAzMTtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxIF4geTIgXiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApICsgMTg1OTc3NTM5MyB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE2MCB8IDA7IChqIHwgMCkgPCAoayArIDI0MCB8IDApOyBqID0gaiArIDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA8PCAxIHwgKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA+Pj4gMzE7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gKCh5MCA8PCA1IHwgeTAgPj4+IDI3KSArICh5MSAmIHkyIHwgeTEgJiB5MyB8IHkyICYgeTMpIHwgMCkgKyAoKHQxICsgeTQgfCAwKSAtIDE4OTQwMDc1ODggfCAwKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIHk0ID0geTM7XG4gICAgICAgICAgICAgICAgICAgIHkzID0geTI7XG4gICAgICAgICAgICAgICAgICAgIHkyID0geTEgPDwgMzAgfCB5MSA+Pj4gMjtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB0MDtcbiAgICAgICAgICAgICAgICAgICAgSFtqID4+IDJdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyAyNDAgfCAwOyAoaiB8IDApIDwgKGsgKyAzMjAgfCAwKTsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPDwgMSB8IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPj4+IDMxO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgXiB5MiBeIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgLSA4OTk0OTc1MTQgfCAwKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIHk0ID0geTM7XG4gICAgICAgICAgICAgICAgICAgIHkzID0geTI7XG4gICAgICAgICAgICAgICAgICAgIHkyID0geTEgPDwgMzAgfCB5MSA+Pj4gMjtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB0MDtcbiAgICAgICAgICAgICAgICAgICAgSFtqID4+IDJdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkwID0geTAgKyB6MCB8IDA7XG4gICAgICAgICAgICAgICAgeTEgPSB5MSArIHoxIHwgMDtcbiAgICAgICAgICAgICAgICB5MiA9IHkyICsgejIgfCAwO1xuICAgICAgICAgICAgICAgIHkzID0geTMgKyB6MyB8IDA7XG4gICAgICAgICAgICAgICAgeTQgPSB5NCArIHo0IHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhbeCArIDMyMCA+PiAyXSA9IHkwO1xuICAgICAgICAgICAgSFt4ICsgMzI0ID4+IDJdID0geTE7XG4gICAgICAgICAgICBIW3ggKyAzMjggPj4gMl0gPSB5MjtcbiAgICAgICAgICAgIEhbeCArIDMzMiA+PiAyXSA9IHkzO1xuICAgICAgICAgICAgSFt4ICsgMzM2ID4+IDJdID0geTQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaGFzaDogaGFzaCB9O1xuICAgIH07XG4gICAgLy8gSWYgd2UnZSBydW5uaW5nIGluIE5vZGUuSlMsIGV4cG9ydCBhIG1vZHVsZS5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBSdXNoYTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5SdXNoYSA9IFJ1c2hhO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGluIGEgd2Vid29ya2VyLCBhY2NlcHRcbiAgICAvLyBtZXNzYWdlcyBjb250YWluaW5nIGEgam9iaWQgYW5kIGEgYnVmZmVyXG4gICAgLy8gb3IgYmxvYiBvYmplY3QsIGFuZCByZXR1cm4gdGhlIGhhc2ggcmVzdWx0LlxuICAgIGlmICh0eXBlb2YgRmlsZVJlYWRlclN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlclN5bmMoKSwgaGFzaGVyID0gbmV3IFJ1c2hhKDQgKiAxMDI0ICogMTAyNCk7XG4gICAgICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFzaCwgZGF0YSA9IGV2ZW50LmRhdGEuZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFzaCA9IGhhc2hlci5kaWdlc3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBldmVudC5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBoYXNoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBldmVudC5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZS5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2J1ZmZlcicpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJlYW0sIGNiKSB7XG4gIHZhciBjaHVua3MgPSBbXVxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBjaHVua3MucHVzaChjaHVuaylcbiAgfSlcbiAgc3RyZWFtLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIGNiKG51bGwsIEJ1ZmZlci5jb25jYXQoY2h1bmtzKSlcbiAgICBjYiA9IG51bGxcbiAgfSlcbiAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjYikgY2IoZXJyKVxuICAgIGNiID0gbnVsbFxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzaW1wbGVHZXRcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIHVuemlwUmVzcG9uc2UgPSByZXF1aXJlKCd1bnppcC1yZXNwb25zZScpIC8vIGV4Y2x1ZGVkIGZyb20gYnJvd3NlciBidWlsZFxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbmZ1bmN0aW9uIHNpbXBsZUdldCAob3B0cywgY2IpIHtcbiAgb3B0cyA9IHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJyA/IHsgdXJsOiBvcHRzIH0gOiBleHRlbmQob3B0cylcbiAgY2IgPSBvbmNlKGNiKVxuXG4gIGlmIChvcHRzLnVybCkgcGFyc2VPcHRzVXJsKG9wdHMpXG4gIGlmIChvcHRzLmhlYWRlcnMgPT0gbnVsbCkgb3B0cy5oZWFkZXJzID0ge31cbiAgaWYgKG9wdHMubWF4UmVkaXJlY3RzID09IG51bGwpIG9wdHMubWF4UmVkaXJlY3RzID0gMTBcblxuICB2YXIgYm9keSA9IG9wdHMuYm9keVxuICBvcHRzLmJvZHkgPSB1bmRlZmluZWRcbiAgaWYgKGJvZHkgJiYgIW9wdHMubWV0aG9kKSBvcHRzLm1ldGhvZCA9ICdQT1NUJ1xuXG4gIC8vIFJlcXVlc3QgZ3ppcC9kZWZsYXRlXG4gIHZhciBjdXN0b21BY2NlcHRFbmNvZGluZyA9IE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykuc29tZShmdW5jdGlvbiAoaCkge1xuICAgIHJldHVybiBoLnRvTG93ZXJDYXNlKCkgPT09ICdhY2NlcHQtZW5jb2RpbmcnXG4gIH0pXG4gIGlmICghY3VzdG9tQWNjZXB0RW5jb2RpbmcpIG9wdHMuaGVhZGVyc1snYWNjZXB0LWVuY29kaW5nJ10gPSAnZ3ppcCwgZGVmbGF0ZSdcblxuICAvLyBTdXBwb3J0IGh0dHA6IGFuZCBodHRwczogdXJsc1xuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cFxuICB2YXIgcmVxID0gcHJvdG9jb2wucmVxdWVzdChvcHRzLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgLy8gRm9sbG93IDN4eCByZWRpcmVjdHNcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMzAwICYmIHJlcy5zdGF0dXNDb2RlIDwgNDAwICYmICdsb2NhdGlvbicgaW4gcmVzLmhlYWRlcnMpIHtcbiAgICAgIG9wdHMudXJsID0gcmVzLmhlYWRlcnMubG9jYXRpb25cbiAgICAgIHBhcnNlT3B0c1VybChvcHRzKVxuICAgICAgcmVzLnJlc3VtZSgpIC8vIERpc2NhcmQgcmVzcG9uc2VcblxuICAgICAgb3B0cy5tYXhSZWRpcmVjdHMgLT0gMVxuICAgICAgaWYgKG9wdHMubWF4UmVkaXJlY3RzID4gMCkgc2ltcGxlR2V0KG9wdHMsIGNiKVxuICAgICAgZWxzZSBjYihuZXcgRXJyb3IoJ3RvbyBtYW55IHJlZGlyZWN0cycpKVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjYihudWxsLCB0eXBlb2YgdW56aXBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyA/IHVuemlwUmVzcG9uc2UocmVzKSA6IHJlcylcbiAgfSlcbiAgcmVxLm9uKCdlcnJvcicsIGNiKVxuICByZXEuZW5kKGJvZHkpXG4gIHJldHVybiByZXFcbn1cblxubW9kdWxlLmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIHJldHVybiBzaW1wbGVHZXQob3B0cywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB2YXIgY2h1bmtzID0gW11cbiAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgIH0pXG4gICAgcmVzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCByZXMsIEJ1ZmZlci5jb25jYXQoY2h1bmtzKSlcbiAgICB9KVxuICB9KVxufVxuXG47WydnZXQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnaGVhZCcsICdkZWxldGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgbW9kdWxlLmV4cG9ydHNbbWV0aG9kXSA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIG9wdHMgPSB7IHVybDogb3B0cyB9XG4gICAgb3B0cy5tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiBzaW1wbGVHZXQob3B0cywgY2IpXG4gIH1cbn0pXG5cbmZ1bmN0aW9uIHBhcnNlT3B0c1VybCAob3B0cykge1xuICB2YXIgbG9jID0gdXJsLnBhcnNlKG9wdHMudXJsKVxuICBpZiAobG9jLmhvc3RuYW1lKSBvcHRzLmhvc3RuYW1lID0gbG9jLmhvc3RuYW1lXG4gIGlmIChsb2MucG9ydCkgb3B0cy5wb3J0ID0gbG9jLnBvcnRcbiAgaWYgKGxvYy5wcm90b2NvbCkgb3B0cy5wcm90b2NvbCA9IGxvYy5wcm90b2NvbFxuICBpZiAobG9jLmF1dGgpIG9wdHMuYXV0aCA9IGxvYy5hdXRoXG4gIG9wdHMucGF0aCA9IGxvYy5wYXRoXG4gIGRlbGV0ZSBvcHRzLnVybFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBQZWVyXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NpbXBsZS1wZWVyJylcbnZhciBnZXRCcm93c2VyUlRDID0gcmVxdWlyZSgnZ2V0LWJyb3dzZXItcnRjJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG5pbmhlcml0cyhQZWVyLCBzdHJlYW0uRHVwbGV4KVxuXG4vKipcbiAqIFdlYlJUQyBwZWVyIGNvbm5lY3Rpb24uIFNhbWUgQVBJIGFzIG5vZGUgY29yZSBgbmV0LlNvY2tldGAsIHBsdXMgYSBmZXcgZXh0cmEgbWV0aG9kcy5cbiAqIER1cGxleCBzdHJlYW0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBQZWVyIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgUGVlcikpIHJldHVybiBuZXcgUGVlcihvcHRzKVxuICBzZWxmLl9kZWJ1ZygnbmV3IHBlZXIgJW8nLCBvcHRzKVxuXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIG9wdHMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlXG4gIGlmIChvcHRzLmhpZ2hXYXRlck1hcmsgPT0gbnVsbCkgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTAyNCAqIDEwMjRcblxuICBzdHJlYW0uRHVwbGV4LmNhbGwoc2VsZiwgb3B0cylcblxuICBzZWxmLmluaXRpYXRvciA9IG9wdHMuaW5pdGlhdG9yIHx8IGZhbHNlXG4gIHNlbGYuY2hhbm5lbENvbmZpZyA9IG9wdHMuY2hhbm5lbENvbmZpZyB8fCBQZWVyLmNoYW5uZWxDb25maWdcbiAgc2VsZi5jaGFubmVsTmFtZSA9IG9wdHMuaW5pdGlhdG9yID8gKG9wdHMuY2hhbm5lbE5hbWUgfHwgaGF0KDE2MCkpIDogbnVsbFxuICBzZWxmLmNvbmZpZyA9IG9wdHMuY29uZmlnIHx8IFBlZXIuY29uZmlnXG4gIHNlbGYuY29uc3RyYWludHMgPSBvcHRzLmNvbnN0cmFpbnRzIHx8IFBlZXIuY29uc3RyYWludHNcbiAgc2VsZi5vZmZlckNvbnN0cmFpbnRzID0gb3B0cy5vZmZlckNvbnN0cmFpbnRzXG4gIHNlbGYuYW5zd2VyQ29uc3RyYWludHMgPSBvcHRzLmFuc3dlckNvbnN0cmFpbnRzXG4gIHNlbGYucmVjb25uZWN0VGltZXIgPSBvcHRzLnJlY29ubmVjdFRpbWVyIHx8IGZhbHNlXG4gIHNlbGYuc2RwVHJhbnNmb3JtID0gb3B0cy5zZHBUcmFuc2Zvcm0gfHwgZnVuY3Rpb24gKHNkcCkgeyByZXR1cm4gc2RwIH1cbiAgc2VsZi5zdHJlYW0gPSBvcHRzLnN0cmVhbSB8fCBmYWxzZVxuICBzZWxmLnRyaWNrbGUgPSBvcHRzLnRyaWNrbGUgIT09IHVuZGVmaW5lZCA/IG9wdHMudHJpY2tsZSA6IHRydWVcblxuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcblxuICAvLyBzbyBQZWVyIG9iamVjdCBhbHdheXMgaGFzIHNhbWUgc2hhcGUgKFY4IG9wdGltaXphdGlvbilcbiAgc2VsZi5yZW1vdGVBZGRyZXNzID0gdW5kZWZpbmVkXG4gIHNlbGYucmVtb3RlRmFtaWx5ID0gdW5kZWZpbmVkXG4gIHNlbGYucmVtb3RlUG9ydCA9IHVuZGVmaW5lZFxuICBzZWxmLmxvY2FsQWRkcmVzcyA9IHVuZGVmaW5lZFxuICBzZWxmLmxvY2FsUG9ydCA9IHVuZGVmaW5lZFxuXG4gIHNlbGYuX2lzV3J0YyA9ICEhb3B0cy53cnRjIC8vIEhBQ0s6IHRvIGZpeCBgd3J0Y2AgYnVnLiBTZWUgaXNzdWU6ICM2MFxuICBzZWxmLl93cnRjID0gKG9wdHMud3J0YyAmJiB0eXBlb2Ygb3B0cy53cnRjID09PSAnb2JqZWN0JylcbiAgICA/IG9wdHMud3J0Y1xuICAgIDogZ2V0QnJvd3NlclJUQygpXG4gIGlmICghc2VsZi5fd3J0Yykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBXZWJSVEMgc3VwcG9ydDogU3BlY2lmeSBgb3B0cy53cnRjYCBvcHRpb24gaW4gdGhpcyBlbnZpcm9ubWVudCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IE5vdCBhIHN1cHBvcnRlZCBicm93c2VyJylcbiAgICB9XG4gIH1cblxuICBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCA9IG9wdHMuaGlnaFdhdGVyTWFya1xuICBzZWxmLl9wY1JlYWR5ID0gZmFsc2VcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gZmFsc2VcbiAgc2VsZi5faWNlQ29tcGxldGUgPSBmYWxzZSAvLyBpY2UgY2FuZGlkYXRlIHRyaWNrbGUgZG9uZSAoZ290IG51bGwgY2FuZGlkYXRlKVxuICBzZWxmLl9jaGFubmVsID0gbnVsbFxuICBzZWxmLl9wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdXG5cbiAgc2VsZi5fY2h1bmsgPSBudWxsXG4gIHNlbGYuX2NiID0gbnVsbFxuICBzZWxmLl9pbnRlcnZhbCA9IG51bGxcbiAgc2VsZi5fcmVjb25uZWN0VGltZW91dCA9IG51bGxcblxuICBzZWxmLl9wYyA9IG5ldyAoc2VsZi5fd3J0Yy5SVENQZWVyQ29ubmVjdGlvbikoc2VsZi5jb25maWcsIHNlbGYuY29uc3RyYWludHMpXG4gIHNlbGYuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKClcbiAgfVxuICBzZWxmLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UoKVxuICB9XG4gIHNlbGYuX3BjLm9uaWNlY2FuZGlkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgc2VsZi5fb25JY2VDYW5kaWRhdGUoZXZlbnQpXG4gIH1cblxuICBpZiAoc2VsZi5zdHJlYW0pIHNlbGYuX3BjLmFkZFN0cmVhbShzZWxmLnN0cmVhbSlcbiAgc2VsZi5fcGMub25hZGRzdHJlYW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWxmLl9vbkFkZFN0cmVhbShldmVudClcbiAgfVxuXG4gIGlmIChzZWxmLmluaXRpYXRvcikge1xuICAgIHNlbGYuX3NldHVwRGF0YSh7XG4gICAgICBjaGFubmVsOiBzZWxmLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChzZWxmLmNoYW5uZWxOYW1lLCBzZWxmLmNoYW5uZWxDb25maWcpXG4gICAgfSlcbiAgICBzZWxmLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9jcmVhdGVPZmZlcigpXG4gICAgfSlcbiAgICAvLyBPbmx5IENocm9tZSB0cmlnZ2VycyBcIm5lZ290aWF0aW9ubmVlZGVkXCI7IHRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBvdGhlclxuICAgIC8vIGltcGxlbWVudGF0aW9uc1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgICBzZWxmLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkKClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fcGMub25kYXRhY2hhbm5lbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc2VsZi5fc2V0dXBEYXRhKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5jb25uZWN0ZWQpIHtcbiAgICAgIC8vIFdoZW4gbG9jYWwgcGVlciBpcyBmaW5pc2hlZCB3cml0aW5nLCBjbG9zZSBjb25uZWN0aW9uIHRvIHJlbW90ZSBwZWVyLlxuICAgICAgLy8gSGFsZiBvcGVuIGNvbm5lY3Rpb25zIGFyZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cbiAgICAgIC8vIFdhaXQgYSBiaXQgYmVmb3JlIGRlc3Ryb3lpbmcgc28gdGhlIGRhdGFjaGFubmVsIGZsdXNoZXMuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kZXN0cm95KClcbiAgICAgIH0sIDEwMClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgZGF0YSBjaGFubmVsIGlzIG5vdCBjb25uZWN0ZWQgd2hlbiBsb2NhbCBwZWVyIGlzIGZpbmlzaGVkIHdyaXRpbmcsIHdhaXQgdW50aWxcbiAgICAgIC8vIGRhdGEgaXMgZmx1c2hlZCB0byBuZXR3b3JrIGF0IFwiY29ubmVjdFwiIGV2ZW50LlxuICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgICBzZWxmLm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgICB9LCAxMDApXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuUGVlci5XRUJSVENfU1VQUE9SVCA9ICEhZ2V0QnJvd3NlclJUQygpXG5cbi8qKlxuICogRXhwb3NlIGNvbmZpZywgY29uc3RyYWludHMsIGFuZCBkYXRhIGNoYW5uZWwgY29uZmlnIGZvciBvdmVycmlkaW5nIGFsbCBQZWVyXG4gKiBpbnN0YW5jZXMuIE90aGVyd2lzZSwganVzdCBzZXQgb3B0cy5jb25maWcsIG9wdHMuY29uc3RyYWludHMsIG9yIG9wdHMuY2hhbm5lbENvbmZpZ1xuICogd2hlbiBjb25zdHJ1Y3RpbmcgYSBQZWVyLlxuICovXG5QZWVyLmNvbmZpZyA9IHtcbiAgaWNlU2VydmVyczogW1xuICAgIHtcbiAgICAgIHVybDogJ3N0dW46MjMuMjEuMTUwLjEyMScsIC8vIGRlcHJlY2F0ZWQsIHJlcGxhY2VkIGJ5IGB1cmxzYFxuICAgICAgdXJsczogJ3N0dW46MjMuMjEuMTUwLjEyMSdcbiAgICB9XG4gIF1cbn1cblBlZXIuY29uc3RyYWludHMgPSB7fVxuUGVlci5jaGFubmVsQ29uZmlnID0ge31cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBlZXIucHJvdG90eXBlLCAnYnVmZmVyU2l6ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgcmV0dXJuIChzZWxmLl9jaGFubmVsICYmIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpIHx8IDBcbiAgfVxufSlcblxuUGVlci5wcm90b3R5cGUuYWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiB7IHBvcnQ6IHNlbGYubG9jYWxQb3J0LCBmYW1pbHk6ICdJUHY0JywgYWRkcmVzczogc2VsZi5sb2NhbEFkZHJlc3MgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzaWduYWwgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkYXRhID0ge31cbiAgICB9XG4gIH1cbiAgc2VsZi5fZGVidWcoJ3NpZ25hbCgpJylcblxuICBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLl9wYy5hZGRJY2VDYW5kaWRhdGUoXG4gICAgICAgIG5ldyBzZWxmLl93cnRjLlJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpLFxuICAgICAgICBub29wLFxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9XG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZWxmLl9kZXN0cm95KG5ldyBFcnJvcignZXJyb3IgYWRkaW5nIGNhbmRpZGF0ZTogJyArIGVyci5tZXNzYWdlKSlcbiAgICB9XG4gIH1cblxuICBpZiAoZGF0YS5zZHApIHtcbiAgICBzZWxmLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgKHNlbGYuX3dydGMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShkYXRhKSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChzZWxmLl9wYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInKSBzZWxmLl9jcmVhdGVBbnN3ZXIoKVxuXG4gICAgICBzZWxmLl9wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGFkZEljZUNhbmRpZGF0ZSlcbiAgICAgIHNlbGYuX3BlbmRpbmdDYW5kaWRhdGVzID0gW11cbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9KVxuICB9XG4gIGlmIChkYXRhLmNhbmRpZGF0ZSkge1xuICAgIGlmIChzZWxmLl9wYy5yZW1vdGVEZXNjcmlwdGlvbikgYWRkSWNlQ2FuZGlkYXRlKGRhdGEuY2FuZGlkYXRlKVxuICAgIGVsc2Ugc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMucHVzaChkYXRhLmNhbmRpZGF0ZSlcbiAgfVxuICBpZiAoIWRhdGEuc2RwICYmICFkYXRhLmNhbmRpZGF0ZSkge1xuICAgIHNlbGYuX2Rlc3Ryb3kobmV3IEVycm9yKCdzaWduYWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIHNpZ25hbCBkYXRhJykpXG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kIHRleHQvYmluYXJ5IGRhdGEgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICogQHBhcmFtIHtUeXBlZEFycmF5Vmlld3xBcnJheUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nfEJsb2J8T2JqZWN0fSBjaHVua1xuICovXG5QZWVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIEhBQ0s6IGB3cnRjYCBtb2R1bGUgZG9lc24ndCBhY2NlcHQgbm9kZS5qcyBidWZmZXIuIFNlZSBpc3N1ZTogIzYwXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHNlbGYuX2lzV3J0Yykge1xuICAgIGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gIH1cblxuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoIHx8IGNodW5rLmJ5dGVMZW5ndGggfHwgY2h1bmsuc2l6ZVxuICBzZWxmLl9jaGFubmVsLnNlbmQoY2h1bmspXG4gIHNlbGYuX2RlYnVnKCd3cml0ZTogJWQgYnl0ZXMnLCBsZW4pXG59XG5cblBlZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob25jbG9zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVzdHJveShudWxsLCBvbmNsb3NlKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIG9uY2xvc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmIChvbmNsb3NlKSBzZWxmLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSlcblxuICBzZWxmLl9kZWJ1ZygnZGVzdHJveSAoZXJyb3I6ICVzKScsIGVyciAmJiBlcnIubWVzc2FnZSlcblxuICBzZWxmLnJlYWRhYmxlID0gc2VsZi53cml0YWJsZSA9IGZhbHNlXG5cbiAgaWYgKCFzZWxmLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBzZWxmLnB1c2gobnVsbClcbiAgaWYgKCFzZWxmLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSBzZWxmLmVuZCgpXG5cbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcbiAgc2VsZi5fcGNSZWFkeSA9IGZhbHNlXG4gIHNlbGYuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG5cbiAgc2VsZi5fY2h1bmsgPSBudWxsXG4gIHNlbGYuX2NiID0gbnVsbFxuICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKVxuICBjbGVhclRpbWVvdXQoc2VsZi5fcmVjb25uZWN0VGltZW91dClcblxuICBpZiAoc2VsZi5fcGMpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5fcGMuY2xvc2UoKVxuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIHNlbGYuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgc2VsZi5fcGMub25pY2VjYW5kaWRhdGUgPSBudWxsXG4gICAgc2VsZi5fcGMub25hZGRzdHJlYW0gPSBudWxsXG4gICAgc2VsZi5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGxcbiAgICBzZWxmLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbFxuICB9XG5cbiAgaWYgKHNlbGYuX2NoYW5uZWwpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5fY2hhbm5lbC5jbG9zZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgc2VsZi5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBudWxsXG4gICAgc2VsZi5fY2hhbm5lbC5vbm9wZW4gPSBudWxsXG4gICAgc2VsZi5fY2hhbm5lbC5vbmNsb3NlID0gbnVsbFxuICB9XG4gIHNlbGYuX3BjID0gbnVsbFxuICBzZWxmLl9jaGFubmVsID0gbnVsbFxuXG4gIGlmIChlcnIpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHNlbGYuZW1pdCgnY2xvc2UnKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fc2V0dXBEYXRhID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9jaGFubmVsID0gZXZlbnQuY2hhbm5lbFxuICBzZWxmLmNoYW5uZWxOYW1lID0gc2VsZi5fY2hhbm5lbC5sYWJlbFxuXG4gIHNlbGYuX2NoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgc2VsZi5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWxmLl9vbkNoYW5uZWxNZXNzYWdlKGV2ZW50KVxuICB9XG4gIHNlbGYuX2NoYW5uZWwub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uQ2hhbm5lbE9wZW4oKVxuICB9XG4gIHNlbGYuX2NoYW5uZWwub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkNoYW5uZWxDbG9zZSgpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7fVxuXG5QZWVyLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobmV3IEVycm9yKCdjYW5ub3Qgd3JpdGUgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSlcblxuICBpZiAoc2VsZi5jb25uZWN0ZWQpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5zZW5kKGNodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHNlbGYuX29uRXJyb3IoZXJyKVxuICAgIH1cbiAgICBpZiAoc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50KSB7XG4gICAgICBzZWxmLl9kZWJ1Zygnc3RhcnQgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gICAgICBzZWxmLl9jYiA9IGNiXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX2RlYnVnKCd3cml0ZSBiZWZvcmUgY29ubmVjdCcpXG4gICAgc2VsZi5fY2h1bmsgPSBjaHVua1xuICAgIHNlbGYuX2NiID0gY2JcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuX3BjLmNyZWF0ZU9mZmVyKGZ1bmN0aW9uIChvZmZlcikge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgb2ZmZXIuc2RwID0gc2VsZi5zZHBUcmFuc2Zvcm0ob2ZmZXIuc2RwKVxuICAgIHNlbGYuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIsIG5vb3AsIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0pXG4gICAgdmFyIHNlbmRPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzaWduYWwgPSBzZWxmLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IG9mZmVyXG4gICAgICBzZWxmLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgIHNlbGYuZW1pdCgnc2lnbmFsJywge1xuICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgc2RwOiBzaWduYWwuc2RwXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoc2VsZi50cmlja2xlIHx8IHNlbGYuX2ljZUNvbXBsZXRlKSBzZW5kT2ZmZXIoKVxuICAgIGVsc2Ugc2VsZi5vbmNlKCdfaWNlQ29tcGxldGUnLCBzZW5kT2ZmZXIpIC8vIHdhaXQgZm9yIGNhbmRpZGF0ZXNcbiAgfSwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSwgc2VsZi5vZmZlckNvbnN0cmFpbnRzKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBzZWxmLl9wYy5jcmVhdGVBbnN3ZXIoZnVuY3Rpb24gKGFuc3dlcikge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgYW5zd2VyLnNkcCA9IHNlbGYuc2RwVHJhbnNmb3JtKGFuc3dlci5zZHApXG4gICAgc2VsZi5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIsIG5vb3AsIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0pXG4gICAgdmFyIHNlbmRBbnN3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2lnbmFsID0gc2VsZi5fcGMubG9jYWxEZXNjcmlwdGlvbiB8fCBhbnN3ZXJcbiAgICAgIHNlbGYuX2RlYnVnKCdzaWduYWwnKVxuICAgICAgc2VsZi5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgIHR5cGU6IHNpZ25hbC50eXBlLFxuICAgICAgICBzZHA6IHNpZ25hbC5zZHBcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChzZWxmLnRyaWNrbGUgfHwgc2VsZi5faWNlQ29tcGxldGUpIHNlbmRBbnN3ZXIoKVxuICAgIGVsc2Ugc2VsZi5vbmNlKCdfaWNlQ29tcGxldGUnLCBzZW5kQW5zd2VyKVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9LCBzZWxmLmFuc3dlckNvbnN0cmFpbnRzKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICB2YXIgaWNlR2F0aGVyaW5nU3RhdGUgPSBzZWxmLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZVxuICB2YXIgaWNlQ29ubmVjdGlvblN0YXRlID0gc2VsZi5fcGMuaWNlQ29ubmVjdGlvblN0YXRlXG4gIHNlbGYuX2RlYnVnKCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgJXMgJXMnLCBpY2VHYXRoZXJpbmdTdGF0ZSwgaWNlQ29ubmVjdGlvblN0YXRlKVxuICBzZWxmLmVtaXQoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZScsIGljZUdhdGhlcmluZ1N0YXRlLCBpY2VDb25uZWN0aW9uU3RhdGUpXG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVjb25uZWN0VGltZW91dClcbiAgICBzZWxmLl9wY1JlYWR5ID0gdHJ1ZVxuICAgIHNlbGYuX21heWJlUmVhZHkoKVxuICB9XG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgaWYgKHNlbGYucmVjb25uZWN0VGltZXIpIHtcbiAgICAgIC8vIElmIHVzZXIgaGFzIHNldCBgb3B0LnJlY29ubmVjdFRpbWVyYCwgYWxsb3cgdGltZSBmb3IgSUNFIHRvIGF0dGVtcHQgYSByZWNvbm5lY3RcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9yZWNvbm5lY3RUaW1lb3V0KVxuICAgICAgc2VsZi5fcmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kZXN0cm95KClcbiAgICAgIH0sIHNlbGYucmVjb25uZWN0VGltZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgIH1cbiAgfVxuICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgIHNlbGYuX2Rlc3Ryb3koKVxuICB9XG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgc2VsZi5fZGVzdHJveSgpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5fcGMuZ2V0U3RhdHMpIHsgLy8gTm8gYWJpbGl0eSB0byBjYWxsIHN0YXRzXG4gICAgY2IoW10pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pIHsgLy8gTW96aWxsYVxuICAgIHNlbGYuX3BjLmdldFN0YXRzKG51bGwsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICByZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG4gICAgICB9KVxuICAgICAgY2IoaXRlbXMpXG4gICAgfSwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9wYy5nZXRTdGF0cyhmdW5jdGlvbiAocmVzKSB7IC8vIENocm9tZVxuICAgICAgdmFyIGl0ZW1zID0gW11cbiAgICAgIHJlcy5yZXN1bHQoKS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7fVxuICAgICAgICByZXN1bHQubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaXRlbVtuYW1lXSA9IHJlc3VsdC5zdGF0KG5hbWUpXG4gICAgICAgIH0pXG4gICAgICAgIGl0ZW0uaWQgPSByZXN1bHQuaWRcbiAgICAgICAgaXRlbS50eXBlID0gcmVzdWx0LnR5cGVcbiAgICAgICAgaXRlbS50aW1lc3RhbXAgPSByZXN1bHQudGltZXN0YW1wXG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgIH0pXG4gICAgICBjYihpdGVtcylcbiAgICB9KVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9tYXliZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVidWcoJ21heWJlUmVhZHkgcGMgJXMgY2hhbm5lbCAlcycsIHNlbGYuX3BjUmVhZHksIHNlbGYuX2NoYW5uZWxSZWFkeSlcbiAgaWYgKHNlbGYuY29ubmVjdGVkIHx8IHNlbGYuX2Nvbm5lY3RpbmcgfHwgIXNlbGYuX3BjUmVhZHkgfHwgIXNlbGYuX2NoYW5uZWxSZWFkeSkgcmV0dXJuXG4gIHNlbGYuX2Nvbm5lY3RpbmcgPSB0cnVlXG5cbiAgc2VsZi5nZXRTdGF0cyhmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICBzZWxmLl9jb25uZWN0aW5nID0gZmFsc2VcbiAgICBzZWxmLmNvbm5lY3RlZCA9IHRydWVcblxuICAgIHZhciByZW1vdGVDYW5kaWRhdGVzID0ge31cbiAgICB2YXIgbG9jYWxDYW5kaWRhdGVzID0ge31cblxuICAgIGZ1bmN0aW9uIHNldEFjdGl2ZUNhbmRpZGF0ZXMgKGl0ZW0pIHtcbiAgICAgIHZhciBsb2NhbCA9IGxvY2FsQ2FuZGlkYXRlc1tpdGVtLmxvY2FsQ2FuZGlkYXRlSWRdXG4gICAgICB2YXIgcmVtb3RlID0gcmVtb3RlQ2FuZGlkYXRlc1tpdGVtLnJlbW90ZUNhbmRpZGF0ZUlkXVxuXG4gICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBsb2NhbC5pcEFkZHJlc3NcbiAgICAgICAgc2VsZi5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWwucG9ydE51bWJlcilcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0uZ29vZ0xvY2FsQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gU29tZXRpbWVzIGBpdGVtLmlkYCBpcyB1bmRlZmluZWQgaW4gYHdydGNgIGFuZCBDaHJvbWVcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NpbXBsZS1wZWVyL2lzc3Vlcy82NlxuICAgICAgICBsb2NhbCA9IGl0ZW0uZ29vZ0xvY2FsQWRkcmVzcy5zcGxpdCgnOicpXG4gICAgICAgIHNlbGYubG9jYWxBZGRyZXNzID0gbG9jYWxbMF1cbiAgICAgICAgc2VsZi5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWxbMV0pXG4gICAgICB9XG4gICAgICBzZWxmLl9kZWJ1ZygnY29ubmVjdCBsb2NhbDogJXM6JXMnLCBzZWxmLmxvY2FsQWRkcmVzcywgc2VsZi5sb2NhbFBvcnQpXG5cbiAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgc2VsZi5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwQWRkcmVzc1xuICAgICAgICBzZWxmLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlLnBvcnROdW1iZXIpXG4gICAgICAgIHNlbGYucmVtb3RlRmFtaWx5ID0gJ0lQdjQnXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmdvb2dSZW1vdGVBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICByZW1vdGUgPSBpdGVtLmdvb2dSZW1vdGVBZGRyZXNzLnNwbGl0KCc6JylcbiAgICAgICAgc2VsZi5yZW1vdGVBZGRyZXNzID0gcmVtb3RlWzBdXG4gICAgICAgIHNlbGYucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGVbMV0pXG4gICAgICAgIHNlbGYucmVtb3RlRmFtaWx5ID0gJ0lQdjQnXG4gICAgICB9XG4gICAgICBzZWxmLl9kZWJ1ZygnY29ubmVjdCByZW1vdGU6ICVzOiVzJywgc2VsZi5yZW1vdGVBZGRyZXNzLCBzZWxmLnJlbW90ZVBvcnQpXG4gICAgfVxuXG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3JlbW90ZWNhbmRpZGF0ZScpIHJlbW90ZUNhbmRpZGF0ZXNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICBpZiAoaXRlbS50eXBlID09PSAnbG9jYWxjYW5kaWRhdGUnKSBsb2NhbENhbmRpZGF0ZXNbaXRlbS5pZF0gPSBpdGVtXG4gICAgfSlcblxuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBpc0NhbmRpZGF0ZVBhaXIgPSAoXG4gICAgICAgIChpdGVtLnR5cGUgPT09ICdnb29nQ2FuZGlkYXRlUGFpcicgJiYgaXRlbS5nb29nQWN0aXZlQ29ubmVjdGlvbiA9PT0gJ3RydWUnKSB8fFxuICAgICAgICAoaXRlbS50eXBlID09PSAnY2FuZGlkYXRlcGFpcicgJiYgaXRlbS5zZWxlY3RlZClcbiAgICAgIClcbiAgICAgIGlmIChpc0NhbmRpZGF0ZVBhaXIpIHNldEFjdGl2ZUNhbmRpZGF0ZXMoaXRlbSlcbiAgICB9KVxuXG4gICAgaWYgKHNlbGYuX2NodW5rKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLnNlbmQoc2VsZi5fY2h1bmspXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX29uRXJyb3IoZXJyKVxuICAgICAgfVxuICAgICAgc2VsZi5fY2h1bmsgPSBudWxsXG4gICAgICBzZWxmLl9kZWJ1Zygnc2VudCBjaHVuayBmcm9tIFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcIicpXG5cbiAgICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgICBzZWxmLl9jYiA9IG51bGxcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuXG4gICAgc2VsZi5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNlbGYuX2NiIHx8ICFzZWxmLl9jaGFubmVsIHx8IHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCkgcmV0dXJuXG4gICAgICBzZWxmLl9kZWJ1ZygnZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCBzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KVxuICAgICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICB9LCAxNTApXG4gICAgaWYgKHNlbGYuX2ludGVydmFsLnVucmVmKSBzZWxmLl9pbnRlcnZhbC51bnJlZigpXG5cbiAgICBzZWxmLl9kZWJ1ZygnY29ubmVjdCcpXG4gICAgc2VsZi5lbWl0KCdjb25uZWN0JylcbiAgfSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnc2lnbmFsaW5nU3RhdGVDaGFuZ2UgJXMnLCBzZWxmLl9wYy5zaWduYWxpbmdTdGF0ZSlcbiAgc2VsZi5lbWl0KCdzaWduYWxpbmdTdGF0ZUNoYW5nZScsIHNlbGYuX3BjLnNpZ25hbGluZ1N0YXRlKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25JY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmIChldmVudC5jYW5kaWRhdGUgJiYgc2VsZi50cmlja2xlKSB7XG4gICAgc2VsZi5lbWl0KCdzaWduYWwnLCB7XG4gICAgICBjYW5kaWRhdGU6IHtcbiAgICAgICAgY2FuZGlkYXRlOiBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICBzZHBNTGluZUluZGV4OiBldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgc2RwTWlkOiBldmVudC5jYW5kaWRhdGUuc2RwTWlkXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIGlmICghZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgc2VsZi5faWNlQ29tcGxldGUgPSB0cnVlXG4gICAgc2VsZi5lbWl0KCdfaWNlQ29tcGxldGUnKVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9vbkNoYW5uZWxNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFcbiAgc2VsZi5fZGVidWcoJ3JlYWQ6ICVkIGJ5dGVzJywgZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoKVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpXG4gIHNlbGYucHVzaChkYXRhKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25DaGFubmVsT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmNvbm5lY3RlZCB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdvbiBjaGFubmVsIG9wZW4nKVxuICBzZWxmLl9jaGFubmVsUmVhZHkgPSB0cnVlXG4gIHNlbGYuX21heWJlUmVhZHkoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25DaGFubmVsQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gY2hhbm5lbCBjbG9zZScpXG4gIHNlbGYuX2Rlc3Ryb3koKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25BZGRTdHJlYW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdvbiBhZGQgc3RyZWFtJylcbiAgc2VsZi5lbWl0KCdzdHJlYW0nLCBldmVudC5zdHJlYW0pXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ2Vycm9yICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICBzZWxmLl9kZXN0cm95KGVycilcbn1cblxuUGVlci5wcm90b3R5cGUuX2RlYnVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgdmFyIGlkID0gc2VsZi5jaGFubmVsTmFtZSAmJiBzZWxmLmNoYW5uZWxOYW1lLnN1YnN0cmluZygwLCA3KVxuICBhcmdzWzBdID0gJ1snICsgaWQgKyAnXSAnICsgYXJnc1swXVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmdzKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCJ2YXIgUnVzaGEgPSByZXF1aXJlKCdydXNoYScpXG5cbnZhciBydXNoYSA9IG5ldyBSdXNoYVxudmFyIGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvIHx8IHt9XG52YXIgc3VidGxlID0gY3J5cHRvLnN1YnRsZSB8fCBjcnlwdG8ud2Via2l0U3VidGxlXG5cbmZ1bmN0aW9uIHNoYTFzeW5jIChidWYpIHtcbiAgcmV0dXJuIHJ1c2hhLmRpZ2VzdChidWYpXG59XG5cbi8vIEJyb3dzZXJzIHRocm93IGlmIHRoZXkgbGFjayBzdXBwb3J0IGZvciBhbiBhbGdvcml0aG0uXG4vLyBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgb24gbm9uLXNlY3VyZSBvcmlnaW5zLiAoaHR0cDovL2dvby5nbC9scTRnQ28pXG50cnkge1xuICBzdWJ0bGUuZGlnZXN0KHsgbmFtZTogJ3NoYS0xJyB9LCBuZXcgVWludDhBcnJheSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgIHN1YnRsZSA9IGZhbHNlXG4gIH0pXG59IGNhdGNoIChlcnIpIHsgc3VidGxlID0gZmFsc2UgfVxuXG5mdW5jdGlvbiBzaGExIChidWYsIGNiKSB7XG4gIGlmICghc3VidGxlKSB7XG4gICAgLy8gVXNlIFJ1c2hhXG4gICAgc2V0VGltZW91dChjYiwgMCwgc2hhMXN5bmMoYnVmKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IHVpbnQ4YXJyYXkoYnVmKVxuICB9XG5cbiAgc3VidGxlLmRpZ2VzdCh7IG5hbWU6ICdzaGEtMScgfSwgYnVmKVxuICAgIC50aGVuKGZ1bmN0aW9uIHN1Y2NlZWQgKHJlc3VsdCkge1xuICAgICAgY2IoaGV4KG5ldyBVaW50OEFycmF5KHJlc3VsdCkpKVxuICAgIH0sXG4gICAgZnVuY3Rpb24gZmFpbCAoZXJyb3IpIHtcbiAgICAgIGNiKHNoYTFzeW5jKGJ1ZikpXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gdWludDhhcnJheSAocykge1xuICB2YXIgbCA9IHMubGVuZ3RoXG4gIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGwpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBzLmNoYXJDb2RlQXQoaSlcbiAgfVxuICByZXR1cm4gYXJyYXlcbn1cblxuZnVuY3Rpb24gaGV4IChidWYpIHtcbiAgdmFyIGwgPSBidWYubGVuZ3RoXG4gIHZhciBjaGFycyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGJpdGUgPSBidWZbaV1cbiAgICBjaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpXG4gICAgY2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSlcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGExXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gc2hhMXN5bmNcbiIsIi8qIGdsb2JhbCBXZWJTb2NrZXQgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXRcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlLXdlYnNvY2tldCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciB3cyA9IHJlcXVpcmUoJ3dzJykgLy8gd2Vic29ja2V0cyBpbiBub2RlIC0gd2lsbCBiZSBlbXB0eSBvYmplY3QgaW4gYnJvd3NlclxuXG52YXIgX1dlYlNvY2tldCA9IHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnID8gV2ViU29ja2V0IDogd3NcblxuaW5oZXJpdHMoU29ja2V0LCBzdHJlYW0uRHVwbGV4KVxuXG4vKipcbiAqIFdlYlNvY2tldC4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YC4gRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgd2Vic29ja2V0IHNlcnZlciB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbnMgdG8gc3RyZWFtLkR1cGxleFxuICovXG5mdW5jdGlvbiBTb2NrZXQgKHVybCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVybCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgZGVidWcoJ25ldyB3ZWJzb2NrZXQ6ICVzICVvJywgdXJsLCBvcHRzKVxuXG4gIG9wdHMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlXG4gIGlmIChvcHRzLmhpZ2hXYXRlck1hcmsgPT0gbnVsbCkgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTAyNCAqIDEwMjRcblxuICBzdHJlYW0uRHVwbGV4LmNhbGwoc2VsZiwgb3B0cylcblxuICBzZWxmLnVybCA9IHVybFxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCA9IG9wdHMuaGlnaFdhdGVyTWFya1xuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIHNlbGYuX2ludGVydmFsID0gbnVsbFxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBXZWJTb2NrZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBgd3NgIHBhY2thZ2UgYWNjZXB0cyBvcHRpb25zXG4gICAgICBzZWxmLl93cyA9IG5ldyBfV2ViU29ja2V0KHNlbGYudXJsLCBvcHRzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl93cyA9IG5ldyBfV2ViU29ja2V0KHNlbGYudXJsKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9vbkVycm9yKGVycilcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIHNlbGYuX3dzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIHNlbGYuX3dzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbk9wZW4oKVxuICB9XG4gIHNlbGYuX3dzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlbGYuX29uTWVzc2FnZShldmVudClcbiAgfVxuICBzZWxmLl93cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uQ2xvc2UoKVxuICB9XG4gIHNlbGYuX3dzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25FcnJvcihuZXcgRXJyb3IoJ2Nvbm5lY3Rpb24gZXJyb3IgdG8gJyArIHNlbGYudXJsKSlcbiAgfVxuXG4gIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5jb25uZWN0ZWQpIHtcbiAgICAgIC8vIFdoZW4gc3RyZWFtIGlzIGZpbmlzaGVkIHdyaXRpbmcsIGNsb3NlIHNvY2tldCBjb25uZWN0aW9uLiBIYWxmIG9wZW4gY29ubmVjdGlvbnNcbiAgICAgIC8vIGFyZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cbiAgICAgIC8vIFdhaXQgYSBiaXQgYmVmb3JlIGRlc3Ryb3lpbmcgc28gdGhlIHNvY2tldCBmbHVzaGVzLlxuICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICB9LCAxMDApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHNvY2tldCBpcyBub3QgY29ubmVjdGVkIHdoZW4gc3RyZWFtIGlzIGZpbmlzaGVkIHdyaXRpbmcsIHdhaXQgdW50aWwgZGF0YSBpc1xuICAgICAgLy8gZmx1c2hlZCB0byBuZXR3b3JrIGF0IFwiY29ubmVjdFwiIGV2ZW50LlxuICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgICBzZWxmLm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgICB9LCAxMDApXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuU29ja2V0LldFQlNPQ0tFVF9TVVBQT1JUID0gISFfV2ViU29ja2V0XG5cbi8qKlxuICogU2VuZCB0ZXh0L2JpbmFyeSBkYXRhIHRvIHRoZSBXZWJTb2NrZXQgc2VydmVyLlxuICogQHBhcmFtIHtUeXBlZEFycmF5Vmlld3xBcnJheUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nfEJsb2J8T2JqZWN0fSBjaHVua1xuICovXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aCB8fCBjaHVuay5ieXRlTGVuZ3RoIHx8IGNodW5rLnNpemVcbiAgc2VsZi5fd3Muc2VuZChjaHVuaylcbiAgZGVidWcoJ3dyaXRlOiAlZCBieXRlcycsIGxlbilcbn1cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9uY2xvc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2Rlc3Ryb3kobnVsbCwgb25jbG9zZSlcbn1cblxuU29ja2V0LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIG9uY2xvc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmIChvbmNsb3NlKSBzZWxmLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSlcblxuICBkZWJ1ZygnZGVzdHJveSAoZXJyb3I6ICVzKScsIGVyciAmJiBlcnIubWVzc2FnZSlcblxuICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgaWYgKCFzZWxmLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBzZWxmLnB1c2gobnVsbClcbiAgaWYgKCFzZWxmLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSBzZWxmLmVuZCgpXG5cbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKVxuICBzZWxmLl9pbnRlcnZhbCA9IG51bGxcbiAgc2VsZi5fY2h1bmsgPSBudWxsXG4gIHNlbGYuX2NiID0gbnVsbFxuXG4gIGlmIChzZWxmLl93cykge1xuICAgIHZhciB3cyA9IHNlbGYuX3dzXG4gICAgdmFyIG9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3cy5vbmNsb3NlID0gbnVsbFxuICAgICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gICAgfVxuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSBfV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgb25DbG9zZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBvbkNsb3NlXG4gICAgICAgIHdzLmNsb3NlKClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBvbkNsb3NlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3cy5vbm9wZW4gPSBudWxsXG4gICAgd3Mub25tZXNzYWdlID0gbnVsbFxuICAgIHdzLm9uZXJyb3IgPSBudWxsXG4gIH1cbiAgc2VsZi5fd3MgPSBudWxsXG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cblxuU29ja2V0LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cblNvY2tldC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGFmdGVyIHNvY2tldCBpcyBkZXN0cm95ZWQnKSlcblxuICBpZiAoc2VsZi5jb25uZWN0ZWQpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5zZW5kKGNodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHNlbGYuX29uRXJyb3IoZXJyKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHdzICE9PSAnZnVuY3Rpb24nICYmIHNlbGYuX3dzLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHtcbiAgICAgIGRlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fd3MuYnVmZmVyZWRBbW91bnQpXG4gICAgICBzZWxmLl9jYiA9IGNiXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCd3cml0ZSBiZWZvcmUgY29ubmVjdCcpXG4gICAgc2VsZi5fY2h1bmsgPSBjaHVua1xuICAgIHNlbGYuX2NiID0gY2JcbiAgfVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICBkZWJ1ZygncmVhZDogJWQgYnl0ZXMnLCBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGgpXG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcbiAgc2VsZi5wdXNoKGRhdGEpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX29uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmNvbm5lY3RlZCB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuY29ubmVjdGVkID0gdHJ1ZVxuXG4gIGlmIChzZWxmLl9jaHVuaykge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLnNlbmQoc2VsZi5fY2h1bmspXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5fb25FcnJvcihlcnIpXG4gICAgfVxuICAgIHNlbGYuX2NodW5rID0gbnVsbFxuICAgIGRlYnVnKCdzZW50IGNodW5rIGZyb20gXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiJylcblxuICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgc2VsZi5fY2IgPSBudWxsXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIC8vIE5vIGJhY2twcmVzc3VyZSBpbiBub2RlLiBUaGUgYHdzYCBtb2R1bGUgaGFzIGEgYnVnZ3kgYGJ1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eS5cbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvNDkyXG4gIGlmICh0eXBlb2Ygd3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5fY2IgfHwgIXNlbGYuX3dzIHx8IHNlbGYuX3dzLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBkZWJ1ZygnZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCBzZWxmLl93cy5idWZmZXJlZEFtb3VudClcbiAgICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgICBzZWxmLl9jYiA9IG51bGxcbiAgICAgIGNiKG51bGwpXG4gICAgfSwgMTUwKVxuICAgIGlmIChzZWxmLl9pbnRlcnZhbC51bnJlZikgc2VsZi5faW50ZXJ2YWwudW5yZWYoKVxuICB9XG5cbiAgZGVidWcoJ2Nvbm5lY3QnKVxuICBzZWxmLmVtaXQoJ2Nvbm5lY3QnKVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgZGVidWcoJ29uIGNsb3NlJylcbiAgc2VsZi5fZGVzdHJveSgpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBkZWJ1ZygnZXJyb3I6ICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICBzZWxmLl9kZXN0cm95KGVycilcbn1cbiIsInZhciB0aWNrID0gMVxudmFyIG1heFRpY2sgPSA2NTUzNVxudmFyIHJlc29sdXRpb24gPSA0XG52YXIgaW5jID0gZnVuY3Rpb24gKCkge1xuICB0aWNrID0gKHRpY2sgKyAxKSAmIG1heFRpY2tcbn1cblxudmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoaW5jLCAoMTAwMCAvIHJlc29sdXRpb24pIHwgMClcbmlmICh0aW1lci51bnJlZikgdGltZXIudW5yZWYoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG4gIHZhciBzaXplID0gcmVzb2x1dGlvbiAqIChzZWNvbmRzIHx8IDUpXG4gIHZhciBidWZmZXIgPSBbMF1cbiAgdmFyIHBvaW50ZXIgPSAxXG4gIHZhciBsYXN0ID0gKHRpY2sgLSAxKSAmIG1heFRpY2tcblxuICByZXR1cm4gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgdmFyIGRpc3QgPSAodGljayAtIGxhc3QpICYgbWF4VGlja1xuICAgIGlmIChkaXN0ID4gc2l6ZSkgZGlzdCA9IHNpemVcbiAgICBsYXN0ID0gdGlja1xuXG4gICAgd2hpbGUgKGRpc3QtLSkge1xuICAgICAgaWYgKHBvaW50ZXIgPT09IHNpemUpIHBvaW50ZXIgPSAwXG4gICAgICBidWZmZXJbcG9pbnRlcl0gPSBidWZmZXJbcG9pbnRlciA9PT0gMCA/IHNpemUgLSAxIDogcG9pbnRlciAtIDFdXG4gICAgICBwb2ludGVyKytcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEpIGJ1ZmZlcltwb2ludGVyIC0gMV0gKz0gZGVsdGFcblxuICAgIHZhciB0b3AgPSBidWZmZXJbcG9pbnRlciAtIDFdXG4gICAgdmFyIGJ0bSA9IGJ1ZmZlci5sZW5ndGggPCBzaXplID8gMCA6IGJ1ZmZlcltwb2ludGVyID09PSBzaXplID8gMCA6IHBvaW50ZXJdXG5cbiAgICByZXR1cm4gYnVmZmVyLmxlbmd0aCA8IHJlc29sdXRpb24gPyB0b3AgOiAodG9wIC0gYnRtKSAqIHJlc29sdXRpb24gLyBidWZmZXIubGVuZ3RoXG4gIH1cbn1cbiIsInZhciBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHN0YXR1c0NvZGVzID0gcmVxdWlyZSgnYnVpbHRpbi1zdGF0dXMtY29kZXMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwID0gZXhwb3J0c1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcblx0XHRvcHRzID0gdXJsLnBhcnNlKG9wdHMpXG5cdGVsc2Vcblx0XHRvcHRzID0gZXh0ZW5kKG9wdHMpXG5cblx0Ly8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcblx0Ly8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG5cdC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG5cdHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuXHR2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuXHR2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cdHZhciBwb3J0ID0gb3B0cy5wb3J0XG5cdHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG5cdC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcblx0aWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuXHRcdGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cblx0Ly8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXHRvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuXHRvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuXHQvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cblx0dmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG5cdGlmIChjYilcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgY2IpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5nZXQgPSBmdW5jdGlvbiBnZXQgKG9wdHMsIGNiKSB7XG5cdHZhciByZXEgPSBodHRwLnJlcXVlc3Qob3B0cywgY2IpXG5cdHJlcS5lbmQoKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fVxuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDRcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSBzdGF0dXNDb2Rlc1xuXG5odHRwLk1FVEhPRFMgPSBbXG5cdCdDSEVDS09VVCcsXG5cdCdDT05ORUNUJyxcblx0J0NPUFknLFxuXHQnREVMRVRFJyxcblx0J0dFVCcsXG5cdCdIRUFEJyxcblx0J0xPQ0snLFxuXHQnTS1TRUFSQ0gnLFxuXHQnTUVSR0UnLFxuXHQnTUtBQ1RJVklUWScsXG5cdCdNS0NPTCcsXG5cdCdNT1ZFJyxcblx0J05PVElGWScsXG5cdCdPUFRJT05TJyxcblx0J1BBVENIJyxcblx0J1BPU1QnLFxuXHQnUFJPUEZJTkQnLFxuXHQnUFJPUFBBVENIJyxcblx0J1BVUkdFJyxcblx0J1BVVCcsXG5cdCdSRVBPUlQnLFxuXHQnU0VBUkNIJyxcblx0J1NVQlNDUklCRScsXG5cdCdUUkFDRScsXG5cdCdVTkxPQ0snLFxuXHQnVU5TVUJTQ1JJQkUnXG5dIiwiZXhwb3J0cy5mZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsLmZldGNoKSAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5SZWFkYWJsZUJ5dGVTdHJlYW0pXG5cbmV4cG9ydHMuYmxvYkNvbnN0cnVjdG9yID0gZmFsc2VcbnRyeSB7XG5cdG5ldyBCbG9iKFtuZXcgQXJyYXlCdWZmZXIoMSldKVxuXHRleHBvcnRzLmJsb2JDb25zdHJ1Y3RvciA9IHRydWVcbn0gY2F0Y2ggKGUpIHt9XG5cbnZhciB4aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcbi8vIElmIGxvY2F0aW9uLmhvc3QgaXMgZW1wdHksIGUuZy4gaWYgdGhpcyBwYWdlL3dvcmtlciB3YXMgbG9hZGVkXG4vLyBmcm9tIGEgQmxvYiwgdGhlbiB1c2UgZXhhbXBsZS5jb20gdG8gYXZvaWQgYW4gZXJyb3Jcbnhoci5vcGVuKCdHRVQnLCBnbG9iYWwubG9jYXRpb24uaG9zdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJylcblxuZnVuY3Rpb24gY2hlY2tUeXBlU3VwcG9ydCAodHlwZSkge1xuXHR0cnkge1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSB0eXBlXG5cdFx0cmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09IHR5cGVcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlXG59XG5cbi8vIEZvciBzb21lIHN0cmFuZ2UgcmVhc29uLCBTYWZhcmkgNy4wIHJlcG9ydHMgdHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciA9PT0gJ29iamVjdCcuXG4vLyBTYWZhcmkgNy4xIGFwcGVhcnMgdG8gaGF2ZSBmaXhlZCB0aGlzIGJ1Zy5cbnZhciBoYXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhdmVTbGljZSA9IGhhdmVBcnJheUJ1ZmZlciAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5BcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UpXG5cbmV4cG9ydHMuYXJyYXlidWZmZXIgPSBoYXZlQXJyYXlCdWZmZXIgJiYgY2hlY2tUeXBlU3VwcG9ydCgnYXJyYXlidWZmZXInKVxuLy8gVGhlc2UgbmV4dCB0d28gdGVzdHMgdW5hdm9pZGFibHkgc2hvdyB3YXJuaW5ncyBpbiBDaHJvbWUuIFNpbmNlIGZldGNoIHdpbGwgYWx3YXlzXG4vLyBiZSB1c2VkIGlmIGl0J3MgYXZhaWxhYmxlLCBqdXN0IHJldHVybiBmYWxzZSBmb3IgdGhlc2UgdG8gYXZvaWQgdGhlIHdhcm5pbmdzLlxuZXhwb3J0cy5tc3N0cmVhbSA9ICFleHBvcnRzLmZldGNoICYmIGhhdmVTbGljZSAmJiBjaGVja1R5cGVTdXBwb3J0KCdtcy1zdHJlYW0nKVxuZXhwb3J0cy5tb3pjaHVua2VkYXJyYXlidWZmZXIgPSAhZXhwb3J0cy5mZXRjaCAmJiBoYXZlQXJyYXlCdWZmZXIgJiZcblx0Y2hlY2tUeXBlU3VwcG9ydCgnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKVxuZXhwb3J0cy5vdmVycmlkZU1pbWVUeXBlID0gaXNGdW5jdGlvbih4aHIub3ZlcnJpZGVNaW1lVHlwZSlcbmV4cG9ydHMudmJBcnJheSA9IGlzRnVuY3Rpb24oZ2xvYmFsLlZCQXJyYXkpXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cblxueGhyID0gbnVsbCAvLyBIZWxwIGdjXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIHRvQXJyYXlCdWZmZXIgPSByZXF1aXJlKCd0by1hcnJheWJ1ZmZlcicpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5KSB7XG5cdGlmIChjYXBhYmlsaXR5LmZldGNoKSB7XG5cdFx0cmV0dXJuICdmZXRjaCdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1vemNodW5rZWRhcnJheWJ1ZmZlcikge1xuXHRcdHJldHVybiAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tc3N0cmVhbSkge1xuXHRcdHJldHVybiAnbXMtc3RyZWFtJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkuYXJyYXlidWZmZXIgJiYgcHJlZmVyQmluYXJ5KSB7XG5cdFx0cmV0dXJuICdhcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LnZiQXJyYXkgJiYgcHJlZmVyQmluYXJ5KSB7XG5cdFx0cmV0dXJuICd0ZXh0OnZiYXJyYXknXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICd0ZXh0J1xuXHR9XG59XG5cbnZhciBDbGllbnRSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9vcHRzID0gb3B0c1xuXHRzZWxmLl9ib2R5ID0gW11cblx0c2VsZi5faGVhZGVycyA9IHt9XG5cdGlmIChvcHRzLmF1dGgpXG5cdFx0c2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIG5ldyBCdWZmZXIob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0JykpXG5cdE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdHNlbGYuc2V0SGVhZGVyKG5hbWUsIG9wdHMuaGVhZGVyc1tuYW1lXSlcblx0fSlcblxuXHR2YXIgcHJlZmVyQmluYXJ5XG5cdGlmIChvcHRzLm1vZGUgPT09ICdwcmVmZXItc3RyZWFtaW5nJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBhIGhpZ2ggcHJpb3JpdHkgYnV0IGJpbmFyeSBjb21wYXRpYmlsaXR5IGFuZFxuXHRcdC8vIHRoZSBhY2N1cmFjeSBvZiB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyIGFyZW4ndFxuXHRcdHByZWZlckJpbmFyeSA9IGZhbHNlXG5cdH0gZWxzZSBpZiAob3B0cy5tb2RlID09PSAnYWxsb3ctd3JvbmctY29udGVudC10eXBlJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIHByZXNlcnZpbmcgdGhlICdjb250ZW50LXR5cGUnIGhlYWRlclxuXHRcdHByZWZlckJpbmFyeSA9ICFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGVcblx0fSBlbHNlIGlmICghb3B0cy5tb2RlIHx8IG9wdHMubW9kZSA9PT0gJ2RlZmF1bHQnIHx8IG9wdHMubW9kZSA9PT0gJ3ByZWZlci1mYXN0Jykge1xuXHRcdC8vIFVzZSBiaW5hcnkgaWYgdGV4dCBzdHJlYW1pbmcgbWF5IGNvcnJ1cHQgZGF0YSBvciB0aGUgY29udGVudC10eXBlIGhlYWRlciwgb3IgZm9yIHNwZWVkXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igb3B0cy5tb2RlJylcblx0fVxuXHRzZWxmLl9tb2RlID0gZGVjaWRlTW9kZShwcmVmZXJCaW5hcnkpXG5cblx0c2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuX29uRmluaXNoKClcblx0fSlcbn1cblxuaW5oZXJpdHMoQ2xpZW50UmVxdWVzdCwgc3RyZWFtLldyaXRhYmxlKVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHZhciBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblx0Ly8gVGhpcyBjaGVjayBpcyBub3QgbmVjZXNzYXJ5LCBidXQgaXQgcHJldmVudHMgd2FybmluZ3MgZnJvbSBicm93c2VycyBhYm91dCBzZXR0aW5nIHVuc2FmZVxuXHQvLyBoZWFkZXJzLiBUbyBiZSBob25lc3QgSSdtIG5vdCBlbnRpcmVseSBzdXJlIGhpZGluZyB0aGVzZSB3YXJuaW5ncyBpcyBhIGdvb2QgdGhpbmcsIGJ1dFxuXHQvLyBodHRwLWJyb3dzZXJpZnkgZGlkIGl0LCBzbyBJIHdpbGwgdG9vLlxuXHRpZiAodW5zYWZlSGVhZGVycy5pbmRleE9mKGxvd2VyTmFtZSkgIT09IC0xKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX2hlYWRlcnNbbG93ZXJOYW1lXSA9IHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRyZXR1cm4gc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldLnZhbHVlXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblx0dmFyIG9wdHMgPSBzZWxmLl9vcHRzXG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5XG5cdGlmIChvcHRzLm1ldGhvZCA9PT0gJ1BPU1QnIHx8IG9wdHMubWV0aG9kID09PSAnUFVUJyB8fCBvcHRzLm1ldGhvZCA9PT0gJ1BBVENIJykge1xuXHRcdGlmIChjYXBhYmlsaXR5LmJsb2JDb25zdHJ1Y3Rvcikge1xuXHRcdFx0Ym9keSA9IG5ldyBnbG9iYWwuQmxvYihzZWxmLl9ib2R5Lm1hcChmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRcdHJldHVybiB0b0FycmF5QnVmZmVyKGJ1ZmZlcilcblx0XHRcdH0pLCB7XG5cdFx0XHRcdHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJydcblx0XHRcdH0pXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGdldCB1dGY4IHN0cmluZ1xuXHRcdFx0Ym9keSA9IEJ1ZmZlci5jb25jYXQoc2VsZi5fYm9keSkudG9TdHJpbmcoKVxuXHRcdH1cblx0fVxuXG5cdGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0dmFyIGhlYWRlcnMgPSBPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBbaGVhZGVyc09ialtuYW1lXS5uYW1lLCBoZWFkZXJzT2JqW25hbWVdLnZhbHVlXVxuXHRcdH0pXG5cblx0XHRnbG9iYWwuZmV0Y2goc2VsZi5fb3B0cy51cmwsIHtcblx0XHRcdG1ldGhvZDogc2VsZi5fb3B0cy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0Ym9keTogYm9keSxcblx0XHRcdG1vZGU6ICdjb3JzJyxcblx0XHRcdGNyZWRlbnRpYWxzOiBvcHRzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbidcblx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgcmVhc29uKVxuXHRcdH0pXG5cdH0gZWxzZSB7XG5cdFx0dmFyIHhociA9IHNlbGYuX3hociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbihzZWxmLl9vcHRzLm1ldGhvZCwgc2VsZi5fb3B0cy51cmwsIHRydWUpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBDYW4ndCBzZXQgcmVzcG9uc2VUeXBlIG9uIHJlYWxseSBvbGQgYnJvd3NlcnNcblx0XHRpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHNlbGYuX21vZGUuc3BsaXQoJzonKVswXVxuXG5cdFx0aWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocilcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzXG5cblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ3RleHQnICYmICdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpXG5cblx0XHRPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJzT2JqW25hbWVdLm5hbWUsIGhlYWRlcnNPYmpbbmFtZV0udmFsdWUpXG5cdFx0fSlcblxuXHRcdHNlbGYuX3Jlc3BvbnNlID0gbnVsbFxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5MT0FESU5HOlxuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuRE9ORTpcblx0XHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkXG5cdFx0Ly8gaW4gb25wcm9ncmVzcywgbm90IGluIG9ucmVhZHlzdGF0ZWNoYW5nZSB3aXRoIHhoci5yZWFkeVN0YXRlID0gM1xuXHRcdGlmIChzZWxmLl9tb2RlID09PSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKSB7XG5cdFx0XHR4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1hIUiBlcnJvcicpKVxuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR4aHIuc2VuZChib2R5KVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHhoci5zdGF0dXMgaXMgcmVhZGFibGUgYW5kIG5vbi16ZXJvLCBpbmRpY2F0aW5nIG5vIGVycm9yLlxuICogRXZlbiB0aG91Z2ggdGhlIHNwZWMgc2F5cyBpdCBzaG91bGQgYmUgYXZhaWxhYmxlIGluIHJlYWR5U3RhdGUgMyxcbiAqIGFjY2Vzc2luZyBpdCB0aHJvd3MgYW4gZXhjZXB0aW9uIGluIElFOFxuICovXG5mdW5jdGlvbiBzdGF0dXNWYWxpZCAoeGhyKSB7XG5cdHRyeSB7XG5cdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXNcblx0XHRyZXR1cm4gKHN0YXR1cyAhPT0gbnVsbCAmJiBzdGF0dXMgIT09IDApXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKCFzdGF0dXNWYWxpZChzZWxmLl94aHIpIHx8IHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRpZiAoIXNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX2Nvbm5lY3QoKVxuXG5cdHNlbGYuX3Jlc3BvbnNlLl9vblhIUlByb2dyZXNzKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5fcmVzcG9uc2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKHNlbGYuX3hociwgc2VsZi5fZmV0Y2hSZXNwb25zZSwgc2VsZi5fbW9kZSlcblx0c2VsZi5lbWl0KCdyZXNwb25zZScsIHNlbGYuX3Jlc3BvbnNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9ib2R5LnB1c2goY2h1bmspXG5cdGNiKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fcmVzcG9uc2UuX2Rlc3Ryb3llZCA9IHRydWVcblx0aWYgKHNlbGYuX3hocilcblx0XHRzZWxmLl94aHIuYWJvcnQoKVxuXHQvLyBDdXJyZW50bHksIHRoZXJlIGlzbid0IGEgd2F5IHRvIHRydWx5IGFib3J0IGEgZmV0Y2guXG5cdC8vIElmIHlvdSBsaWtlIGJpa2VzaGVkZGluZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzI3XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNiID0gZGF0YVxuXHRcdGRhdGEgPSB1bmRlZmluZWRcblx0fVxuXG5cdHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwoc2VsZiwgZGF0YSwgZW5jb2RpbmcsIGNiKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5mbHVzaEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXROb0RlbGF5ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFNvY2tldEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1zZXRyZXF1ZXN0aGVhZGVyJTI4JTI5LW1ldGhvZFxudmFyIHVuc2FmZUhlYWRlcnMgPSBbXG5cdCdhY2NlcHQtY2hhcnNldCcsXG5cdCdhY2NlcHQtZW5jb2RpbmcnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJyxcblx0J2Nvbm5lY3Rpb24nLFxuXHQnY29udGVudC1sZW5ndGgnLFxuXHQnY29va2llJyxcblx0J2Nvb2tpZTInLFxuXHQnZGF0ZScsXG5cdCdkbnQnLFxuXHQnZXhwZWN0Jyxcblx0J2hvc3QnLFxuXHQna2VlcC1hbGl2ZScsXG5cdCdvcmlnaW4nLFxuXHQncmVmZXJlcicsXG5cdCd0ZScsXG5cdCd0cmFpbGVyJyxcblx0J3RyYW5zZmVyLWVuY29kaW5nJyxcblx0J3VwZ3JhZGUnLFxuXHQndXNlci1hZ2VudCcsXG5cdCd2aWEnXG5dXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxudmFyIHJTdGF0ZXMgPSBleHBvcnRzLnJlYWR5U3RhdGVzID0ge1xuXHRVTlNFTlQ6IDAsXG5cdE9QRU5FRDogMSxcblx0SEVBREVSU19SRUNFSVZFRDogMixcblx0TE9BRElORzogMyxcblx0RE9ORTogNFxufVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gZXhwb3J0cy5JbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbiAoeGhyLCByZXNwb25zZSwgbW9kZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLlJlYWRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9tb2RlID0gbW9kZVxuXHRzZWxmLmhlYWRlcnMgPSB7fVxuXHRzZWxmLnJhd0hlYWRlcnMgPSBbXVxuXHRzZWxmLnRyYWlsZXJzID0ge31cblx0c2VsZi5yYXdUcmFpbGVycyA9IFtdXG5cblx0Ly8gRmFrZSB0aGUgJ2Nsb3NlJyBldmVudCwgYnV0IG9ubHkgb25jZSAnZW5kJyBmaXJlc1xuXHRzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlIG5leHRUaWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSAncmVxdWVzdCcgbW9kdWxlIGZyb20gY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wXG5cdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Nsb3NlJylcblx0XHR9KVxuXHR9KVxuXG5cdGlmIChtb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cblx0XHRzZWxmLnVybCA9IHJlc3BvbnNlLnVybFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSB2ZXJzaW9uIG9mIGZvciAoPGl0ZW0+IG9mIDxpdGVyYWJsZT4pOlxuXHRcdC8vIGZvciAodmFyIDxpdGVtPixfaSxfaXQgPSA8aXRlcmFibGU+W1N5bWJvbC5pdGVyYXRvcl0oKTsgPGl0ZW0+ID0gKF9pID0gX2l0Lm5leHQoKSkudmFsdWUsIV9pLmRvbmU7KVxuXHRcdGZvciAodmFyIGhlYWRlciwgX2ksIF9pdCA9IHJlc3BvbnNlLmhlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXSgpOyBoZWFkZXIgPSAoX2kgPSBfaXQubmV4dCgpKS52YWx1ZSwgIV9pLmRvbmU7KSB7XG5cdFx0XHRzZWxmLmhlYWRlcnNbaGVhZGVyWzBdLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyWzFdXG5cdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChoZWFkZXJbMF0sIGhlYWRlclsxXSlcblx0XHR9XG5cblx0XHQvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgcmVzcGVjdCBiYWNrcHJlc3N1cmUuIE9uY2UgV3JpdGFibGVTdHJlYW0gaXMgYXZhaWxhYmxlLCB0aGlzIGNhbiBiZSBmaXhlZFxuXHRcdHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpXG5cdFx0ZnVuY3Rpb24gcmVhZCAoKSB7XG5cdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihyZXN1bHQudmFsdWUpKVxuXHRcdFx0XHRyZWFkKClcblx0XHRcdH0pXG5cdFx0fVxuXHRcdHJlYWQoKVxuXG5cdH0gZWxzZSB7XG5cdFx0c2VsZi5feGhyID0geGhyXG5cdFx0c2VsZi5fcG9zID0gMFxuXG5cdFx0c2VsZi51cmwgPSB4aHIucmVzcG9uc2VVUkxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1c1RleHRcblx0XHR2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pXG5cdFx0aGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pXG5cdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHR2YXIga2V5ID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuXHRcdFx0XHRcdGlmIChzZWxmLmhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IFtdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldLnB1c2gobWF0Y2hlc1syXSlcblx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLmhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIG1hdGNoZXNbMl1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IG1hdGNoZXNbMl1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChtYXRjaGVzWzFdLCBtYXRjaGVzWzJdKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRzZWxmLl9jaGFyc2V0ID0gJ3gtdXNlci1kZWZpbmVkJ1xuXHRcdGlmICghY2FwYWJpbGl0eS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHR2YXIgbWltZVR5cGUgPSBzZWxmLnJhd0hlYWRlcnNbJ21pbWUtdHlwZSddXG5cdFx0XHRpZiAobWltZVR5cGUpIHtcblx0XHRcdFx0dmFyIGNoYXJzZXRNYXRjaCA9IG1pbWVUeXBlLm1hdGNoKC87XFxzKmNoYXJzZXQ9KFteO10pKDt8JCkvKVxuXHRcdFx0XHRpZiAoY2hhcnNldE1hdGNoKSB7XG5cdFx0XHRcdFx0c2VsZi5fY2hhcnNldCA9IGNoYXJzZXRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghc2VsZi5fY2hhcnNldClcblx0XHRcdFx0c2VsZi5fY2hhcnNldCA9ICd1dGYtOCcgLy8gYmVzdCBndWVzc1xuXHRcdH1cblx0fVxufVxuXG5pbmhlcml0cyhJbmNvbWluZ01lc3NhZ2UsIHN0cmVhbS5SZWFkYWJsZSlcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciB4aHIgPSBzZWxmLl94aHJcblxuXHR2YXIgcmVzcG9uc2UgPSBudWxsXG5cdHN3aXRjaCAoc2VsZi5fbW9kZSkge1xuXHRcdGNhc2UgJ3RleHQ6dmJhcnJheSc6IC8vIEZvciBJRTlcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5ET05FKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gVGhpcyBmYWlscyBpbiBJRThcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgZ2xvYmFsLlZCQXJyYXkoeGhyLnJlc3BvbnNlQm9keSkudG9BcnJheSgpXG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0aWYgKHJlc3BvbnNlICE9PSBudWxsKSB7XG5cdFx0XHRcdHNlbGYucHVzaChuZXcgQnVmZmVyKHJlc3BvbnNlKSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdC8vIEZhbGxzIHRocm91Z2ggaW4gSUU4XHRcblx0XHRjYXNlICd0ZXh0Jzpcblx0XHRcdHRyeSB7IC8vIFRoaXMgd2lsbCBmYWlsIHdoZW4gcmVhZHlTdGF0ZSA9IDMgaW4gSUU5LiBTd2l0Y2ggbW9kZSBhbmQgd2FpdCBmb3IgcmVhZHlTdGF0ZSA9IDRcblx0XHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHNlbGYuX21vZGUgPSAndGV4dDp2YmFycmF5J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlc3BvbnNlLmxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHR2YXIgbmV3RGF0YSA9IHJlc3BvbnNlLnN1YnN0cihzZWxmLl9wb3MpXG5cdFx0XHRcdGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobmV3RGF0YS5sZW5ndGgpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0YnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZlxuXG5cdFx0XHRcdFx0c2VsZi5wdXNoKGJ1ZmZlcilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3RGF0YSwgc2VsZi5fY2hhcnNldClcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9wb3MgPSByZXNwb25zZS5sZW5ndGhcblx0XHRcdH1cblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInOiAvLyB0YWtlIHdob2xlXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbXMtc3RyZWFtJzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcblx0XHRcdFx0YnJlYWtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgZ2xvYmFsLk1TU3RyZWFtUmVhZGVyKClcblx0XHRcdHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdC5zbGljZShzZWxmLl9wb3MpKSkpXG5cdFx0XHRcdFx0c2VsZi5fcG9zID0gcmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVhZGVyLm9uZXJyb3IgPSA/Pz8gLy8gVE9ETzogdGhpc1xuXHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHJlc3BvbnNlKVxuXHRcdFx0YnJlYWtcblx0fVxuXG5cdC8vIFRoZSBtcy1zdHJlYW0gY2FzZSBoYW5kbGVzIGVuZCBzZXBhcmF0ZWx5IGluIHJlYWRlci5vbmxvYWQoKVxuXHRpZiAoc2VsZi5feGhyLnJlYWR5U3RhdGUgPT09IHJTdGF0ZXMuRE9ORSAmJiBzZWxmLl9tb2RlICE9PSAnbXMtc3RyZWFtJykge1xuXHRcdHNlbGYucHVzaChudWxsKVxuXHR9XG59XG4iLCIvKiBnbG9iYWwgVVJMICovXG5cbnZhciBnZXRCbG9iID0gcmVxdWlyZSgnc3RyZWFtLXRvLWJsb2InKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJsb2JVUkwgKHN0cmVhbSwgbWltZVR5cGUsIGNiKSB7XG4gIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdmdW5jdGlvbicpIHJldHVybiBnZXRCbG9iVVJMKHN0cmVhbSwgbnVsbCwgbWltZVR5cGUpXG4gIGdldEJsb2Ioc3RyZWFtLCBtaW1lVHlwZSwgZnVuY3Rpb24gKGVyciwgYmxvYikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICBjYihudWxsLCB1cmwpXG4gIH0pXG59XG4iLCIvKiBnbG9iYWwgQmxvYiAqL1xuXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJsb2IgKHN0cmVhbSwgbWltZVR5cGUsIGNiKSB7XG4gIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdmdW5jdGlvbicpIHJldHVybiBnZXRCbG9iKHN0cmVhbSwgbnVsbCwgbWltZVR5cGUpXG4gIGNiID0gb25jZShjYilcbiAgdmFyIGNodW5rcyA9IFtdXG4gIHN0cmVhbVxuICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgfSlcbiAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBibG9iID0gbWltZVR5cGVcbiAgICAgICAgPyBuZXcgQmxvYihjaHVua3MsIHsgdHlwZTogbWltZVR5cGUgfSlcbiAgICAgICAgOiBuZXcgQmxvYihjaHVua3MpXG4gICAgICBjYihudWxsLCBibG9iKVxuICAgIH0pXG4gICAgLm9uKCdlcnJvcicsIGNiKVxufVxuIiwidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCdWZmZXIgKHN0cmVhbSwgbGVuZ3RoLCBjYikge1xuICBjYiA9IG9uY2UoY2IpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIG9mZnNldCA9IDBcbiAgc3RyZWFtXG4gICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBjaHVuay5jb3B5KGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aFxuICAgIH0pXG4gICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7IGNiKG51bGwsIGJ1ZikgfSlcbiAgICAub24oJ2Vycm9yJywgY2IpXG59XG4iLCJ2YXIgYWRkclRvSVBQb3J0ID0gcmVxdWlyZSgnYWRkci10by1pcC1wb3J0JylcbnZhciBpcGFkZHIgPSByZXF1aXJlKCdpcGFkZHIuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhZGRycykge1xuICBpZiAodHlwZW9mIGFkZHJzID09PSAnc3RyaW5nJykge1xuICAgIGFkZHJzID0gWyBhZGRycyBdXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChhZGRycy5tYXAoZnVuY3Rpb24gKGFkZHIpIHtcbiAgICB2YXIgcyA9IGFkZHJUb0lQUG9ydChhZGRyKVxuICAgIGlmIChzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHJlc3MgZm9ybWF0LCBleHBlY3Rpbmc6IDEwLjEwLjEwLjU6MTI4JylcbiAgICB9XG5cbiAgICB2YXIgaXAgPSBpcGFkZHIucGFyc2Uoc1swXSlcbiAgICB2YXIgaXBCdWYgPSBuZXcgQnVmZmVyKGlwLnRvQnl0ZUFycmF5KCkpXG4gICAgdmFyIHBvcnQgPSBOdW1iZXIoc1sxXSlcbiAgICB2YXIgcG9ydEJ1ZiA9IG5ldyBCdWZmZXIoMilcbiAgICBwb3J0QnVmLndyaXRlVUludDE2QkUocG9ydCwgMClcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbaXBCdWYsIHBvcnRCdWZdKVxuICB9KSlcbn1cblxuLyoqXG4gKiBBbHNvIHN1cHBvcnQgdGhpcyB1c2FnZTpcbiAqICAgc3RyaW5nMmNvbXBhY3QubXVsdGkoWyAnMTAuMTAuMTAuNToxMjgnLCAnMTAwLjU2LjU4Ljk5OjI4NTI1JyBdKVxuICpcbiAqIGZvciBwYXJhbGxlbGlzbSB3aXRoIHRoZSBgY29tcGFjdDJzdHJpbmdgIG1vZHVsZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMubXVsdGkgPSBtb2R1bGUuZXhwb3J0c1xubW9kdWxlLmV4cG9ydHMubXVsdGk2ID0gbW9kdWxlLmV4cG9ydHNcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbkNvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWxcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiAgICAgIFxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBcblRIRSBTT0ZUV0FSRS5cbiovXG5cbnZhciBiYXNlMzIgPSByZXF1aXJlKCcuL3RoaXJ0eS10d28nKTtcblxuZXhwb3J0cy5lbmNvZGUgPSBiYXNlMzIuZW5jb2RlO1xuZXhwb3J0cy5kZWNvZGUgPSBiYXNlMzIuZGVjb2RlO1xuIiwiLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbkNvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWxcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiovXG5cbnZhciBjaGFyVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCI7XG52YXIgYnl0ZVRhYmxlID0gW1xuICAgIDB4ZmYsIDB4ZmYsIDB4MWEsIDB4MWIsIDB4MWMsIDB4MWQsIDB4MWUsIDB4MWYsXG4gICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgICAweGZmLCAweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDA0LCAweDA1LCAweDA2LFxuICAgIDB4MDcsIDB4MDgsIDB4MDksIDB4MGEsIDB4MGIsIDB4MGMsIDB4MGQsIDB4MGUsXG4gICAgMHgwZiwgMHgxMCwgMHgxMSwgMHgxMiwgMHgxMywgMHgxNCwgMHgxNSwgMHgxNixcbiAgICAweDE3LCAweDE4LCAweDE5LCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAgIDB4ZmYsIDB4MDAsIDB4MDEsIDB4MDIsIDB4MDMsIDB4MDQsIDB4MDUsIDB4MDYsXG4gICAgMHgwNywgMHgwOCwgMHgwOSwgMHgwYSwgMHgwYiwgMHgwYywgMHgwZCwgMHgwZSxcbiAgICAweDBmLCAweDEwLCAweDExLCAweDEyLCAweDEzLCAweDE0LCAweDE1LCAweDE2LFxuICAgIDB4MTcsIDB4MTgsIDB4MTksIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZcbl07XG5cbmZ1bmN0aW9uIHF1aW50ZXRDb3VudChidWZmKSB7XG4gICAgdmFyIHF1aW50ZXRzID0gTWF0aC5mbG9vcihidWZmLmxlbmd0aCAvIDUpO1xuICAgIHJldHVybiBidWZmLmxlbmd0aCAlIDUgPT0gMCA/IHF1aW50ZXRzOiBxdWludGV0cyArIDE7XG59XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24ocGxhaW4pIHtcbiAgICBpZighQnVmZmVyLmlzQnVmZmVyKHBsYWluKSl7XG4gICAgXHRwbGFpbiA9IG5ldyBCdWZmZXIocGxhaW4pO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBzaGlmdEluZGV4ID0gMDtcbiAgICB2YXIgZGlnaXQgPSAwO1xuICAgIHZhciBlbmNvZGVkID0gbmV3IEJ1ZmZlcihxdWludGV0Q291bnQocGxhaW4pICogOCk7XG5cbiAgICAvKiBieXRlIGJ5IGJ5dGUgaXNuJ3QgYXMgcHJldHR5IGFzIHF1aW50ZXQgYnkgcXVpbnRldCBidXQgdGVzdHMgYSBiaXRcbiAgICAgICAgZmFzdGVyLiB3aWxsIGhhdmUgdG8gcmV2aXNpdC4gKi9cbiAgICB3aGlsZShpIDwgcGxhaW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcGxhaW5baV07XG4gICAgXG4gICAgICAgIGlmKHNoaWZ0SW5kZXggPiAzKSB7XG4gICAgICAgICAgICBkaWdpdCA9IGN1cnJlbnQgJiAoMHhmZiA+PiBzaGlmdEluZGV4KTtcbiAgICAgICAgICAgIHNoaWZ0SW5kZXggPSAoc2hpZnRJbmRleCArIDUpICUgODtcbiAgICAgICAgICAgIGRpZ2l0ID0gKGRpZ2l0IDw8IHNoaWZ0SW5kZXgpIHwgKChpICsgMSA8IHBsYWluLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgIHBsYWluW2kgKyAxXSA6IDApID4+ICg4IC0gc2hpZnRJbmRleCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWdpdCA9IChjdXJyZW50ID4+ICg4IC0gKHNoaWZ0SW5kZXggKyA1KSkpICYgMHgxZjtcbiAgICAgICAgICAgIHNoaWZ0SW5kZXggPSAoc2hpZnRJbmRleCArIDUpICUgODsgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHNoaWZ0SW5kZXggPT0gMCkgaSsrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBlbmNvZGVkW2pdID0gY2hhclRhYmxlLmNoYXJDb2RlQXQoZGlnaXQpO1xuICAgICAgICBqKys7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBqOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKylcbiAgICAgICAgZW5jb2RlZFtpXSA9IDB4M2Q7IC8vJz0nLmNoYXJDb2RlQXQoMClcbiAgICAgICAgXG4gICAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICB2YXIgc2hpZnRJbmRleCA9IDA7XG4gICAgdmFyIHBsYWluRGlnaXQgPSAwO1xuICAgIHZhciBwbGFpbkNoYXI7XG4gICAgdmFyIHBsYWluUG9zID0gMDtcbiAgICBpZighQnVmZmVyLmlzQnVmZmVyKGVuY29kZWQpKXtcbiAgICBcdGVuY29kZWQgPSBuZXcgQnVmZmVyKGVuY29kZWQpO1xuICAgIH1cbiAgICB2YXIgZGVjb2RlZCA9IG5ldyBCdWZmZXIoTWF0aC5jZWlsKGVuY29kZWQubGVuZ3RoICogNSAvIDgpKTtcbiAgICBcbiAgICAvKiBieXRlIGJ5IGJ5dGUgaXNuJ3QgYXMgcHJldHR5IGFzIG9jdGV0IGJ5IG9jdGV0IGJ1dCB0ZXN0cyBhIGJpdFxuICAgICAgICBmYXN0ZXIuIHdpbGwgaGF2ZSB0byByZXZpc2l0LiAqLyAgICBcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgIFx0aWYoZW5jb2RlZFtpXSA9PSAweDNkKXsgLy8nPSdcbiAgICBcdFx0YnJlYWs7XG4gICAgXHR9XG4gICAgXHRcdFxuICAgICAgICB2YXIgZW5jb2RlZEJ5dGUgPSBlbmNvZGVkW2ldIC0gMHgzMDtcbiAgICAgICAgXG4gICAgICAgIGlmKGVuY29kZWRCeXRlIDwgYnl0ZVRhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgcGxhaW5EaWdpdCA9IGJ5dGVUYWJsZVtlbmNvZGVkQnl0ZV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHNoaWZ0SW5kZXggPD0gMykge1xuICAgICAgICAgICAgICAgIHNoaWZ0SW5kZXggPSAoc2hpZnRJbmRleCArIDUpICUgODtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihzaGlmdEluZGV4ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhaW5DaGFyIHw9IHBsYWluRGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWRbcGxhaW5Qb3NdID0gcGxhaW5DaGFyO1xuICAgICAgICAgICAgICAgICAgICBwbGFpblBvcysrO1xuICAgICAgICAgICAgICAgICAgICBwbGFpbkNoYXIgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYWluQ2hhciB8PSAweGZmICYgKHBsYWluRGlnaXQgPDwgKDggLSBzaGlmdEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGlmdEluZGV4ID0gKHNoaWZ0SW5kZXggKyA1KSAlIDg7XG4gICAgICAgICAgICAgICAgcGxhaW5DaGFyIHw9IDB4ZmYgJiAocGxhaW5EaWdpdCA+Pj4gc2hpZnRJbmRleCk7XG4gICAgICAgICAgICAgICAgZGVjb2RlZFtwbGFpblBvc10gPSBwbGFpbkNoYXI7XG4gICAgICAgICAgICAgICAgcGxhaW5Qb3MrKztcblxuICAgICAgICAgICAgICAgIHBsYWluQ2hhciA9IDB4ZmYgJiAocGxhaW5EaWdpdCA8PCAoOCAtIHNoaWZ0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgXHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgLSBpdCBpcyBub3QgYmFzZTMyIGVuY29kZWQgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuc2xpY2UoMCwgcGxhaW5Qb3MpO1xufTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYnVmKSB7XG5cdC8vIElmIHRoZSBidWZmZXIgaXMgYmFja2VkIGJ5IGEgVWludDhBcnJheSwgYSBmYXN0ZXIgdmVyc2lvbiB3aWxsIHdvcmtcblx0aWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHQvLyBJZiB0aGUgYnVmZmVyIGlzbid0IGEgc3ViYXJyYXksIHJldHVybiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuXHRcdGlmIChidWYuYnl0ZU9mZnNldCA9PT0gMCAmJiBidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGJ1Zi5idWZmZXIuc2xpY2UgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGdldCBhIHByb3BlciBjb3B5XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aClcblx0XHR9XG5cdH1cblxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcblx0XHQvLyBUaGlzIGlzIHRoZSBzbG93IHZlcnNpb24gdGhhdCB3aWxsIHdvcmsgd2l0aCBhbnkgQnVmZmVyXG5cdFx0Ly8gaW1wbGVtZW50YXRpb24gKGV2ZW4gaW4gb2xkIGJyb3dzZXJzKVxuXHRcdHZhciBhcnJheUNvcHkgPSBuZXcgVWludDhBcnJheShidWYubGVuZ3RoKVxuXHRcdHZhciBsZW4gPSBidWYubGVuZ3RoXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJyYXlDb3B5W2ldID0gYnVmW2ldXG5cdFx0fVxuXHRcdHJldHVybiBhcnJheUNvcHkuYnVmZmVyXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcblx0fVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBEaXNjb3ZlcnlcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgndG9ycmVudC1kaXNjb3ZlcnknKVxudmFyIERIVCA9IHJlcXVpcmUoJ2JpdHRvcnJlbnQtZGh0L2NsaWVudCcpIC8vIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcbnZhciBUcmFja2VyID0gcmVxdWlyZSgnYml0dG9ycmVudC10cmFja2VyL2NsaWVudCcpXG5cbmluaGVyaXRzKERpc2NvdmVyeSwgRXZlbnRFbWl0dGVyKVxuXG5mdW5jdGlvbiBEaXNjb3ZlcnkgKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBEaXNjb3ZlcnkpKSByZXR1cm4gbmV3IERpc2NvdmVyeShvcHRzKVxuICBFdmVudEVtaXR0ZXIuY2FsbChzZWxmKVxuXG4gIGlmICghb3B0cy5wZWVySWQpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBwZWVySWRgIGlzIHJlcXVpcmVkJylcbiAgaWYgKCFvcHRzLmluZm9IYXNoKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgaW5mb0hhc2hgIGlzIHJlcXVpcmVkJylcbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgIW9wdHMucG9ydCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYHBvcnRgIGlzIHJlcXVpcmVkJylcblxuICBzZWxmLnBlZXJJZCA9IHR5cGVvZiBvcHRzLnBlZXJJZCA9PT0gJ3N0cmluZydcbiAgICA/IG9wdHMucGVlcklkXG4gICAgOiBvcHRzLnBlZXJJZC50b1N0cmluZygnaGV4JylcbiAgc2VsZi5pbmZvSGFzaCA9IHR5cGVvZiBvcHRzLmluZm9IYXNoID09PSAnc3RyaW5nJ1xuICAgID8gb3B0cy5pbmZvSGFzaFxuICAgIDogb3B0cy5pbmZvSGFzaC50b1N0cmluZygnaGV4JylcbiAgc2VsZi5fcG9ydCA9IG9wdHMucG9ydCAvLyB0b3JyZW50IHBvcnRcblxuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgc2VsZi5fYW5ub3VuY2UgPSBvcHRzLmFubm91bmNlIHx8IFtdXG4gIHNlbGYuX2ludGVydmFsTXMgPSBvcHRzLmludGVydmFsTXMgfHwgKDE1ICogNjAgKiAxMDAwKVxuICBzZWxmLl90cmFja2VyT3B0cyA9IG51bGxcbiAgc2VsZi5fZGh0QW5ub3VuY2luZyA9IGZhbHNlXG4gIHNlbGYuX2RodFRpbWVvdXQgPSBmYWxzZVxuICBzZWxmLl9pbnRlcm5hbERIVCA9IGZhbHNlIC8vIGlzIHRoZSBESFQgY3JlYXRlZCBpbnRlcm5hbGx5P1xuXG4gIHNlbGYuX29uV2FybmluZyA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmVtaXQoJ3dhcm5pbmcnLCBlcnIpXG4gIH1cbiAgc2VsZi5fb25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG4gIHNlbGYuX29uREhUUGVlciA9IGZ1bmN0aW9uIChwZWVyLCBpbmZvSGFzaCkge1xuICAgIGlmIChpbmZvSGFzaC50b1N0cmluZygnaGV4JykgIT09IHNlbGYuaW5mb0hhc2gpIHJldHVyblxuICAgIHNlbGYuZW1pdCgncGVlcicsIHBlZXIuaG9zdCArICc6JyArIHBlZXIucG9ydClcbiAgfVxuICBzZWxmLl9vblRyYWNrZXJQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgICBzZWxmLmVtaXQoJ3BlZXInLCBwZWVyKVxuICB9XG4gIHNlbGYuX29uVHJhY2tlckFubm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgndHJhY2tlckFubm91bmNlJylcbiAgfVxuXG4gIGlmIChvcHRzLnRyYWNrZXIgPT09IGZhbHNlKSB7XG4gICAgc2VsZi50cmFja2VyID0gbnVsbFxuICB9IGVsc2UgaWYgKG9wdHMudHJhY2tlciAmJiB0eXBlb2Ygb3B0cy50cmFja2VyID09PSAnb2JqZWN0Jykge1xuICAgIHNlbGYuX3RyYWNrZXJPcHRzID0gZXh0ZW5kKG9wdHMudHJhY2tlcilcbiAgICBzZWxmLnRyYWNrZXIgPSBzZWxmLl9jcmVhdGVUcmFja2VyKClcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnRyYWNrZXIgPSBzZWxmLl9jcmVhdGVUcmFja2VyKClcbiAgfVxuXG4gIGlmIChvcHRzLmRodCA9PT0gZmFsc2UgfHwgdHlwZW9mIERIVCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuZGh0ID0gbnVsbFxuICB9IGVsc2UgaWYgKG9wdHMuZGh0ICYmIHR5cGVvZiBvcHRzLmRodC5hZGROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5kaHQgPSBvcHRzLmRodFxuICB9IGVsc2UgaWYgKG9wdHMuZGh0ICYmIHR5cGVvZiBvcHRzLmRodCA9PT0gJ29iamVjdCcpIHtcbiAgICBzZWxmLmRodCA9IGNyZWF0ZURIVChvcHRzLmRodFBvcnQsIG9wdHMuZGh0KVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZGh0ID0gY3JlYXRlREhUKG9wdHMuZGh0UG9ydClcbiAgfVxuXG4gIGlmIChzZWxmLmRodCkge1xuICAgIHNlbGYuZGh0Lm9uKCdwZWVyJywgc2VsZi5fb25ESFRQZWVyKVxuICAgIHNlbGYuX2RodEFubm91bmNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURIVCAocG9ydCwgb3B0cykge1xuICAgIHZhciBkaHQgPSBuZXcgREhUKG9wdHMpXG4gICAgZGh0Lm9uKCd3YXJuaW5nJywgc2VsZi5fb25XYXJuaW5nKVxuICAgIGRodC5vbignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxuICAgIGRodC5saXN0ZW4ocG9ydClcbiAgICBzZWxmLl9pbnRlcm5hbERIVCA9IHRydWVcbiAgICByZXR1cm4gZGh0XG4gIH1cbn1cblxuRGlzY292ZXJ5LnByb3RvdHlwZS51cGRhdGVQb3J0ID0gZnVuY3Rpb24gKHBvcnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChwb3J0ID09PSBzZWxmLl9wb3J0KSByZXR1cm5cbiAgc2VsZi5fcG9ydCA9IHBvcnRcblxuICBpZiAoc2VsZi5kaHQpIHNlbGYuX2RodEFubm91bmNlKClcblxuICBpZiAoc2VsZi50cmFja2VyKSB7XG4gICAgc2VsZi50cmFja2VyLnN0b3AoKVxuICAgIHNlbGYudHJhY2tlci5kZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYudHJhY2tlciA9IHNlbGYuX2NyZWF0ZVRyYWNrZXIoKVxuICAgIH0pXG4gIH1cbn1cblxuRGlzY292ZXJ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuICBjbGVhclRpbWVvdXQoc2VsZi5fZGh0VGltZW91dClcblxuICB2YXIgdGFza3MgPSBbXVxuXG4gIGlmIChzZWxmLnRyYWNrZXIpIHtcbiAgICBzZWxmLnRyYWNrZXIuc3RvcCgpXG4gICAgc2VsZi50cmFja2VyLnJlbW92ZUxpc3RlbmVyKCd3YXJuaW5nJywgc2VsZi5fb25XYXJuaW5nKVxuICAgIHNlbGYudHJhY2tlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxuICAgIHNlbGYudHJhY2tlci5yZW1vdmVMaXN0ZW5lcigncGVlcicsIHNlbGYuX29uVHJhY2tlclBlZXIpXG4gICAgc2VsZi50cmFja2VyLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBzZWxmLl9vblRyYWNrZXJBbm5vdW5jZSlcbiAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VsZi50cmFja2VyLmRlc3Ryb3koY2IpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzZWxmLmRodCkge1xuICAgIHNlbGYuZGh0LnJlbW92ZUxpc3RlbmVyKCdwZWVyJywgc2VsZi5fb25ESFRQZWVyKVxuICB9XG5cbiAgaWYgKHNlbGYuX2ludGVybmFsREhUKSB7XG4gICAgc2VsZi5kaHQucmVtb3ZlTGlzdGVuZXIoJ3dhcm5pbmcnLCBzZWxmLl9vbldhcm5pbmcpXG4gICAgc2VsZi5kaHQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25FcnJvcilcbiAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VsZi5kaHQuZGVzdHJveShjYilcbiAgICB9KVxuICB9XG5cbiAgcGFyYWxsZWwodGFza3MsIGNiKVxuXG4gIC8vIGNsZWFudXBcbiAgc2VsZi5kaHQgPSBudWxsXG4gIHNlbGYudHJhY2tlciA9IG51bGxcbiAgc2VsZi5fYW5ub3VuY2UgPSBudWxsXG59XG5cbkRpc2NvdmVyeS5wcm90b3R5cGUuX2NyZWF0ZVRyYWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHNlbGYuX3RyYWNrZXJPcHRzLCB7XG4gICAgaW5mb0hhc2g6IHNlbGYuaW5mb0hhc2gsXG4gICAgYW5ub3VuY2U6IHNlbGYuX2Fubm91bmNlLFxuICAgIHBlZXJJZDogc2VsZi5wZWVySWQsXG4gICAgcG9ydDogc2VsZi5fcG9ydFxuICB9KVxuXG4gIHZhciB0cmFja2VyID0gbmV3IFRyYWNrZXIob3B0cylcbiAgdHJhY2tlci5vbignd2FybmluZycsIHNlbGYuX29uV2FybmluZylcbiAgdHJhY2tlci5vbignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxuICB0cmFja2VyLm9uKCdwZWVyJywgc2VsZi5fb25UcmFja2VyUGVlcilcbiAgdHJhY2tlci5vbigndXBkYXRlJywgc2VsZi5fb25UcmFja2VyQW5ub3VuY2UpXG4gIHRyYWNrZXIuc2V0SW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWxNcylcbiAgdHJhY2tlci5zdGFydCgpXG4gIHJldHVybiB0cmFja2VyXG59XG5cbkRpc2NvdmVyeS5wcm90b3R5cGUuX2RodEFubm91bmNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuX2RodEFubm91bmNpbmcpIHJldHVyblxuICBkZWJ1ZygnZGh0IGFubm91bmNlJylcblxuICBzZWxmLl9kaHRBbm5vdW5jaW5nID0gdHJ1ZVxuICBjbGVhclRpbWVvdXQoc2VsZi5fZGh0VGltZW91dClcblxuICBzZWxmLmRodC5hbm5vdW5jZShzZWxmLmluZm9IYXNoLCBzZWxmLl9wb3J0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5fZGh0QW5ub3VuY2luZyA9IGZhbHNlXG4gICAgZGVidWcoJ2RodCBhbm5vdW5jZSBjb21wbGV0ZScpXG5cbiAgICBpZiAoZXJyKSBzZWxmLmVtaXQoJ3dhcm5pbmcnLCBlcnIpXG4gICAgc2VsZi5lbWl0KCdkaHRBbm5vdW5jZScpXG5cbiAgICBpZiAoIXNlbGYuZGVzdHJveWVkKSB7XG4gICAgICBzZWxmLl9kaHRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2RodEFubm91bmNlKClcbiAgICAgIH0sIGdldFJhbmRvbVRpbWVvdXQoKSlcbiAgICAgIGlmIChzZWxmLl9kaHRUaW1lb3V0LnVucmVmKSBzZWxmLl9kaHRUaW1lb3V0LnVucmVmKClcbiAgICB9XG4gIH0pXG5cbiAgLy8gUmV0dXJucyB0aW1lb3V0IGludGVydmFsLCB3aXRoIHNvbWUgcmFuZG9tIGppdHRlclxuICBmdW5jdGlvbiBnZXRSYW5kb21UaW1lb3V0ICgpIHtcbiAgICByZXR1cm4gc2VsZi5faW50ZXJ2YWxNcyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNlbGYuX2ludGVydmFsTXMgLyA1KVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBpZWNlXG5cbnZhciBCTE9DS19MRU5HVEggPSAxIDw8IDE0XG5cbmZ1bmN0aW9uIFBpZWNlIChsZW5ndGgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBpZWNlKSkgcmV0dXJuIG5ldyBQaWVjZShsZW5ndGgpXG5cbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5taXNzaW5nID0gbGVuZ3RoXG4gIHRoaXMuc291cmNlcyA9IG51bGxcblxuICB0aGlzLl9jaHVua3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gQkxPQ0tfTEVOR1RIKVxuICB0aGlzLl9yZW1haW5kZXIgPSAobGVuZ3RoICUgQkxPQ0tfTEVOR1RIKSB8fCBCTE9DS19MRU5HVEhcbiAgdGhpcy5fYnVmZmVyZWQgPSAwXG4gIHRoaXMuX2J1ZmZlciA9IG51bGxcbiAgdGhpcy5fY2FuY2VsbGF0aW9ucyA9IG51bGxcbiAgdGhpcy5fcmVzZXJ2YXRpb25zID0gMFxuICB0aGlzLl9mbHVzaGVkID0gZmFsc2Vcbn1cblxuUGllY2UuQkxPQ0tfTEVOR1RIID0gQkxPQ0tfTEVOR1RIXG5cblBpZWNlLnByb3RvdHlwZS5jaHVua0xlbmd0aCA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiBpID09PSB0aGlzLl9jaHVua3MgLSAxID8gdGhpcy5fcmVtYWluZGVyIDogQkxPQ0tfTEVOR1RIXG59XG5cblBpZWNlLnByb3RvdHlwZS5jaHVua0xlbmd0aFJlbWFpbmluZyA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCAtIChpICogQkxPQ0tfTEVOR1RIKVxufVxuXG5QaWVjZS5wcm90b3R5cGUuY2h1bmtPZmZzZXQgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gaSAqIEJMT0NLX0xFTkdUSFxufVxuXG5QaWVjZS5wcm90b3R5cGUucmVzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmluaXQoKSkgcmV0dXJuIC0xXG4gIGlmICh0aGlzLl9jYW5jZWxsYXRpb25zLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2NhbmNlbGxhdGlvbnMucG9wKClcbiAgaWYgKHRoaXMuX3Jlc2VydmF0aW9ucyA8IHRoaXMuX2NodW5rcykgcmV0dXJuIHRoaXMuX3Jlc2VydmF0aW9ucysrXG4gIHJldHVybiAtMVxufVxuXG5QaWVjZS5wcm90b3R5cGUucmVzZXJ2ZVJlbWFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmluaXQoKSkgcmV0dXJuIC0xXG4gIGlmICh0aGlzLl9yZXNlcnZhdGlvbnMgPCB0aGlzLl9jaHVua3MpIHtcbiAgICB2YXIgbWluID0gdGhpcy5fcmVzZXJ2YXRpb25zXG4gICAgdGhpcy5fcmVzZXJ2YXRpb25zID0gdGhpcy5fY2h1bmtzXG4gICAgcmV0dXJuIG1pblxuICB9XG4gIHJldHVybiAtMVxufVxuXG5QaWVjZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGkpIHtcbiAgaWYgKCF0aGlzLmluaXQoKSkgcmV0dXJuXG4gIHRoaXMuX2NhbmNlbGxhdGlvbnMucHVzaChpKVxufVxuXG5QaWVjZS5wcm90b3R5cGUuY2FuY2VsUmVtYWluaW5nID0gZnVuY3Rpb24gKGkpIHtcbiAgaWYgKCF0aGlzLmluaXQoKSkgcmV0dXJuXG4gIHRoaXMuX3Jlc2VydmF0aW9ucyA9IGlcbn1cblxuUGllY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpKSB7XG4gIGlmICghdGhpcy5pbml0KCkpIHJldHVybiBudWxsXG4gIHJldHVybiB0aGlzLl9idWZmZXJbaV1cbn1cblxuUGllY2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCBkYXRhLCBzb3VyY2UpIHtcbiAgaWYgKCF0aGlzLmluaXQoKSkgcmV0dXJuIGZhbHNlXG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aFxuICB2YXIgYmxvY2tzID0gTWF0aC5jZWlsKGxlbiAvIEJMT0NLX0xFTkdUSClcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBibG9ja3M7IGorKykge1xuICAgIGlmICghdGhpcy5fYnVmZmVyW2kgKyBqXSkge1xuICAgICAgdmFyIG9mZnNldCA9IGogKiBCTE9DS19MRU5HVEhcbiAgICAgIHZhciBzcGxpdERhdGEgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgQkxPQ0tfTEVOR1RIKVxuICAgICAgdGhpcy5fYnVmZmVyZWQrK1xuICAgICAgdGhpcy5fYnVmZmVyW2kgKyBqXSA9IHNwbGl0RGF0YVxuICAgICAgdGhpcy5taXNzaW5nIC09IHNwbGl0RGF0YS5sZW5ndGhcbiAgICAgIGlmICh0aGlzLnNvdXJjZXMuaW5kZXhPZihzb3VyY2UpID09PSAtMSkge1xuICAgICAgICB0aGlzLnNvdXJjZXMucHVzaChzb3VyY2UpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLl9idWZmZXJlZCA9PT0gdGhpcy5fY2h1bmtzXG59XG5cblBpZWNlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9idWZmZXIgfHwgdGhpcy5fY2h1bmtzICE9PSB0aGlzLl9idWZmZXJlZCkgcmV0dXJuIG51bGxcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmZmVyLCB0aGlzLmxlbmd0aClcbiAgdGhpcy5fYnVmZmVyID0gbnVsbFxuICB0aGlzLl9jYW5jZWxsYXRpb25zID0gbnVsbFxuICB0aGlzLnNvdXJjZXMgPSBudWxsXG4gIHRoaXMuX2ZsdXNoZWQgPSB0cnVlXG4gIHJldHVybiBidWZmZXJcbn1cblxuUGllY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9mbHVzaGVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuX2J1ZmZlcikgcmV0dXJuIHRydWVcbiAgdGhpcy5fYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuX2NodW5rcylcbiAgdGhpcy5fY2FuY2VsbGF0aW9ucyA9IFtdXG4gIHRoaXMuc291cmNlcyA9IFtdXG4gIHJldHVybiB0cnVlXG59XG4iLCIvKipcbiAqIENvbnZlcnQgYSB0eXBlZCBhcnJheSB0byBhIEJ1ZmZlciB3aXRob3V0IGEgY29weVxuICpcbiAqIEF1dGhvcjogICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCB0eXBlZGFycmF5LXRvLWJ1ZmZlcmBcbiAqL1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWRhcnJheScpLnN0cmljdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHR5cGVkYXJyYXlUb0J1ZmZlciAoYXJyKSB7XG4gIGlmIChpc1R5cGVkQXJyYXkoYXJyKSkge1xuICAgIC8vIFRvIGF2b2lkIGEgY29weSwgdXNlIHRoZSB0eXBlZCBhcnJheSdzIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIgdG8gYmFjayBuZXcgQnVmZmVyXG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYXJyLmJ1ZmZlcilcbiAgICBpZiAoYXJyLmJ5dGVMZW5ndGggIT09IGFyci5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgLy8gUmVzcGVjdCB0aGUgXCJ2aWV3XCIsIGkuZS4gYnl0ZU9mZnNldCBhbmQgYnl0ZUxlbmd0aCwgd2l0aG91dCBkb2luZyBhIGNvcHlcbiAgICAgIGJ1ZiA9IGJ1Zi5zbGljZShhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVPZmZzZXQgKyBhcnIuYnl0ZUxlbmd0aClcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9IGVsc2Uge1xuICAgIC8vIFBhc3MgdGhyb3VnaCBhbGwgb3RoZXIgdHlwZXMgdG8gdGhlIGBCdWZmZXJgIGNvbnN0cnVjdG9yXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJyKVxuICB9XG59XG4iLCJ2YXIgVUlOVF8zMl9NQVggPSAweGZmZmZmZmZmXG5cbmV4cG9ydHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiA4XG59XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bSwgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKCFidWYpIGJ1ZiA9IG5ldyBCdWZmZXIoOClcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgdG9wID0gTWF0aC5mbG9vcihudW0gLyBVSU5UXzMyX01BWClcbiAgdmFyIHJlbSA9IG51bSAtIHRvcCAqIFVJTlRfMzJfTUFYXG5cbiAgYnVmLndyaXRlVUludDMyQkUodG9wLCBvZmZzZXQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKHJlbSwgb2Zmc2V0ICsgNClcbiAgcmV0dXJuIGJ1ZlxufVxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIGlmICghYnVmKSBidWYgPSBuZXcgQnVmZmVyKDQpXG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIHRvcCA9IGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0KVxuICB2YXIgcmVtID0gYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KVxuXG4gIHJldHVybiB0b3AgKiBVSU5UXzMyX01BWCArIHJlbVxufVxuXG5leHBvcnRzLmVuY29kZS5ieXRlcyA9IDhcbmV4cG9ydHMuZGVjb2RlLmJ5dGVzID0gOFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYj1saXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGNvbXBhcmUoYSwgYikpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZV9lcShsaXN0KSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiID0gbGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSwgYj1hKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGEgIT09IGIpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0LCBjb21wYXJlLCBzb3J0ZWQpIHtcbiAgaWYobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIGlmKGNvbXBhcmUpIHtcbiAgICBpZighc29ydGVkKSB7XG4gICAgICBsaXN0LnNvcnQoY29tcGFyZSlcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpXG4gIH1cbiAgaWYoIXNvcnRlZCkge1xuICAgIGxpc3Quc29ydCgpXG4gIH1cbiAgcmV0dXJuIHVuaXF1ZV9lcShsaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZW1vdmVcblxuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGkpIHtcbiAgaWYgKGkgPj0gYXJyLmxlbmd0aCB8fCBpIDwgMCkgcmV0dXJuXG4gIHZhciBsYXN0ID0gYXJyLnBvcCgpXG4gIGlmIChpIDwgYXJyLmxlbmd0aCkge1xuICAgIHZhciB0bXAgPSBhcnJbaV1cbiAgICBhcnJbaV0gPSBsYXN0XG4gICAgcmV0dXJuIHRtcFxuICB9XG4gIHJldHVybiBsYXN0XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsInZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgQml0RmllbGQgPSByZXF1aXJlKCdiaXRmaWVsZCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3V0X21ldGFkYXRhJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxuXG52YXIgTUFYX01FVEFEQVRBX1NJWkUgPSAxMDAwMDAwMCAvLyAxME1CXG52YXIgQklURklFTERfR1JPVyA9IDEwMDBcbnZhciBQSUVDRV9MRU5HVEggPSAxNiAqIDEwMjRcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgaW5oZXJpdHModXRNZXRhZGF0YSwgRXZlbnRFbWl0dGVyKVxuXG4gIGZ1bmN0aW9uIHV0TWV0YWRhdGEgKHdpcmUpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gICAgdGhpcy5fd2lyZSA9IHdpcmVcblxuICAgIHRoaXMuX21ldGFkYXRhQ29tcGxldGUgPSBmYWxzZVxuICAgIHRoaXMuX21ldGFkYXRhU2l6ZSA9IG51bGxcbiAgICB0aGlzLl9yZW1haW5pbmdSZWplY3RzID0gbnVsbCAvLyBob3cgbWFueSByZWplY3QgbWVzc2FnZXMgdG8gdG9sZXJhdGUgYmVmb3JlIHF1aXR0aW5nXG4gICAgdGhpcy5fZmV0Y2hpbmcgPSBmYWxzZVxuXG4gICAgLy8gVGhlIGxhcmdlc3QgLnRvcnJlbnQgZmlsZSB0aGF0IEkga25vdyBvZiBpcyB+MS0yTUIsIHdoaWNoIGlzIH4xMDAgcGllY2VzLlxuICAgIC8vIFRoZXJlZm9yZSwgY2FwIHRoZSBiaXRmaWVsZCB0byAxMHggdGhhdCAoMTAwMCBwaWVjZXMpIHNvIGEgbWFsaWNpb3VzIHBlZXIgY2FuJ3RcbiAgICAvLyBtYWtlIGl0IGdyb3cgdG8gZmlsbCBhbGwgbWVtb3J5LlxuICAgIHRoaXMuX2JpdGZpZWxkID0gbmV3IEJpdEZpZWxkKDAsIHsgZ3JvdzogQklURklFTERfR1JPVyB9KVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihtZXRhZGF0YSkpIHtcbiAgICAgIHRoaXMuc2V0TWV0YWRhdGEobWV0YWRhdGEpXG4gICAgfVxuICB9XG5cbiAgLy8gTmFtZSBvZiB0aGUgYml0dG9ycmVudC1wcm90b2NvbCBleHRlbnNpb25cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUubmFtZSA9ICd1dF9tZXRhZGF0YSdcblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKSB7XG4gICAgdGhpcy5faW5mb0hhc2ggPSBpbmZvSGFzaFxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUub25FeHRlbmRlZEhhbmRzaGFrZSA9IGZ1bmN0aW9uIChoYW5kc2hha2UpIHtcbiAgICBpZiAoIWhhbmRzaGFrZS5tIHx8ICFoYW5kc2hha2UubS51dF9tZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBkb2VzIG5vdCBzdXBwb3J0IHV0X21ldGFkYXRhJykpXG4gICAgfVxuICAgIGlmICghaGFuZHNoYWtlLm1ldGFkYXRhX3NpemUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BlZXIgZG9lcyBub3QgaGF2ZSBtZXRhZGF0YScpKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGhhbmRzaGFrZS5tZXRhZGF0YV9zaXplICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICBNQVhfTUVUQURBVEFfU0laRSA8IGhhbmRzaGFrZS5tZXRhZGF0YV9zaXplIHx8XG4gICAgICAgIGhhbmRzaGFrZS5tZXRhZGF0YV9zaXplIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BlZXIgZ2F2ZSBpbnZhbGlkIG1ldGFkYXRhIHNpemUnKSlcbiAgICB9XG5cbiAgICB0aGlzLl9tZXRhZGF0YVNpemUgPSBoYW5kc2hha2UubWV0YWRhdGFfc2l6ZVxuICAgIHRoaXMuX251bVBpZWNlcyA9IE1hdGguY2VpbCh0aGlzLl9tZXRhZGF0YVNpemUgLyBQSUVDRV9MRU5HVEgpXG4gICAgdGhpcy5fcmVtYWluaW5nUmVqZWN0cyA9IHRoaXMuX251bVBpZWNlcyAqIDJcblxuICAgIGlmICh0aGlzLl9mZXRjaGluZykge1xuICAgICAgdGhpcy5fcmVxdWVzdFBpZWNlcygpXG4gICAgfVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBkaWN0LCB0cmFpbGVyXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzdHIgPSBidWYudG9TdHJpbmcoKVxuICAgICAgdmFyIHRyYWlsZXJJbmRleCA9IHN0ci5pbmRleE9mKCdlZScpICsgMlxuICAgICAgZGljdCA9IGJlbmNvZGUuZGVjb2RlKHN0ci5zdWJzdHJpbmcoMCwgdHJhaWxlckluZGV4KSlcbiAgICAgIHRyYWlsZXIgPSBidWYuc2xpY2UodHJhaWxlckluZGV4KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZHJvcCBpbnZhbGlkIG1lc3NhZ2VzXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRpY3QubXNnX3R5cGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gdXRfbWV0YWRhdGEgcmVxdWVzdCAoZnJvbSBwZWVyKVxuICAgICAgICAvLyBleGFtcGxlOiB7ICdtc2dfdHlwZSc6IDAsICdwaWVjZSc6IDAgfVxuICAgICAgICB0aGlzLl9vblJlcXVlc3QoZGljdC5waWVjZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gdXRfbWV0YWRhdGEgZGF0YSAoaW4gcmVzcG9uc2UgdG8gb3VyIHJlcXVlc3QpXG4gICAgICAgIC8vIGV4YW1wbGU6IHsgJ21zZ190eXBlJzogMSwgJ3BpZWNlJzogMCwgJ3RvdGFsX3NpemUnOiAzNDI1IH1cbiAgICAgICAgdGhpcy5fb25EYXRhKGRpY3QucGllY2UsIHRyYWlsZXIsIGRpY3QudG90YWxfc2l6ZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdXRfbWV0YWRhdGEgcmVqZWN0IChwZWVyIGRvZXNuJ3QgaGF2ZSBwaWVjZSB3ZSByZXF1ZXN0ZWQpXG4gICAgICAgIC8vIHsgJ21zZ190eXBlJzogMiwgJ3BpZWNlJzogMCB9XG4gICAgICAgIHRoaXMuX29uUmVqZWN0KGRpY3QucGllY2UpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzayB0aGUgcGVlciB0byBzZW5kIG1ldGFkYXRhLlxuICAgKiBAcHVibGljXG4gICAqL1xuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbWV0YWRhdGFDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2ZldGNoaW5nID0gdHJ1ZVxuICAgIGlmICh0aGlzLl9tZXRhZGF0YVNpemUpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RQaWVjZXMoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGFza2luZyB0aGUgcGVlciB0byBzZW5kIG1ldGFkYXRhLlxuICAgKiBAcHVibGljXG4gICAqL1xuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZmV0Y2hpbmcgPSBmYWxzZVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICBpZiAodGhpcy5fbWV0YWRhdGFDb21wbGV0ZSkgcmV0dXJuIHRydWVcbiAgICBkZWJ1Zygnc2V0IG1ldGFkYXRhJylcblxuICAgIC8vIGlmIGZ1bGwgdG9ycmVudCBkaWN0aW9uYXJ5IHdhcyBwYXNzZWQgaW4sIHB1bGwgb3V0IGp1c3QgYGluZm9gIGtleVxuICAgIHRyeSB7XG4gICAgICB2YXIgaW5mbyA9IGJlbmNvZGUuZGVjb2RlKG1ldGFkYXRhKS5pbmZvXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBtZXRhZGF0YSA9IGJlbmNvZGUuZW5jb2RlKGluZm8pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgLy8gY2hlY2sgaGFzaFxuICAgIGlmICh0aGlzLl9pbmZvSGFzaCAmJiB0aGlzLl9pbmZvSGFzaCAhPT0gc2hhMS5zeW5jKG1ldGFkYXRhKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5jYW5jZWwoKVxuXG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhXG4gICAgdGhpcy5fbWV0YWRhdGFDb21wbGV0ZSA9IHRydWVcbiAgICB0aGlzLl9tZXRhZGF0YVNpemUgPSB0aGlzLm1ldGFkYXRhLmxlbmd0aFxuICAgIHRoaXMuX3dpcmUuZXh0ZW5kZWRIYW5kc2hha2UubWV0YWRhdGFfc2l6ZSA9IHRoaXMuX21ldGFkYXRhU2l6ZVxuXG4gICAgdGhpcy5lbWl0KCdtZXRhZGF0YScsIGJlbmNvZGUuZW5jb2RlKHsgaW5mbzogYmVuY29kZS5kZWNvZGUodGhpcy5tZXRhZGF0YSkgfSkpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAoZGljdCwgdHJhaWxlcikge1xuICAgIHZhciBidWYgPSBiZW5jb2RlLmVuY29kZShkaWN0KVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodHJhaWxlcikpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgdHJhaWxlcl0pXG4gICAgfVxuICAgIHRoaXMuX3dpcmUuZXh0ZW5kZWQoJ3V0X21ldGFkYXRhJywgYnVmKVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbiAocGllY2UpIHtcbiAgICB0aGlzLl9zZW5kKHsgbXNnX3R5cGU6IDAsIHBpZWNlOiBwaWVjZSB9KVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX2RhdGEgPSBmdW5jdGlvbiAocGllY2UsIGJ1ZiwgdG90YWxTaXplKSB7XG4gICAgdmFyIG1zZyA9IHsgbXNnX3R5cGU6IDEsIHBpZWNlOiBwaWVjZSB9XG4gICAgaWYgKHR5cGVvZiB0b3RhbFNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICBtc2cudG90YWxfc2l6ZSA9IHRvdGFsU2l6ZVxuICAgIH1cbiAgICB0aGlzLl9zZW5kKG1zZywgYnVmKVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChwaWVjZSkge1xuICAgIHRoaXMuX3NlbmQoeyBtc2dfdHlwZTogMiwgcGllY2U6IHBpZWNlIH0pXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fb25SZXF1ZXN0ID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgaWYgKCF0aGlzLl9tZXRhZGF0YUNvbXBsZXRlKSB7XG4gICAgICB0aGlzLl9yZWplY3QocGllY2UpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gcGllY2UgKiBQSUVDRV9MRU5HVEhcbiAgICB2YXIgZW5kID0gc3RhcnQgKyBQSUVDRV9MRU5HVEhcbiAgICBpZiAoZW5kID4gdGhpcy5fbWV0YWRhdGFTaXplKSB7XG4gICAgICBlbmQgPSB0aGlzLl9tZXRhZGF0YVNpemVcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IHRoaXMubWV0YWRhdGEuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICB0aGlzLl9kYXRhKHBpZWNlLCBidWYsIHRoaXMuX21ldGFkYXRhU2l6ZSlcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9vbkRhdGEgPSBmdW5jdGlvbiAocGllY2UsIGJ1ZiwgdG90YWxTaXplKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPiBQSUVDRV9MRU5HVEgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBidWYuY29weSh0aGlzLm1ldGFkYXRhLCBwaWVjZSAqIFBJRUNFX0xFTkdUSClcbiAgICB0aGlzLl9iaXRmaWVsZC5zZXQocGllY2UpXG4gICAgdGhpcy5fY2hlY2tEb25lKClcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9vblJlamVjdCA9IGZ1bmN0aW9uIChwaWVjZSkge1xuICAgIGlmICh0aGlzLl9yZW1haW5pbmdSZWplY3RzID4gMCAmJiB0aGlzLl9mZXRjaGluZykge1xuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBiZWVuIHJlamVjdGVkIHRvbyBtdWNoLCB0aGVuIHRyeSB0byByZXF1ZXN0IHRoZSBwaWVjZSBhZ2FpblxuICAgICAgdGhpcy5fcmVxdWVzdChwaWVjZSlcbiAgICAgIHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgLT0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BlZXIgc2VudCBcInJlamVjdFwiIHRvbyBtdWNoJykpXG4gICAgfVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX3JlcXVlc3RQaWVjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tZXRhZGF0YSA9IEJ1ZmZlci5hbGxvYyh0aGlzLl9tZXRhZGF0YVNpemUpXG4gICAgZm9yICh2YXIgcGllY2UgPSAwOyBwaWVjZSA8IHRoaXMuX251bVBpZWNlczsgcGllY2UrKykge1xuICAgICAgdGhpcy5fcmVxdWVzdChwaWVjZSlcbiAgICB9XG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fY2hlY2tEb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb25lID0gdHJ1ZVxuICAgIGZvciAodmFyIHBpZWNlID0gMDsgcGllY2UgPCB0aGlzLl9udW1QaWVjZXM7IHBpZWNlKyspIHtcbiAgICAgIGlmICghdGhpcy5fYml0ZmllbGQuZ2V0KHBpZWNlKSkge1xuICAgICAgICBkb25lID0gZmFsc2VcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkb25lKSByZXR1cm5cblxuICAgIC8vIGF0dGVtcHQgdG8gc2V0IG1ldGFkYXRhIC0tIG1heSBmYWlsIHNoYTEgY2hlY2tcbiAgICB2YXIgc3VjY2VzcyA9IHRoaXMuc2V0TWV0YWRhdGEodGhpcy5tZXRhZGF0YSlcblxuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgdGhpcy5fZmFpbGVkTWV0YWRhdGEoKVxuICAgIH1cbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9mYWlsZWRNZXRhZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZXNldCBiaXRmaWVsZCAmIHRyeSBhZ2FpblxuICAgIHRoaXMuX2JpdGZpZWxkID0gbmV3IEJpdEZpZWxkKDAsIHsgZ3JvdzogQklURklFTERfR1JPVyB9KVxuICAgIHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgLT0gdGhpcy5fbnVtUGllY2VzXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgPiAwKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0UGllY2VzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIHNlbnQgaW52YWxpZCBtZXRhZGF0YScpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1dE1ldGFkYXRhXG59XG4iLCIvKiBqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZSAqL1xuXG4vLyBUT0RPOiBpcHY2IHN1cHBvcnRcbi8vIFRPRE86IHBhcnNlIGFuZCBzZW5kIHBlZXIgZmxhZ3MgKGN1cnJlbnRseSB1bnVzZWQpXG4vLyBOT1RFOiBhZGRQZWVyIHNob3VsZCB0YWtlIGluIGFuIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCwgZmxhZ3Ncbi8vIFRPRE86IGRlc3Ryb3kgd2lyZSBpZiBwZWVyIHNlbmRzIFBFWCBtZXNzYWdlcyB0b28gZnJlcXVlbnRseVxuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgY29tcGFjdDJzdHJpbmcgPSByZXF1aXJlKCdjb21wYWN0MnN0cmluZycpXG52YXIgc3RyaW5nMmNvbXBhY3QgPSByZXF1aXJlKCdzdHJpbmcyY29tcGFjdCcpXG52YXIgYmVuY29kZSA9IHJlcXVpcmUoJ2JlbmNvZGUnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgUEVYX0lOVEVSVkFMID0gNjUwMDAgLy8ganVzdCBvdmVyIG9uZSBtaW51dGVcbnZhciBQRVhfTUFYX1BFRVJTID0gNTAgICAgLy8gbWF4IG51bWJlciBvZiBwZWVycyB0byBhZHZlcnRpc2UgcGVyIFBFWCBtZXNzYWdlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBpbmhlcml0cyh1dF9wZXgsIEV2ZW50RW1pdHRlcilcblxuICBmdW5jdGlvbiB1dF9wZXggKHdpcmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBFdmVudEVtaXR0ZXIuY2FsbChzZWxmKVxuXG4gICAgc2VsZi5fd2lyZSA9IHdpcmVcbiAgICBzZWxmLl9pbnRlcnZhbElkID0gbnVsbFxuXG4gICAgc2VsZi5yZXNldCgpXG4gIH1cblxuICB1dF9wZXgucHJvdG90eXBlLm5hbWUgPSAndXRfcGV4J1xuXG4gIC8qKlxuICAgKiBTdGFydCBzZW5kaW5nIHJlZ3VsYXIgUEVYIHVwZGF0ZXMgdG8gcmVtb3RlIHBlZXIuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWxJZClcbiAgICBzZWxmLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoc2VsZi5fc2VuZE1lc3NhZ2UuYmluZChzZWxmKSwgUEVYX0lOVEVSVkFMKVxuICAgIGlmIChzZWxmLl9pbnRlcnZhbElkLnVucmVmKSBzZWxmLl9pbnRlcnZhbElkLnVucmVmKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHNlbmRpbmcgUEVYIHVwZGF0ZXMgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWxJZClcbiAgICBzZWxmLl9pbnRlcnZhbElkID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHNlbmRpbmcgdXBkYXRlcyB0byB0aGUgcmVtb3RlIHBlZXIgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZSBvZiBwZWVycyBzZWVuLlxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBzZWxmLl9yZW1vdGVBZGRlZFBlZXJzID0ge31cbiAgICBzZWxmLl9yZW1vdGVEcm9wcGVkUGVlcnMgPSB7fVxuICAgIHNlbGYuX2xvY2FsQWRkZWRQZWVycyA9IHt9XG4gICAgc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnMgPSB7fVxuICAgIHNlbGYuc3RvcCgpXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHBlZXIgdG8gdGhlIGxvY2FsbHkgZGlzY292ZXJlZCBwZWVyIGxpc3QgZm9yIHRoZSBuZXh0IFBFWCBtZXNzYWdlLlxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5hZGRQZWVyID0gZnVuY3Rpb24gKHBlZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAocGVlci5pbmRleE9mKCc6JykgPCAwKSByZXR1cm4gLy8gZGlzcmVnYXJkIGludmFsaWQgcGVlcnNcbiAgICBpZiAocGVlciBpbiBzZWxmLl9yZW1vdGVBZGRlZFBlZXJzKSByZXR1cm4gLy8gbmV2ZXIgYWR2ZXJ0aXNlIHBlZXIgdGhlIHJlbW90ZSB3aXJlIGFscmVhZHkgc2VudCB1c1xuICAgIGlmIChwZWVyIGluIHNlbGYuX2xvY2FsRHJvcHBlZFBlZXJzKSBkZWxldGUgc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnNbcGVlcl1cbiAgICBzZWxmLl9sb2NhbEFkZGVkUGVlcnNbcGVlcl0gPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHBlZXIgdG8gdGhlIGxvY2FsbHkgZHJvcHBlZCBwZWVyIGxpc3QgZm9yIHRoZSBuZXh0IFBFWCBtZXNzYWdlLlxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5kcm9wUGVlciA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgaWYgKHBlZXIuaW5kZXhPZignOicpIDwgMCkgcmV0dXJuIC8vIGRpc3JlZ2FyZCBpbnZhbGlkIHBlZXJzXG4gICAgaWYgKHBlZXIgaW4gc2VsZi5fcmVtb3RlRHJvcHBlZFBlZXJzKSByZXR1cm4gLy8gbmV2ZXIgYWR2ZXJ0aXNlIHBlZXIgdGhlIHJlbW90ZSB3aXJlIGFscmVhZHkgc2VudCB1c1xuICAgIGlmIChwZWVyIGluIHNlbGYuX2xvY2FsQWRkZWRQZWVycykgZGVsZXRlIHNlbGYuX2xvY2FsQWRkZWRQZWVyc1twZWVyXVxuICAgIHNlbGYuX2xvY2FsRHJvcHBlZFBlZXJzW3BlZXJdID0gdHJ1ZVxuICB9XG5cbiAgdXRfcGV4LnByb3RvdHlwZS5vbkV4dGVuZGVkSGFuZHNoYWtlID0gZnVuY3Rpb24gKGhhbmRzaGFrZSkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGlmICghaGFuZHNoYWtlLm0gfHwgIWhhbmRzaGFrZS5tLnV0X3BleCkge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBkb2VzIG5vdCBzdXBwb3J0IHV0X3BleCcpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQRVggbWVzc2FnZXMgYXJlIGJlbmNvZGVkIGRpY3Rpb25hcmllcyB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICogJ2FkZGVkJyAgICAgOiBhcnJheSBvZiBwZWVycyBtZXQgc2luY2UgbGFzdCBQRVggbWVzc2FnZVxuICAgKiAnYWRkZWQuZicgICA6IGFycmF5IG9mIGZsYWdzIHBlciBwZWVyXG4gICAqICAnMHgwMScgICAgIDogcGVlciBwcmVmZXJzIGVuY3J5cHRpb25cbiAgICogICcweDAyJyAgICAgOiBwZWVyIGlzIHNlZWRlclxuICAgKiAnZHJvcHBlZCcgICA6IGFycmF5IG9mIHBlZXJzIGxvY2FsbHkgZHJvcHBlZCBmcm9tIHN3YXJtIHNpbmNlIGxhc3QgUEVYIG1lc3NhZ2VcbiAgICogJ2FkZGVkNicgICAgOiBpcHY2IHZlcnNpb24gb2YgJ2FkZGVkJ1xuICAgKiAnYWRkZWQ2LmYnICA6IGlwdjYgdmVyc2lvbiBvZiAnYWRkZWQuZidcbiAgICogJ2Ryb3BwZWQuZicgOiBpcHY2IHZlcnNpb24gb2YgJ2Ryb3BwZWQnXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBidWYgYmVuY29kZWQgUEVYIGRpY3Rpb25hcnlcbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBtZXNzYWdlXG5cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IGJlbmNvZGUuZGVjb2RlKGJ1ZilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGRyb3AgaW52YWxpZCBtZXNzYWdlc1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UuYWRkZWQpIHtcbiAgICAgIGNvbXBhY3Qyc3RyaW5nLm11bHRpKG1lc3NhZ2UuYWRkZWQpLmZvckVhY2goZnVuY3Rpb24gKHBlZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGYuX3JlbW90ZURyb3BwZWRQZWVyc1twZWVyXVxuICAgICAgICBpZiAoIShwZWVyIGluIHNlbGYuX3JlbW90ZUFkZGVkUGVlcnMpKSB7XG4gICAgICAgICAgc2VsZi5fcmVtb3RlQWRkZWRQZWVyc1twZWVyXSA9IHRydWVcbiAgICAgICAgICBzZWxmLmVtaXQoJ3BlZXInLCBwZWVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLmRyb3BwZWQpIHtcbiAgICAgIGNvbXBhY3Qyc3RyaW5nLm11bHRpKG1lc3NhZ2UuZHJvcHBlZCkuZm9yRWFjaChmdW5jdGlvbiAocGVlcikge1xuICAgICAgICBkZWxldGUgc2VsZi5fcmVtb3RlQWRkZWRQZWVyc1twZWVyXVxuICAgICAgICBpZiAoIShwZWVyIGluIHNlbGYuX3JlbW90ZURyb3BwZWRQZWVycykpIHtcbiAgICAgICAgICBzZWxmLl9yZW1vdGVEcm9wcGVkUGVlcnNbcGVlcl0gPSB0cnVlXG4gICAgICAgICAgc2VsZi5lbWl0KCdkcm9wcGVkJywgcGVlcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBQRVggbWVzc2FnZSB0byB0aGUgcmVtb3RlIHBlZXIgaW5jbHVkaW5nIGluZm9ybWF0aW9uIGFib3V0IGFueSBsb2NhbGx5XG4gICAqIGFkZGVkIC8gZHJvcHBlZCBwZWVycy5cbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUuX3NlbmRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgdmFyIGxvY2FsQWRkZWQgPSBPYmplY3Qua2V5cyhzZWxmLl9sb2NhbEFkZGVkUGVlcnMpLnNsaWNlKDAsIFBFWF9NQVhfUEVFUlMpXG4gICAgdmFyIGxvY2FsRHJvcHBlZCA9IE9iamVjdC5rZXlzKHNlbGYuX2xvY2FsRHJvcHBlZFBlZXJzKS5zbGljZSgwLCBQRVhfTUFYX1BFRVJTKVxuXG4gICAgdmFyIGFkZGVkID0gQnVmZmVyLmNvbmNhdChsb2NhbEFkZGVkLm1hcChzdHJpbmcyY29tcGFjdCkpXG4gICAgdmFyIGRyb3BwZWQgPSBCdWZmZXIuY29uY2F0KGxvY2FsRHJvcHBlZC5tYXAoc3RyaW5nMmNvbXBhY3QpKVxuXG4gICAgdmFyIGFkZGVkRmxhZ3MgPSBCdWZmZXIuY29uY2F0KGxvY2FsQWRkZWQubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgZmxhZ3NcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKFswXSlcbiAgICB9KSlcblxuICAgIC8vIHVwZGF0ZSBsb2NhbCBkZWx0YXNcbiAgICBsb2NhbEFkZGVkLmZvckVhY2goZnVuY3Rpb24gKHBlZXIpIHsgZGVsZXRlIHNlbGYuX2xvY2FsQWRkZWRQZWVyc1twZWVyXSB9KVxuICAgIGxvY2FsRHJvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyKSB7IGRlbGV0ZSBzZWxmLl9sb2NhbERyb3BwZWRQZWVyc1twZWVyXSB9KVxuXG4gICAgLy8gc2VuZCBQRVggbWVzc2FnZVxuICAgIHNlbGYuX3dpcmUuZXh0ZW5kZWQoJ3V0X3BleCcsIHtcbiAgICAgICdhZGRlZCc6IGFkZGVkLFxuICAgICAgJ2FkZGVkLmYnOiBhZGRlZEZsYWdzLFxuICAgICAgJ2Ryb3BwZWQnOiBkcm9wcGVkLFxuICAgICAgJ2FkZGVkNic6IG5ldyBCdWZmZXIoMCksXG4gICAgICAnYWRkZWQ2LmYnOiBuZXcgQnVmZmVyKDApLFxuICAgICAgJ2Ryb3BwZWQ2JzogbmV3IEJ1ZmZlcigwKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdXRfcGV4XG59XG4iLCJ2YXIgRGljdCA9IHJlcXVpcmUoXCIuL2RpY3RcIilcblxuLyoqXG4gKiBEZWNvZGVzIGJlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IChvcHRpb25hbClcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kIChvcHRpb25hbClcbiAqIEBwYXJhbSAge1N0cmluZ30gZW5jb2RpbmcgKG9wdGlvbmFsKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWNvZGUoIGRhdGEsIHN0YXJ0LCBlbmQsIGVuY29kaW5nICkge1xuICBcbiAgaWYoIHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicgJiYgZW5jb2RpbmcgPT0gbnVsbCApIHtcbiAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgc3RhcnQgPSB1bmRlZmluZWRcbiAgfVxuICBcbiAgaWYoIHR5cGVvZiBlbmQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBlbmRcbiAgICBlbmQgPSB1bmRlZmluZWRcbiAgfVxuICBcbiAgZGVjb2RlLnBvc2l0aW9uID0gMFxuICBkZWNvZGUuZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBudWxsXG5cbiAgZGVjb2RlLmRhdGEgPSAhKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKVxuICAgID8gbmV3IEJ1ZmZlciggZGF0YSApXG4gICAgOiBkYXRhLnNsaWNlKCBzdGFydCwgZW5kIClcbiAgXG4gIGRlY29kZS5ieXRlcyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICBcbiAgcmV0dXJuIGRlY29kZS5uZXh0KClcblxufVxuXG5kZWNvZGUuYnl0ZXMgPSAwXG5kZWNvZGUucG9zaXRpb24gPSAwXG5kZWNvZGUuZGF0YSAgICAgPSBudWxsXG5kZWNvZGUuZW5jb2RpbmcgPSBudWxsXG5cbmRlY29kZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgc3dpdGNoKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICkge1xuICAgIGNhc2UgMHg2NDogcmV0dXJuIGRlY29kZS5kaWN0aW9uYXJ5KCk7IGJyZWFrXG4gICAgY2FzZSAweDZDOiByZXR1cm4gZGVjb2RlLmxpc3QoKTsgYnJlYWtcbiAgICBjYXNlIDB4Njk6IHJldHVybiBkZWNvZGUuaW50ZWdlcigpOyBicmVha1xuICAgIGRlZmF1bHQ6ICAgcmV0dXJuIGRlY29kZS5idWZmZXIoKTsgYnJlYWtcbiAgfVxuXG59XG5cbmRlY29kZS5maW5kID0gZnVuY3Rpb24oIGNociApIHtcblxuICB2YXIgaSA9IGRlY29kZS5wb3NpdGlvblxuICB2YXIgYyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICB2YXIgZCA9IGRlY29kZS5kYXRhXG5cbiAgd2hpbGUoIGkgPCBjICkge1xuICAgIGlmKCBkW2ldID09PSBjaHIgKVxuICAgICAgcmV0dXJuIGlcbiAgICBpKytcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBkYXRhOiBNaXNzaW5nIGRlbGltaXRlciBcIicgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoIGNociApICsgJ1wiIFsweCcgK1xuICAgIGNoci50b1N0cmluZyggMTYgKSArICddJ1xuICApXG5cbn1cblxuZGVjb2RlLmRpY3Rpb25hcnkgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBkaWN0ID0gbmV3IERpY3QoKVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGRpY3QuYmluYXJ5U2V0KGRlY29kZS5idWZmZXIoKSwgZGVjb2RlLm5leHQoKSlcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGRpY3RcblxufVxuXG5kZWNvZGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGxzdCA9IFtdXG5cbiAgd2hpbGUoIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gIT09IDB4NjUgKSB7XG4gICAgbHN0LnB1c2goIGRlY29kZS5uZXh0KCkgKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gbHN0XG5cbn1cblxuZGVjb2RlLmludGVnZXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZW5kICAgID0gZGVjb2RlLmZpbmQoIDB4NjUgKVxuICB2YXIgbnVtYmVyID0gZGVjb2RlLmRhdGEudG9TdHJpbmcoICdhc2NpaScsIGRlY29kZS5wb3NpdGlvbiArIDEsIGVuZCApXG5cbiAgZGVjb2RlLnBvc2l0aW9uICs9IGVuZCArIDEgLSBkZWNvZGUucG9zaXRpb25cblxuICByZXR1cm4gcGFyc2VJbnQoIG51bWJlciwgMTAgKVxuXG59XG5cbmRlY29kZS5idWZmZXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgc2VwICAgID0gZGVjb2RlLmZpbmQoIDB4M0EgKVxuICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoIGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24sIHNlcCApLCAxMCApXG4gIHZhciBlbmQgICAgPSArK3NlcCArIGxlbmd0aFxuXG4gIGRlY29kZS5wb3NpdGlvbiA9IGVuZFxuXG4gIHJldHVybiBkZWNvZGUuZW5jb2RpbmdcbiAgICA/IGRlY29kZS5kYXRhLnRvU3RyaW5nKCBkZWNvZGUuZW5jb2RpbmcsIHNlcCwgZW5kIClcbiAgICA6IGRlY29kZS5kYXRhLnNsaWNlKCBzZXAsIGVuZCApXG5cbn1cblxuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGVcbiIsIi8qKlxuICogRW5jb2RlcyBkYXRhIGluIGJlbmNvZGUuXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfEFycmF5fFN0cmluZ3xPYmplY3R8TnVtYmVyfEJvb2xlYW59IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKCBkYXRhLCBidWZmZXIsIG9mZnNldCApIHtcbiAgXG4gIHZhciBidWZmZXJzID0gW11cbiAgdmFyIHJlc3VsdCA9IG51bGxcbiAgXG4gIGVuY29kZS5fZW5jb2RlKCBidWZmZXJzLCBkYXRhIClcbiAgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdCggYnVmZmVycyApXG4gIGVuY29kZS5ieXRlcyA9IHJlc3VsdC5sZW5ndGhcbiAgXG4gIGlmKCBCdWZmZXIuaXNCdWZmZXIoIGJ1ZmZlciApICkge1xuICAgIHJlc3VsdC5jb3B5KCBidWZmZXIsIG9mZnNldCApXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0XG4gIFxufVxuXG5lbmNvZGUuYnl0ZXMgPSAtMVxuZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCA9IGZhbHNlXG5cbmVuY29kZS5fZW5jb2RlID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgaWYoIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSApIHtcbiAgICBidWZmZXJzLnB1c2gobmV3IEJ1ZmZlcihkYXRhLmxlbmd0aCArICc6JykpXG4gICAgYnVmZmVycy5wdXNoKGRhdGEpXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoKCB0eXBlb2YgZGF0YSApIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgZW5jb2RlLmJ1ZmZlciggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBlbmNvZGUubnVtYmVyKCBidWZmZXJzLCBkYXRhIClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGRhdGEuY29uc3RydWN0b3IgPT09IEFycmF5XG4gICAgICAgID8gZW5jb2RlLmxpc3QoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgICA6IGVuY29kZS5kaWN0KCBidWZmZXJzLCBkYXRhIClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBlbmNvZGUubnVtYmVyKCBidWZmZXJzLCBkYXRhID8gMSA6IDAgKVxuICAgICAgYnJlYWtcbiAgfVxuXG59XG5cbnZhciBidWZmX2UgPSBuZXcgQnVmZmVyKCdlJylcbiAgLCBidWZmX2QgPSBuZXcgQnVmZmVyKCdkJylcbiAgLCBidWZmX2wgPSBuZXcgQnVmZmVyKCdsJylcblxuZW5jb2RlLmJ1ZmZlciA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGJ1ZmZlcnMucHVzaCggbmV3IEJ1ZmZlcihCdWZmZXIuYnl0ZUxlbmd0aCggZGF0YSApICsgJzonICsgZGF0YSkgKVxufVxuXG5lbmNvZGUubnVtYmVyID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG4gIHZhciBtYXhMbyA9IDB4ODAwMDAwMDBcbiAgdmFyIGhpID0gKCBkYXRhIC8gbWF4TG8gKSA8PCAwXG4gIHZhciBsbyA9ICggZGF0YSAlIG1heExvICApIDw8IDBcbiAgdmFyIHZhbCA9IGhpICogbWF4TG8gKyBsb1xuXG4gIGJ1ZmZlcnMucHVzaCggbmV3IEJ1ZmZlciggJ2knICsgdmFsICsgJ2UnICkpXG5cbiAgaWYoIHZhbCAhPT0gZGF0YSAmJiAhZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCApIHtcbiAgICBlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gdHJ1ZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXQVJOSU5HOiBQb3NzaWJsZSBkYXRhIGNvcnJ1cHRpb24gZGV0ZWN0ZWQgd2l0aCB2YWx1ZSBcIicrZGF0YSsnXCI6JyxcbiAgICAgICdCZW5jb2Rpbmcgb25seSBkZWZpbmVzIHN1cHBvcnQgZm9yIGludGVnZXJzLCB2YWx1ZSB3YXMgY29udmVydGVkIHRvIFwiJyt2YWwrJ1wiJ1xuICAgIClcbiAgICBjb25zb2xlLnRyYWNlKClcbiAgfVxuXG59XG5cbmVuY29kZS5kaWN0ID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgYnVmZmVycy5wdXNoKCBidWZmX2QgKVxuXG4gIHZhciBqID0gMFxuICB2YXIga1xuICAvLyBmaXggZm9yIGlzc3VlICMxMyAtIHNvcnRlZCBkaWN0c1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBkYXRhICkuc29ydCgpXG4gIHZhciBrbCA9IGtleXMubGVuZ3RoXG5cbiAgZm9yKCA7IGogPCBrbCA7IGorKykge1xuICAgIGs9a2V5c1tqXVxuICAgIGVuY29kZS5idWZmZXIoIGJ1ZmZlcnMsIGsgKVxuICAgIGVuY29kZS5fZW5jb2RlKCBidWZmZXJzLCBkYXRhW2tdIClcbiAgfVxuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9lIClcbn1cblxuZW5jb2RlLmxpc3QgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICB2YXIgaSA9IDAsIGogPSAxXG4gIHZhciBjID0gZGF0YS5sZW5ndGhcbiAgYnVmZmVycy5wdXNoKCBidWZmX2wgKVxuXG4gIGZvciggOyBpIDwgYzsgaSsrICkge1xuICAgIGVuY29kZS5fZW5jb2RlKCBidWZmZXJzLCBkYXRhW2ldIClcbiAgfVxuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9lIClcblxufVxuXG4vLyBFeHBvc2Vcbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlXG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwidmFyIGJzID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaCcpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbXA0ID0gcmVxdWlyZSgnbXA0LXN0cmVhbScpXG52YXIgQm94ID0gcmVxdWlyZSgnbXA0LWJveC1lbmNvZGluZycpXG52YXIgUmFuZ2VTbGljZVN0cmVhbSA9IHJlcXVpcmUoJ3JhbmdlLXNsaWNlLXN0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzID0gTVA0UmVtdXhlclxuXG5mdW5jdGlvbiBNUDRSZW11eGVyIChmaWxlKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRFdmVudEVtaXR0ZXIuY2FsbChzZWxmKVxuXHRzZWxmLl90cmFja3MgPSBbXVxuXHRzZWxmLl9mcmFnbWVudFNlcXVlbmNlID0gMVxuXHRzZWxmLl9maWxlID0gZmlsZVxuXHRzZWxmLl9kZWNvZGVyID0gbnVsbFxuXHRzZWxmLl9maW5kTW9vdigwKVxufVxuXG5pbmhlcml0cyhNUDRSZW11eGVyLCBFdmVudEVtaXR0ZXIpXG5cbk1QNFJlbXV4ZXIucHJvdG90eXBlLl9maW5kTW9vdiA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2RlY29kZXIpIHtcblx0XHRzZWxmLl9kZWNvZGVyLmRlc3Ryb3koKVxuXHR9XG5cblx0c2VsZi5fZGVjb2RlciA9IG1wNC5kZWNvZGUoKVxuXHR2YXIgZmlsZVN0cmVhbSA9IHNlbGYuX2ZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XG5cdFx0c3RhcnQ6IG9mZnNldFxuXHR9KVxuXHRmaWxlU3RyZWFtLnBpcGUoc2VsZi5fZGVjb2RlcilcblxuXHRzZWxmLl9kZWNvZGVyLm9uY2UoJ2JveCcsIGZ1bmN0aW9uIChoZWFkZXJzKSB7XG5cdFx0aWYgKGhlYWRlcnMudHlwZSA9PT0gJ21vb3YnKSB7XG5cdFx0XHRzZWxmLl9kZWNvZGVyLmRlY29kZShmdW5jdGlvbiAobW9vdikge1xuXHRcdFx0XHRmaWxlU3RyZWFtLmRlc3Ryb3koKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHNlbGYuX3Byb2Nlc3NNb292KG1vb3YpXG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGVyci5tZXNzYWdlID0gJ0Nhbm5vdCBwYXJzZSBtcDQgZmlsZTogJyArIGVyci5tZXNzYWdlXG5cdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmlsZVN0cmVhbS5kZXN0cm95KClcblx0XHRcdHNlbGYuX2ZpbmRNb292KG9mZnNldCArIGhlYWRlcnMubGVuZ3RoKVxuXHRcdH1cblx0fSlcbn1cblxuZnVuY3Rpb24gUnVuTGVuZ3RoSW5kZXggKGVudHJpZXMsIGNvdW50TmFtZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fZW50cmllcyA9IGVudHJpZXNcblx0c2VsZi5fY291bnROYW1lID0gY291bnROYW1lIHx8ICdjb3VudCdcblx0c2VsZi5faW5kZXggPSAwXG5cdHNlbGYuX29mZnNldCA9IDBcblxuXHRzZWxmLnZhbHVlID0gc2VsZi5fZW50cmllc1swXVxufVxuXG5SdW5MZW5ndGhJbmRleC5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fb2Zmc2V0Kytcblx0aWYgKHNlbGYuX29mZnNldCA+PSBzZWxmLl9lbnRyaWVzW3NlbGYuX2luZGV4XVtzZWxmLl9jb3VudE5hbWVdKSB7XG5cdFx0c2VsZi5faW5kZXgrK1xuXHRcdHNlbGYuX29mZnNldCA9IDBcblx0fVxuXG5cdHNlbGYudmFsdWUgPSBzZWxmLl9lbnRyaWVzW3NlbGYuX2luZGV4XVxufVxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5fcHJvY2Vzc01vb3YgPSBmdW5jdGlvbiAobW9vdikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgdHJha3MgPSBtb292LnRyYWtzXG5cdHNlbGYuX3RyYWNrcyA9IFtdXG5cdHNlbGYuX2hhc1ZpZGVvID0gZmFsc2Vcblx0c2VsZi5faGFzQXVkaW8gPSBmYWxzZVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRyYWtzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHRyYWsgPSB0cmFrc1tpXVxuXHRcdHZhciBzdGJsID0gdHJhay5tZGlhLm1pbmYuc3RibFxuXHRcdHZhciBzdHNkRW50cnkgPSBzdGJsLnN0c2QuZW50cmllc1swXVxuXHRcdHZhciBoYW5kbGVyVHlwZSA9IHRyYWsubWRpYS5oZGxyLmhhbmRsZXJUeXBlXG5cdFx0dmFyIGNvZGVjXG5cdFx0dmFyIG1pbWVcblx0XHRpZiAoaGFuZGxlclR5cGUgPT09ICd2aWRlJyAmJiBzdHNkRW50cnkudHlwZSA9PT0gJ2F2YzEnKSB7XG5cdFx0XHRpZiAoc2VsZi5faGFzVmlkZW8pIHtcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH1cblx0XHRcdHNlbGYuX2hhc1ZpZGVvID0gdHJ1ZVxuXHRcdFx0Y29kZWMgPSAnYXZjMSdcblx0XHRcdGlmIChzdHNkRW50cnkuYXZjQykge1xuXHRcdFx0XHRjb2RlYyArPSAnLicgKyBzdHNkRW50cnkuYXZjQy5taW1lQ29kZWNcblx0XHRcdH1cblx0XHRcdG1pbWUgPSAndmlkZW8vbXA0OyBjb2RlY3M9XCInICsgY29kZWMgKyAnXCInXG5cdFx0fSBlbHNlIGlmIChoYW5kbGVyVHlwZSA9PT0gJ3NvdW4nICYmIHN0c2RFbnRyeS50eXBlID09PSAnbXA0YScpIHtcblx0XHRcdGlmIChzZWxmLl9oYXNBdWRpbykge1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0c2VsZi5faGFzQXVkaW8gPSB0cnVlXG5cdFx0XHRjb2RlYyA9ICdtcDRhJ1xuXHRcdFx0aWYgKHN0c2RFbnRyeS5lc2RzICYmIHN0c2RFbnRyeS5lc2RzLm1pbWVDb2RlYykge1xuXHRcdFx0XHRjb2RlYyArPSAnLicgKyBzdHNkRW50cnkuZXNkcy5taW1lQ29kZWNcblx0XHRcdH1cblx0XHRcdG1pbWUgPSAnYXVkaW8vbXA0OyBjb2RlY3M9XCInICsgY29kZWMgKyAnXCInXG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRpbnVlXG5cdFx0fVxuXG5cdFx0dmFyIHNhbXBsZXMgPSBbXVxuXHRcdHZhciBzYW1wbGUgPSAwXG5cblx0XHQvLyBDaHVuay9wb3NpdGlvbiBkYXRhXG5cdFx0dmFyIHNhbXBsZUluQ2h1bmsgPSAwXG5cdFx0dmFyIGNodW5rID0gMFxuXHRcdHZhciBvZmZzZXRJbkNodW5rID0gMFxuXHRcdHZhciBzYW1wbGVUb0NodW5rSW5kZXggPSAwXG5cblx0XHQvLyBUaW1lIGRhdGFcblx0XHR2YXIgZHRzID0gMFxuXHRcdHZhciBkZWNvZGluZ1RpbWVFbnRyeSA9IG5ldyBSdW5MZW5ndGhJbmRleChzdGJsLnN0dHMuZW50cmllcylcblx0XHR2YXIgcHJlc2VudGF0aW9uT2Zmc2V0RW50cnkgPSBudWxsXG5cdFx0aWYgKHN0YmwuY3R0cykge1xuXHRcdFx0cHJlc2VudGF0aW9uT2Zmc2V0RW50cnkgPSBuZXcgUnVuTGVuZ3RoSW5kZXgoc3RibC5jdHRzLmVudHJpZXMpXG5cdFx0fVxuXG5cdFx0Ly8gU3luYyB0YWJsZSBpbmRleFxuXHRcdHZhciBzeW5jU2FtcGxlSW5kZXggPSAwXG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0dmFyIGN1cnJDaHVua0VudHJ5ID0gc3RibC5zdHNjLmVudHJpZXNbc2FtcGxlVG9DaHVua0luZGV4XVxuXG5cdFx0XHQvLyBDb21wdXRlIHNpemVcblx0XHRcdHZhciBzaXplID0gc3RibC5zdHN6LmVudHJpZXNbc2FtcGxlXVxuXG5cdFx0XHQvLyBDb21wdXRlIHRpbWUgZGF0YVxuXHRcdFx0dmFyIGR1cmF0aW9uID0gZGVjb2RpbmdUaW1lRW50cnkudmFsdWUuZHVyYXRpb25cblx0XHRcdHZhciBwcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25PZmZzZXRFbnRyeSA/IHByZXNlbnRhdGlvbk9mZnNldEVudHJ5LnZhbHVlLmNvbXBvc2l0aW9uT2Zmc2V0IDogMFxuXG5cdFx0XHQvLyBDb21wdXRlIHN5bmNcblx0XHRcdHZhciBzeW5jID0gdHJ1ZVxuXHRcdFx0aWYgKHN0Ymwuc3Rzcykge1xuXHRcdFx0XHRzeW5jID0gc3RibC5zdHNzLmVudHJpZXNbc3luY1NhbXBsZUluZGV4XSA9PT0gc2FtcGxlICsgMVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgbmV3IHNhbXBsZSBlbnRyeVxuXHRcdFx0c2FtcGxlcy5wdXNoKHtcblx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRkdHM6IGR0cyxcblx0XHRcdFx0cHJlc2VudGF0aW9uT2Zmc2V0OiBwcmVzZW50YXRpb25PZmZzZXQsXG5cdFx0XHRcdHN5bmM6IHN5bmMsXG5cdFx0XHRcdG9mZnNldDogb2Zmc2V0SW5DaHVuayArIHN0Ymwuc3Rjby5lbnRyaWVzW2NodW5rXVxuXHRcdFx0fSlcblxuXHRcdFx0Ly8gR28gdG8gbmV4dCBzYW1wbGVcblx0XHRcdHNhbXBsZSsrXG5cdFx0XHRpZiAoc2FtcGxlID49IHN0Ymwuc3Rzei5lbnRyaWVzLmxlbmd0aCkge1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNb3ZlIHBvc2l0aW9uL2NodW5rXG5cdFx0XHRzYW1wbGVJbkNodW5rKytcblx0XHRcdG9mZnNldEluQ2h1bmsgKz0gc2l6ZVxuXHRcdFx0aWYgKHNhbXBsZUluQ2h1bmsgPj0gY3VyckNodW5rRW50cnkuc2FtcGxlc1BlckNodW5rKSB7XG5cdFx0XHRcdC8vIE1vdmUgdG8gbmV3IGNodW5rXG5cdFx0XHRcdHNhbXBsZUluQ2h1bmsgPSAwXG5cdFx0XHRcdG9mZnNldEluQ2h1bmsgPSAwXG5cdFx0XHRcdGNodW5rKytcblx0XHRcdFx0Ly8gTW92ZSBzYW1wbGUgdG8gY2h1bmsgYm94IGluZGV4XG5cdFx0XHRcdHZhciBuZXh0Q2h1bmtFbnRyeSA9IHN0Ymwuc3RzYy5lbnRyaWVzW3NhbXBsZVRvQ2h1bmtJbmRleCArIDFdXG5cdFx0XHRcdGlmIChuZXh0Q2h1bmtFbnRyeSAmJiBjaHVuayArIDEgPj0gbmV4dENodW5rRW50cnkuZmlyc3RDaHVuaykge1xuXHRcdFx0XHRcdHNhbXBsZVRvQ2h1bmtJbmRleCsrXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTW92ZSB0aW1lIGZvcndhcmRcblx0XHRcdGR0cyArPSBkdXJhdGlvblxuXHRcdFx0ZGVjb2RpbmdUaW1lRW50cnkuaW5jKClcblx0XHRcdHByZXNlbnRhdGlvbk9mZnNldEVudHJ5ICYmIHByZXNlbnRhdGlvbk9mZnNldEVudHJ5LmluYygpXG5cblx0XHRcdC8vIE1vdmUgc3luYyB0YWJsZSBpbmRleFxuXHRcdFx0aWYgKHN5bmMpIHtcblx0XHRcdFx0c3luY1NhbXBsZUluZGV4Kytcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0cmFrLm1kaWEubWRoZC5kdXJhdGlvbiA9IDBcblx0XHR0cmFrLnRraGQuZHVyYXRpb24gPSAwXG5cblx0XHR2YXIgZGVmYXVsdFNhbXBsZURlc2NyaXB0aW9uSW5kZXggPSBjdXJyQ2h1bmtFbnRyeS5zYW1wbGVEZXNjcmlwdGlvbklkXG5cblx0XHR2YXIgdHJhY2tNb292ID0ge1xuXHRcdFx0dHlwZTogJ21vb3YnLFxuXHRcdFx0bXZoZDogbW9vdi5tdmhkLFxuXHRcdFx0dHJha3M6IFt7XG5cdFx0XHRcdHRraGQ6IHRyYWsudGtoZCxcblx0XHRcdFx0bWRpYToge1xuXHRcdFx0XHRcdG1kaGQ6IHRyYWsubWRpYS5tZGhkLFxuXHRcdFx0XHRcdGhkbHI6IHRyYWsubWRpYS5oZGxyLFxuXHRcdFx0XHRcdGVsbmc6IHRyYWsubWRpYS5lbG5nLFxuXHRcdFx0XHRcdG1pbmY6IHtcblx0XHRcdFx0XHRcdHZtaGQ6IHRyYWsubWRpYS5taW5mLnZtaGQsXG5cdFx0XHRcdFx0XHRzbWhkOiB0cmFrLm1kaWEubWluZi5zbWhkLFxuXHRcdFx0XHRcdFx0ZGluZjogdHJhay5tZGlhLm1pbmYuZGluZixcblx0XHRcdFx0XHRcdHN0Ymw6IHtcblx0XHRcdFx0XHRcdFx0c3RzZDogc3RibC5zdHNkLFxuXHRcdFx0XHRcdFx0XHRzdHRzOiBlbXB0eSgpLFxuXHRcdFx0XHRcdFx0XHRjdHRzOiBlbXB0eSgpLFxuXHRcdFx0XHRcdFx0XHRzdHNjOiBlbXB0eSgpLFxuXHRcdFx0XHRcdFx0XHRzdHN6OiBlbXB0eSgpLFxuXHRcdFx0XHRcdFx0XHRzdGNvOiBlbXB0eSgpLFxuXHRcdFx0XHRcdFx0XHRzdHNzOiBlbXB0eSgpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XSxcblx0XHRcdG12ZXg6IHtcblx0XHRcdFx0bWVoZDoge1xuXHRcdFx0XHRcdGZyYWdtZW50RHVyYXRpb246IG1vb3YubXZoZC5kdXJhdGlvblxuXHRcdFx0XHR9LFxuXHRcdFx0XHR0cmV4czogW3tcblx0XHRcdFx0XHR0cmFja0lkOiB0cmFrLnRraGQudHJhY2tJZCxcblx0XHRcdFx0XHRkZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleDogZGVmYXVsdFNhbXBsZURlc2NyaXB0aW9uSW5kZXgsXG5cdFx0XHRcdFx0ZGVmYXVsdFNhbXBsZUR1cmF0aW9uOiAwLFxuXHRcdFx0XHRcdGRlZmF1bHRTYW1wbGVTaXplOiAwLFxuXHRcdFx0XHRcdGRlZmF1bHRTYW1wbGVGbGFnczogMFxuXHRcdFx0XHR9XVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlbGYuX3RyYWNrcy5wdXNoKHtcblx0XHRcdHRyYWNrSWQ6IHRyYWsudGtoZC50cmFja0lkLFxuXHRcdFx0dGltZVNjYWxlOiB0cmFrLm1kaWEubWRoZC50aW1lU2NhbGUsXG5cdFx0XHRzYW1wbGVzOiBzYW1wbGVzLFxuXHRcdFx0Y3VyclNhbXBsZTogbnVsbCxcblx0XHRcdGN1cnJUaW1lOiBudWxsLFxuXHRcdFx0bW9vdjogdHJhY2tNb292LFxuXHRcdFx0bWltZTogbWltZVxuXHRcdH0pXG5cdH1cblxuXHRpZiAoc2VsZi5fdHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHBsYXlhYmxlIHRyYWNrcycpKVxuXHRcdHJldHVyblxuXHR9XG5cblx0Ly8gTXVzdCBiZSBzZXQgbGFzdCBzaW5jZSB0aGlzIGlzIHVzZWQgYWJvdmVcblx0bW9vdi5tdmhkLmR1cmF0aW9uID0gMFxuXG5cdHNlbGYuX2Z0eXAgPSB7XG5cdFx0dHlwZTogJ2Z0eXAnLFxuXHRcdGJyYW5kOiAnaXNvNScsXG5cdFx0YnJhbmRWZXJzaW9uOiAwLFxuXHRcdGNvbXBhdGlibGVCcmFuZHM6IFtcblx0XHRcdCdpc281J1xuXHRcdF1cblx0fVxuXG5cdHZhciBmdHlwQnVmID0gQm94LmVuY29kZShzZWxmLl9mdHlwKVxuXHR2YXIgZGF0YSA9IHNlbGYuX3RyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0dmFyIG1vb3ZCdWYgPSBCb3guZW5jb2RlKHRyYWNrLm1vb3YpXG5cdFx0cmV0dXJuIHtcblx0XHRcdG1pbWU6IHRyYWNrLm1pbWUsXG5cdFx0XHRpbml0OiBCdWZmZXIuY29uY2F0KFtmdHlwQnVmLCBtb292QnVmXSlcblx0XHR9XG5cdH0pXG5cblx0c2VsZi5lbWl0KCdyZWFkeScsIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHtcblx0cmV0dXJuIHtcblx0XHR2ZXJzaW9uOiAwLFxuXHRcdGZsYWdzOiAwLFxuXHRcdGVudHJpZXM6IFtdXG5cdH1cbn1cblxuTVA0UmVtdXhlci5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoIXNlbGYuX3RyYWNrcykge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm90IHJlYWR5IHlldDsgd2FpdCBmb3IgXFwncmVhZHlcXCcgZXZlbnQnKVxuXHR9XG5cblx0aWYgKHNlbGYuX2ZpbGVTdHJlYW0pIHtcblx0XHRzZWxmLl9maWxlU3RyZWFtLmRlc3Ryb3koKVxuXHRcdHNlbGYuX2ZpbGVTdHJlYW0gPSBudWxsXG5cdH1cblxuXHR2YXIgc3RhcnRPZmZzZXQgPSAtMVxuXHRzZWxmLl90cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaywgaSkge1xuXHRcdC8vIGZpbmQgdGhlIGtleWZyYW1lIGJlZm9yZSB0aGUgdGltZVxuXHRcdC8vIHN0cmVhbSBmcm9tIHRoZXJlXG5cdFx0aWYgKHRyYWNrLm91dFN0cmVhbSkge1xuXHRcdFx0dHJhY2sub3V0U3RyZWFtLmRlc3Ryb3koKVxuXHRcdH1cblx0XHRpZiAodHJhY2suaW5TdHJlYW0pIHtcblx0XHRcdHRyYWNrLmluU3RyZWFtLmRlc3Ryb3koKVxuXHRcdFx0dHJhY2suaW5TdHJlYW0gPSBudWxsXG5cdFx0fVxuXHRcdHZhciBvdXRTdHJlYW0gPSB0cmFjay5vdXRTdHJlYW0gPSBtcDQuZW5jb2RlKClcblx0XHR2YXIgZnJhZ21lbnQgPSBzZWxmLl9nZW5lcmF0ZUZyYWdtZW50KGksIHRpbWUpXG5cdFx0aWYgKCFmcmFnbWVudCkge1xuXHRcdFx0cmV0dXJuIG91dFN0cmVhbS5maW5hbGl6ZSgpXG5cdFx0fVxuXG5cdFx0aWYgKHN0YXJ0T2Zmc2V0ID09PSAtMSB8fCBmcmFnbWVudC5yYW5nZXNbMF0uc3RhcnQgPCBzdGFydE9mZnNldCkge1xuXHRcdFx0c3RhcnRPZmZzZXQgPSBmcmFnbWVudC5yYW5nZXNbMF0uc3RhcnRcblx0XHR9XG5cblx0XHR3cml0ZUZyYWdtZW50KGZyYWdtZW50KVxuXG5cdFx0ZnVuY3Rpb24gd3JpdGVGcmFnbWVudCAoZnJhZykge1xuXHRcdFx0aWYgKG91dFN0cmVhbS5kZXN0cm95ZWQpIHJldHVyblxuXHRcdFx0b3V0U3RyZWFtLmJveChmcmFnLm1vb2YsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0aWYgKGVycikgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdGlmIChvdXRTdHJlYW0uZGVzdHJveWVkKSByZXR1cm5cblx0XHRcdFx0dmFyIHNsaWNlZFN0cmVhbSA9IHRyYWNrLmluU3RyZWFtLnNsaWNlKGZyYWcucmFuZ2VzKVxuXHRcdFx0XHRzbGljZWRTdHJlYW0ucGlwZShvdXRTdHJlYW0ubWVkaWFEYXRhKGZyYWcubGVuZ3RoLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0aWYgKGVycikgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdFx0aWYgKG91dFN0cmVhbS5kZXN0cm95ZWQpIHJldHVyblxuXHRcdFx0XHRcdHZhciBuZXh0RnJhZyA9IHNlbGYuX2dlbmVyYXRlRnJhZ21lbnQoaSlcblx0XHRcdFx0XHRpZiAoIW5leHRGcmFnKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3V0U3RyZWFtLmZpbmFsaXplKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d3JpdGVGcmFnbWVudChuZXh0RnJhZylcblx0XHRcdFx0fSkpXG5cdFx0XHR9KVxuXHRcdH1cblx0fSlcblxuXHRpZiAoc3RhcnRPZmZzZXQgPj0gMCkge1xuXHRcdHZhciBmaWxlU3RyZWFtID0gc2VsZi5fZmlsZVN0cmVhbSA9IHNlbGYuX2ZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XG5cdFx0XHRzdGFydDogc3RhcnRPZmZzZXRcblx0XHR9KVxuXG5cdFx0c2VsZi5fdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0XHR0cmFjay5pblN0cmVhbSA9IG5ldyBSYW5nZVNsaWNlU3RyZWFtKHN0YXJ0T2Zmc2V0KVxuXHRcdFx0ZmlsZVN0cmVhbS5waXBlKHRyYWNrLmluU3RyZWFtKVxuXHRcdH0pXG5cdH1cblxuXHRyZXR1cm4gc2VsZi5fdHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcblx0XHRyZXR1cm4gdHJhY2sub3V0U3RyZWFtXG5cdH0pXG59XG5cbk1QNFJlbXV4ZXIucHJvdG90eXBlLl9maW5kU2FtcGxlQmVmb3JlID0gZnVuY3Rpb24gKHRyYWNrSW5kLCB0aW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciB0cmFjayA9IHNlbGYuX3RyYWNrc1t0cmFja0luZF1cblx0dmFyIHNjYWxlZFRpbWUgPSBNYXRoLmZsb29yKHRyYWNrLnRpbWVTY2FsZSAqIHRpbWUpXG5cdHZhciBzYW1wbGUgPSBicyh0cmFjay5zYW1wbGVzLCBzY2FsZWRUaW1lLCBmdW5jdGlvbiAoc2FtcGxlLCB0KSB7XG5cdFx0dmFyIHB0cyA9IHNhbXBsZS5kdHMgKyBzYW1wbGUucHJlc2VudGF0aW9uT2Zmc2V0Ly8gLSB0cmFjay5lZGl0U2hpZnRcblx0XHRyZXR1cm4gcHRzIC0gdFxuXHR9KVxuXHRpZiAoc2FtcGxlID09PSAtMSkge1xuXHRcdHNhbXBsZSA9IDBcblx0fSBlbHNlIGlmIChzYW1wbGUgPCAwKSB7XG5cdFx0c2FtcGxlID0gLXNhbXBsZSAtIDJcblx0fVxuXHQvLyBzYW1wbGUgaXMgbm93IHRoZSBsYXN0IHNhbXBsZSB3aXRoIGR0cyA8PSB0aW1lXG5cdC8vIEZpbmQgdGhlIHByZWNlZWRpbmcgc3luYyBzYW1wbGVcblx0d2hpbGUgKCF0cmFjay5zYW1wbGVzW3NhbXBsZV0uc3luYykge1xuXHRcdHNhbXBsZS0tXG5cdH1cblx0cmV0dXJuIHNhbXBsZVxufVxuXG52YXIgTUlOX0ZSQUdNRU5UX0RVUkFUSU9OID0gMSAvLyBzZWNvbmRcblxuTVA0UmVtdXhlci5wcm90b3R5cGUuX2dlbmVyYXRlRnJhZ21lbnQgPSBmdW5jdGlvbiAodHJhY2ssIHRpbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdC8qXG5cdDEuIEZpbmQgY29ycmVjdCBzYW1wbGVcblx0Mi4gUHJvY2VzcyBiYWNrd2FyZCB1bnRpbCBzeW5jIHNhbXBsZSBmb3VuZFxuXHQzLiBQcm9jZXNzIGZvcndhcmQgdW50aWwgbmV4dCBzeW5jIHNhbXBsZSBhZnRlciBNSU5fRlJBR01FTlRfRFVSQVRJT04gZm91bmRcblx0Ki9cblx0dmFyIGN1cnJUcmFjayA9IHNlbGYuX3RyYWNrc1t0cmFja11cblx0dmFyIGZpcnN0U2FtcGxlXG5cdGlmICh0aW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRmaXJzdFNhbXBsZSA9IHNlbGYuX2ZpbmRTYW1wbGVCZWZvcmUodHJhY2ssIHRpbWUpXG5cdH0gZWxzZSB7XG5cdFx0Zmlyc3RTYW1wbGUgPSBjdXJyVHJhY2suY3VyclNhbXBsZVxuXHR9XG5cblx0aWYgKGZpcnN0U2FtcGxlID49IGN1cnJUcmFjay5zYW1wbGVzLmxlbmd0aClcblx0XHRyZXR1cm4gbnVsbFxuXG5cdHZhciBzdGFydER0cyA9IGN1cnJUcmFjay5zYW1wbGVzW2ZpcnN0U2FtcGxlXS5kdHNcblxuXHR2YXIgdG90YWxMZW4gPSAwXG5cdHZhciByYW5nZXMgPSBbXVxuXHRmb3IgKHZhciBjdXJyU2FtcGxlID0gZmlyc3RTYW1wbGU7IGN1cnJTYW1wbGUgPCBjdXJyVHJhY2suc2FtcGxlcy5sZW5ndGg7IGN1cnJTYW1wbGUrKykge1xuXHRcdHZhciBzYW1wbGUgPSBjdXJyVHJhY2suc2FtcGxlc1tjdXJyU2FtcGxlXVxuXHRcdGlmIChzYW1wbGUuc3luYyAmJiBzYW1wbGUuZHRzIC0gc3RhcnREdHMgPj0gY3VyclRyYWNrLnRpbWVTY2FsZSAqIE1JTl9GUkFHTUVOVF9EVVJBVElPTikge1xuXHRcdFx0YnJlYWsgLy8gVGhpcyBpcyBhIHJlYXNvbmFibGUgcGxhY2UgdG8gZW5kIHRoZSBmcmFnbWVudFxuXHRcdH1cblxuXHRcdHRvdGFsTGVuICs9IHNhbXBsZS5zaXplXG5cdFx0dmFyIGN1cnJSYW5nZSA9IHJhbmdlcy5sZW5ndGggLSAxXG5cdFx0aWYgKGN1cnJSYW5nZSA8IDAgfHwgcmFuZ2VzW2N1cnJSYW5nZV0uZW5kICE9PSBzYW1wbGUub2Zmc2V0KSB7XG5cdFx0XHQvLyBQdXNoIGEgbmV3IHJhbmdlXG5cdFx0XHRyYW5nZXMucHVzaCh7XG5cdFx0XHRcdHN0YXJ0OiBzYW1wbGUub2Zmc2V0LFxuXHRcdFx0XHRlbmQ6IHNhbXBsZS5vZmZzZXQgKyBzYW1wbGUuc2l6ZVxuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFuZ2VzW2N1cnJSYW5nZV0uZW5kICs9IHNhbXBsZS5zaXplXG5cdFx0fVxuXHR9XG5cblx0Y3VyclRyYWNrLmN1cnJTYW1wbGUgPSBjdXJyU2FtcGxlXG5cblx0cmV0dXJuIHtcblx0XHRtb29mOiBzZWxmLl9nZW5lcmF0ZU1vb2YodHJhY2ssIGZpcnN0U2FtcGxlLCBjdXJyU2FtcGxlKSxcblx0XHRyYW5nZXM6IHJhbmdlcyxcblx0XHRsZW5ndGg6IHRvdGFsTGVuXG5cdH1cbn1cblxuTVA0UmVtdXhlci5wcm90b3R5cGUuX2dlbmVyYXRlTW9vZiA9IGZ1bmN0aW9uICh0cmFjaywgZmlyc3RTYW1wbGUsIGxhc3RTYW1wbGUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIGN1cnJUcmFjayA9IHNlbGYuX3RyYWNrc1t0cmFja11cblxuXHR2YXIgZW50cmllcyA9IFtdXG5cdGZvciAodmFyIGogPSBmaXJzdFNhbXBsZTsgaiA8IGxhc3RTYW1wbGU7IGorKykge1xuXHRcdHZhciBjdXJyU2FtcGxlID0gY3VyclRyYWNrLnNhbXBsZXNbal1cblx0XHRlbnRyaWVzLnB1c2goe1xuXHRcdFx0c2FtcGxlRHVyYXRpb246IGN1cnJTYW1wbGUuZHVyYXRpb24sXG5cdFx0XHRzYW1wbGVTaXplOiBjdXJyU2FtcGxlLnNpemUsXG5cdFx0XHRzYW1wbGVGbGFnczogY3VyclNhbXBsZS5zeW5jID8gMHgyMDAwMDAwIDogMHgxMDEwMDAwLFxuXHRcdFx0c2FtcGxlQ29tcG9zaXRpb25UaW1lT2Zmc2V0OiBjdXJyU2FtcGxlLnByZXNlbnRhdGlvbk9mZnNldFxuXHRcdH0pXG5cdH1cblxuXHR2YXIgbW9vZiA9IHtcblx0XHR0eXBlOiAnbW9vZicsXG5cdFx0bWZoZDoge1xuXHRcdFx0c2VxdWVuY2VOdW1iZXI6IHNlbGYuX2ZyYWdtZW50U2VxdWVuY2UrK1xuXHRcdH0sXG5cdFx0dHJhZnM6IFt7XG5cdFx0XHR0ZmhkOiB7XG5cdFx0XHRcdGZsYWdzOiAweDIwMDAwLCAvLyBkZWZhdWx0LWJhc2UtaXMtbW9vZlxuXHRcdFx0XHR0cmFja0lkOiBjdXJyVHJhY2sudHJhY2tJZFxuXHRcdFx0fSxcblx0XHRcdHRmZHQ6IHtcblx0XHRcdFx0YmFzZU1lZGlhRGVjb2RlVGltZTogY3VyclRyYWNrLnNhbXBsZXNbZmlyc3RTYW1wbGVdLmR0c1xuXHRcdFx0fSxcblx0XHRcdHRydW46IHtcblx0XHRcdFx0ZmxhZ3M6IDB4ZjAxLFxuXHRcdFx0XHRkYXRhT2Zmc2V0OiA4LCAvLyBUaGUgbW9vZiBzaXplIGhhcyB0byBiZSBhZGRlZCB0byB0aGlzIGxhdGVyIGFzIHdlbGxcblx0XHRcdFx0ZW50cmllczogZW50cmllc1xuXHRcdFx0fVxuXHRcdH1dXG5cdH1cblxuXHQvLyBVcGRhdGUgdGhlIG9mZnNldFxuXHRtb29mLnRyYWZzWzBdLnRydW4uZGF0YU9mZnNldCArPSBCb3guZW5jb2RpbmdMZW5ndGgobW9vZilcblxuXHRyZXR1cm4gbW9vZlxufVxuIiwidmFyIE1lZGlhRWxlbWVudFdyYXBwZXIgPSByZXF1aXJlKCdtZWRpYXNvdXJjZScpXG52YXIgcHVtcCA9IHJlcXVpcmUoJ3B1bXAnKVxuXG52YXIgTVA0UmVtdXhlciA9IHJlcXVpcmUoJy4vbXA0LXJlbXV4ZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZGVvU3RyZWFtXG5cbmZ1bmN0aW9uIFZpZGVvU3RyZWFtIChmaWxlLCBtZWRpYUVsZW0sIG9wdHMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBWaWRlb1N0cmVhbSkpIHJldHVybiBuZXcgVmlkZW9TdHJlYW0oZmlsZSwgbWVkaWFFbGVtLCBvcHRzKVxuXHRvcHRzID0gb3B0cyB8fCB7fVxuXG5cdHNlbGYuX2VsZW0gPSBtZWRpYUVsZW1cblx0c2VsZi5fZWxlbVdyYXBwZXIgPSBuZXcgTWVkaWFFbGVtZW50V3JhcHBlcihtZWRpYUVsZW0pXG5cdHNlbGYuX3dhaXRpbmdGaXJlZCA9IGZhbHNlXG5cdHNlbGYuX3RyYWNrTWV0YSA9IG51bGxcblx0c2VsZi5fZmlsZSA9IGZpbGVcblx0c2VsZi5fdHJhY2tzID0gbnVsbFxuXHRpZiAoc2VsZi5fZWxlbS5wcmVsb2FkICE9PSAnbm9uZScpIHtcblx0XHRzZWxmLl9jcmVhdGVNdXhlcigpXG5cdH1cblxuXHRzZWxmLl9vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHRcdHNlbGYuZGVzdHJveSgpIC8vIGRvbid0IHBhc3MgZXJyIHRob3VnaCBzbyB0aGUgdXNlciBkb2Vzbid0IG5lZWQgdG8gbGlzdGVuIGZvciBlcnJvcnNcblx0fVxuXHRzZWxmLl9vbldhaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5fd2FpdGluZ0ZpcmVkID0gdHJ1ZVxuXHRcdGlmICghc2VsZi5fbXV4ZXIpIHtcblx0XHRcdHNlbGYuX2NyZWF0ZU11eGVyKClcblx0XHR9IGVsc2UgaWYgKHNlbGYuX3RyYWNrcykge1xuXHRcdFx0c2VsZi5fcHVtcCgpXG5cdFx0fVxuXHR9XG5cdHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHNlbGYuX29uV2FpdGluZylcblx0c2VsZi5fZWxlbS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG59XG5cblZpZGVvU3RyZWFtLnByb3RvdHlwZS5fY3JlYXRlTXV4ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9tdXhlciA9IG5ldyBNUDRSZW11eGVyKHNlbGYuX2ZpbGUpXG5cdHNlbGYuX211eGVyLm9uKCdyZWFkeScsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0c2VsZi5fdHJhY2tzID0gZGF0YS5tYXAoZnVuY3Rpb24gKHRyYWNrRGF0YSkge1xuXHRcdFx0dmFyIG1lZGlhU291cmNlID0gc2VsZi5fZWxlbVdyYXBwZXIuY3JlYXRlV3JpdGVTdHJlYW0odHJhY2tEYXRhLm1pbWUpXG5cdFx0XHRtZWRpYVNvdXJjZS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdHNlbGYuX2VsZW1XcmFwcGVyLmVycm9yKGVycilcblx0XHRcdH0pXG5cdFx0XHRtZWRpYVNvdXJjZS53cml0ZSh0cmFja0RhdGEuaW5pdClcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG11eGVkOiBudWxsLFxuXHRcdFx0XHRtZWRpYVNvdXJjZTogbWVkaWFTb3VyY2Vcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0aWYgKHNlbGYuX3dhaXRpbmdGaXJlZCB8fCBzZWxmLl9lbGVtLnByZWxvYWQgPT09ICdhdXRvJykge1xuXHRcdFx0c2VsZi5fcHVtcCgpXG5cdFx0fVxuXHR9KVxuXG5cdHNlbGYuX211eGVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRzZWxmLl9lbGVtV3JhcHBlci5lcnJvcihlcnIpXG5cdH0pXG59XG5cblZpZGVvU3RyZWFtLnByb3RvdHlwZS5fcHVtcCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIG11eGVkID0gc2VsZi5fbXV4ZXIuc2VlayhzZWxmLl9lbGVtLmN1cnJlbnRUaW1lLCAhc2VsZi5fdHJhY2tzKVxuXG5cdHNlbGYuX3RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaSkge1xuXHRcdGlmICh0cmFjay5tdXhlZCkge1xuXHRcdFx0dHJhY2subXV4ZWQuZGVzdHJveSgpXG5cdFx0XHR0cmFjay5tZWRpYVNvdXJjZSA9IHNlbGYuX2VsZW1XcmFwcGVyLmNyZWF0ZVdyaXRlU3RyZWFtKHRyYWNrLm1lZGlhU291cmNlKVxuXHRcdFx0dHJhY2subWVkaWFTb3VyY2Uub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRzZWxmLl9lbGVtV3JhcHBlci5lcnJvcihlcnIpXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR0cmFjay5tdXhlZCA9IG11eGVkW2ldXG5cdFx0cHVtcCh0cmFjay5tdXhlZCwgdHJhY2subWVkaWFTb3VyY2UpXG5cdH0pXG59XG5cblZpZGVvU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHNlbGYuZGVzdHJveWVkKSB7XG5cdFx0cmV0dXJuXG5cdH1cblx0c2VsZi5kZXN0cm95ZWQgPSB0cnVlXG5cblx0c2VsZi5fZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgc2VsZi5fb25XYWl0aW5nKVxuXHRzZWxmLl9lbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25FcnJvcilcblxuXHRpZiAoc2VsZi5fdHJhY2tzKSB7XG5cdFx0c2VsZi5fdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0XHR0cmFjay5tdXhlZC5kZXN0cm95KClcblx0XHR9KVxuXHR9XG5cblx0c2VsZi5fZWxlbS5zcmMgPSAnJ1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBXZWJUb3JyZW50XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNvbmNhdCA9IHJlcXVpcmUoJ3NpbXBsZS1jb25jYXQnKVxudmFyIGNyZWF0ZVRvcnJlbnQgPSByZXF1aXJlKCdjcmVhdGUtdG9ycmVudCcpXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJ0b3JyZW50JylcbnZhciBESFQgPSByZXF1aXJlKCdiaXR0b3JyZW50LWRodC9jbGllbnQnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgaGF0ID0gcmVxdWlyZSgnaGF0JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBsb2FkSVBTZXQgPSByZXF1aXJlKCdsb2FkLWlwLXNldCcpIC8vIGJyb3dzZXIgZXhjbHVkZVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcbnZhciBwYXJzZVRvcnJlbnQgPSByZXF1aXJlKCdwYXJzZS10b3JyZW50JylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgUGVlciA9IHJlcXVpcmUoJ3NpbXBsZS1wZWVyJylcbnZhciBzcGVlZG9tZXRlciA9IHJlcXVpcmUoJ3NwZWVkb21ldGVyJylcbnZhciB6ZXJvRmlsbCA9IHJlcXVpcmUoJ3plcm8tZmlsbCcpXG5cbnZhciBUQ1BQb29sID0gcmVxdWlyZSgnLi9saWIvdGNwLXBvb2wnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBUb3JyZW50ID0gcmVxdWlyZSgnLi9saWIvdG9ycmVudCcpXG5cbi8qKlxuICogV2ViVG9ycmVudCB2ZXJzaW9uLlxuICovXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4vKipcbiAqIFZlcnNpb24gbnVtYmVyIGluIEF6dXJldXMtc3R5bGUuIEdlbmVyYXRlZCBmcm9tIG1ham9yIGFuZCBtaW5vciBzZW12ZXIgdmVyc2lvbi5cbiAqIEZvciBleGFtcGxlOlxuICogICAnMC4xNi4xJyAtPiAnMDAxNidcbiAqICAgJzEuMi41JyAtPiAnMDEwMidcbiAqL1xudmFyIFZFUlNJT05fU1RSID0gVkVSU0lPTi5tYXRjaCgvKFswLTldKykvZykuc2xpY2UoMCwgMikubWFwKHplcm9GaWxsKDIpKS5qb2luKCcnKVxuXG4vKipcbiAqIFZlcnNpb24gcHJlZml4IHN0cmluZyAodXNlZCBpbiBwZWVyIElEKS4gV2ViVG9ycmVudCB1c2VzIHRoZSBBenVyZXVzLXN0eWxlXG4gKiBlbmNvZGluZzogJy0nLCB0d28gY2hhcmFjdGVycyBmb3IgY2xpZW50IGlkICgnV1cnKSwgZm91ciBhc2NpaSBkaWdpdHMgZm9yIHZlcnNpb25cbiAqIG51bWJlciwgJy0nLCBmb2xsb3dlZCBieSByYW5kb20gbnVtYmVycy5cbiAqIEZvciBleGFtcGxlOlxuICogICAnLVdXMDEwMi0nLi4uXG4gKi9cbnZhciBWRVJTSU9OX1BSRUZJWCA9ICctV1cnICsgVkVSU0lPTl9TVFIgKyAnLSdcblxuaW5oZXJpdHMoV2ViVG9ycmVudCwgRXZlbnRFbWl0dGVyKVxuXG4vKipcbiAqIFdlYlRvcnJlbnQgQ2xpZW50XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdHNcbiAqL1xuZnVuY3Rpb24gV2ViVG9ycmVudCAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFdlYlRvcnJlbnQpKSByZXR1cm4gbmV3IFdlYlRvcnJlbnQob3B0cylcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcblxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIGlmICh0eXBlb2Ygb3B0cy5wZWVySWQgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi5wZWVySWQgPSBvcHRzLnBlZXJJZFxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRzLnBlZXJJZCkpIHtcbiAgICBzZWxmLnBlZXJJZCA9IG9wdHMucGVlcklkLnRvU3RyaW5nKCdoZXgnKVxuICB9IGVsc2Uge1xuICAgIHNlbGYucGVlcklkID0gQnVmZmVyLmZyb20oVkVSU0lPTl9QUkVGSVggKyBoYXQoNDgpKVxuICB9XG4gIHNlbGYucGVlcklkQnVmZmVyID0gQnVmZmVyLmZyb20oc2VsZi5wZWVySWQsICdoZXgnKVxuXG4gIGlmICh0eXBlb2Ygb3B0cy5ub2RlSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi5ub2RlSWQgPSBvcHRzLm5vZGVJZFxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRzLm5vZGVJZCkpIHtcbiAgICBzZWxmLm5vZGVJZCA9IG9wdHMubm9kZUlkLnRvU3RyaW5nKCdoZXgnKVxuICB9IGVsc2Uge1xuICAgIHNlbGYubm9kZUlkID0gaGF0KDE2MClcbiAgfVxuICBzZWxmLm5vZGVJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlbGYubm9kZUlkLCAnaGV4JylcblxuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHNlbGYubGlzdGVuaW5nID0gZmFsc2VcbiAgc2VsZi50b3JyZW50UG9ydCA9IG9wdHMudG9ycmVudFBvcnQgfHwgMFxuICBzZWxmLmRodFBvcnQgPSBvcHRzLmRodFBvcnQgfHwgMFxuICBzZWxmLnRyYWNrZXIgPSBvcHRzLnRyYWNrZXIgIT09IHVuZGVmaW5lZCA/IG9wdHMudHJhY2tlciA6IHt9XG4gIHNlbGYudG9ycmVudHMgPSBbXVxuICBzZWxmLm1heENvbm5zID0gTnVtYmVyKG9wdHMubWF4Q29ubnMpIHx8IDU1XG5cbiAgaWYgKHNlbGYudHJhY2tlcikge1xuICAgIGlmICh0eXBlb2Ygc2VsZi50cmFja2VyICE9PSAnb2JqZWN0Jykgc2VsZi50cmFja2VyID0ge31cbiAgICBpZiAob3B0cy5ydGNDb25maWcpIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB2MVxuICAgICAgY29uc29sZS53YXJuKCdXZWJUb3JyZW50OiBvcHRzLnJ0Y0NvbmZpZyBpcyBkZXByZWNhdGVkLiBVc2Ugb3B0cy50cmFja2VyLnJ0Y0NvbmZpZyBpbnN0ZWFkJylcbiAgICAgIHNlbGYudHJhY2tlci5ydGNDb25maWcgPSBvcHRzLnJ0Y0NvbmZpZ1xuICAgIH1cbiAgICBpZiAob3B0cy53cnRjKSB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdjFcbiAgICAgIGNvbnNvbGUud2FybignV2ViVG9ycmVudDogb3B0cy53cnRjIGlzIGRlcHJlY2F0ZWQuIFVzZSBvcHRzLnRyYWNrZXIud3J0YyBpbnN0ZWFkJylcbiAgICAgIHNlbGYudHJhY2tlci53cnRjID0gb3B0cy53cnRjIC8vIHRvIHN1cHBvcnQgYHdlYnRvcnJlbnQtaHlicmlkYCBwYWNrYWdlXG4gICAgfVxuICAgIGlmIChnbG9iYWwuV1JUQyAmJiAhc2VsZi50cmFja2VyLndydGMpIHNlbGYudHJhY2tlci53cnRjID0gZ2xvYmFsLldSVENcbiAgfVxuXG4gIGlmICh0eXBlb2YgVENQUG9vbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuX3RjcFBvb2wgPSBuZXcgVENQUG9vbChzZWxmKVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fb25MaXN0ZW5pbmcoKVxuICAgIH0pXG4gIH1cblxuICAvLyBzdGF0c1xuICBzZWxmLl9kb3dubG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuICBzZWxmLl91cGxvYWRTcGVlZCA9IHNwZWVkb21ldGVyKClcblxuICBpZiAob3B0cy5kaHQgIT09IGZhbHNlICYmIHR5cGVvZiBESFQgPT09ICdmdW5jdGlvbicgLyogYnJvd3NlciBleGNsdWRlICovKSB7XG4gICAgLy8gdXNlIGEgc2luZ2xlIERIVCBpbnN0YW5jZSBmb3IgYWxsIHRvcnJlbnRzLCBzbyB0aGUgcm91dGluZyB0YWJsZSBjYW4gYmUgcmV1c2VkXG4gICAgc2VsZi5kaHQgPSBuZXcgREhUKGV4dGVuZCh7IG5vZGVJZDogc2VsZi5ub2RlSWQgfSwgb3B0cy5kaHQpKVxuXG4gICAgc2VsZi5kaHQub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBzZWxmLl9kZXN0cm95KGVycilcbiAgICB9KVxuXG4gICAgc2VsZi5kaHQub25jZSgnbGlzdGVuaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFkZHJlc3MgPSBzZWxmLmRodC5hZGRyZXNzKClcbiAgICAgIGlmIChhZGRyZXNzKSBzZWxmLmRodFBvcnQgPSBhZGRyZXNzLnBvcnRcbiAgICB9KVxuXG4gICAgLy8gSWdub3JlIHdhcm5pbmcgd2hlbiB0aGVyZSBhcmUgPiAxMCB0b3JyZW50cyBpbiB0aGUgY2xpZW50XG4gICAgc2VsZi5kaHQuc2V0TWF4TGlzdGVuZXJzKDApXG5cbiAgICBzZWxmLmRodC5saXN0ZW4oc2VsZi5kaHRQb3J0KVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZGh0ID0gZmFsc2VcbiAgfVxuXG4gIGRlYnVnKCduZXcgd2VidG9ycmVudCAocGVlcklkICVzLCBub2RlSWQgJXMpJywgc2VsZi5wZWVySWQsIHNlbGYubm9kZUlkKVxuXG4gIGlmICh0eXBlb2YgbG9hZElQU2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbG9hZElQU2V0KG9wdHMuYmxvY2tsaXN0LCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICd1c2VyLWFnZW50JzogJ1dlYlRvcnJlbnQvJyArIFZFUlNJT04gKyAnIChodHRwczovL3dlYnRvcnJlbnQuaW8pJ1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnIsIGlwU2V0KSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5lcnJvcignRmFpbGVkIHRvIGxvYWQgYmxvY2tsaXN0OiAnICsgZXJyLm1lc3NhZ2UpXG4gICAgICBzZWxmLmJsb2NrZWQgPSBpcFNldFxuICAgICAgcmVhZHkoKVxuICAgIH0pXG4gIH0gZWxzZSBwcm9jZXNzLm5leHRUaWNrKHJlYWR5KVxuXG4gIGZ1bmN0aW9uIHJlYWR5ICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNlbGYucmVhZHkgPSB0cnVlXG4gICAgc2VsZi5lbWl0KCdyZWFkeScpXG4gIH1cbn1cblxuV2ViVG9ycmVudC5XRUJSVENfU1VQUE9SVCA9IFBlZXIuV0VCUlRDX1NVUFBPUlRcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlRvcnJlbnQucHJvdG90eXBlLCAnZG93bmxvYWRTcGVlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb3dubG9hZFNwZWVkKCkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlRvcnJlbnQucHJvdG90eXBlLCAndXBsb2FkU3BlZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdXBsb2FkU3BlZWQoKSB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViVG9ycmVudC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvcnJlbnRzID0gdGhpcy50b3JyZW50cy5maWx0ZXIoZnVuY3Rpb24gKHRvcnJlbnQpIHtcbiAgICAgIHJldHVybiB0b3JyZW50LnByb2dyZXNzICE9PSAxXG4gICAgfSlcbiAgICB2YXIgZG93bmxvYWRlZCA9IHRvcnJlbnRzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIHRvcnJlbnQpIHtcbiAgICAgIHJldHVybiB0b3RhbCArIHRvcnJlbnQuZG93bmxvYWRlZFxuICAgIH0sIDApXG4gICAgdmFyIGxlbmd0aCA9IHRvcnJlbnRzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIHRvcnJlbnQpIHtcbiAgICAgIHJldHVybiB0b3RhbCArICh0b3JyZW50Lmxlbmd0aCB8fCAwKVxuICAgIH0sIDApIHx8IDFcbiAgICByZXR1cm4gZG93bmxvYWRlZCAvIGxlbmd0aFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViVG9ycmVudC5wcm90b3R5cGUsICdyYXRpbycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVwbG9hZGVkID0gdGhpcy50b3JyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyB0b3JyZW50LnVwbG9hZGVkXG4gICAgfSwgMClcbiAgICB2YXIgcmVjZWl2ZWQgPSB0aGlzLnRvcnJlbnRzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIHRvcnJlbnQpIHtcbiAgICAgIHJldHVybiB0b3RhbCArIHRvcnJlbnQucmVjZWl2ZWRcbiAgICB9LCAwKSB8fCAxXG4gICAgcmV0dXJuIHVwbG9hZGVkIC8gcmVjZWl2ZWRcbiAgfVxufSlcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0b3JyZW50IHdpdGggdGhlIGdpdmVuIGB0b3JyZW50SWRgLiBDb252ZW5pZW5jZSBtZXRob2QuIEVhc2llciB0aGFuXG4gKiBzZWFyY2hpbmcgdGhyb3VnaCB0aGUgYGNsaWVudC50b3JyZW50c2AgYXJyYXkuIFJldHVybnMgYG51bGxgIGlmIG5vIG1hdGNoaW5nIHRvcnJlbnRcbiAqIGZvdW5kLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xCdWZmZXJ8T2JqZWN0fFRvcnJlbnR9IHRvcnJlbnRJZFxuICogQHJldHVybiB7VG9ycmVudHxudWxsfVxuICovXG5XZWJUb3JyZW50LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9ycmVudElkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgaSwgdG9ycmVudFxuICB2YXIgbGVuID0gc2VsZi50b3JyZW50cy5sZW5ndGhcblxuICBpZiAodG9ycmVudElkIGluc3RhbmNlb2YgVG9ycmVudCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdG9ycmVudCA9IHNlbGYudG9ycmVudHNbaV1cbiAgICAgIGlmICh0b3JyZW50ID09PSB0b3JyZW50SWQpIHJldHVybiB0b3JyZW50XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwYXJzZWRcbiAgICB0cnkgeyBwYXJzZWQgPSBwYXJzZVRvcnJlbnQodG9ycmVudElkKSB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBpZiAoIXBhcnNlZCkgcmV0dXJuIG51bGxcbiAgICBpZiAoIXBhcnNlZC5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRvcnJlbnQgaWRlbnRpZmllcicpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRvcnJlbnQgPSBzZWxmLnRvcnJlbnRzW2ldXG4gICAgICBpZiAodG9ycmVudC5pbmZvSGFzaCA9PT0gcGFyc2VkLmluZm9IYXNoKSByZXR1cm4gdG9ycmVudFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyBUT0RPOiByZW1vdmUgaW4gdjFcbldlYlRvcnJlbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24gKHRvcnJlbnRJZCwgb3B0cywgb250b3JyZW50KSB7XG4gIGNvbnNvbGUud2FybignV2ViVG9ycmVudDogY2xpZW50LmRvd25sb2FkKCkgaXMgZGVwcmVjYXRlZC4gVXNlIGNsaWVudC5hZGQoKSBpbnN0ZWFkJylcbiAgcmV0dXJuIHRoaXMuYWRkKHRvcnJlbnRJZCwgb3B0cywgb250b3JyZW50KVxufVxuXG4vKipcbiAqIFN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IHRvcnJlbnQuIEFsaWFzZWQgYXMgYGNsaWVudC5kb3dubG9hZGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8T2JqZWN0fSB0b3JyZW50SWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIHRvcnJlbnQtc3BlY2lmaWMgb3B0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbj19IG9udG9ycmVudCBjYWxsZWQgd2hlbiB0aGUgdG9ycmVudCBpcyByZWFkeSAoaGFzIG1ldGFkYXRhKVxuICovXG5XZWJUb3JyZW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodG9ycmVudElkLCBvcHRzLCBvbnRvcnJlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdjbGllbnQgaXMgZGVzdHJveWVkJylcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZi5hZGQodG9ycmVudElkLCBudWxsLCBvcHRzKVxuXG4gIGRlYnVnKCdhZGQnKVxuICBvcHRzID0gb3B0cyA/IGV4dGVuZChvcHRzKSA6IHt9XG5cbiAgdmFyIHRvcnJlbnQgPSBuZXcgVG9ycmVudCh0b3JyZW50SWQsIHNlbGYsIG9wdHMpXG4gIHNlbGYudG9ycmVudHMucHVzaCh0b3JyZW50KVxuXG4gIHRvcnJlbnQub25jZSgnX2luZm9IYXNoJywgb25JbmZvSGFzaClcbiAgdG9ycmVudC5vbmNlKCdyZWFkeScsIG9uUmVhZHkpXG4gIHRvcnJlbnQub25jZSgnY2xvc2UnLCBvbkNsb3NlKVxuXG4gIGZ1bmN0aW9uIG9uSW5mb0hhc2ggKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYudG9ycmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0ID0gc2VsZi50b3JyZW50c1tpXVxuICAgICAgaWYgKHQuaW5mb0hhc2ggPT09IHRvcnJlbnQuaW5mb0hhc2ggJiYgdCAhPT0gdG9ycmVudCkge1xuICAgICAgICB0b3JyZW50Ll9kZXN0cm95KG5ldyBFcnJvcignQ2Fubm90IGFkZCBkdXBsaWNhdGUgdG9ycmVudCAnICsgdG9ycmVudC5pbmZvSGFzaCkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVhZHkgKCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKHR5cGVvZiBvbnRvcnJlbnQgPT09ICdmdW5jdGlvbicpIG9udG9ycmVudCh0b3JyZW50KVxuICAgIHNlbGYuZW1pdCgndG9ycmVudCcsIHRvcnJlbnQpXG4gIH1cblxuICBmdW5jdGlvbiBvbkNsb3NlICgpIHtcbiAgICB0b3JyZW50LnJlbW92ZUxpc3RlbmVyKCdfaW5mb0hhc2gnLCBvbkluZm9IYXNoKVxuICAgIHRvcnJlbnQucmVtb3ZlTGlzdGVuZXIoJ3JlYWR5Jywgb25SZWFkeSlcbiAgICB0b3JyZW50LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG4gIH1cblxuICByZXR1cm4gdG9ycmVudFxufVxuXG4vKipcbiAqIFN0YXJ0IHNlZWRpbmcgYSBuZXcgZmlsZS9mb2xkZXIuXG4gKiBAcGFyYW0gIHtzdHJpbmd8RmlsZXxGaWxlTGlzdHxCdWZmZXJ8QXJyYXkuPHN0cmluZ3xGaWxlfEJ1ZmZlcj59IGlucHV0XG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRzXG4gKiBAcGFyYW0gIHtmdW5jdGlvbj19IG9uc2VlZCBjYWxsZWQgd2hlbiB0b3JyZW50IGlzIHNlZWRpbmdcbiAqL1xuV2ViVG9ycmVudC5wcm90b3R5cGUuc2VlZCA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0cywgb25zZWVkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignY2xpZW50IGlzIGRlc3Ryb3llZCcpXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGYuc2VlZChpbnB1dCwgbnVsbCwgb3B0cylcblxuICBkZWJ1Zygnc2VlZCcpXG4gIG9wdHMgPSBvcHRzID8gZXh0ZW5kKG9wdHMpIDoge31cblxuICAvLyBXaGVuIHNlZWRpbmcgZnJvbSBmcyBwYXRoLCBpbml0aWFsaXplIHN0b3JlIGZyb20gdGhhdCBwYXRoIHRvIGF2b2lkIGEgY29weVxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgb3B0cy5wYXRoID0gcGF0aC5kaXJuYW1lKGlucHV0KVxuICBpZiAoIW9wdHMuY3JlYXRlZEJ5KSBvcHRzLmNyZWF0ZWRCeSA9ICdXZWJUb3JyZW50LycgKyBWRVJTSU9OX1NUUlxuICBpZiAoIXNlbGYudHJhY2tlcikgb3B0cy5hbm5vdW5jZSA9IFtdXG5cbiAgdmFyIHRvcnJlbnQgPSBzZWxmLmFkZChudWxsLCBvcHRzLCBvblRvcnJlbnQpXG4gIHZhciBzdHJlYW1zXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkgaW5wdXQgPSBbIGlucHV0IF1cbiAgcGFyYWxsZWwoaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgaWYgKGlzUmVhZGFibGUoaXRlbSkpIGNvbmNhdChpdGVtLCBjYilcbiAgICAgIGVsc2UgY2IobnVsbCwgaXRlbSlcbiAgICB9XG4gIH0pLCBmdW5jdGlvbiAoZXJyLCBpbnB1dCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGVycikgcmV0dXJuIHRvcnJlbnQuX2Rlc3Ryb3koZXJyKVxuXG4gICAgY3JlYXRlVG9ycmVudC5wYXJzZUlucHV0KGlucHV0LCBvcHRzLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChlcnIpIHJldHVybiB0b3JyZW50Ll9kZXN0cm95KGVycilcblxuICAgICAgc3RyZWFtcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZS5nZXRTdHJlYW1cbiAgICAgIH0pXG5cbiAgICAgIGNyZWF0ZVRvcnJlbnQoaW5wdXQsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIHRvcnJlbnRCdWYpIHtcbiAgICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHRvcnJlbnQuX2Rlc3Ryb3koZXJyKVxuXG4gICAgICAgIHZhciBleGlzdGluZ1RvcnJlbnQgPSBzZWxmLmdldCh0b3JyZW50QnVmKVxuICAgICAgICBpZiAoZXhpc3RpbmdUb3JyZW50KSB7XG4gICAgICAgICAgdG9ycmVudC5fZGVzdHJveShuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgZHVwbGljYXRlIHRvcnJlbnQgJyArIGV4aXN0aW5nVG9ycmVudC5pbmZvSGFzaCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9ycmVudC5fb25Ub3JyZW50SWQodG9ycmVudEJ1ZilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIG9uVG9ycmVudCAodG9ycmVudCkge1xuICAgIHZhciB0YXNrcyA9IFtcbiAgICAgIGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0b3JyZW50LmxvYWQoc3RyZWFtcywgY2IpXG4gICAgICB9XG4gICAgXVxuICAgIGlmIChzZWxmLmRodCkge1xuICAgICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdG9ycmVudC5vbmNlKCdkaHRBbm5vdW5jZScsIGNiKVxuICAgICAgfSlcbiAgICB9XG4gICAgcGFyYWxsZWwodGFza3MsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoZXJyKSByZXR1cm4gdG9ycmVudC5fZGVzdHJveShlcnIpXG4gICAgICBfb25zZWVkKHRvcnJlbnQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vbnNlZWQgKHRvcnJlbnQpIHtcbiAgICBkZWJ1Zygnb24gc2VlZCcpXG4gICAgaWYgKHR5cGVvZiBvbnNlZWQgPT09ICdmdW5jdGlvbicpIG9uc2VlZCh0b3JyZW50KVxuICAgIHNlbGYuZW1pdCgnc2VlZCcsIHRvcnJlbnQpXG4gIH1cblxuICByZXR1cm4gdG9ycmVudFxufVxuXG4vKipcbiAqIFJlbW92ZSBhIHRvcnJlbnQgZnJvbSB0aGUgY2xpZW50LlxuICogQHBhcmFtICB7c3RyaW5nfEJ1ZmZlcnxUb3JyZW50fSAgIHRvcnJlbnRJZFxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0b3JyZW50SWQsIGNiKSB7XG4gIGRlYnVnKCdyZW1vdmUnKVxuICB2YXIgdG9ycmVudCA9IHRoaXMuZ2V0KHRvcnJlbnRJZClcbiAgaWYgKCF0b3JyZW50KSB0aHJvdyBuZXcgRXJyb3IoJ05vIHRvcnJlbnQgd2l0aCBpZCAnICsgdG9ycmVudElkKVxuICB0aGlzLl9yZW1vdmUodG9ycmVudElkLCBjYilcbn1cblxuV2ViVG9ycmVudC5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uICh0b3JyZW50SWQsIGNiKSB7XG4gIHZhciB0b3JyZW50ID0gdGhpcy5nZXQodG9ycmVudElkKVxuICBpZiAoIXRvcnJlbnQpIHJldHVyblxuICB0aGlzLnRvcnJlbnRzLnNwbGljZSh0aGlzLnRvcnJlbnRzLmluZGV4T2YodG9ycmVudCksIDEpXG4gIHRvcnJlbnQuZGVzdHJveShjYilcbn1cblxuV2ViVG9ycmVudC5wcm90b3R5cGUuYWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmxpc3RlbmluZykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHRoaXMuX3RjcFBvb2xcbiAgICA/IHRoaXMuX3RjcFBvb2wuc2VydmVyLmFkZHJlc3MoKVxuICAgIDogeyBhZGRyZXNzOiAnMC4wLjAuMCcsIGZhbWlseTogJ0lQdjQnLCBwb3J0OiAwIH1cbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBjbGllbnQsIGluY2x1ZGluZyBhbGwgdG9ycmVudHMgYW5kIGNvbm5lY3Rpb25zIHRvIHBlZXJzLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBhbHJlYWR5IGRlc3Ryb3llZCcpXG4gIHRoaXMuX2Rlc3Ryb3kobnVsbCwgY2IpXG59XG5cbldlYlRvcnJlbnQucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdjbGllbnQgZGVzdHJveScpXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIHZhciB0YXNrcyA9IHNlbGYudG9ycmVudHMubWFwKGZ1bmN0aW9uICh0b3JyZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgdG9ycmVudC5kZXN0cm95KGNiKVxuICAgIH1cbiAgfSlcblxuICBpZiAoc2VsZi5fdGNwUG9vbCkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLl90Y3BQb29sLmRlc3Ryb3koY2IpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzZWxmLmRodCkge1xuICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZWxmLmRodC5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBwYXJhbGxlbCh0YXNrcywgY2IpXG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcblxuICBzZWxmLnRvcnJlbnRzID0gW11cbiAgc2VsZi5fdGNwUG9vbCA9IG51bGxcbiAgc2VsZi5kaHQgPSBudWxsXG59XG5cbldlYlRvcnJlbnQucHJvdG90eXBlLl9vbkxpc3RlbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5saXN0ZW5pbmcgPSB0cnVlXG5cbiAgaWYgKHRoaXMuX3RjcFBvb2wpIHtcbiAgICAvLyBTb21ldGltZXMgc2VydmVyLmFkZHJlc3MoKSByZXR1cm5zIGBudWxsYCBpbiBEb2NrZXIuXG4gICAgLy8gV2ViVG9ycmVudCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9iaXR0b3JyZW50LXN3YXJtL3B1bGwvMThcbiAgICB2YXIgYWRkcmVzcyA9IHRoaXMuX3RjcFBvb2wuc2VydmVyLmFkZHJlc3MoKVxuICAgIGlmIChhZGRyZXNzKSB0aGlzLnRvcnJlbnRQb3J0ID0gYWRkcmVzcy5wb3J0XG4gIH1cblxuICB0aGlzLmVtaXQoJ2xpc3RlbmluZycpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBub2RlIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBGaWxlU3RyZWFtXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnRvcnJlbnQ6ZmlsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbmluaGVyaXRzKEZpbGVTdHJlYW0sIHN0cmVhbS5SZWFkYWJsZSlcblxuLyoqXG4gKiBSZWFkYWJsZSBzdHJlYW0gb2YgYSB0b3JyZW50IGZpbGVcbiAqXG4gKiBAcGFyYW0ge0ZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zdGFydCBzdHJlYW0gc2xpY2Ugb2YgZmlsZSwgc3RhcnRpbmcgZnJvbSB0aGlzIGJ5dGUgKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmVuZCBzdHJlYW0gc2xpY2Ugb2YgZmlsZSwgZW5kaW5nIHdpdGggdGhpcyBieXRlIChpbmNsdXNpdmUpXG4gKi9cbmZ1bmN0aW9uIEZpbGVTdHJlYW0gKGZpbGUsIG9wdHMpIHtcbiAgc3RyZWFtLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0cylcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHRoaXMuX3RvcnJlbnQgPSBmaWxlLl90b3JyZW50XG5cbiAgdmFyIHN0YXJ0ID0gKG9wdHMgJiYgb3B0cy5zdGFydCkgfHwgMFxuICB2YXIgZW5kID0gKG9wdHMgJiYgb3B0cy5lbmQgJiYgb3B0cy5lbmQgPCBmaWxlLmxlbmd0aClcbiAgICA/IG9wdHMuZW5kXG4gICAgOiBmaWxlLmxlbmd0aCAtIDFcblxuICB2YXIgcGllY2VMZW5ndGggPSBmaWxlLl90b3JyZW50LnBpZWNlTGVuZ3RoXG5cbiAgdGhpcy5fc3RhcnRQaWVjZSA9IChzdGFydCArIGZpbGUub2Zmc2V0KSAvIHBpZWNlTGVuZ3RoIHwgMFxuICB0aGlzLl9lbmRQaWVjZSA9IChlbmQgKyBmaWxlLm9mZnNldCkgLyBwaWVjZUxlbmd0aCB8IDBcblxuICB0aGlzLl9waWVjZSA9IHRoaXMuX3N0YXJ0UGllY2VcbiAgdGhpcy5fb2Zmc2V0ID0gKHN0YXJ0ICsgZmlsZS5vZmZzZXQpIC0gKHRoaXMuX3N0YXJ0UGllY2UgKiBwaWVjZUxlbmd0aClcblxuICB0aGlzLl9taXNzaW5nID0gZW5kIC0gc3RhcnQgKyAxXG4gIHRoaXMuX3JlYWRpbmcgPSBmYWxzZVxuICB0aGlzLl9ub3RpZnlpbmcgPSBmYWxzZVxuICB0aGlzLl9jcml0aWNhbExlbmd0aCA9IE1hdGgubWluKCgxMDI0ICogMTAyNCAvIHBpZWNlTGVuZ3RoKSB8IDAsIDIpXG59XG5cbkZpbGVTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcmVhZGluZykgcmV0dXJuXG4gIHRoaXMuX3JlYWRpbmcgPSB0cnVlXG4gIHRoaXMuX25vdGlmeSgpXG59XG5cbkZpbGVTdHJlYW0ucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghc2VsZi5fcmVhZGluZyB8fCBzZWxmLl9taXNzaW5nID09PSAwKSByZXR1cm5cbiAgaWYgKCFzZWxmLl90b3JyZW50LmJpdGZpZWxkLmdldChzZWxmLl9waWVjZSkpIHtcbiAgICByZXR1cm4gc2VsZi5fdG9ycmVudC5jcml0aWNhbChzZWxmLl9waWVjZSwgc2VsZi5fcGllY2UgKyBzZWxmLl9jcml0aWNhbExlbmd0aClcbiAgfVxuXG4gIGlmIChzZWxmLl9ub3RpZnlpbmcpIHJldHVyblxuICBzZWxmLl9ub3RpZnlpbmcgPSB0cnVlXG5cbiAgdmFyIHAgPSBzZWxmLl9waWVjZVxuICBzZWxmLl90b3JyZW50LnN0b3JlLmdldChwLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcbiAgICBzZWxmLl9ub3RpZnlpbmcgPSBmYWxzZVxuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGVycikgcmV0dXJuIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICAgIGRlYnVnKCdyZWFkICVzIChsZW5ndGggJXMpIChlcnIgJXMpJywgcCwgYnVmZmVyLmxlbmd0aCwgZXJyICYmIGVyci5tZXNzYWdlKVxuXG4gICAgaWYgKHNlbGYuX29mZnNldCkge1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKHNlbGYuX29mZnNldClcbiAgICAgIHNlbGYuX29mZnNldCA9IDBcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fbWlzc2luZyA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBzZWxmLl9taXNzaW5nKVxuICAgIH1cbiAgICBzZWxmLl9taXNzaW5nIC09IGJ1ZmZlci5sZW5ndGhcblxuICAgIGRlYnVnKCdwdXNoaW5nIGJ1ZmZlciBvZiBsZW5ndGggJXMnLCBidWZmZXIubGVuZ3RoKVxuICAgIHNlbGYuX3JlYWRpbmcgPSBmYWxzZVxuICAgIHNlbGYucHVzaChidWZmZXIpXG5cbiAgICBpZiAoc2VsZi5fbWlzc2luZyA9PT0gMCkgc2VsZi5wdXNoKG51bGwpXG4gIH0pXG4gIHNlbGYuX3BpZWNlICs9IDFcbn1cblxuRmlsZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvbmNsb3NlKSB7XG4gIHRoaXMuX2Rlc3Ryb3kobnVsbCwgb25jbG9zZSlcbn1cblxuRmlsZVN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBvbmNsb3NlKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIGlmICghdGhpcy5fdG9ycmVudC5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl90b3JyZW50LmRlc2VsZWN0KHRoaXMuX3N0YXJ0UGllY2UsIHRoaXMuX2VuZFBpZWNlLCB0cnVlKVxuICB9XG5cbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG4gIGlmIChvbmNsb3NlKSBvbmNsb3NlKClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gRmlsZVxuXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgRmlsZVN0cmVhbSA9IHJlcXVpcmUoJy4vZmlsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciByZW5kZXIgPSByZXF1aXJlKCdyZW5kZXItbWVkaWEnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgc3RyZWFtVG9CbG9iVVJMID0gcmVxdWlyZSgnc3RyZWFtLXRvLWJsb2ItdXJsJylcbnZhciBzdHJlYW1Ub0J1ZmZlciA9IHJlcXVpcmUoJ3N0cmVhbS13aXRoLWtub3duLWxlbmd0aC10by1idWZmZXInKVxuXG5pbmhlcml0cyhGaWxlLCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIEZpbGUgKHRvcnJlbnQsIGZpbGUpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICB0aGlzLl90b3JyZW50ID0gdG9ycmVudFxuICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIHRoaXMubmFtZSA9IGZpbGUubmFtZVxuICB0aGlzLnBhdGggPSBmaWxlLnBhdGhcbiAgdGhpcy5sZW5ndGggPSBmaWxlLmxlbmd0aFxuICB0aGlzLm9mZnNldCA9IGZpbGUub2Zmc2V0XG5cbiAgdGhpcy5kb25lID0gZmFsc2VcblxuICB2YXIgc3RhcnQgPSBmaWxlLm9mZnNldFxuICB2YXIgZW5kID0gc3RhcnQgKyBmaWxlLmxlbmd0aCAtIDFcblxuICB0aGlzLl9zdGFydFBpZWNlID0gc3RhcnQgLyB0aGlzLl90b3JyZW50LnBpZWNlTGVuZ3RoIHwgMFxuICB0aGlzLl9lbmRQaWVjZSA9IGVuZCAvIHRoaXMuX3RvcnJlbnQucGllY2VMZW5ndGggfCAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5kb25lID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgnZG9uZScpXG4gIH1cbn1cblxuRmlsZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIHRoaXMuX3RvcnJlbnQuc2VsZWN0KHRoaXMuX3N0YXJ0UGllY2UsIHRoaXMuX2VuZFBpZWNlLCBwcmlvcml0eSlcbn1cblxuRmlsZS5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIHRoaXMuX3RvcnJlbnQuZGVzZWxlY3QodGhpcy5fc3RhcnRQaWVjZSwgdGhpcy5fZW5kUGllY2UsIGZhbHNlKVxufVxuXG5GaWxlLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBlbXB0eSA9IG5ldyBzdHJlYW0uUGFzc1Rocm91Z2goKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgZW1wdHkuZW5kKClcbiAgICB9KVxuICAgIHJldHVybiBlbXB0eVxuICB9XG5cbiAgdmFyIGZpbGVTdHJlYW0gPSBuZXcgRmlsZVN0cmVhbShzZWxmLCBvcHRzKVxuICBzZWxmLl90b3JyZW50LnNlbGVjdChmaWxlU3RyZWFtLl9zdGFydFBpZWNlLCBmaWxlU3RyZWFtLl9lbmRQaWVjZSwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuICAgIGZpbGVTdHJlYW0uX25vdGlmeSgpXG4gIH0pXG4gIGVvcyhmaWxlU3RyZWFtLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKCFzZWxmLl90b3JyZW50LmRlc3Ryb3llZCkge1xuICAgICAgc2VsZi5fdG9ycmVudC5kZXNlbGVjdChmaWxlU3RyZWFtLl9zdGFydFBpZWNlLCBmaWxlU3RyZWFtLl9lbmRQaWVjZSwgdHJ1ZSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWxlU3RyZWFtXG59XG5cbkZpbGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIChjYikge1xuICBzdHJlYW1Ub0J1ZmZlcih0aGlzLmNyZWF0ZVJlYWRTdHJlYW0oKSwgdGhpcy5sZW5ndGgsIGNiKVxufVxuXG5GaWxlLnByb3RvdHlwZS5nZXRCbG9iVVJMID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdicm93c2VyLW9ubHkgbWV0aG9kJylcbiAgdmFyIG1pbWUgPSByZW5kZXIubWltZVtwYXRoLmV4dG5hbWUodGhpcy5uYW1lKS50b0xvd2VyQ2FzZSgpXVxuICBzdHJlYW1Ub0Jsb2JVUkwodGhpcy5jcmVhdGVSZWFkU3RyZWFtKCksIG1pbWUsIGNiKVxufVxuXG5GaWxlLnByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uIChlbGVtLCBjYikge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYnJvd3Nlci1vbmx5IG1ldGhvZCcpXG4gIHJlbmRlci5hcHBlbmQodGhpcywgZWxlbSwgY2IpXG59XG5cbkZpbGUucHJvdG90eXBlLnJlbmRlclRvID0gZnVuY3Rpb24gKGVsZW0sIGNiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdicm93c2VyLW9ubHkgbWV0aG9kJylcbiAgcmVuZGVyLnJlbmRlcih0aGlzLCBlbGVtLCBjYilcbn1cblxuRmlsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5fdG9ycmVudCA9IG51bGxcbn1cbiIsInZhciBhcnJheVJlbW92ZSA9IHJlcXVpcmUoJ3Vub3JkZXJlZC1hcnJheS1yZW1vdmUnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2VidG9ycmVudDpwZWVyJylcbnZhciBXaXJlID0gcmVxdWlyZSgnYml0dG9ycmVudC1wcm90b2NvbCcpXG5cbnZhciBXZWJDb25uID0gcmVxdWlyZSgnLi93ZWJjb25uJylcblxudmFyIENPTk5FQ1RfVElNRU9VVF9UQ1AgPSA1MDAwXG52YXIgQ09OTkVDVF9USU1FT1VUX1dFQlJUQyA9IDI1MDAwXG52YXIgSEFORFNIQUtFX1RJTUVPVVQgPSAyNTAwMFxuXG4vKipcbiAqIFdlYlJUQyBwZWVyIGNvbm5lY3Rpb25zIHN0YXJ0IG91dCBjb25uZWN0ZWQsIGJlY2F1c2UgV2ViUlRDIHBlZXJzIHJlcXVpcmUgYW5cbiAqIFwiaW50cm9kdWN0aW9uXCIgKGkuZS4gV2ViUlRDIHNpZ25hbGluZyksIGFuZCB0aGVyZSdzIG5vIGVxdWl2YWxlbnQgdG8gYW4gSVAgYWRkcmVzc1xuICogdGhhdCBsZXRzIHlvdSByZWZlciB0byBhIFdlYlJUQyBlbmRwb2ludC5cbiAqL1xuZXhwb3J0cy5jcmVhdGVXZWJSVENQZWVyID0gZnVuY3Rpb24gKGNvbm4sIHN3YXJtKSB7XG4gIHZhciBwZWVyID0gbmV3IFBlZXIoY29ubi5pZCwgJ3dlYnJ0YycpXG4gIHBlZXIuY29ubiA9IGNvbm5cbiAgcGVlci5zd2FybSA9IHN3YXJtXG5cbiAgaWYgKHBlZXIuY29ubi5jb25uZWN0ZWQpIHtcbiAgICBwZWVyLm9uQ29ubmVjdCgpXG4gIH0gZWxzZSB7XG4gICAgcGVlci5jb25uLm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7IHBlZXIub25Db25uZWN0KCkgfSlcbiAgICBwZWVyLmNvbm4ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IHBlZXIuZGVzdHJveShlcnIpIH0pXG4gICAgcGVlci5zdGFydENvbm5lY3RUaW1lb3V0KClcbiAgfVxuXG4gIHJldHVybiBwZWVyXG59XG5cbi8qKlxuICogSW5jb21pbmcgVENQIHBlZXJzIHN0YXJ0IG91dCBjb25uZWN0ZWQsIGJlY2F1c2UgdGhlIHJlbW90ZSBwZWVyIGNvbm5lY3RlZCB0byB0aGVcbiAqIGxpc3RlbmluZyBwb3J0IG9mIHRoZSBUQ1Agc2VydmVyLiBVbnRpbCB0aGUgcmVtb3RlIHBlZXIgc2VuZHMgYSBoYW5kc2hha2UsIHdlIGRvbid0XG4gKiBrbm93IHdoYXQgc3dhcm0gdGhlIGNvbm5lY3Rpb24gaXMgaW50ZW5kZWQgZm9yLlxuICovXG5leHBvcnRzLmNyZWF0ZVRDUEluY29taW5nUGVlciA9IGZ1bmN0aW9uIChjb25uKSB7XG4gIHZhciBhZGRyID0gY29ubi5yZW1vdGVBZGRyZXNzICsgJzonICsgY29ubi5yZW1vdGVQb3J0XG4gIHZhciBwZWVyID0gbmV3IFBlZXIoYWRkciwgJ3RjcEluY29taW5nJylcbiAgcGVlci5jb25uID0gY29ublxuICBwZWVyLmFkZHIgPSBhZGRyXG5cbiAgcGVlci5vbkNvbm5lY3QoKVxuXG4gIHJldHVybiBwZWVyXG59XG5cbi8qKlxuICogT3V0Z29pbmcgVENQIHBlZXJzIHN0YXJ0IG91dCB3aXRoIGp1c3QgYW4gSVAgYWRkcmVzcy4gQXQgc29tZSBwb2ludCAod2hlbiB0aGVyZSBpcyBhblxuICogYXZhaWxhYmxlIGNvbm5lY3Rpb24pLCB0aGUgY2xpZW50IGNhbiBhdHRlbXB0IHRvIGNvbm5lY3QgdG8gdGhlIGFkZHJlc3MuXG4gKi9cbmV4cG9ydHMuY3JlYXRlVENQT3V0Z29pbmdQZWVyID0gZnVuY3Rpb24gKGFkZHIsIHN3YXJtKSB7XG4gIHZhciBwZWVyID0gbmV3IFBlZXIoYWRkciwgJ3RjcE91dGdvaW5nJylcbiAgcGVlci5hZGRyID0gYWRkclxuICBwZWVyLnN3YXJtID0gc3dhcm1cblxuICByZXR1cm4gcGVlclxufVxuXG4vKipcbiAqIFBlZXIgdGhhdCByZXByZXNlbnRzIGEgV2ViIFNlZWQgKEJFUDE3IC8gQkVQMTkpLlxuICovXG5leHBvcnRzLmNyZWF0ZVdlYlNlZWRQZWVyID0gZnVuY3Rpb24gKHVybCwgc3dhcm0pIHtcbiAgdmFyIHBlZXIgPSBuZXcgUGVlcih1cmwsICd3ZWJTZWVkJylcbiAgcGVlci5zd2FybSA9IHN3YXJtXG4gIHBlZXIuY29ubiA9IG5ldyBXZWJDb25uKHVybCwgc3dhcm0pXG5cbiAgcGVlci5vbkNvbm5lY3QoKVxuXG4gIHJldHVybiBwZWVyXG59XG5cbi8qKlxuICogUGVlci4gUmVwcmVzZW50cyBhIHBlZXIgaW4gdGhlIHRvcnJlbnQgc3dhcm0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFwiaXA6cG9ydFwiIHN0cmluZywgcGVlciBpZCAoZm9yIFdlYlJUQyBwZWVycyksIG9yIHVybCAoZm9yIFdlYiBTZWVkcylcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBwZWVyXG4gKi9cbmZ1bmN0aW9uIFBlZXIgKGlkLCB0eXBlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLmlkID0gaWRcbiAgc2VsZi50eXBlID0gdHlwZVxuXG4gIGRlYnVnKCduZXcgUGVlciAlcycsIGlkKVxuXG4gIHNlbGYuYWRkciA9IG51bGxcbiAgc2VsZi5jb25uID0gbnVsbFxuICBzZWxmLnN3YXJtID0gbnVsbFxuICBzZWxmLndpcmUgPSBudWxsXG5cbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHNlbGYudGltZW91dCA9IG51bGwgLy8gaGFuZHNoYWtlIHRpbWVvdXRcbiAgc2VsZi5yZXRyaWVzID0gMCAvLyBvdXRnb2luZyBUQ1AgY29ubmVjdGlvbiByZXRyeSBjb3VudFxuXG4gIHNlbGYuc2VudEhhbmRzaGFrZSA9IGZhbHNlXG59XG5cbi8qKlxuICogQ2FsbGVkIG9uY2UgdGhlIHBlZXIgaXMgY29ubmVjdGVkIChpLmUuIGZpcmVkICdjb25uZWN0JyBldmVudClcbiAqIEBwYXJhbSB7U29ja2V0fSBjb25uXG4gKi9cblBlZXIucHJvdG90eXBlLm9uQ29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuY29ubmVjdGVkID0gdHJ1ZVxuXG4gIGRlYnVnKCdQZWVyICVzIGNvbm5lY3RlZCcsIHNlbGYuaWQpXG5cbiAgY2xlYXJUaW1lb3V0KHNlbGYuY29ubmVjdFRpbWVvdXQpXG5cbiAgdmFyIGNvbm4gPSBzZWxmLmNvbm5cbiAgY29ubi5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgY29ubi5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICBjb25uLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICBjb25uLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZGVzdHJveShlcnIpXG4gIH0pXG5cbiAgdmFyIHdpcmUgPSBzZWxmLndpcmUgPSBuZXcgV2lyZSgpXG4gIHdpcmUudHlwZSA9IHNlbGYudHlwZVxuICB3aXJlLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICB3aXJlLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveSgpXG4gIH0pXG4gIHdpcmUub25jZSgnZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveSgpXG4gIH0pXG4gIHdpcmUub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5kZXN0cm95KGVycilcbiAgfSlcblxuICB3aXJlLm9uY2UoJ2hhbmRzaGFrZScsIGZ1bmN0aW9uIChpbmZvSGFzaCwgcGVlcklkKSB7XG4gICAgc2VsZi5vbkhhbmRzaGFrZShpbmZvSGFzaCwgcGVlcklkKVxuICB9KVxuICBzZWxmLnN0YXJ0SGFuZHNoYWtlVGltZW91dCgpXG5cbiAgY29ubi5waXBlKHdpcmUpLnBpcGUoY29ubilcbiAgaWYgKHNlbGYuc3dhcm0gJiYgIXNlbGYuc2VudEhhbmRzaGFrZSkgc2VsZi5oYW5kc2hha2UoKVxufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuIGhhbmRzaGFrZSBpcyByZWNlaXZlZCBmcm9tIHJlbW90ZSBwZWVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGluZm9IYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVlcklkXG4gKi9cblBlZXIucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGluZm9IYXNoLCBwZWVySWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5zd2FybSkgcmV0dXJuIC8vIGBzZWxmLnN3YXJtYCBub3Qgc2V0IHlldCwgc28gZG8gbm90aGluZ1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmIChzZWxmLnN3YXJtLmRlc3Ryb3llZCkge1xuICAgIHJldHVybiBzZWxmLmRlc3Ryb3kobmV3IEVycm9yKCdzd2FybSBhbHJlYWR5IGRlc3Ryb3llZCcpKVxuICB9XG4gIGlmIChpbmZvSGFzaCAhPT0gc2VsZi5zd2FybS5pbmZvSGFzaCkge1xuICAgIHJldHVybiBzZWxmLmRlc3Ryb3kobmV3IEVycm9yKCd1bmV4cGVjdGVkIGhhbmRzaGFrZSBpbmZvIGhhc2ggZm9yIHRoaXMgc3dhcm0nKSlcbiAgfVxuICBpZiAocGVlcklkID09PSBzZWxmLnN3YXJtLnBlZXJJZCkge1xuICAgIHJldHVybiBzZWxmLmRlc3Ryb3kobmV3IEVycm9yKCdyZWZ1c2luZyB0byBjb25uZWN0IHRvIG91cnNlbHZlcycpKVxuICB9XG5cbiAgZGVidWcoJ1BlZXIgJXMgZ290IGhhbmRzaGFrZSAlcycsIHNlbGYuaWQsIGluZm9IYXNoKVxuXG4gIGNsZWFyVGltZW91dChzZWxmLmhhbmRzaGFrZVRpbWVvdXQpXG5cbiAgc2VsZi5yZXRyaWVzID0gMFxuXG4gIHZhciBhZGRyID0gc2VsZi5hZGRyXG4gIGlmICghYWRkciAmJiBzZWxmLmNvbm4ucmVtb3RlQWRkcmVzcykge1xuICAgIGFkZHIgPSBzZWxmLmNvbm4ucmVtb3RlQWRkcmVzcyArICc6JyArIHNlbGYuY29ubi5yZW1vdGVQb3J0XG4gIH1cbiAgc2VsZi5zd2FybS5fb25XaXJlKHNlbGYud2lyZSwgYWRkcilcblxuICAvLyBzd2FybSBjb3VsZCBiZSBkZXN0cm95ZWQgaW4gdXNlcidzICd3aXJlJyBldmVudCBoYW5kbGVyXG4gIGlmICghc2VsZi5zd2FybSB8fCBzZWxmLnN3YXJtLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgaWYgKCFzZWxmLnNlbnRIYW5kc2hha2UpIHNlbGYuaGFuZHNoYWtlKClcbn1cblxuUGVlci5wcm90b3R5cGUuaGFuZHNoYWtlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIG9wdHMgPSB7XG4gICAgZGh0OiBzZWxmLnN3YXJtLnByaXZhdGUgPyBmYWxzZSA6ICEhc2VsZi5zd2FybS5jbGllbnQuZGh0XG4gIH1cbiAgc2VsZi53aXJlLmhhbmRzaGFrZShzZWxmLnN3YXJtLmluZm9IYXNoLCBzZWxmLnN3YXJtLmNsaWVudC5wZWVySWQsIG9wdHMpXG4gIHNlbGYuc2VudEhhbmRzaGFrZSA9IHRydWVcbn1cblxuUGVlci5wcm90b3R5cGUuc3RhcnRDb25uZWN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGNsZWFyVGltZW91dChzZWxmLmNvbm5lY3RUaW1lb3V0KVxuICBzZWxmLmNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KG5ldyBFcnJvcignY29ubmVjdCB0aW1lb3V0JykpXG4gIH0sIHNlbGYudHlwZSA9PT0gJ3dlYnJ0YycgPyBDT05ORUNUX1RJTUVPVVRfV0VCUlRDIDogQ09OTkVDVF9USU1FT1VUX1RDUClcbiAgaWYgKHNlbGYuY29ubmVjdFRpbWVvdXQudW5yZWYpIHNlbGYuY29ubmVjdFRpbWVvdXQudW5yZWYoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5zdGFydEhhbmRzaGFrZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBjbGVhclRpbWVvdXQoc2VsZi5oYW5kc2hha2VUaW1lb3V0KVxuICBzZWxmLmhhbmRzaGFrZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3kobmV3IEVycm9yKCdoYW5kc2hha2UgdGltZW91dCcpKVxuICB9LCBIQU5EU0hBS0VfVElNRU9VVClcbiAgaWYgKHNlbGYuaGFuZHNoYWtlVGltZW91dC51bnJlZikgc2VsZi5oYW5kc2hha2VUaW1lb3V0LnVucmVmKClcbn1cblxuUGVlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgZGVidWcoJ2Rlc3Ryb3kgJXMgKGVycm9yOiAlcyknLCBzZWxmLmlkLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgY2xlYXJUaW1lb3V0KHNlbGYuY29ubmVjdFRpbWVvdXQpXG4gIGNsZWFyVGltZW91dChzZWxmLmhhbmRzaGFrZVRpbWVvdXQpXG5cbiAgdmFyIHN3YXJtID0gc2VsZi5zd2FybVxuICB2YXIgY29ubiA9IHNlbGYuY29ublxuICB2YXIgd2lyZSA9IHNlbGYud2lyZVxuXG4gIHNlbGYuc3dhcm0gPSBudWxsXG4gIHNlbGYuY29ubiA9IG51bGxcbiAgc2VsZi53aXJlID0gbnVsbFxuXG4gIGlmIChzd2FybSAmJiB3aXJlKSB7XG4gICAgYXJyYXlSZW1vdmUoc3dhcm0ud2lyZXMsIHN3YXJtLndpcmVzLmluZGV4T2Yod2lyZSkpXG4gIH1cbiAgaWYgKGNvbm4pIHtcbiAgICBjb25uLm9uKCdlcnJvcicsIG5vb3ApXG4gICAgY29ubi5kZXN0cm95KClcbiAgfVxuICBpZiAod2lyZSkgd2lyZS5kZXN0cm95KClcbiAgaWYgKHN3YXJtKSBzd2FybS5yZW1vdmVQZWVyKHNlbGYuaWQpXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsIm1vZHVsZS5leHBvcnRzID0gUmFyaXR5TWFwXG5cbi8qKlxuICogTWFwcGluZyBvZiB0b3JyZW50IHBpZWNlcyB0byB0aGVpciByZXNwZWN0aXZlIGF2YWlsYWJpbGl0eSBpbiB0aGUgdG9ycmVudCBzd2FybS4gVXNlZFxuICogYnkgdGhlIHRvcnJlbnQgbWFuYWdlciBmb3IgaW1wbGVtZW50aW5nIHRoZSByYXJlc3QgcGllY2UgZmlyc3Qgc2VsZWN0aW9uIHN0cmF0ZWd5LlxuICovXG5mdW5jdGlvbiBSYXJpdHlNYXAgKHRvcnJlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fdG9ycmVudCA9IHRvcnJlbnRcbiAgc2VsZi5fbnVtUGllY2VzID0gdG9ycmVudC5waWVjZXMubGVuZ3RoXG4gIHNlbGYuX3BpZWNlcyA9IFtdXG5cbiAgc2VsZi5fb25XaXJlID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgICBzZWxmLnJlY2FsY3VsYXRlKClcbiAgICBzZWxmLl9pbml0V2lyZSh3aXJlKVxuICB9XG4gIHNlbGYuX29uV2lyZUhhdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBzZWxmLl9waWVjZXNbaW5kZXhdICs9IDFcbiAgfVxuICBzZWxmLl9vbldpcmVCaXRmaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnJlY2FsY3VsYXRlKClcbiAgfVxuXG4gIHNlbGYuX3RvcnJlbnQud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIHNlbGYuX2luaXRXaXJlKHdpcmUpXG4gIH0pXG4gIHNlbGYuX3RvcnJlbnQub24oJ3dpcmUnLCBzZWxmLl9vbldpcmUpXG4gIHNlbGYucmVjYWxjdWxhdGUoKVxufVxuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgdGhlIHJhcmVzdCBwaWVjZS4gT3B0aW9uYWxseSwgcGFzcyBhIGZpbHRlciBmdW5jdGlvbiB0byBleGNsdWRlXG4gKiBjZXJ0YWluIHBpZWNlcyAoZm9yIGluc3RhbmNlLCB0aG9zZSB0aGF0IHdlIGFscmVhZHkgaGF2ZSkuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcGllY2VGaWx0ZXJGdW5jXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGluZGV4IG9mIHJhcmVzdCBwaWVjZSwgb3IgLTFcbiAqL1xuUmFyaXR5TWFwLnByb3RvdHlwZS5nZXRSYXJlc3RQaWVjZSA9IGZ1bmN0aW9uIChwaWVjZUZpbHRlckZ1bmMpIHtcbiAgaWYgKCFwaWVjZUZpbHRlckZ1bmMpIHBpZWNlRmlsdGVyRnVuYyA9IHRydWVGblxuXG4gIHZhciBjYW5kaWRhdGVzID0gW11cbiAgdmFyIG1pbiA9IEluZmluaXR5XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9udW1QaWVjZXM7ICsraSkge1xuICAgIGlmICghcGllY2VGaWx0ZXJGdW5jKGkpKSBjb250aW51ZVxuXG4gICAgdmFyIGF2YWlsYWJpbGl0eSA9IHRoaXMuX3BpZWNlc1tpXVxuICAgIGlmIChhdmFpbGFiaWxpdHkgPT09IG1pbikge1xuICAgICAgY2FuZGlkYXRlcy5wdXNoKGkpXG4gICAgfSBlbHNlIGlmIChhdmFpbGFiaWxpdHkgPCBtaW4pIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBbIGkgXVxuICAgICAgbWluID0gYXZhaWxhYmlsaXR5XG4gICAgfVxuICB9XG5cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgIC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBwaWVjZXMgd2l0aCB0aGUgc2FtZSBhdmFpbGFiaWxpdHksIGNob29zZSBvbmUgcmFuZG9tbHlcbiAgICByZXR1cm4gY2FuZGlkYXRlc1tNYXRoLnJhbmRvbSgpICogY2FuZGlkYXRlcy5sZW5ndGggfCAwXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMVxuICB9XG59XG5cblJhcml0eU1hcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX3RvcnJlbnQucmVtb3ZlTGlzdGVuZXIoJ3dpcmUnLCBzZWxmLl9vbldpcmUpXG4gIHNlbGYuX3RvcnJlbnQud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIHNlbGYuX2NsZWFudXBXaXJlRXZlbnRzKHdpcmUpXG4gIH0pXG4gIHNlbGYuX3RvcnJlbnQgPSBudWxsXG4gIHNlbGYuX3BpZWNlcyA9IG51bGxcblxuICBzZWxmLl9vbldpcmUgPSBudWxsXG4gIHNlbGYuX29uV2lyZUhhdmUgPSBudWxsXG4gIHNlbGYuX29uV2lyZUJpdGZpZWxkID0gbnVsbFxufVxuXG5SYXJpdHlNYXAucHJvdG90eXBlLl9pbml0V2lyZSA9IGZ1bmN0aW9uICh3aXJlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHdpcmUuX29uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fY2xlYW51cFdpcmVFdmVudHMod2lyZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX251bVBpZWNlczsgKytpKSB7XG4gICAgICBzZWxmLl9waWVjZXNbaV0gLT0gd2lyZS5wZWVyUGllY2VzLmdldChpKVxuICAgIH1cbiAgfVxuXG4gIHdpcmUub24oJ2hhdmUnLCBzZWxmLl9vbldpcmVIYXZlKVxuICB3aXJlLm9uKCdiaXRmaWVsZCcsIHNlbGYuX29uV2lyZUJpdGZpZWxkKVxuICB3aXJlLm9uY2UoJ2Nsb3NlJywgd2lyZS5fb25DbG9zZSlcbn1cblxuLyoqXG4gKiBSZWNhbGN1bGF0ZXMgcGllY2UgYXZhaWxhYmlsaXR5IGFjcm9zcyBhbGwgcGVlcnMgaW4gdGhlIHRvcnJlbnQuXG4gKi9cblJhcml0eU1hcC5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9udW1QaWVjZXM7ICsraSkge1xuICAgIHRoaXMuX3BpZWNlc1tpXSA9IDBcbiAgfVxuXG4gIHZhciBudW1XaXJlcyA9IHRoaXMuX3RvcnJlbnQud2lyZXMubGVuZ3RoXG4gIGZvciAoaSA9IDA7IGkgPCBudW1XaXJlczsgKytpKSB7XG4gICAgdmFyIHdpcmUgPSB0aGlzLl90b3JyZW50LndpcmVzW2ldXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9udW1QaWVjZXM7ICsraikge1xuICAgICAgdGhpcy5fcGllY2VzW2pdICs9IHdpcmUucGVlclBpZWNlcy5nZXQoailcbiAgICB9XG4gIH1cbn1cblxuUmFyaXR5TWFwLnByb3RvdHlwZS5fY2xlYW51cFdpcmVFdmVudHMgPSBmdW5jdGlvbiAod2lyZSkge1xuICB3aXJlLnJlbW92ZUxpc3RlbmVyKCdoYXZlJywgdGhpcy5fb25XaXJlSGF2ZSlcbiAgd2lyZS5yZW1vdmVMaXN0ZW5lcignYml0ZmllbGQnLCB0aGlzLl9vbldpcmVCaXRmaWVsZClcbiAgaWYgKHdpcmUuX29uQ2xvc2UpIHdpcmUucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgd2lyZS5fb25DbG9zZSlcbiAgd2lyZS5fb25DbG9zZSA9IG51bGxcbn1cblxuZnVuY3Rpb24gdHJ1ZUZuICgpIHtcbiAgcmV0dXJuIHRydWVcbn1cbiIsIi8qIGdsb2JhbCBVUkwsIEJsb2IgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUb3JyZW50XG5cbnZhciBhZGRyVG9JUFBvcnQgPSByZXF1aXJlKCdhZGRyLXRvLWlwLXBvcnQnKVxudmFyIEJpdEZpZWxkID0gcmVxdWlyZSgnYml0ZmllbGQnKVxudmFyIENodW5rU3RvcmVXcml0ZVN0cmVhbSA9IHJlcXVpcmUoJ2NodW5rLXN0b3JlLXN0cmVhbS93cml0ZScpXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJ0b3JyZW50OnRvcnJlbnQnKVxudmFyIERpc2NvdmVyeSA9IHJlcXVpcmUoJ3RvcnJlbnQtZGlzY292ZXJ5JylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgZXh0ZW5kTXV0YWJsZSA9IHJlcXVpcmUoJ3h0ZW5kL211dGFibGUnKVxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIEZTQ2h1bmtTdG9yZSA9IHJlcXVpcmUoJ2ZzLWNodW5rLXN0b3JlJykgLy8gYnJvd3NlcjogYG1lbW9yeS1jaHVuay1zdG9yZWBcbnZhciBnZXQgPSByZXF1aXJlKCdzaW1wbGUtZ2V0JylcbnZhciBJbW1lZGlhdGVDaHVua1N0b3JlID0gcmVxdWlyZSgnaW1tZWRpYXRlLWNodW5rLXN0b3JlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBNdWx0aVN0cmVhbSA9IHJlcXVpcmUoJ211bHRpc3RyZWFtJylcbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBvcyA9IHJlcXVpcmUoJ29zJykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxudmFyIHBhcmFsbGVsTGltaXQgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwtbGltaXQnKVxudmFyIHBhcnNlVG9ycmVudCA9IHJlcXVpcmUoJ3BhcnNlLXRvcnJlbnQnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBQaWVjZSA9IHJlcXVpcmUoJ3RvcnJlbnQtcGllY2UnKVxudmFyIHB1bXAgPSByZXF1aXJlKCdwdW1wJylcbnZhciByYW5kb21JdGVyYXRlID0gcmVxdWlyZSgncmFuZG9tLWl0ZXJhdGUnKVxudmFyIHNoYTEgPSByZXF1aXJlKCdzaW1wbGUtc2hhMScpXG52YXIgc3BlZWRvbWV0ZXIgPSByZXF1aXJlKCdzcGVlZG9tZXRlcicpXG52YXIgdW5pcSA9IHJlcXVpcmUoJ3VuaXEnKVxudmFyIHV0TWV0YWRhdGEgPSByZXF1aXJlKCd1dF9tZXRhZGF0YScpXG52YXIgdXRQZXggPSByZXF1aXJlKCd1dF9wZXgnKSAvLyBicm93c2VyIGV4Y2x1ZGVcblxudmFyIEZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKVxudmFyIFBlZXIgPSByZXF1aXJlKCcuL3BlZXInKVxudmFyIFJhcml0eU1hcCA9IHJlcXVpcmUoJy4vcmFyaXR5LW1hcCcpXG52YXIgU2VydmVyID0gcmVxdWlyZSgnLi9zZXJ2ZXInKSAvLyBicm93c2VyIGV4Y2x1ZGVcblxudmFyIE1BWF9CTE9DS19MRU5HVEggPSAxMjggKiAxMDI0XG52YXIgUElFQ0VfVElNRU9VVCA9IDMwMDAwXG52YXIgQ0hPS0VfVElNRU9VVCA9IDUwMDBcbnZhciBTUEVFRF9USFJFU0hPTEQgPSAzICogUGllY2UuQkxPQ0tfTEVOR1RIXG5cbnZhciBQSVBFTElORV9NSU5fRFVSQVRJT04gPSAwLjVcbnZhciBQSVBFTElORV9NQVhfRFVSQVRJT04gPSAxXG5cbnZhciBSRUNIT0tFX0lOVEVSVkFMID0gMTAwMDAgLy8gMTAgc2Vjb25kc1xudmFyIFJFQ0hPS0VfT1BUSU1JU1RJQ19EVVJBVElPTiA9IDIgLy8gMzAgc2Vjb25kc1xuXG52YXIgRklMRVNZU1RFTV9DT05DVVJSRU5DWSA9IDJcblxudmFyIFJFQ09OTkVDVF9XQUlUID0gWyAxMDAwLCA1MDAwLCAxNTAwMCBdXG5cbnZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG52YXIgVE1QXG50cnkge1xuICBUTVAgPSBwYXRoLmpvaW4oZnMuc3RhdFN5bmMoJy90bXAnKSAmJiAnL3RtcCcsICd3ZWJ0b3JyZW50Jylcbn0gY2F0Y2ggKGVycikge1xuICBUTVAgPSBwYXRoLmpvaW4odHlwZW9mIG9zLnRtcERpciA9PT0gJ2Z1bmN0aW9uJyA/IG9zLnRtcERpcigpIDogJy8nLCAnd2VidG9ycmVudCcpXG59XG5cbmluaGVyaXRzKFRvcnJlbnQsIEV2ZW50RW1pdHRlcilcblxuZnVuY3Rpb24gVG9ycmVudCAodG9ycmVudElkLCBjbGllbnQsIG9wdHMpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLl9kZWJ1Z0lkID0gdGhpcy5jbGllbnQucGVlcklkLnNsaWNlKDMyKVxuXG4gIHRoaXMuX2RlYnVnKCduZXcgdG9ycmVudCcpXG5cbiAgdGhpcy5hbm5vdW5jZSA9IG9wdHMuYW5ub3VuY2VcbiAgdGhpcy51cmxMaXN0ID0gb3B0cy51cmxMaXN0XG5cbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoXG4gIHRoaXMuX3N0b3JlID0gb3B0cy5zdG9yZSB8fCBGU0NodW5rU3RvcmVcbiAgdGhpcy5fZ2V0QW5ub3VuY2VPcHRzID0gb3B0cy5nZXRBbm5vdW5jZU9wdHNcblxuICB0aGlzLnN0cmF0ZWd5ID0gb3B0cy5zdHJhdGVneSB8fCAnc2VxdWVudGlhbCdcblxuICB0aGlzLm1heFdlYkNvbm5zID0gb3B0cy5tYXhXZWJDb25ucyB8fCA0XG5cbiAgdGhpcy5fcmVjaG9rZU51bVNsb3RzID0gKG9wdHMudXBsb2FkcyA9PT0gZmFsc2UgfHwgb3B0cy51cGxvYWRzID09PSAwKVxuICAgID8gMFxuICAgIDogKCtvcHRzLnVwbG9hZHMgfHwgMTApXG4gIHRoaXMuX3JlY2hva2VPcHRpbWlzdGljV2lyZSA9IG51bGxcbiAgdGhpcy5fcmVjaG9rZU9wdGltaXN0aWNUaW1lID0gMFxuICB0aGlzLl9yZWNob2tlSW50ZXJ2YWxJZCA9IG51bGxcblxuICB0aGlzLnJlYWR5ID0gZmFsc2VcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gIHRoaXMuZG9uZSA9IGZhbHNlXG5cbiAgdGhpcy5tZXRhZGF0YSA9IG51bGxcbiAgdGhpcy5zdG9yZSA9IG51bGxcbiAgdGhpcy5maWxlcyA9IFtdXG4gIHRoaXMucGllY2VzID0gW11cblxuICB0aGlzLl9hbUludGVyZXN0ZWQgPSBmYWxzZVxuICB0aGlzLl9zZWxlY3Rpb25zID0gW11cbiAgdGhpcy5fY3JpdGljYWwgPSBbXVxuXG4gIHRoaXMud2lyZXMgPSBbXSAvLyBvcGVuIHdpcmVzIChhZGRlZCAqYWZ0ZXIqIGhhbmRzaGFrZSlcblxuICB0aGlzLl9xdWV1ZSA9IFtdIC8vIHF1ZXVlIG9mIG91dGdvaW5nIHRjcCBwZWVycyB0byBjb25uZWN0IHRvXG4gIHRoaXMuX3BlZXJzID0ge30gLy8gY29ubmVjdGVkIHBlZXJzIChhZGRyL3BlZXJJZCAtPiBQZWVyKVxuICB0aGlzLl9wZWVyc0xlbmd0aCA9IDAgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIGluIGB0aGlzLl9wZWVyc2AgKGNhY2hlLCBmb3IgcGVyZilcblxuICAvLyBzdGF0c1xuICB0aGlzLnJlY2VpdmVkID0gMFxuICB0aGlzLnVwbG9hZGVkID0gMFxuICB0aGlzLl9kb3dubG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuICB0aGlzLl91cGxvYWRTcGVlZCA9IHNwZWVkb21ldGVyKClcblxuICAvLyBmb3IgY2xlYW51cFxuICB0aGlzLl9zZXJ2ZXJzID0gW11cbiAgdGhpcy5feHNSZXF1ZXN0cyA9IFtdXG5cbiAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgYW5kIGV4cG9zZSBhIGhvb2sgaW5zdGVhZFxuICAvLyBvcHRpbWl6YXRpb246IGRvbid0IHJlY2hlY2sgZXZlcnkgZmlsZSBpZiBpdCBoYXNuJ3QgY2hhbmdlZFxuICB0aGlzLl9maWxlTW9kdGltZXMgPSBvcHRzLmZpbGVNb2R0aW1lc1xuXG4gIGlmICh0b3JyZW50SWQgIT09IG51bGwpIHRoaXMuX29uVG9ycmVudElkKHRvcnJlbnRJZClcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAndGltZVJlbWFpbmluZycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZG9uZSkgcmV0dXJuIDBcbiAgICBpZiAodGhpcy5kb3dubG9hZFNwZWVkID09PSAwKSByZXR1cm4gSW5maW5pdHlcbiAgICByZXR1cm4gKCh0aGlzLmxlbmd0aCAtIHRoaXMuZG93bmxvYWRlZCkgLyB0aGlzLmRvd25sb2FkU3BlZWQpICogMTAwMFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdkb3dubG9hZGVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuYml0ZmllbGQpIHJldHVybiAwXG4gICAgdmFyIGRvd25sb2FkZWQgPSAwXG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW4gPSB0aGlzLnBpZWNlcy5sZW5ndGg7IGluZGV4IDwgbGVuOyArK2luZGV4KSB7XG4gICAgICBpZiAodGhpcy5iaXRmaWVsZC5nZXQoaW5kZXgpKSB7IC8vIHZlcmlmaWVkIGRhdGFcbiAgICAgICAgZG93bmxvYWRlZCArPSAoaW5kZXggPT09IGxlbiAtIDEpID8gdGhpcy5sYXN0UGllY2VMZW5ndGggOiB0aGlzLnBpZWNlTGVuZ3RoXG4gICAgICB9IGVsc2UgeyAvLyBcImluIHByb2dyZXNzXCIgZGF0YVxuICAgICAgICB2YXIgcGllY2UgPSB0aGlzLnBpZWNlc1tpbmRleF1cbiAgICAgICAgZG93bmxvYWRlZCArPSAocGllY2UubGVuZ3RoIC0gcGllY2UubWlzc2luZylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvd25sb2FkZWRcbiAgfVxufSlcblxuLy8gVE9ETzogcmUtZW5hYmxlIHRoaXMuIFRoZSBudW1iZXIgb2YgbWlzc2luZyBwaWVjZXMuIFVzZWQgdG8gaW1wbGVtZW50ICdlbmQgZ2FtZScgbW9kZS5cbi8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yYWdlLnByb3RvdHlwZSwgJ251bU1pc3NpbmcnLCB7XG4vLyAgIGdldDogZnVuY3Rpb24gKCkge1xuLy8gICAgIHZhciBzZWxmID0gdGhpc1xuLy8gICAgIHZhciBudW1NaXNzaW5nID0gc2VsZi5waWVjZXMubGVuZ3RoXG4vLyAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW4gPSBzZWxmLnBpZWNlcy5sZW5ndGg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4vLyAgICAgICBudW1NaXNzaW5nIC09IHNlbGYuYml0ZmllbGQuZ2V0KGluZGV4KVxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gbnVtTWlzc2luZ1xuLy8gICB9XG4vLyB9KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdkb3dubG9hZFNwZWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rvd25sb2FkU3BlZWQoKSB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICd1cGxvYWRTcGVlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl91cGxvYWRTcGVlZCgpIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ3Byb2dyZXNzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubGVuZ3RoID8gdGhpcy5kb3dubG9hZGVkIC8gdGhpcy5sZW5ndGggOiAwIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ3JhdGlvJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXBsb2FkZWQgLyAodGhpcy5yZWNlaXZlZCB8fCAxKSB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdudW1QZWVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndpcmVzLmxlbmd0aCB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICd0b3JyZW50RmlsZUJsb2JVUkwnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdicm93c2VyLW9ubHkgcHJvcGVydHknKVxuICAgIGlmICghdGhpcy50b3JyZW50RmlsZSkgcmV0dXJuIG51bGxcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgIG5ldyBCbG9iKFsgdGhpcy50b3JyZW50RmlsZSBdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi94LWJpdHRvcnJlbnQnIH0pXG4gICAgKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdfbnVtUXVldWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWUubGVuZ3RoICsgKHRoaXMuX3BlZXJzTGVuZ3RoIC0gdGhpcy5fbnVtQ29ubnMpXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ19udW1Db25ucycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIG51bUNvbm5zID0gMFxuICAgIGZvciAodmFyIGlkIGluIHNlbGYuX3BlZXJzKSB7XG4gICAgICBpZiAoc2VsZi5fcGVlcnNbaWRdLmNvbm5lY3RlZCkgbnVtQ29ubnMgKz0gMVxuICAgIH1cbiAgICByZXR1cm4gbnVtQ29ubnNcbiAgfVxufSlcblxuLy8gVE9ETzogcmVtb3ZlIGluIHYxXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdzd2FybScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS53YXJuKCdXZWJUb3JyZW50OiBgdG9ycmVudC5zd2FybWAgaXMgZGVwcmVjYXRlZC4gVXNlIGB0b3JyZW50YCBkaXJlY3RseSBpbnN0ZWFkLicpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufSlcblxuVG9ycmVudC5wcm90b3R5cGUuX29uVG9ycmVudElkID0gZnVuY3Rpb24gKHRvcnJlbnRJZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICB2YXIgcGFyc2VkVG9ycmVudFxuICB0cnkgeyBwYXJzZWRUb3JyZW50ID0gcGFyc2VUb3JyZW50KHRvcnJlbnRJZCkgfSBjYXRjaCAoZXJyKSB7fVxuICBpZiAocGFyc2VkVG9ycmVudCkge1xuICAgIC8vIEF0dGVtcHQgdG8gc2V0IGluZm9IYXNoIHByb3BlcnR5IHN5bmNocm9ub3VzbHlcbiAgICBzZWxmLmluZm9IYXNoID0gcGFyc2VkVG9ycmVudC5pbmZvSGFzaFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIHNlbGYuX29uUGFyc2VkVG9ycmVudChwYXJzZWRUb3JyZW50KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdG9ycmVudElkIGZhaWxlZCB0byBwYXJzZSwgaXQgY291bGQgYmUgaW4gYSBmb3JtIHRoYXQgcmVxdWlyZXMgYW4gYXN5bmNcbiAgICAvLyBvcGVyYXRpb24sIGkuZS4gaHR0cC9odHRwcyBsaW5rLCBmaWxlc3lzdGVtIHBhdGgsIG9yIEJsb2IuXG4gICAgcGFyc2VUb3JyZW50LnJlbW90ZSh0b3JyZW50SWQsIGZ1bmN0aW9uIChlcnIsIHBhcnNlZFRvcnJlbnQpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVzdHJveShlcnIpXG4gICAgICBzZWxmLl9vblBhcnNlZFRvcnJlbnQocGFyc2VkVG9ycmVudClcbiAgICB9KVxuICB9XG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9vblBhcnNlZFRvcnJlbnQgPSBmdW5jdGlvbiAocGFyc2VkVG9ycmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBzZWxmLl9wcm9jZXNzUGFyc2VkVG9ycmVudChwYXJzZWRUb3JyZW50KVxuXG4gIGlmICghc2VsZi5pbmZvSGFzaCkge1xuICAgIHJldHVybiBzZWxmLl9kZXN0cm95KG5ldyBFcnJvcignTWFsZm9ybWVkIHRvcnJlbnQgZGF0YTogTm8gaW5mbyBoYXNoJykpXG4gIH1cblxuICBpZiAoIXNlbGYucGF0aCkgc2VsZi5wYXRoID0gcGF0aC5qb2luKFRNUCwgc2VsZi5pbmZvSGFzaClcblxuICBzZWxmLl9yZWNob2tlSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9yZWNob2tlKClcbiAgfSwgUkVDSE9LRV9JTlRFUlZBTClcbiAgaWYgKHNlbGYuX3JlY2hva2VJbnRlcnZhbElkLnVucmVmKSBzZWxmLl9yZWNob2tlSW50ZXJ2YWxJZC51bnJlZigpXG5cbiAgLy8gUHJpdmF0ZSAnaW5mb0hhc2gnIGV2ZW50IGFsbG93cyBjbGllbnQuYWRkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGUgdG9ycmVudHMgYW5kXG4gIC8vIGRlc3Ryb3kgdGhlbSBiZWZvcmUgdGhlIG5vcm1hbCAnaW5mb0hhc2gnIGV2ZW50IGlzIGVtaXR0ZWQuIFByZXZlbnRzIHVzZXJcbiAgLy8gYXBwbGljYXRpb25zIGZyb20gbmVlZGluZyB0byBkZWFsIHdpdGggZHVwbGljYXRlICdpbmZvSGFzaCcgZXZlbnRzLlxuICBzZWxmLmVtaXQoJ19pbmZvSGFzaCcsIHNlbGYuaW5mb0hhc2gpXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5lbWl0KCdpbmZvSGFzaCcsIHNlbGYuaW5mb0hhc2gpXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIC8vIHVzZXIgbWlnaHQgZGVzdHJveSB0b3JyZW50IGluIGV2ZW50IGhhbmRsZXJcblxuICBpZiAoc2VsZi5jbGllbnQubGlzdGVuaW5nKSB7XG4gICAgc2VsZi5fb25MaXN0ZW5pbmcoKVxuICB9IGVsc2Uge1xuICAgIHNlbGYuY2xpZW50Lm9uY2UoJ2xpc3RlbmluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX29uTGlzdGVuaW5nKClcbiAgICB9KVxuICB9XG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9wcm9jZXNzUGFyc2VkVG9ycmVudCA9IGZ1bmN0aW9uIChwYXJzZWRUb3JyZW50KSB7XG4gIGlmICh0aGlzLmFubm91bmNlKSB7XG4gICAgLy8gQWxsb3cgc3BlY2lmeWluZyB0cmFja2VycyB2aWEgYG9wdHNgIHBhcmFtZXRlclxuICAgIHBhcnNlZFRvcnJlbnQuYW5ub3VuY2UgPSBwYXJzZWRUb3JyZW50LmFubm91bmNlLmNvbmNhdCh0aGlzLmFubm91bmNlKVxuICB9XG5cbiAgaWYgKHRoaXMuY2xpZW50LnRyYWNrZXIgJiYgZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UgJiYgIXRoaXMucHJpdmF0ZSkge1xuICAgIC8vIFNvIGB3ZWJ0b3JyZW50LWh5YnJpZGAgY2FuIGZvcmNlIHNwZWNpZmljIHRyYWNrZXJzIHRvIGJlIHVzZWRcbiAgICBwYXJzZWRUb3JyZW50LmFubm91bmNlID0gcGFyc2VkVG9ycmVudC5hbm5vdW5jZS5jb25jYXQoZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UpXG4gIH1cblxuICBpZiAodGhpcy51cmxMaXN0KSB7XG4gICAgLy8gQWxsb3cgc3BlY2lmeWluZyB3ZWIgc2VlZHMgdmlhIGBvcHRzYCBwYXJhbWV0ZXJcbiAgICBwYXJzZWRUb3JyZW50LnVybExpc3QgPSBwYXJzZWRUb3JyZW50LnVybExpc3QuY29uY2F0KHRoaXMudXJsTGlzdClcbiAgfVxuXG4gIHVuaXEocGFyc2VkVG9ycmVudC5hbm5vdW5jZSlcbiAgdW5pcShwYXJzZWRUb3JyZW50LnVybExpc3QpXG5cbiAgZXh0ZW5kTXV0YWJsZSh0aGlzLCBwYXJzZWRUb3JyZW50KVxuXG4gIHRoaXMubWFnbmV0VVJJID0gcGFyc2VUb3JyZW50LnRvTWFnbmV0VVJJKHBhcnNlZFRvcnJlbnQpXG4gIHRoaXMudG9ycmVudEZpbGUgPSBwYXJzZVRvcnJlbnQudG9Ub3JyZW50RmlsZShwYXJzZWRUb3JyZW50KVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fb25MaXN0ZW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kaXNjb3ZlcnkgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHZhciB0cmFja2VyT3B0cyA9IHNlbGYuY2xpZW50LnRyYWNrZXJcbiAgaWYgKHRyYWNrZXJPcHRzKSB7XG4gICAgdHJhY2tlck9wdHMgPSBleHRlbmQoc2VsZi5jbGllbnQudHJhY2tlciwge1xuICAgICAgZ2V0QW5ub3VuY2VPcHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIHVwbG9hZGVkOiBzZWxmLnVwbG9hZGVkLFxuICAgICAgICAgIGRvd25sb2FkZWQ6IHNlbGYuZG93bmxvYWRlZCxcbiAgICAgICAgICBsZWZ0OiBNYXRoLm1heChzZWxmLmxlbmd0aCAtIHNlbGYuZG93bmxvYWRlZCwgMClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5jbGllbnQudHJhY2tlci5nZXRBbm5vdW5jZU9wdHMpIHtcbiAgICAgICAgICBleHRlbmRNdXRhYmxlKG9wdHMsIHNlbGYuY2xpZW50LnRyYWNrZXIuZ2V0QW5ub3VuY2VPcHRzKCkpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuX2dldEFubm91bmNlT3B0cykge1xuICAgICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGRlcHJlY2F0aW5nIHRoaXMsIGFzIGl0J3MgcmVkdW5kYW50IHdpdGggdGhlIGZvcm1lciBjYXNlXG4gICAgICAgICAgZXh0ZW5kTXV0YWJsZShvcHRzLCBzZWxmLl9nZXRBbm5vdW5jZU9wdHMoKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0c1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBiZWdpbiBkaXNjb3ZlcmluZyBwZWVycyB2aWEgREhUIGFuZCB0cmFja2Vyc1xuICBzZWxmLmRpc2NvdmVyeSA9IG5ldyBEaXNjb3Zlcnkoe1xuICAgIGluZm9IYXNoOiBzZWxmLmluZm9IYXNoLFxuICAgIGFubm91bmNlOiBzZWxmLmFubm91bmNlLFxuICAgIHBlZXJJZDogc2VsZi5jbGllbnQucGVlcklkLFxuICAgIGRodDogIXNlbGYucHJpdmF0ZSAmJiBzZWxmLmNsaWVudC5kaHQsXG4gICAgdHJhY2tlcjogdHJhY2tlck9wdHMsXG4gICAgcG9ydDogc2VsZi5jbGllbnQudG9ycmVudFBvcnRcbiAgfSlcblxuICBzZWxmLmRpc2NvdmVyeS5vbignZXJyb3InLCBvbkVycm9yKVxuICBzZWxmLmRpc2NvdmVyeS5vbigncGVlcicsIG9uUGVlcilcbiAgc2VsZi5kaXNjb3Zlcnkub24oJ3RyYWNrZXJBbm5vdW5jZScsIG9uVHJhY2tlckFubm91bmNlKVxuICBzZWxmLmRpc2NvdmVyeS5vbignZGh0QW5ub3VuY2UnLCBvbkRIVEFubm91bmNlKVxuICBzZWxmLmRpc2NvdmVyeS5vbignd2FybmluZycsIG9uV2FybmluZylcblxuICBmdW5jdGlvbiBvbkVycm9yIChlcnIpIHtcbiAgICBzZWxmLl9kZXN0cm95KGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUGVlciAocGVlcikge1xuICAgIC8vIERvbid0IGNyZWF0ZSBuZXcgb3V0Z29pbmcgVENQIGNvbm5lY3Rpb25zIHdoZW4gdG9ycmVudCBpcyBkb25lXG4gICAgaWYgKHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJyAmJiBzZWxmLmRvbmUpIHJldHVyblxuICAgIHNlbGYuYWRkUGVlcihwZWVyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFja2VyQW5ub3VuY2UgKCkge1xuICAgIHNlbGYuZW1pdCgndHJhY2tlckFubm91bmNlJylcbiAgICBpZiAoc2VsZi5udW1QZWVycyA9PT0gMCkgc2VsZi5lbWl0KCdub1BlZXJzJywgJ3RyYWNrZXInKVxuICB9XG5cbiAgZnVuY3Rpb24gb25ESFRBbm5vdW5jZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdkaHRBbm5vdW5jZScpXG4gICAgaWYgKHNlbGYubnVtUGVlcnMgPT09IDApIHNlbGYuZW1pdCgnbm9QZWVycycsICdkaHQnKVxuICB9XG5cbiAgZnVuY3Rpb24gb25XYXJuaW5nIChlcnIpIHtcbiAgICBzZWxmLmVtaXQoJ3dhcm5pbmcnLCBlcnIpXG4gIH1cblxuICBpZiAoc2VsZi5pbmZvKSB7XG4gICAgLy8gaWYgZnVsbCBtZXRhZGF0YSB3YXMgaW5jbHVkZWQgaW4gaW5pdGlhbCB0b3JyZW50IGlkLCB1c2UgaXQgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSxcbiAgICAvLyB3YWl0IGZvciB0b3JyZW50LWRpc2NvdmVyeSB0byBmaW5kIHBlZXJzIGFuZCB1dF9tZXRhZGF0YSB0byBnZXQgdGhlIG1ldGFkYXRhLlxuICAgIHNlbGYuX29uTWV0YWRhdGEoc2VsZilcbiAgfSBlbHNlIGlmIChzZWxmLnhzKSB7XG4gICAgc2VsZi5fZ2V0TWV0YWRhdGFGcm9tU2VydmVyKClcbiAgfVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fZ2V0TWV0YWRhdGFGcm9tU2VydmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHVybHMgPSBBcnJheS5pc0FycmF5KHNlbGYueHMpID8gc2VsZi54cyA6IFsgc2VsZi54cyBdXG5cbiAgdmFyIHRhc2tzID0gdXJscy5tYXAoZnVuY3Rpb24gKHVybCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGdldE1ldGFkYXRhRnJvbVVSTCh1cmwsIGNiKVxuICAgIH1cbiAgfSlcbiAgcGFyYWxsZWwodGFza3MpXG5cbiAgZnVuY3Rpb24gZ2V0TWV0YWRhdGFGcm9tVVJMICh1cmwsIGNiKSB7XG4gICAgaWYgKHVybC5pbmRleE9mKCdodHRwOi8vJykgIT09IDAgJiYgdXJsLmluZGV4T2YoJ2h0dHBzOi8vJykgIT09IDApIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdza2lwcGluZyBub24taHR0cCB4cyBwYXJhbTogJXMnLCB1cmwpXG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ3VzZXItYWdlbnQnOiAnV2ViVG9ycmVudC8nICsgVkVSU0lPTiArICcgKGh0dHBzOi8vd2VidG9ycmVudC5pbyknXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXFcbiAgICB0cnkge1xuICAgICAgcmVxID0gZ2V0LmNvbmNhdChvcHRzLCBvblJlc3BvbnNlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2VsZi5fZGVidWcoJ3NraXBwaW5nIGludmFsaWQgdXJsIHhzIHBhcmFtOiAlcycsIHVybClcbiAgICAgIHJldHVybiBjYihudWxsKVxuICAgIH1cblxuICAgIHNlbGYuX3hzUmVxdWVzdHMucHVzaChyZXEpXG5cbiAgICBmdW5jdGlvbiBvblJlc3BvbnNlIChlcnIsIHJlcywgdG9ycmVudCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobnVsbClcbiAgICAgIGlmIChzZWxmLm1ldGFkYXRhKSByZXR1cm4gY2IobnVsbClcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLl9kZWJ1ZygnaHR0cCBlcnJvciBmcm9tIHhzIHBhcmFtOiAlcycsIHVybClcbiAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICB9XG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICBzZWxmLl9kZWJ1Zygnbm9uLTIwMCBzdGF0dXMgY29kZSAlcyBmcm9tIHhzIHBhcmFtOiAlcycsIHJlcy5zdGF0dXNDb2RlLCB1cmwpXG4gICAgICAgIHJldHVybiBjYihudWxsKVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkVG9ycmVudFxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkVG9ycmVudCA9IHBhcnNlVG9ycmVudCh0b3JyZW50KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgICBpZiAoIXBhcnNlZFRvcnJlbnQpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ2dvdCBpbnZhbGlkIHRvcnJlbnQgZmlsZSBmcm9tIHhzIHBhcmFtOiAlcycsIHVybClcbiAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZWRUb3JyZW50LmluZm9IYXNoICE9PSBzZWxmLmluZm9IYXNoKSB7XG4gICAgICAgIHNlbGYuX2RlYnVnKCdnb3QgdG9ycmVudCBmaWxlIHdpdGggaW5jb3JyZWN0IGluZm8gaGFzaCBmcm9tIHhzIHBhcmFtOiAlcycsIHVybClcbiAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX29uTWV0YWRhdGEocGFyc2VkVG9ycmVudClcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIGZ1bGwgdG9ycmVudCBtZXRhZGF0YSBpcyByZWNlaXZlZC5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX29uTWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLm1ldGFkYXRhIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ2dvdCBtZXRhZGF0YScpXG5cbiAgc2VsZi5feHNSZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXEpIHtcbiAgICByZXEuYWJvcnQoKVxuICB9KVxuICBzZWxmLl94c1JlcXVlc3RzID0gW11cblxuICB2YXIgcGFyc2VkVG9ycmVudFxuICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuaW5mb0hhc2gpIHtcbiAgICAvLyBgbWV0YWRhdGFgIGlzIGEgcGFyc2VkIHRvcnJlbnQgKGZyb20gcGFyc2UtdG9ycmVudCBtb2R1bGUpXG4gICAgcGFyc2VkVG9ycmVudCA9IG1ldGFkYXRhXG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFRvcnJlbnQgPSBwYXJzZVRvcnJlbnQobWV0YWRhdGEpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5fZGVzdHJveShlcnIpXG4gICAgfVxuICB9XG5cbiAgc2VsZi5fcHJvY2Vzc1BhcnNlZFRvcnJlbnQocGFyc2VkVG9ycmVudClcbiAgc2VsZi5tZXRhZGF0YSA9IHNlbGYudG9ycmVudEZpbGVcblxuICAvLyBhZGQgd2ViIHNlZWQgdXJscyAoQkVQMTkpXG4gIHNlbGYudXJsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpIHtcbiAgICBzZWxmLmFkZFdlYlNlZWQodXJsKVxuICB9KVxuXG4gIHNlbGYuX3Jhcml0eU1hcCA9IG5ldyBSYXJpdHlNYXAoc2VsZilcblxuICBzZWxmLnN0b3JlID0gbmV3IEltbWVkaWF0ZUNodW5rU3RvcmUoXG4gICAgbmV3IHNlbGYuX3N0b3JlKHNlbGYucGllY2VMZW5ndGgsIHtcbiAgICAgIHRvcnJlbnQ6IHtcbiAgICAgICAgaW5mb0hhc2g6IHNlbGYuaW5mb0hhc2hcbiAgICAgIH0sXG4gICAgICBmaWxlczogc2VsZi5maWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoOiBwYXRoLmpvaW4oc2VsZi5wYXRoLCBmaWxlLnBhdGgpLFxuICAgICAgICAgIGxlbmd0aDogZmlsZS5sZW5ndGgsXG4gICAgICAgICAgb2Zmc2V0OiBmaWxlLm9mZnNldFxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGxlbmd0aDogc2VsZi5sZW5ndGhcbiAgICB9KVxuICApXG5cbiAgc2VsZi5maWxlcyA9IHNlbGYuZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWxlKHNlbGYsIGZpbGUpXG4gIH0pXG5cbiAgc2VsZi5faGFzaGVzID0gc2VsZi5waWVjZXNcblxuICBzZWxmLnBpZWNlcyA9IHNlbGYucGllY2VzLm1hcChmdW5jdGlvbiAoaGFzaCwgaSkge1xuICAgIHZhciBwaWVjZUxlbmd0aCA9IChpID09PSBzZWxmLnBpZWNlcy5sZW5ndGggLSAxKVxuICAgICAgPyBzZWxmLmxhc3RQaWVjZUxlbmd0aFxuICAgICAgOiBzZWxmLnBpZWNlTGVuZ3RoXG4gICAgcmV0dXJuIG5ldyBQaWVjZShwaWVjZUxlbmd0aClcbiAgfSlcblxuICBzZWxmLl9yZXNlcnZhdGlvbnMgPSBzZWxmLnBpZWNlcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXVxuICB9KVxuXG4gIHNlbGYuYml0ZmllbGQgPSBuZXcgQml0RmllbGQoc2VsZi5waWVjZXMubGVuZ3RoKVxuXG4gIHNlbGYud2lyZXMuZm9yRWFjaChmdW5jdGlvbiAod2lyZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBoYXZlIHRoZSBtZXRhZGF0YSBhdCB0aGUgdGltZSB1dF9tZXRhZGF0YSB3YXMgaW5pdGlhbGl6ZWQgZm9yIHRoaXNcbiAgICAvLyB3aXJlLCB3ZSBzdGlsbCB3YW50IHRvIG1ha2UgaXQgYXZhaWxhYmxlIHRvIHRoZSBwZWVyIGluIGNhc2UgdGhleSByZXF1ZXN0IGl0LlxuICAgIGlmICh3aXJlLnV0X21ldGFkYXRhKSB3aXJlLnV0X21ldGFkYXRhLnNldE1ldGFkYXRhKHNlbGYubWV0YWRhdGEpXG5cbiAgICBzZWxmLl9vbldpcmVXaXRoTWV0YWRhdGEod2lyZSlcbiAgfSlcblxuICBzZWxmLl9kZWJ1ZygndmVyaWZ5aW5nIGV4aXN0aW5nIHRvcnJlbnQgZGF0YScpXG4gIGlmIChzZWxmLl9maWxlTW9kdGltZXMgJiYgc2VsZi5fc3RvcmUgPT09IEZTQ2h1bmtTdG9yZSkge1xuICAgIC8vIGRvbid0IHZlcmlmeSBpZiB0aGUgZmlsZXMgaGF2ZW4ndCBiZWVuIG1vZGlmaWVkIHNpbmNlIHdlIGxhc3QgY2hlY2tlZFxuICAgIHNlbGYuZ2V0RmlsZU1vZHRpbWVzKGZ1bmN0aW9uIChlcnIsIGZpbGVNb2R0aW1lcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuX2Rlc3Ryb3koZXJyKVxuXG4gICAgICB2YXIgdW5jaGFuZ2VkID0gc2VsZi5maWxlcy5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmaWxlTW9kdGltZXNbaW5kZXhdID09PSBzZWxmLl9maWxlTW9kdGltZXNbaW5kZXhdXG4gICAgICB9KS5ldmVyeShmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geFxuICAgICAgfSlcblxuICAgICAgaWYgKHVuY2hhbmdlZCkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc2VsZi5waWVjZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc2VsZi5fbWFya1ZlcmlmaWVkKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuX29uU3RvcmUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fdmVyaWZ5UGllY2VzKClcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3ZlcmlmeVBpZWNlcygpXG4gIH1cblxuICBzZWxmLmVtaXQoJ21ldGFkYXRhJylcbn1cblxuLypcbiAqIFRPRE86IHJlbW92ZSB0aGlzXG4gKiBHZXRzIHRoZSBsYXN0IG1vZGlmaWVkIHRpbWUgb2YgZXZlcnkgZmlsZSBvbiBkaXNrIGZvciB0aGlzIHRvcnJlbnQuXG4gKiBPbmx5IHZhbGlkIGluIE5vZGUsIG5vdCBpbiB0aGUgYnJvd3Nlci5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuZ2V0RmlsZU1vZHRpbWVzID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmV0ID0gW11cbiAgcGFyYWxsZWxMaW1pdChzZWxmLmZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBmcy5zdGF0KHBhdGguam9pbihzZWxmLnBhdGgsIGZpbGUucGF0aCksIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIHJldHVybiBjYihlcnIpXG4gICAgICAgIHJldFtpbmRleF0gPSBzdGF0ICYmIHN0YXQubXRpbWUuZ2V0VGltZSgpXG4gICAgICAgIGNiKG51bGwpXG4gICAgICB9KVxuICAgIH1cbiAgfSksIEZJTEVTWVNURU1fQ09OQ1VSUkVOQ1ksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9kZWJ1ZygnZG9uZSBnZXR0aW5nIGZpbGUgbW9kdGltZXMnKVxuICAgIGNiKGVyciwgcmV0KVxuICB9KVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fdmVyaWZ5UGllY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcGFyYWxsZWxMaW1pdChzZWxmLnBpZWNlcy5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpKVxuICAgICAgc2VsZi5zdG9yZS5nZXQoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGJ1Zikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IobnVsbCkgLy8gaWdub3JlIGVycm9yXG4gICAgICAgIHNoYTEoYnVmLCBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgIGlmIChoYXNoID09PSBzZWxmLl9oYXNoZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYucGllY2VzW2luZGV4XSkgcmV0dXJuXG4gICAgICAgICAgICBzZWxmLl9kZWJ1ZygncGllY2UgdmVyaWZpZWQgJXMnLCBpbmRleClcbiAgICAgICAgICAgIHNlbGYuX21hcmtWZXJpZmllZChpbmRleClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5fZGVidWcoJ3BpZWNlIGludmFsaWQgJXMnLCBpbmRleClcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IobnVsbClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9KSwgRklMRVNZU1RFTV9DT05DVVJSRU5DWSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLl9kZXN0cm95KGVycilcbiAgICBzZWxmLl9kZWJ1ZygnZG9uZSB2ZXJpZnlpbmcnKVxuICAgIHNlbGYuX29uU3RvcmUoKVxuICB9KVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fbWFya1ZlcmlmaWVkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHRoaXMucGllY2VzW2luZGV4XSA9IG51bGxcbiAgdGhpcy5fcmVzZXJ2YXRpb25zW2luZGV4XSA9IG51bGxcbiAgdGhpcy5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpXG59XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIG1ldGFkYXRhLCBsaXN0ZW5pbmcgc2VydmVyLCBhbmQgdW5kZXJseWluZyBjaHVuayBzdG9yZSBpcyBpbml0aWFsaXplZC5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX29uU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gc3RvcmUnKVxuXG4gIC8vIHN0YXJ0IG9mZiBzZWxlY3RpbmcgdGhlIGVudGlyZSB0b3JyZW50IHdpdGggbG93IHByaW9yaXR5XG4gIGlmIChzZWxmLnBpZWNlcy5sZW5ndGggIT09IDApIHtcbiAgICBzZWxmLnNlbGVjdCgwLCBzZWxmLnBpZWNlcy5sZW5ndGggLSAxLCBmYWxzZSlcbiAgfVxuXG4gIHNlbGYucmVhZHkgPSB0cnVlXG4gIHNlbGYuZW1pdCgncmVhZHknKVxuXG4gIC8vIEZpbGVzIG1heSBzdGFydCBvdXQgZG9uZSBpZiB0aGUgZmlsZSB3YXMgYWxyZWFkeSBpbiB0aGUgc3RvcmVcbiAgc2VsZi5fY2hlY2tEb25lKClcblxuICAvLyBJbiBjYXNlIGFueSBzZWxlY3Rpb25zIHdlcmUgbWFkZSBiZWZvcmUgdG9ycmVudCB3YXMgcmVhZHlcbiAgc2VsZi5fdXBkYXRlU2VsZWN0aW9ucygpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2Rlc3Ryb3kobnVsbCwgY2IpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuICBzZWxmLl9kZWJ1ZygnZGVzdHJveScpXG5cbiAgc2VsZi5jbGllbnQuX3JlbW92ZShzZWxmKVxuXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5fcmVjaG9rZUludGVydmFsSWQpXG5cbiAgc2VsZi5feHNSZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXEpIHtcbiAgICByZXEuYWJvcnQoKVxuICB9KVxuXG4gIGlmIChzZWxmLl9yYXJpdHlNYXApIHtcbiAgICBzZWxmLl9yYXJpdHlNYXAuZGVzdHJveSgpXG4gIH1cblxuICBmb3IgKHZhciBpZCBpbiBzZWxmLl9wZWVycykge1xuICAgIHNlbGYucmVtb3ZlUGVlcihpZClcbiAgfVxuXG4gIHNlbGYuZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSkgZmlsZS5fZGVzdHJveSgpXG4gIH0pXG5cbiAgdmFyIHRhc2tzID0gc2VsZi5fc2VydmVycy5tYXAoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHNlcnZlci5kZXN0cm95KGNiKVxuICAgIH1cbiAgfSlcblxuICBpZiAoc2VsZi5kaXNjb3ZlcnkpIHtcbiAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VsZi5kaXNjb3ZlcnkuZGVzdHJveShjYilcbiAgICB9KVxuICB9XG5cbiAgaWYgKHNlbGYuc3RvcmUpIHtcbiAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VsZi5zdG9yZS5jbG9zZShjYilcbiAgICB9KVxuICB9XG5cbiAgcGFyYWxsZWwodGFza3MsIGNiKVxuXG4gIGlmIChlcnIpIHtcbiAgICAvLyBUb3JyZW50IGVycm9ycyBhcmUgZW1pdHRlZCBhdCBgdG9ycmVudC5vbignZXJyb3InKWAuIElmIHRoZXJlIGFyZSBubyAnZXJyb3InIGV2ZW50XG4gICAgLy8gaGFuZGxlcnMgb24gdGhlIHRvcnJlbnQgaW5zdGFuY2UsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgYXRcbiAgICAvLyBgY2xpZW50Lm9uKCdlcnJvcicpYC4gVGhpcyBwcmV2ZW50cyBjcmFzaGluZyB0aGUgdXNlcidzIHByb2dyYW0sIGJ1dCBpdCBtYWtlcyBpdFxuICAgIC8vIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lIGEgY2xpZW50IGVycm9yIHZlcnN1cyBhIHRvcnJlbnQgZXJyb3IgKHdoZXJlIHRoZSBjbGllbnRcbiAgICAvLyBpcyBzdGlsbCB1c2FibGUgYWZ0ZXJ3YXJkcykuIFVzZXJzIGFyZSByZWNvbW1lbmRlZCBmb3IgZXJyb3JzIGluIGJvdGggcGxhY2VzXG4gICAgLy8gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZXJyb3IgdHlwZXMuXG4gICAgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgICAgc2VsZi5jbGllbnQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgc2VsZi5lbWl0KCdjbG9zZScpXG5cbiAgc2VsZi5jbGllbnQgPSBudWxsXG4gIHNlbGYuZmlsZXMgPSBbXVxuICBzZWxmLmRpc2NvdmVyeSA9IG51bGxcbiAgc2VsZi5zdG9yZSA9IG51bGxcbiAgc2VsZi5fcmFyaXR5TWFwID0gbnVsbFxuICBzZWxmLl9wZWVycyA9IG51bGxcbiAgc2VsZi5fc2VydmVycyA9IG51bGxcbiAgc2VsZi5feHNSZXF1ZXN0cyA9IG51bGxcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuYWRkUGVlciA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuICBpZiAoIXNlbGYuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignYWRkUGVlcigpIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGBpbmZvSGFzaGAgZXZlbnQnKVxuXG4gIGlmIChzZWxmLmNsaWVudC5ibG9ja2VkKSB7XG4gICAgdmFyIGhvc3RcbiAgICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcGFydHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnRzID0gYWRkclRvSVBQb3J0KHBlZXIpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiBpbnZhbGlkICVzJywgcGVlcilcbiAgICAgICAgc2VsZi5lbWl0KCdpbnZhbGlkUGVlcicsIHBlZXIpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaG9zdCA9IHBhcnRzWzBdXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGVlci5yZW1vdGVBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgaG9zdCA9IHBlZXIucmVtb3RlQWRkcmVzc1xuICAgIH1cblxuICAgIGlmIChob3N0ICYmIHNlbGYuY2xpZW50LmJsb2NrZWQuY29udGFpbnMoaG9zdCkpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiBibG9ja2VkICVzJywgcGVlcilcbiAgICAgIGlmICh0eXBlb2YgcGVlciAhPT0gJ3N0cmluZycpIHBlZXIuZGVzdHJveSgpXG4gICAgICBzZWxmLmVtaXQoJ2Jsb2NrZWRQZWVyJywgcGVlcilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHZhciB3YXNBZGRlZCA9ICEhc2VsZi5fYWRkUGVlcihwZWVyKVxuICBpZiAod2FzQWRkZWQpIHtcbiAgICBzZWxmLmVtaXQoJ3BlZXInLCBwZWVyKVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZW1pdCgnaW52YWxpZFBlZXInLCBwZWVyKVxuICB9XG4gIHJldHVybiB3YXNBZGRlZFxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fYWRkUGVlciA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHtcbiAgICBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgcGVlcjogdG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuICAgIGlmICh0eXBlb2YgcGVlciAhPT0gJ3N0cmluZycpIHBlZXIuZGVzdHJveSgpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnICYmICFzZWxmLl92YWxpZEFkZHIocGVlcikpIHtcbiAgICBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgcGVlcjogaW52YWxpZCAlcycsIHBlZXIpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBpZCA9IChwZWVyICYmIHBlZXIuaWQpIHx8IHBlZXJcbiAgaWYgKHNlbGYuX3BlZXJzW2lkXSkge1xuICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiBkdXBsaWNhdGUgKCVzKScsIGlkKVxuICAgIGlmICh0eXBlb2YgcGVlciAhPT0gJ3N0cmluZycpIHBlZXIuZGVzdHJveSgpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmIChzZWxmLnBhdXNlZCkge1xuICAgIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBwZWVyOiB0b3JyZW50IGlzIHBhdXNlZCcpXG4gICAgaWYgKHR5cGVvZiBwZWVyICE9PSAnc3RyaW5nJykgcGVlci5kZXN0cm95KClcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgc2VsZi5fZGVidWcoJ2FkZCBwZWVyICVzJywgaWQpXG5cbiAgdmFyIG5ld1BlZXJcbiAgaWYgKHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJykge1xuICAgIC8vIGBwZWVyYCBpcyBhbiBhZGRyIChcImlwOnBvcnRcIiBzdHJpbmcpXG4gICAgbmV3UGVlciA9IFBlZXIuY3JlYXRlVENQT3V0Z29pbmdQZWVyKHBlZXIsIHNlbGYpXG4gIH0gZWxzZSB7XG4gICAgLy8gYHBlZXJgIGlzIGEgV2ViUlRDIGNvbm5lY3Rpb24gKHNpbXBsZS1wZWVyKVxuICAgIG5ld1BlZXIgPSBQZWVyLmNyZWF0ZVdlYlJUQ1BlZXIocGVlciwgc2VsZilcbiAgfVxuXG4gIHNlbGYuX3BlZXJzW25ld1BlZXIuaWRdID0gbmV3UGVlclxuICBzZWxmLl9wZWVyc0xlbmd0aCArPSAxXG5cbiAgaWYgKHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJykge1xuICAgIC8vIGBwZWVyYCBpcyBhbiBhZGRyIChcImlwOnBvcnRcIiBzdHJpbmcpXG4gICAgc2VsZi5fcXVldWUucHVzaChuZXdQZWVyKVxuICAgIHNlbGYuX2RyYWluKClcbiAgfVxuXG4gIHJldHVybiBuZXdQZWVyXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmFkZFdlYlNlZWQgPSBmdW5jdGlvbiAodXJsKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG5cbiAgaWYgKCEvXmh0dHBzPzpcXC9cXC8uKy8udGVzdCh1cmwpKSB7XG4gICAgdGhpcy5fZGVidWcoJ2lnbm9yaW5nIGludmFsaWQgd2ViIHNlZWQgJXMnLCB1cmwpXG4gICAgdGhpcy5lbWl0KCdpbnZhbGlkUGVlcicsIHVybClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0aGlzLl9wZWVyc1t1cmxdKSB7XG4gICAgdGhpcy5fZGVidWcoJ2lnbm9yaW5nIGR1cGxpY2F0ZSB3ZWIgc2VlZCAlcycsIHVybClcbiAgICB0aGlzLmVtaXQoJ2ludmFsaWRQZWVyJywgdXJsKVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5fZGVidWcoJ2FkZCB3ZWIgc2VlZCAlcycsIHVybClcblxuICB2YXIgbmV3UGVlciA9IFBlZXIuY3JlYXRlV2ViU2VlZFBlZXIodXJsLCB0aGlzKVxuICB0aGlzLl9wZWVyc1tuZXdQZWVyLmlkXSA9IG5ld1BlZXJcbiAgdGhpcy5fcGVlcnNMZW5ndGggKz0gMVxuXG4gIHRoaXMuZW1pdCgncGVlcicsIHVybClcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5jb21pbmcgVENQIHBlZXIgY29ubmVjdHMgdG8gdGhpcyB0b3JyZW50IHN3YXJtLiBDYWxsZWQgd2l0aCBhXG4gKiBwZWVyIHRoYXQgaGFzIGFscmVhZHkgc2VudCBhIGhhbmRzaGFrZS5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX2FkZEluY29taW5nUGVlciA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBwZWVyLmRlc3Ryb3kobmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpKVxuICBpZiAoc2VsZi5wYXVzZWQpIHJldHVybiBwZWVyLmRlc3Ryb3kobmV3IEVycm9yKCd0b3JyZW50IGlzIHBhdXNlZCcpKVxuXG4gIHRoaXMuX2RlYnVnKCdhZGQgaW5jb21pbmcgcGVlciAlcycsIHBlZXIuaWQpXG5cbiAgc2VsZi5fcGVlcnNbcGVlci5pZF0gPSBwZWVyXG4gIHNlbGYuX3BlZXJzTGVuZ3RoICs9IDFcbn1cblxuVG9ycmVudC5wcm90b3R5cGUucmVtb3ZlUGVlciA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgaWQgPSAocGVlciAmJiBwZWVyLmlkKSB8fCBwZWVyXG4gIHBlZXIgPSBzZWxmLl9wZWVyc1tpZF1cblxuICBpZiAoIXBlZXIpIHJldHVyblxuXG4gIHRoaXMuX2RlYnVnKCdyZW1vdmVQZWVyICVzJywgaWQpXG5cbiAgZGVsZXRlIHNlbGYuX3BlZXJzW2lkXVxuICBzZWxmLl9wZWVyc0xlbmd0aCAtPSAxXG5cbiAgcGVlci5kZXN0cm95KClcblxuICAvLyBJZiB0b3JyZW50IHN3YXJtIHdhcyBhdCBjYXBhY2l0eSBiZWZvcmUsIHRyeSB0byBvcGVuIGEgbmV3IGNvbm5lY3Rpb24gbm93XG4gIHNlbGYuX2RyYWluKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHByaW9yaXR5LCBub3RpZnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPCBzdGFydCB8fCBzZWxmLnBpZWNlcy5sZW5ndGggPD0gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNlbGVjdGlvbiAnLCBzdGFydCwgJzonLCBlbmQpXG4gIH1cbiAgcHJpb3JpdHkgPSBOdW1iZXIocHJpb3JpdHkpIHx8IDBcblxuICBzZWxmLl9kZWJ1Zygnc2VsZWN0ICVzLSVzIChwcmlvcml0eSAlcyknLCBzdGFydCwgZW5kLCBwcmlvcml0eSlcblxuICBzZWxmLl9zZWxlY3Rpb25zLnB1c2goe1xuICAgIGZyb206IHN0YXJ0LFxuICAgIHRvOiBlbmQsXG4gICAgb2Zmc2V0OiAwLFxuICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICBub3RpZnk6IG5vdGlmeSB8fCBub29wXG4gIH0pXG5cbiAgc2VsZi5fc2VsZWN0aW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5XG4gIH0pXG5cbiAgc2VsZi5fdXBkYXRlU2VsZWN0aW9ucygpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHByaW9yaXR5KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuXG4gIHByaW9yaXR5ID0gTnVtYmVyKHByaW9yaXR5KSB8fCAwXG4gIHNlbGYuX2RlYnVnKCdkZXNlbGVjdCAlcy0lcyAocHJpb3JpdHkgJXMpJywgc3RhcnQsIGVuZCwgcHJpb3JpdHkpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHMgPSBzZWxmLl9zZWxlY3Rpb25zW2ldXG4gICAgaWYgKHMuZnJvbSA9PT0gc3RhcnQgJiYgcy50byA9PT0gZW5kICYmIHMucHJpb3JpdHkgPT09IHByaW9yaXR5KSB7XG4gICAgICBzZWxmLl9zZWxlY3Rpb25zLnNwbGljZShpLS0sIDEpXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHNlbGYuX3VwZGF0ZVNlbGVjdGlvbnMoKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5jcml0aWNhbCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuXG4gIHNlbGYuX2RlYnVnKCdjcml0aWNhbCAlcy0lcycsIHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgc2VsZi5fY3JpdGljYWxbaV0gPSB0cnVlXG4gIH1cblxuICBzZWxmLl91cGRhdGVTZWxlY3Rpb25zKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX29uV2lyZSA9IGZ1bmN0aW9uICh3aXJlLCBhZGRyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZWJ1ZygnZ290IHdpcmUgJXMgKCVzKScsIHdpcmUuX2RlYnVnSWQsIGFkZHIgfHwgJ1Vua25vd24nKVxuXG4gIHdpcmUub24oJ2Rvd25sb2FkJywgZnVuY3Rpb24gKGRvd25sb2FkZWQpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNlbGYucmVjZWl2ZWQgKz0gZG93bmxvYWRlZFxuICAgIHNlbGYuX2Rvd25sb2FkU3BlZWQoZG93bmxvYWRlZClcbiAgICBzZWxmLmNsaWVudC5fZG93bmxvYWRTcGVlZChkb3dubG9hZGVkKVxuICAgIHNlbGYuZW1pdCgnZG93bmxvYWQnLCBkb3dubG9hZGVkKVxuICAgIHNlbGYuY2xpZW50LmVtaXQoJ2Rvd25sb2FkJywgZG93bmxvYWRlZClcbiAgfSlcblxuICB3aXJlLm9uKCd1cGxvYWQnLCBmdW5jdGlvbiAodXBsb2FkZWQpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNlbGYudXBsb2FkZWQgKz0gdXBsb2FkZWRcbiAgICBzZWxmLl91cGxvYWRTcGVlZCh1cGxvYWRlZClcbiAgICBzZWxmLmNsaWVudC5fdXBsb2FkU3BlZWQodXBsb2FkZWQpXG4gICAgc2VsZi5lbWl0KCd1cGxvYWQnLCB1cGxvYWRlZClcbiAgICBzZWxmLmNsaWVudC5lbWl0KCd1cGxvYWQnLCB1cGxvYWRlZClcbiAgfSlcblxuICBzZWxmLndpcmVzLnB1c2god2lyZSlcblxuICBpZiAoYWRkcikge1xuICAgIC8vIFNvbWV0aW1lcyBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpIGRvZXNuJ3QgcmV0dXJuIGFuIGlwOnBvcnQgZm9yIHBlZXJzXG4gICAgdmFyIHBhcnRzID0gYWRkclRvSVBQb3J0KGFkZHIpXG4gICAgd2lyZS5yZW1vdGVBZGRyZXNzID0gcGFydHNbMF1cbiAgICB3aXJlLnJlbW90ZVBvcnQgPSBwYXJ0c1sxXVxuICB9XG5cbiAgLy8gV2hlbiBwZWVyIHNlbmRzIFBPUlQgbWVzc2FnZSwgYWRkIHRoYXQgREhUIG5vZGUgdG8gcm91dGluZyB0YWJsZVxuICBpZiAoc2VsZi5jbGllbnQuZGh0ICYmIHNlbGYuY2xpZW50LmRodC5saXN0ZW5pbmcpIHtcbiAgICB3aXJlLm9uKCdwb3J0JywgZnVuY3Rpb24gKHBvcnQpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCB8fCBzZWxmLmNsaWVudC5kaHQuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKCF3aXJlLnJlbW90ZUFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2RlYnVnKCdpZ25vcmluZyBQT1JUIGZyb20gcGVlciB3aXRoIG5vIGFkZHJlc3MnKVxuICAgICAgfVxuICAgICAgaWYgKHBvcnQgPT09IDAgfHwgcG9ydCA+IDY1NTM2KSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgaW52YWxpZCBQT1JUIGZyb20gcGVlcicpXG4gICAgICB9XG5cbiAgICAgIHNlbGYuX2RlYnVnKCdwb3J0OiAlcyAoZnJvbSAlcyknLCBwb3J0LCBhZGRyKVxuICAgICAgc2VsZi5jbGllbnQuZGh0LmFkZE5vZGUoeyBob3N0OiB3aXJlLnJlbW90ZUFkZHJlc3MsIHBvcnQ6IHBvcnQgfSlcbiAgICB9KVxuICB9XG5cbiAgd2lyZS5vbigndGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9kZWJ1Zygnd2lyZSB0aW1lb3V0ICglcyknLCBhZGRyKVxuICAgIC8vIFRPRE86IHRoaXMgbWlnaHQgYmUgZGVzdHJveWluZyB3aXJlcyB0b28gZWFnZXJseVxuICAgIHdpcmUuZGVzdHJveSgpXG4gIH0pXG5cbiAgLy8gVGltZW91dCBmb3IgcGllY2UgcmVxdWVzdHMgdG8gdGhpcyBwZWVyXG4gIHdpcmUuc2V0VGltZW91dChQSUVDRV9USU1FT1VULCB0cnVlKVxuXG4gIC8vIFNlbmQgS0VFUC1BTElWRSAoZXZlcnkgNjBzKSBzbyBwZWVycyB3aWxsIG5vdCBkaXNjb25uZWN0IHRoZSB3aXJlXG4gIHdpcmUuc2V0S2VlcEFsaXZlKHRydWUpXG5cbiAgLy8gdXNlIHV0X21ldGFkYXRhIGV4dGVuc2lvblxuICB3aXJlLnVzZSh1dE1ldGFkYXRhKHNlbGYubWV0YWRhdGEpKVxuXG4gIHdpcmUudXRfbWV0YWRhdGEub24oJ3dhcm5pbmcnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5fZGVidWcoJ3V0X21ldGFkYXRhIHdhcm5pbmc6ICVzJywgZXJyLm1lc3NhZ2UpXG4gIH0pXG5cbiAgaWYgKCFzZWxmLm1ldGFkYXRhKSB7XG4gICAgd2lyZS51dF9tZXRhZGF0YS5vbignbWV0YWRhdGEnLCBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdnb3QgbWV0YWRhdGEgdmlhIHV0X21ldGFkYXRhJylcbiAgICAgIHNlbGYuX29uTWV0YWRhdGEobWV0YWRhdGEpXG4gICAgfSlcbiAgICB3aXJlLnV0X21ldGFkYXRhLmZldGNoKClcbiAgfVxuXG4gIC8vIHVzZSB1dF9wZXggZXh0ZW5zaW9uIGlmIHRoZSB0b3JyZW50IGlzIG5vdCBmbGFnZ2VkIGFzIHByaXZhdGVcbiAgaWYgKHR5cGVvZiB1dFBleCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2VsZi5wcml2YXRlKSB7XG4gICAgd2lyZS51c2UodXRQZXgoKSlcblxuICAgIHdpcmUudXRfcGV4Lm9uKCdwZWVyJywgZnVuY3Rpb24gKHBlZXIpIHtcbiAgICAgIC8vIE9ubHkgYWRkIHBvdGVudGlhbCBuZXcgcGVlcnMgd2hlbiB3ZSdyZSBub3Qgc2VlZGluZ1xuICAgICAgaWYgKHNlbGYuZG9uZSkgcmV0dXJuXG4gICAgICBzZWxmLl9kZWJ1ZygndXRfcGV4OiBnb3QgcGVlcjogJXMgKGZyb20gJXMpJywgcGVlciwgYWRkcilcbiAgICAgIHNlbGYuYWRkUGVlcihwZWVyKVxuICAgIH0pXG5cbiAgICB3aXJlLnV0X3BleC5vbignZHJvcHBlZCcsIGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgICAvLyB0aGUgcmVtb3RlIHBlZXIgYmVsaWV2ZXMgYSBnaXZlbiBwZWVyIGhhcyBiZWVuIGRyb3BwZWQgZnJvbSB0aGUgdG9ycmVudCBzd2FybS5cbiAgICAgIC8vIGlmIHdlJ3JlIG5vdCBjdXJyZW50bHkgY29ubmVjdGVkIHRvIGl0LCB0aGVuIHJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZS5cbiAgICAgIHZhciBwZWVyT2JqID0gc2VsZi5fcGVlcnNbcGVlcl1cbiAgICAgIGlmIChwZWVyT2JqICYmICFwZWVyT2JqLmNvbm5lY3RlZCkge1xuICAgICAgICBzZWxmLl9kZWJ1ZygndXRfcGV4OiBkcm9wcGVkIHBlZXI6ICVzIChmcm9tICVzKScsIHBlZXIsIGFkZHIpXG4gICAgICAgIHNlbGYucmVtb3ZlUGVlcihwZWVyKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB3aXJlLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gU3RvcCBzZW5kaW5nIHVwZGF0ZXMgdG8gcmVtb3RlIHBlZXJcbiAgICAgIHdpcmUudXRfcGV4LnJlc2V0KClcbiAgICB9KVxuICB9XG5cbiAgLy8gSG9vayB0byBhbGxvdyB1c2VyLWRlZmluZWQgYGJpdHRvcnJlbnQtcHJvdG9jb2xgIGV4dGVuc2lvbnNcbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2JpdHRvcnJlbnQtcHJvdG9jb2wjZXh0ZW5zaW9uLWFwaVxuICBzZWxmLmVtaXQoJ3dpcmUnLCB3aXJlLCBhZGRyKVxuXG4gIGlmIChzZWxmLm1ldGFkYXRhKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUaGlzIGFsbG93cyB3aXJlLmhhbmRzaGFrZSgpIHRvIGJlIGNhbGxlZCAoYnkgUGVlci5vbkhhbmRzaGFrZSkgYmVmb3JlIGFueVxuICAgICAgLy8gbWVzc2FnZXMgZ2V0IHNlbnQgb24gdGhlIHdpcmVcbiAgICAgIHNlbGYuX29uV2lyZVdpdGhNZXRhZGF0YSh3aXJlKVxuICAgIH0pXG4gIH1cbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX29uV2lyZVdpdGhNZXRhZGF0YSA9IGZ1bmN0aW9uICh3aXJlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdGltZW91dElkID0gbnVsbFxuXG4gIGZ1bmN0aW9uIG9uQ2hva2VUaW1lb3V0ICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQgfHwgd2lyZS5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgaWYgKHNlbGYuX251bVF1ZXVlZCA+IDIgKiAoc2VsZi5fbnVtQ29ubnMgLSBzZWxmLm51bVBlZXJzKSAmJlxuICAgICAgd2lyZS5hbUludGVyZXN0ZWQpIHtcbiAgICAgIHdpcmUuZGVzdHJveSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQob25DaG9rZVRpbWVvdXQsIENIT0tFX1RJTUVPVVQpXG4gICAgICBpZiAodGltZW91dElkLnVucmVmKSB0aW1lb3V0SWQudW5yZWYoKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpID0gMFxuICBmdW5jdGlvbiB1cGRhdGVTZWVkU3RhdHVzICgpIHtcbiAgICBpZiAod2lyZS5wZWVyUGllY2VzLmxlbmd0aCAhPT0gc2VsZi5waWVjZXMubGVuZ3RoKSByZXR1cm5cbiAgICBmb3IgKDsgaSA8IHNlbGYucGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIXdpcmUucGVlclBpZWNlcy5nZXQoaSkpIHJldHVyblxuICAgIH1cbiAgICB3aXJlLmlzU2VlZGVyID0gdHJ1ZVxuICAgIHdpcmUuY2hva2UoKSAvLyBhbHdheXMgY2hva2Ugc2VlZGVyc1xuICB9XG5cbiAgd2lyZS5vbignYml0ZmllbGQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlU2VlZFN0YXR1cygpXG4gICAgc2VsZi5fdXBkYXRlKClcbiAgfSlcblxuICB3aXJlLm9uKCdoYXZlJywgZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZVNlZWRTdGF0dXMoKVxuICAgIHNlbGYuX3VwZGF0ZSgpXG4gIH0pXG5cbiAgd2lyZS5vbmNlKCdpbnRlcmVzdGVkJywgZnVuY3Rpb24gKCkge1xuICAgIHdpcmUudW5jaG9rZSgpXG4gIH0pXG5cbiAgd2lyZS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICB9KVxuXG4gIHdpcmUub24oJ2Nob2tlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChvbkNob2tlVGltZW91dCwgQ0hPS0VfVElNRU9VVClcbiAgICBpZiAodGltZW91dElkLnVucmVmKSB0aW1lb3V0SWQudW5yZWYoKVxuICB9KVxuXG4gIHdpcmUub24oJ3VuY2hva2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICBzZWxmLl91cGRhdGUoKVxuICB9KVxuXG4gIHdpcmUub24oJ3JlcXVlc3QnLCBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYikge1xuICAgIGlmIChsZW5ndGggPiBNQVhfQkxPQ0tfTEVOR1RIKSB7XG4gICAgICAvLyBQZXIgc3BlYywgZGlzY29ubmVjdCBmcm9tIHBlZXJzIHRoYXQgcmVxdWVzdCA+MTI4S0JcbiAgICAgIHJldHVybiB3aXJlLmRlc3Ryb3koKVxuICAgIH1cbiAgICBpZiAoc2VsZi5waWVjZXNbaW5kZXhdKSByZXR1cm5cbiAgICBzZWxmLnN0b3JlLmdldChpbmRleCwgeyBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGggfSwgY2IpXG4gIH0pXG5cbiAgd2lyZS5iaXRmaWVsZChzZWxmLmJpdGZpZWxkKSAvLyBhbHdheXMgc2VuZCBiaXRmaWVsZCAocmVxdWlyZWQpXG4gIHdpcmUuaW50ZXJlc3RlZCgpIC8vIGFsd2F5cyBzdGFydCBvdXQgaW50ZXJlc3RlZFxuXG4gIC8vIFNlbmQgUE9SVCBtZXNzYWdlIHRvIHBlZXJzIHRoYXQgc3VwcG9ydCBESFRcbiAgaWYgKHdpcmUucGVlckV4dGVuc2lvbnMuZGh0ICYmIHNlbGYuY2xpZW50LmRodCAmJiBzZWxmLmNsaWVudC5kaHQubGlzdGVuaW5nKSB7XG4gICAgd2lyZS5wb3J0KHNlbGYuY2xpZW50LmRodC5hZGRyZXNzKCkucG9ydClcbiAgfVxuXG4gIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQob25DaG9rZVRpbWVvdXQsIENIT0tFX1RJTUVPVVQpXG4gIGlmICh0aW1lb3V0SWQudW5yZWYpIHRpbWVvdXRJZC51bnJlZigpXG5cbiAgd2lyZS5pc1NlZWRlciA9IGZhbHNlXG4gIHVwZGF0ZVNlZWRTdGF0dXMoKVxufVxuXG4vKipcbiAqIENhbGxlZCBvbiBzZWxlY3Rpb24gY2hhbmdlcy5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3VwZGF0ZVNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYucmVhZHkgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2djU2VsZWN0aW9ucygpXG4gIH0pXG4gIHNlbGYuX3VwZGF0ZUludGVyZXN0KClcbiAgc2VsZi5fdXBkYXRlKClcbn1cblxuLyoqXG4gKiBHYXJiYWdlIGNvbGxlY3Qgc2VsZWN0aW9ucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0b3JlJ3MgY3VycmVudCBzdGF0ZS5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX2djU2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHMgPSBzZWxmLl9zZWxlY3Rpb25zW2ldXG4gICAgdmFyIG9sZE9mZnNldCA9IHMub2Zmc2V0XG5cbiAgICAvLyBjaGVjayBmb3IgbmV3bHkgZG93bmxvYWRlZCBwaWVjZXMgaW4gc2VsZWN0aW9uXG4gICAgd2hpbGUgKHNlbGYuYml0ZmllbGQuZ2V0KHMuZnJvbSArIHMub2Zmc2V0KSAmJiBzLmZyb20gKyBzLm9mZnNldCA8IHMudG8pIHtcbiAgICAgIHMub2Zmc2V0KytcbiAgICB9XG5cbiAgICBpZiAob2xkT2Zmc2V0ICE9PSBzLm9mZnNldCkgcy5ub3RpZnkoKVxuICAgIGlmIChzLnRvICE9PSBzLmZyb20gKyBzLm9mZnNldCkgY29udGludWVcbiAgICBpZiAoIXNlbGYuYml0ZmllbGQuZ2V0KHMuZnJvbSArIHMub2Zmc2V0KSkgY29udGludWVcblxuICAgIC8vIHJlbW92ZSBmdWxseSBkb3dubG9hZGVkIHNlbGVjdGlvblxuICAgIHNlbGYuX3NlbGVjdGlvbnMuc3BsaWNlKGktLSwgMSkgLy8gZGVjcmVtZW50IGkgdG8gb2Zmc2V0IHNwbGljZVxuICAgIHMubm90aWZ5KCkgLy8gVE9ETzogdGhpcyBtYXkgbm90aWZ5IHR3aWNlIGluIGEgcm93LiBpcyB0aGlzIGEgcHJvYmxlbT9cbiAgICBzZWxmLl91cGRhdGVJbnRlcmVzdCgpXG4gIH1cblxuICBpZiAoIXNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoKSBzZWxmLmVtaXQoJ2lkbGUnKVxufVxuXG4vKipcbiAqIFVwZGF0ZSBpbnRlcmVzdGVkIHN0YXR1cyBmb3IgYWxsIHBlZXJzLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fdXBkYXRlSW50ZXJlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBwcmV2ID0gc2VsZi5fYW1JbnRlcmVzdGVkXG4gIHNlbGYuX2FtSW50ZXJlc3RlZCA9ICEhc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGhcblxuICBzZWxmLndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICAvLyBUT0RPOiBvbmx5IGNhbGwgd2lyZS5pbnRlcmVzdGVkIGlmIHRoZSB3aXJlIGhhcyBhdCBsZWFzdCBvbmUgcGllY2Ugd2UgbmVlZFxuICAgIGlmIChzZWxmLl9hbUludGVyZXN0ZWQpIHdpcmUuaW50ZXJlc3RlZCgpXG4gICAgZWxzZSB3aXJlLnVuaW50ZXJlc3RlZCgpXG4gIH0pXG5cbiAgaWYgKHByZXYgPT09IHNlbGYuX2FtSW50ZXJlc3RlZCkgcmV0dXJuXG4gIGlmIChzZWxmLl9hbUludGVyZXN0ZWQpIHNlbGYuZW1pdCgnaW50ZXJlc3RlZCcpXG4gIGVsc2Ugc2VsZi5lbWl0KCd1bmludGVyZXN0ZWQnKVxufVxuXG4vKipcbiAqIEhlYXJ0YmVhdCB0byB1cGRhdGUgYWxsIHBlZXJzIGFuZCB0aGVpciByZXF1ZXN0cy5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgLy8gdXBkYXRlIHdpcmVzIGluIHJhbmRvbSBvcmRlciBmb3IgYmV0dGVyIHJlcXVlc3QgZGlzdHJpYnV0aW9uXG4gIHZhciBpdGUgPSByYW5kb21JdGVyYXRlKHNlbGYud2lyZXMpXG4gIHZhciB3aXJlXG4gIHdoaWxlICgod2lyZSA9IGl0ZSgpKSkge1xuICAgIHNlbGYuX3VwZGF0ZVdpcmUod2lyZSlcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHVwZGF0ZSBhIHBlZXIncyByZXF1ZXN0c1xuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fdXBkYXRlV2lyZSA9IGZ1bmN0aW9uICh3aXJlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICh3aXJlLnBlZXJDaG9raW5nKSByZXR1cm5cbiAgaWYgKCF3aXJlLmRvd25sb2FkZWQpIHJldHVybiB2YWxpZGF0ZVdpcmUoKVxuXG4gIHZhciBtaW5PdXRzdGFuZGluZ1JlcXVlc3RzID0gZ2V0QmxvY2tQaXBlbGluZUxlbmd0aCh3aXJlLCBQSVBFTElORV9NSU5fRFVSQVRJT04pXG4gIGlmICh3aXJlLnJlcXVlc3RzLmxlbmd0aCA+PSBtaW5PdXRzdGFuZGluZ1JlcXVlc3RzKSByZXR1cm5cbiAgdmFyIG1heE91dHN0YW5kaW5nUmVxdWVzdHMgPSBnZXRCbG9ja1BpcGVsaW5lTGVuZ3RoKHdpcmUsIFBJUEVMSU5FX01BWF9EVVJBVElPTilcblxuICB0cnlTZWxlY3RXaXJlKGZhbHNlKSB8fCB0cnlTZWxlY3RXaXJlKHRydWUpXG5cbiAgZnVuY3Rpb24gZ2VuUGllY2VGaWx0ZXJGdW5jIChzdGFydCwgZW5kLCB0cmllZCwgcmFuaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkgPj0gc3RhcnQgJiYgaSA8PSBlbmQgJiYgIShpIGluIHRyaWVkKSAmJiB3aXJlLnBlZXJQaWVjZXMuZ2V0KGkpICYmICghcmFuayB8fCByYW5rKGkpKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IERvIHdlIG5lZWQgYm90aCB2YWxpZGF0ZVdpcmUgYW5kIHRyeVNlbGVjdFdpcmU/XG4gIGZ1bmN0aW9uIHZhbGlkYXRlV2lyZSAoKSB7XG4gICAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoKSByZXR1cm5cblxuICAgIHZhciBpID0gc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgbmV4dCA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICAgIHZhciBwaWVjZVxuICAgICAgaWYgKHNlbGYuc3RyYXRlZ3kgPT09ICdyYXJlc3QnKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG5leHQuZnJvbSArIG5leHQub2Zmc2V0XG4gICAgICAgIHZhciBlbmQgPSBuZXh0LnRvXG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydCArIDFcbiAgICAgICAgdmFyIHRyaWVkID0ge31cbiAgICAgICAgdmFyIHRyaWVzID0gMFxuICAgICAgICB2YXIgZmlsdGVyID0gZ2VuUGllY2VGaWx0ZXJGdW5jKHN0YXJ0LCBlbmQsIHRyaWVkKVxuXG4gICAgICAgIHdoaWxlICh0cmllcyA8IGxlbikge1xuICAgICAgICAgIHBpZWNlID0gc2VsZi5fcmFyaXR5TWFwLmdldFJhcmVzdFBpZWNlKGZpbHRlcilcbiAgICAgICAgICBpZiAocGllY2UgPCAwKSBicmVha1xuICAgICAgICAgIGlmIChzZWxmLl9yZXF1ZXN0KHdpcmUsIHBpZWNlLCBmYWxzZSkpIHJldHVyblxuICAgICAgICAgIHRyaWVkW3BpZWNlXSA9IHRydWVcbiAgICAgICAgICB0cmllcyArPSAxXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAocGllY2UgPSBuZXh0LnRvOyBwaWVjZSA+PSBuZXh0LmZyb20gKyBuZXh0Lm9mZnNldDsgLS1waWVjZSkge1xuICAgICAgICAgIGlmICghd2lyZS5wZWVyUGllY2VzLmdldChwaWVjZSkpIGNvbnRpbnVlXG4gICAgICAgICAgaWYgKHNlbGYuX3JlcXVlc3Qod2lyZSwgcGllY2UsIGZhbHNlKSkgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB3aXJlIGZhaWxlZCB0byB2YWxpZGF0ZSBhcyB1c2VmdWw7IHNob3VsZCB3ZSBjbG9zZSBpdD9cbiAgICAvLyBwcm9iYWJseSBub3QsIHNpbmNlICdoYXZlJyBhbmQgJ2JpdGZpZWxkJyBtZXNzYWdlcyBtaWdodCBiZSBjb21pbmdcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWVkUmFua2VyICgpIHtcbiAgICB2YXIgc3BlZWQgPSB3aXJlLmRvd25sb2FkU3BlZWQoKSB8fCAxXG4gICAgaWYgKHNwZWVkID4gU1BFRURfVEhSRVNIT0xEKSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgICB2YXIgc2VjcyA9IE1hdGgubWF4KDEsIHdpcmUucmVxdWVzdHMubGVuZ3RoKSAqIFBpZWNlLkJMT0NLX0xFTkdUSCAvIHNwZWVkXG4gICAgdmFyIHRyaWVzID0gMTBcbiAgICB2YXIgcHRyID0gMFxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaWYgKCF0cmllcyB8fCBzZWxmLmJpdGZpZWxkLmdldChpbmRleCkpIHJldHVybiB0cnVlXG5cbiAgICAgIHZhciBtaXNzaW5nID0gc2VsZi5waWVjZXNbaW5kZXhdLm1pc3NpbmdcblxuICAgICAgZm9yICg7IHB0ciA8IHNlbGYud2lyZXMubGVuZ3RoOyBwdHIrKykge1xuICAgICAgICB2YXIgb3RoZXJXaXJlID0gc2VsZi53aXJlc1twdHJdXG4gICAgICAgIHZhciBvdGhlclNwZWVkID0gb3RoZXJXaXJlLmRvd25sb2FkU3BlZWQoKVxuXG4gICAgICAgIGlmIChvdGhlclNwZWVkIDwgU1BFRURfVEhSRVNIT0xEKSBjb250aW51ZVxuICAgICAgICBpZiAob3RoZXJTcGVlZCA8PSBzcGVlZCkgY29udGludWVcbiAgICAgICAgaWYgKCFvdGhlcldpcmUucGVlclBpZWNlcy5nZXQoaW5kZXgpKSBjb250aW51ZVxuICAgICAgICBpZiAoKG1pc3NpbmcgLT0gb3RoZXJTcGVlZCAqIHNlY3MpID4gMCkgY29udGludWVcblxuICAgICAgICB0cmllcy0tXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNodWZmbGVQcmlvcml0eSAoaSkge1xuICAgIHZhciBsYXN0ID0gaVxuICAgIGZvciAodmFyIGogPSBpOyBqIDwgc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGggJiYgc2VsZi5fc2VsZWN0aW9uc1tqXS5wcmlvcml0eTsgaisrKSB7XG4gICAgICBsYXN0ID0galxuICAgIH1cbiAgICB2YXIgdG1wID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuICAgIHNlbGYuX3NlbGVjdGlvbnNbaV0gPSBzZWxmLl9zZWxlY3Rpb25zW2xhc3RdXG4gICAgc2VsZi5fc2VsZWN0aW9uc1tsYXN0XSA9IHRtcFxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5U2VsZWN0V2lyZSAoaG90c3dhcCkge1xuICAgIGlmICh3aXJlLnJlcXVlc3RzLmxlbmd0aCA+PSBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzKSByZXR1cm4gdHJ1ZVxuICAgIHZhciByYW5rID0gc3BlZWRSYW5rZXIoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cblxuICAgICAgdmFyIHBpZWNlXG4gICAgICBpZiAoc2VsZi5zdHJhdGVneSA9PT0gJ3JhcmVzdCcpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbmV4dC5mcm9tICsgbmV4dC5vZmZzZXRcbiAgICAgICAgdmFyIGVuZCA9IG5leHQudG9cbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0ICsgMVxuICAgICAgICB2YXIgdHJpZWQgPSB7fVxuICAgICAgICB2YXIgdHJpZXMgPSAwXG4gICAgICAgIHZhciBmaWx0ZXIgPSBnZW5QaWVjZUZpbHRlckZ1bmMoc3RhcnQsIGVuZCwgdHJpZWQsIHJhbmspXG5cbiAgICAgICAgd2hpbGUgKHRyaWVzIDwgbGVuKSB7XG4gICAgICAgICAgcGllY2UgPSBzZWxmLl9yYXJpdHlNYXAuZ2V0UmFyZXN0UGllY2UoZmlsdGVyKVxuICAgICAgICAgIGlmIChwaWVjZSA8IDApIGJyZWFrXG5cbiAgICAgICAgICAvLyByZXF1ZXN0IGFsbCBub24tcmVzZXJ2ZWQgYmxvY2tzIGluIHRoaXMgcGllY2VcbiAgICAgICAgICB3aGlsZSAoc2VsZi5fcmVxdWVzdCh3aXJlLCBwaWVjZSwgc2VsZi5fY3JpdGljYWxbcGllY2VdIHx8IGhvdHN3YXApKSB7fVxuXG4gICAgICAgICAgaWYgKHdpcmUucmVxdWVzdHMubGVuZ3RoIDwgbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cykge1xuICAgICAgICAgICAgdHJpZWRbcGllY2VdID0gdHJ1ZVxuICAgICAgICAgICAgdHJpZXMrK1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmV4dC5wcmlvcml0eSkgc2h1ZmZsZVByaW9yaXR5KGkpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChwaWVjZSA9IG5leHQuZnJvbSArIG5leHQub2Zmc2V0OyBwaWVjZSA8PSBuZXh0LnRvOyBwaWVjZSsrKSB7XG4gICAgICAgICAgaWYgKCF3aXJlLnBlZXJQaWVjZXMuZ2V0KHBpZWNlKSB8fCAhcmFuayhwaWVjZSkpIGNvbnRpbnVlXG5cbiAgICAgICAgICAvLyByZXF1ZXN0IGFsbCBub24tcmVzZXJ2ZWQgYmxvY2tzIGluIHBpZWNlXG4gICAgICAgICAgd2hpbGUgKHNlbGYuX3JlcXVlc3Qod2lyZSwgcGllY2UsIHNlbGYuX2NyaXRpY2FsW3BpZWNlXSB8fCBob3Rzd2FwKSkge31cblxuICAgICAgICAgIGlmICh3aXJlLnJlcXVlc3RzLmxlbmd0aCA8IG1heE91dHN0YW5kaW5nUmVxdWVzdHMpIGNvbnRpbnVlXG5cbiAgICAgICAgICBpZiAobmV4dC5wcmlvcml0eSkgc2h1ZmZsZVByaW9yaXR5KGkpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQ2FsbGVkIHBlcmlvZGljYWxseSB0byB1cGRhdGUgdGhlIGNob2tlZCBzdGF0dXMgb2YgYWxsIHBlZXJzLCBoYW5kbGluZyBvcHRpbWlzdGljXG4gKiB1bmNob2tpbmcgYXMgZGVzY3JpYmVkIGluIEJFUDMuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9yZWNob2tlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLnJlYWR5KSByZXR1cm5cblxuICBpZiAoc2VsZi5fcmVjaG9rZU9wdGltaXN0aWNUaW1lID4gMCkgc2VsZi5fcmVjaG9rZU9wdGltaXN0aWNUaW1lIC09IDFcbiAgZWxzZSBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUgPSBudWxsXG5cbiAgdmFyIHBlZXJzID0gW11cblxuICBzZWxmLndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICBpZiAoIXdpcmUuaXNTZWVkZXIgJiYgd2lyZSAhPT0gc2VsZi5fcmVjaG9rZU9wdGltaXN0aWNXaXJlKSB7XG4gICAgICBwZWVycy5wdXNoKHtcbiAgICAgICAgd2lyZTogd2lyZSxcbiAgICAgICAgZG93bmxvYWRTcGVlZDogd2lyZS5kb3dubG9hZFNwZWVkKCksXG4gICAgICAgIHVwbG9hZFNwZWVkOiB3aXJlLnVwbG9hZFNwZWVkKCksXG4gICAgICAgIHNhbHQ6IE1hdGgucmFuZG9tKCksXG4gICAgICAgIGlzQ2hva2VkOiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICBwZWVycy5zb3J0KHJlY2hva2VTb3J0KVxuXG4gIHZhciB1bmNob2tlSW50ZXJlc3RlZCA9IDBcbiAgdmFyIGkgPSAwXG4gIGZvciAoOyBpIDwgcGVlcnMubGVuZ3RoICYmIHVuY2hva2VJbnRlcmVzdGVkIDwgc2VsZi5fcmVjaG9rZU51bVNsb3RzOyArK2kpIHtcbiAgICBwZWVyc1tpXS5pc0Nob2tlZCA9IGZhbHNlXG4gICAgaWYgKHBlZXJzW2ldLndpcmUucGVlckludGVyZXN0ZWQpIHVuY2hva2VJbnRlcmVzdGVkICs9IDFcbiAgfVxuXG4gIC8vIE9wdGltaXN0aWNhbGx5IHVuY2hva2UgYSBwZWVyXG4gIGlmICghc2VsZi5fcmVjaG9rZU9wdGltaXN0aWNXaXJlICYmIGkgPCBwZWVycy5sZW5ndGggJiYgc2VsZi5fcmVjaG9rZU51bVNsb3RzKSB7XG4gICAgdmFyIGNhbmRpZGF0ZXMgPSBwZWVycy5zbGljZShpKS5maWx0ZXIoZnVuY3Rpb24gKHBlZXIpIHsgcmV0dXJuIHBlZXIud2lyZS5wZWVySW50ZXJlc3RlZCB9KVxuICAgIHZhciBvcHRpbWlzdGljID0gY2FuZGlkYXRlc1tyYW5kb21JbnQoY2FuZGlkYXRlcy5sZW5ndGgpXVxuXG4gICAgaWYgKG9wdGltaXN0aWMpIHtcbiAgICAgIG9wdGltaXN0aWMuaXNDaG9rZWQgPSBmYWxzZVxuICAgICAgc2VsZi5fcmVjaG9rZU9wdGltaXN0aWNXaXJlID0gb3B0aW1pc3RpYy53aXJlXG4gICAgICBzZWxmLl9yZWNob2tlT3B0aW1pc3RpY1RpbWUgPSBSRUNIT0tFX09QVElNSVNUSUNfRFVSQVRJT05cbiAgICB9XG4gIH1cblxuICAvLyBVbmNob2tlIGJlc3QgcGVlcnNcbiAgcGVlcnMuZm9yRWFjaChmdW5jdGlvbiAocGVlcikge1xuICAgIGlmIChwZWVyLndpcmUuYW1DaG9raW5nICE9PSBwZWVyLmlzQ2hva2VkKSB7XG4gICAgICBpZiAocGVlci5pc0Nob2tlZCkgcGVlci53aXJlLmNob2tlKClcbiAgICAgIGVsc2UgcGVlci53aXJlLnVuY2hva2UoKVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiByZWNob2tlU29ydCAocGVlckEsIHBlZXJCKSB7XG4gICAgLy8gUHJlZmVyIGhpZ2hlciBkb3dubG9hZCBzcGVlZFxuICAgIGlmIChwZWVyQS5kb3dubG9hZFNwZWVkICE9PSBwZWVyQi5kb3dubG9hZFNwZWVkKSB7XG4gICAgICByZXR1cm4gcGVlckIuZG93bmxvYWRTcGVlZCAtIHBlZXJBLmRvd25sb2FkU3BlZWRcbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgaGlnaGVyIHVwbG9hZCBzcGVlZFxuICAgIGlmIChwZWVyQS51cGxvYWRTcGVlZCAhPT0gcGVlckIudXBsb2FkU3BlZWQpIHtcbiAgICAgIHJldHVybiBwZWVyQi51cGxvYWRTcGVlZCAtIHBlZXJBLnVwbG9hZFNwZWVkXG4gICAgfVxuXG4gICAgLy8gUHJlZmVyIHVuY2hva2VkXG4gICAgaWYgKHBlZXJBLndpcmUuYW1DaG9raW5nICE9PSBwZWVyQi53aXJlLmFtQ2hva2luZykge1xuICAgICAgcmV0dXJuIHBlZXJBLndpcmUuYW1DaG9raW5nID8gMSA6IC0xXG4gICAgfVxuXG4gICAgLy8gUmFuZG9tIG9yZGVyXG4gICAgcmV0dXJuIHBlZXJBLnNhbHQgLSBwZWVyQi5zYWx0XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBjYW5jZWwgYSBzbG93IGJsb2NrIHJlcXVlc3QgZnJvbSBhbm90aGVyIHdpcmUgc3VjaCB0aGF0IHRoZVxuICogZ2l2ZW4gd2lyZSBtYXkgZWZmZWN0aXZlbHkgc3dhcCBvdXQgdGhlIHJlcXVlc3QgZm9yIG9uZSBvZiBpdHMgb3duLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5faG90c3dhcCA9IGZ1bmN0aW9uICh3aXJlLCBpbmRleCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgc3BlZWQgPSB3aXJlLmRvd25sb2FkU3BlZWQoKVxuICBpZiAoc3BlZWQgPCBQaWVjZS5CTE9DS19MRU5HVEgpIHJldHVybiBmYWxzZVxuICBpZiAoIXNlbGYuX3Jlc2VydmF0aW9uc1tpbmRleF0pIHJldHVybiBmYWxzZVxuXG4gIHZhciByID0gc2VsZi5fcmVzZXJ2YXRpb25zW2luZGV4XVxuICBpZiAoIXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBtaW5TcGVlZCA9IEluZmluaXR5XG4gIHZhciBtaW5XaXJlXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb3RoZXJXaXJlID0gcltpXVxuICAgIGlmICghb3RoZXJXaXJlIHx8IG90aGVyV2lyZSA9PT0gd2lyZSkgY29udGludWVcblxuICAgIHZhciBvdGhlclNwZWVkID0gb3RoZXJXaXJlLmRvd25sb2FkU3BlZWQoKVxuICAgIGlmIChvdGhlclNwZWVkID49IFNQRUVEX1RIUkVTSE9MRCkgY29udGludWVcbiAgICBpZiAoMiAqIG90aGVyU3BlZWQgPiBzcGVlZCB8fCBvdGhlclNwZWVkID4gbWluU3BlZWQpIGNvbnRpbnVlXG5cbiAgICBtaW5XaXJlID0gb3RoZXJXaXJlXG4gICAgbWluU3BlZWQgPSBvdGhlclNwZWVkXG4gIH1cblxuICBpZiAoIW1pbldpcmUpIHJldHVybiBmYWxzZVxuXG4gIGZvciAoaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJbaV0gPT09IG1pbldpcmUpIHJbaV0gPSBudWxsXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbWluV2lyZS5yZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXEgPSBtaW5XaXJlLnJlcXVlc3RzW2ldXG4gICAgaWYgKHJlcS5waWVjZSAhPT0gaW5kZXgpIGNvbnRpbnVlXG5cbiAgICBzZWxmLnBpZWNlc1tpbmRleF0uY2FuY2VsKChyZXEub2Zmc2V0IC8gUGllY2UuQkxPQ0tfTEVOR1RIKSB8IDApXG4gIH1cblxuICBzZWxmLmVtaXQoJ2hvdHN3YXAnLCBtaW5XaXJlLCB3aXJlLCBpbmRleClcbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXF1ZXN0IGEgYmxvY2sgZnJvbSB0aGUgZ2l2ZW4gd2lyZS5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbiAod2lyZSwgaW5kZXgsIGhvdHN3YXApIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBudW1SZXF1ZXN0cyA9IHdpcmUucmVxdWVzdHMubGVuZ3RoXG4gIHZhciBpc1dlYlNlZWQgPSB3aXJlLnR5cGUgPT09ICd3ZWJTZWVkJ1xuXG4gIGlmIChzZWxmLmJpdGZpZWxkLmdldChpbmRleCkpIHJldHVybiBmYWxzZVxuXG4gIHZhciBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzID0gaXNXZWJTZWVkXG4gICAgPyBNYXRoLm1pbihcbiAgICAgICAgZ2V0UGllY2VQaXBlbGluZUxlbmd0aCh3aXJlLCBQSVBFTElORV9NQVhfRFVSQVRJT04sIHNlbGYucGllY2VMZW5ndGgpLFxuICAgICAgICBzZWxmLm1heFdlYkNvbm5zXG4gICAgICApXG4gICAgOiBnZXRCbG9ja1BpcGVsaW5lTGVuZ3RoKHdpcmUsIFBJUEVMSU5FX01BWF9EVVJBVElPTilcblxuICBpZiAobnVtUmVxdWVzdHMgPj0gbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cykgcmV0dXJuIGZhbHNlXG4gIC8vIHZhciBlbmRHYW1lID0gKHdpcmUucmVxdWVzdHMubGVuZ3RoID09PSAwICYmIHNlbGYuc3RvcmUubnVtTWlzc2luZyA8IDMwKVxuXG4gIHZhciBwaWVjZSA9IHNlbGYucGllY2VzW2luZGV4XVxuICB2YXIgcmVzZXJ2YXRpb24gPSBpc1dlYlNlZWQgPyBwaWVjZS5yZXNlcnZlUmVtYWluaW5nKCkgOiBwaWVjZS5yZXNlcnZlKClcblxuICBpZiAocmVzZXJ2YXRpb24gPT09IC0xICYmIGhvdHN3YXAgJiYgc2VsZi5faG90c3dhcCh3aXJlLCBpbmRleCkpIHtcbiAgICByZXNlcnZhdGlvbiA9IGlzV2ViU2VlZCA/IHBpZWNlLnJlc2VydmVSZW1haW5pbmcoKSA6IHBpZWNlLnJlc2VydmUoKVxuICB9XG4gIGlmIChyZXNlcnZhdGlvbiA9PT0gLTEpIHJldHVybiBmYWxzZVxuXG4gIHZhciByID0gc2VsZi5fcmVzZXJ2YXRpb25zW2luZGV4XVxuICBpZiAoIXIpIHIgPSBzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdID0gW11cbiAgdmFyIGkgPSByLmluZGV4T2YobnVsbClcbiAgaWYgKGkgPT09IC0xKSBpID0gci5sZW5ndGhcbiAgcltpXSA9IHdpcmVcblxuICB2YXIgY2h1bmtPZmZzZXQgPSBwaWVjZS5jaHVua09mZnNldChyZXNlcnZhdGlvbilcbiAgdmFyIGNodW5rTGVuZ3RoID0gaXNXZWJTZWVkID8gcGllY2UuY2h1bmtMZW5ndGhSZW1haW5pbmcocmVzZXJ2YXRpb24pIDogcGllY2UuY2h1bmtMZW5ndGgocmVzZXJ2YXRpb24pXG5cbiAgd2lyZS5yZXF1ZXN0KGluZGV4LCBjaHVua09mZnNldCwgY2h1bmtMZW5ndGgsIGZ1bmN0aW9uIG9uQ2h1bmsgKGVyciwgY2h1bmspIHtcbiAgICAvLyBUT0RPOiB3aGF0IGlzIHRoaXMgZm9yP1xuICAgIGlmICghc2VsZi5yZWFkeSkgcmV0dXJuIHNlbGYub25jZSgncmVhZHknLCBmdW5jdGlvbiAoKSB7IG9uQ2h1bmsoZXJyLCBjaHVuaykgfSlcblxuICAgIGlmIChyW2ldID09PSB3aXJlKSByW2ldID0gbnVsbFxuXG4gICAgaWYgKHBpZWNlICE9PSBzZWxmLnBpZWNlc1tpbmRleF0pIHJldHVybiBvblVwZGF0ZVRpY2soKVxuXG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5fZGVidWcoXG4gICAgICAgICdlcnJvciBnZXR0aW5nIHBpZWNlICVzIChvZmZzZXQ6ICVzIGxlbmd0aDogJXMpIGZyb20gJXM6ICVzJyxcbiAgICAgICAgaW5kZXgsIGNodW5rT2Zmc2V0LCBjaHVua0xlbmd0aCwgd2lyZS5yZW1vdGVBZGRyZXNzICsgJzonICsgd2lyZS5yZW1vdGVQb3J0LFxuICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgKVxuICAgICAgaXNXZWJTZWVkID8gcGllY2UuY2FuY2VsUmVtYWluaW5nKHJlc2VydmF0aW9uKSA6IHBpZWNlLmNhbmNlbChyZXNlcnZhdGlvbilcbiAgICAgIG9uVXBkYXRlVGljaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZWxmLl9kZWJ1ZyhcbiAgICAgICdnb3QgcGllY2UgJXMgKG9mZnNldDogJXMgbGVuZ3RoOiAlcykgZnJvbSAlcycsXG4gICAgICBpbmRleCwgY2h1bmtPZmZzZXQsIGNodW5rTGVuZ3RoLCB3aXJlLnJlbW90ZUFkZHJlc3MgKyAnOicgKyB3aXJlLnJlbW90ZVBvcnRcbiAgICApXG5cbiAgICBpZiAoIXBpZWNlLnNldChyZXNlcnZhdGlvbiwgY2h1bmssIHdpcmUpKSByZXR1cm4gb25VcGRhdGVUaWNrKClcblxuICAgIHZhciBidWYgPSBwaWVjZS5mbHVzaCgpXG5cbiAgICAvLyBUT0RPOiBtaWdodCBuZWVkIHRvIHNldCBzZWxmLnBpZWNlc1tpbmRleF0gPSBudWxsIGhlcmUgc2luY2Ugc2hhMSBpcyBhc3luY1xuXG4gICAgc2hhMShidWYsIGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICBpZiAoaGFzaCA9PT0gc2VsZi5faGFzaGVzW2luZGV4XSkge1xuICAgICAgICBpZiAoIXNlbGYucGllY2VzW2luZGV4XSkgcmV0dXJuXG4gICAgICAgIHNlbGYuX2RlYnVnKCdwaWVjZSB2ZXJpZmllZCAlcycsIGluZGV4KVxuXG4gICAgICAgIHNlbGYucGllY2VzW2luZGV4XSA9IG51bGxcbiAgICAgICAgc2VsZi5fcmVzZXJ2YXRpb25zW2luZGV4XSA9IG51bGxcbiAgICAgICAgc2VsZi5iaXRmaWVsZC5zZXQoaW5kZXgsIHRydWUpXG5cbiAgICAgICAgc2VsZi5zdG9yZS5wdXQoaW5kZXgsIGJ1ZilcblxuICAgICAgICBzZWxmLndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICAgICAgICB3aXJlLmhhdmUoaW5kZXgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc2VsZi5fY2hlY2tEb25lKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucGllY2VzW2luZGV4XSA9IG5ldyBQaWVjZShwaWVjZS5sZW5ndGgpXG4gICAgICAgIHNlbGYuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGllY2UgJyArIGluZGV4ICsgJyBmYWlsZWQgdmVyaWZpY2F0aW9uJykpXG4gICAgICB9XG4gICAgICBvblVwZGF0ZVRpY2soKVxuICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gb25VcGRhdGVUaWNrICgpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgc2VsZi5fdXBkYXRlKCkgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9jaGVja0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIC8vIGFyZSBhbnkgbmV3IGZpbGVzIGRvbmU/XG4gIHNlbGYuZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgIGlmIChmaWxlLmRvbmUpIHJldHVyblxuICAgIGZvciAodmFyIGkgPSBmaWxlLl9zdGFydFBpZWNlOyBpIDw9IGZpbGUuX2VuZFBpZWNlOyArK2kpIHtcbiAgICAgIGlmICghc2VsZi5iaXRmaWVsZC5nZXQoaSkpIHJldHVyblxuICAgIH1cbiAgICBmaWxlLmRvbmUgPSB0cnVlXG4gICAgZmlsZS5lbWl0KCdkb25lJylcbiAgICBzZWxmLl9kZWJ1ZygnZmlsZSBkb25lOiAnICsgZmlsZS5uYW1lKVxuICB9KVxuXG4gIC8vIGlzIHRoZSB0b3JyZW50IGRvbmU/IChpZiBhbGwgY3VycmVudCBzZWxlY3Rpb25zIGFyZSBzYXRpc2ZpZWQsIG9yIHRoZXJlIGFyZVxuICAvLyBubyBzZWxlY3Rpb25zLCB0aGVuIHRvcnJlbnQgaXMgZG9uZSlcbiAgdmFyIGRvbmUgPSB0cnVlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWxlY3Rpb24gPSBzZWxmLl9zZWxlY3Rpb25zW2ldXG4gICAgZm9yICh2YXIgcGllY2UgPSBzZWxlY3Rpb24uZnJvbTsgcGllY2UgPD0gc2VsZWN0aW9uLnRvOyBwaWVjZSsrKSB7XG4gICAgICBpZiAoIXNlbGYuYml0ZmllbGQuZ2V0KHBpZWNlKSkge1xuICAgICAgICBkb25lID0gZmFsc2VcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkb25lKSBicmVha1xuICB9XG4gIGlmICghc2VsZi5kb25lICYmIGRvbmUpIHtcbiAgICBzZWxmLmRvbmUgPSB0cnVlXG4gICAgc2VsZi5fZGVidWcoJ3RvcnJlbnQgZG9uZTogJyArIHNlbGYuaW5mb0hhc2gpXG4gICAgaWYgKHNlbGYuZGlzY292ZXJ5LnRyYWNrZXIpIHtcbiAgICAgIHNlbGYuZGlzY292ZXJ5LnRyYWNrZXIuY29tcGxldGUoKVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2RvbmUnKVxuICB9XG5cbiAgc2VsZi5fZ2NTZWxlY3Rpb25zKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChzdHJlYW1zLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcbiAgaWYgKCFzZWxmLnJlYWR5KSByZXR1cm4gc2VsZi5vbmNlKCdyZWFkeScsIGZ1bmN0aW9uICgpIHsgc2VsZi5sb2FkKHN0cmVhbXMsIGNiKSB9KVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzdHJlYW1zKSkgc3RyZWFtcyA9IFsgc3RyZWFtcyBdXG4gIGlmICghY2IpIGNiID0gbm9vcFxuXG4gIHZhciByZWFkYWJsZSA9IG5ldyBNdWx0aVN0cmVhbShzdHJlYW1zKVxuICB2YXIgd3JpdGFibGUgPSBuZXcgQ2h1bmtTdG9yZVdyaXRlU3RyZWFtKHNlbGYuc3RvcmUsIHNlbGYucGllY2VMZW5ndGgpXG5cbiAgcHVtcChyZWFkYWJsZSwgd3JpdGFibGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHNlbGYucGllY2VzLmZvckVhY2goZnVuY3Rpb24gKHBpZWNlLCBpbmRleCkge1xuICAgICAgc2VsZi5waWVjZXNbaW5kZXhdID0gbnVsbFxuICAgICAgc2VsZi5fcmVzZXJ2YXRpb25zW2luZGV4XSA9IG51bGxcbiAgICAgIHNlbGYuYml0ZmllbGQuc2V0KGluZGV4LCB0cnVlKVxuICAgIH0pXG4gICAgc2VsZi5fY2hlY2tEb25lKClcbiAgICBjYihudWxsKVxuICB9KVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5jcmVhdGVTZXJ2ZXIgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAodHlwZW9mIFNlcnZlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdub2RlLmpzLW9ubHkgbWV0aG9kJylcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcbiAgdmFyIHNlcnZlciA9IG5ldyBTZXJ2ZXIodGhpcywgb3B0cylcbiAgdGhpcy5fc2VydmVycy5wdXNoKHNlcnZlcilcbiAgcmV0dXJuIHNlcnZlclxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVidWcoJ3BhdXNlJylcbiAgdGhpcy5wYXVzZWQgPSB0cnVlXG59XG5cblRvcnJlbnQucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVidWcoJ3Jlc3VtZScpXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgdGhpcy5fZHJhaW4oKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIGFyZ3NbMF0gPSAnWycgKyB0aGlzLl9kZWJ1Z0lkICsgJ10gJyArIGFyZ3NbMF1cbiAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbn1cblxuLyoqXG4gKiBQb3AgYSBwZWVyIG9mZiB0aGUgRklGTyBxdWV1ZSBhbmQgY29ubmVjdCB0byBpdC4gV2hlbiBfZHJhaW4oKSBnZXRzIGNhbGxlZCxcbiAqIHRoZSBxdWV1ZSB3aWxsIHVzdWFsbHkgaGF2ZSBvbmx5IG9uZSBwZWVyIGluIGl0LCBleGNlcHQgd2hlbiB0aGVyZSBhcmUgdG9vXG4gKiBtYW55IHBlZXJzIChvdmVyIGB0aGlzLm1heENvbm5zYCkgaW4gd2hpY2ggY2FzZSB0aGV5IHdpbGwganVzdCBzaXQgaW4gdGhlXG4gKiBxdWV1ZSB1bnRpbCBhbm90aGVyIGNvbm5lY3Rpb24gY2xvc2VzLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fZHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9kZWJ1ZygnX2RyYWluIG51bUNvbm5zICVzIG1heENvbm5zICVzJywgc2VsZi5fbnVtQ29ubnMsIHNlbGYuY2xpZW50Lm1heENvbm5zKVxuICBpZiAodHlwZW9mIG5ldC5jb25uZWN0ICE9PSAnZnVuY3Rpb24nIHx8IHNlbGYuZGVzdHJveWVkIHx8IHNlbGYucGF1c2VkIHx8XG4gICAgICBzZWxmLl9udW1Db25ucyA+PSBzZWxmLmNsaWVudC5tYXhDb25ucykge1xuICAgIHJldHVyblxuICB9XG4gIHRoaXMuX2RlYnVnKCdkcmFpbiAoJXMgcXVldWVkLCAlcy8lcyBwZWVycyknLCBzZWxmLl9udW1RdWV1ZWQsIHNlbGYubnVtUGVlcnMsIHNlbGYuY2xpZW50Lm1heENvbm5zKVxuXG4gIHZhciBwZWVyID0gc2VsZi5fcXVldWUuc2hpZnQoKVxuICBpZiAoIXBlZXIpIHJldHVybiAvLyBxdWV1ZSBjb3VsZCBiZSBlbXB0eVxuXG4gIHRoaXMuX2RlYnVnKCd0Y3AgY29ubmVjdCBhdHRlbXB0IHRvICVzJywgcGVlci5hZGRyKVxuXG4gIHZhciBwYXJ0cyA9IGFkZHJUb0lQUG9ydChwZWVyLmFkZHIpXG4gIHZhciBvcHRzID0ge1xuICAgIGhvc3Q6IHBhcnRzWzBdLFxuICAgIHBvcnQ6IHBhcnRzWzFdXG4gIH1cblxuICB2YXIgY29ubiA9IHBlZXIuY29ubiA9IG5ldC5jb25uZWN0KG9wdHMpXG5cbiAgY29ubi5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkgeyBwZWVyLm9uQ29ubmVjdCgpIH0pXG4gIGNvbm4ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IHBlZXIuZGVzdHJveShlcnIpIH0pXG4gIHBlZXIuc3RhcnRDb25uZWN0VGltZW91dCgpXG5cbiAgLy8gV2hlbiBjb25uZWN0aW9uIGNsb3NlcywgYXR0ZW1wdCByZWNvbm5lY3QgYWZ0ZXIgdGltZW91dCAod2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmKVxuICBjb25uLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgLy8gVE9ETzogSWYgdG9ycmVudCBpcyBkb25lLCBkbyBub3QgdHJ5IHRvIHJlY29ubmVjdCBhZnRlciBhIHRpbWVvdXRcblxuICAgIGlmIChwZWVyLnJldHJpZXMgPj0gUkVDT05ORUNUX1dBSVQubGVuZ3RoKSB7XG4gICAgICBzZWxmLl9kZWJ1ZyhcbiAgICAgICAgJ2Nvbm4gJXMgY2xvc2VkOiB3aWxsIG5vdCByZS1hZGQgKG1heCAlcyBhdHRlbXB0cyknLFxuICAgICAgICBwZWVyLmFkZHIsIFJFQ09OTkVDVF9XQUlULmxlbmd0aFxuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIG1zID0gUkVDT05ORUNUX1dBSVRbcGVlci5yZXRyaWVzXVxuICAgIHNlbGYuX2RlYnVnKFxuICAgICAgJ2Nvbm4gJXMgY2xvc2VkOiB3aWxsIHJlLWFkZCB0byBxdWV1ZSBpbiAlc21zIChhdHRlbXB0ICVzKScsXG4gICAgICBwZWVyLmFkZHIsIG1zLCBwZWVyLnJldHJpZXMgKyAxXG4gICAgKVxuXG4gICAgdmFyIHJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHJlY29ubmVjdFRpbWVvdXQgKCkge1xuICAgICAgdmFyIG5ld1BlZXIgPSBzZWxmLl9hZGRQZWVyKHBlZXIuYWRkcilcbiAgICAgIGlmIChuZXdQZWVyKSBuZXdQZWVyLnJldHJpZXMgPSBwZWVyLnJldHJpZXMgKyAxXG4gICAgfSwgbXMpXG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXQudW5yZWYpIHJlY29ubmVjdFRpbWVvdXQudW5yZWYoKVxuICB9KVxufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHN0cmluZyBpcyB2YWxpZCBJUHY0LzYgYWRkcmVzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fdmFsaWRBZGRyID0gZnVuY3Rpb24gKGFkZHIpIHtcbiAgdmFyIHBhcnRzXG4gIHRyeSB7XG4gICAgcGFydHMgPSBhZGRyVG9JUFBvcnQoYWRkcilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBob3N0ID0gcGFydHNbMF1cbiAgdmFyIHBvcnQgPSBwYXJ0c1sxXVxuICByZXR1cm4gcG9ydCA+IDAgJiYgcG9ydCA8IDY1NTM1ICYmXG4gICAgIShob3N0ID09PSAnMTI3LjAuMC4xJyAmJiBwb3J0ID09PSB0aGlzLmNsaWVudC50b3JyZW50UG9ydClcbn1cblxuZnVuY3Rpb24gZ2V0QmxvY2tQaXBlbGluZUxlbmd0aCAod2lyZSwgZHVyYXRpb24pIHtcbiAgcmV0dXJuIDIgKyBNYXRoLmNlaWwoZHVyYXRpb24gKiB3aXJlLmRvd25sb2FkU3BlZWQoKSAvIFBpZWNlLkJMT0NLX0xFTkdUSClcbn1cblxuZnVuY3Rpb24gZ2V0UGllY2VQaXBlbGluZUxlbmd0aCAod2lyZSwgZHVyYXRpb24sIHBpZWNlTGVuZ3RoKSB7XG4gIHJldHVybiAxICsgTWF0aC5jZWlsKGR1cmF0aW9uICogd2lyZS5kb3dubG9hZFNwZWVkKCkgLyBwaWVjZUxlbmd0aClcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgaW4gWzAsaGlnaClcbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50IChoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpICogaGlnaCB8IDBcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBXZWJDb25uXG5cbnZhciBCaXRGaWVsZCA9IHJlcXVpcmUoJ2JpdGZpZWxkJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2VidG9ycmVudDp3ZWJjb25uJylcbnZhciBnZXQgPSByZXF1aXJlKCdzaW1wbGUtZ2V0JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIFdpcmUgPSByZXF1aXJlKCdiaXR0b3JyZW50LXByb3RvY29sJylcblxudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbmluaGVyaXRzKFdlYkNvbm4sIFdpcmUpXG5cbi8qKlxuICogQ29udmVydHMgcmVxdWVzdHMgZm9yIHRvcnJlbnQgYmxvY2tzIGludG8gaHR0cCByYW5nZSByZXF1ZXN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgd2ViIHNlZWQgdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gdG9ycmVudFxuICovXG5mdW5jdGlvbiBXZWJDb25uICh1cmwsIHRvcnJlbnQpIHtcbiAgV2lyZS5jYWxsKHRoaXMpXG5cbiAgdGhpcy51cmwgPSB1cmxcbiAgdGhpcy53ZWJQZWVySWQgPSBzaGExLnN5bmModXJsKVxuICB0aGlzLl90b3JyZW50ID0gdG9ycmVudFxuXG4gIHRoaXMuX2luaXQoKVxufVxuXG5XZWJDb25uLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuc2V0S2VlcEFsaXZlKHRydWUpXG5cbiAgc2VsZi5vbmNlKCdoYW5kc2hha2UnLCBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCkge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc2VsZi5oYW5kc2hha2UoaW5mb0hhc2gsIHNlbGYud2ViUGVlcklkKVxuICAgIHZhciBudW1QaWVjZXMgPSBzZWxmLl90b3JyZW50LnBpZWNlcy5sZW5ndGhcbiAgICB2YXIgYml0ZmllbGQgPSBuZXcgQml0RmllbGQobnVtUGllY2VzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG51bVBpZWNlczsgaSsrKSB7XG4gICAgICBiaXRmaWVsZC5zZXQoaSwgdHJ1ZSlcbiAgICB9XG4gICAgc2VsZi5iaXRmaWVsZChiaXRmaWVsZClcbiAgfSlcblxuICBzZWxmLm9uY2UoJ2ludGVyZXN0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ2ludGVyZXN0ZWQnKVxuICAgIHNlbGYudW5jaG9rZSgpXG4gIH0pXG5cbiAgc2VsZi5vbigndW5pbnRlcmVzdGVkJywgZnVuY3Rpb24gKCkgeyBkZWJ1ZygndW5pbnRlcmVzdGVkJykgfSlcbiAgc2VsZi5vbignY2hva2UnLCBmdW5jdGlvbiAoKSB7IGRlYnVnKCdjaG9rZScpIH0pXG4gIHNlbGYub24oJ3VuY2hva2UnLCBmdW5jdGlvbiAoKSB7IGRlYnVnKCd1bmNob2tlJykgfSlcbiAgc2VsZi5vbignYml0ZmllbGQnLCBmdW5jdGlvbiAoKSB7IGRlYnVnKCdiaXRmaWVsZCcpIH0pXG5cbiAgc2VsZi5vbigncmVxdWVzdCcsIGZ1bmN0aW9uIChwaWVjZUluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygncmVxdWVzdCBwaWVjZUluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQnLCBwaWVjZUluZGV4LCBvZmZzZXQsIGxlbmd0aClcbiAgICBzZWxmLmh0dHBSZXF1ZXN0KHBpZWNlSW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYWxsYmFjaylcbiAgfSlcbn1cblxuV2ViQ29ubi5wcm90b3R5cGUuaHR0cFJlcXVlc3QgPSBmdW5jdGlvbiAocGllY2VJbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcGllY2VPZmZzZXQgPSBwaWVjZUluZGV4ICogc2VsZi5fdG9ycmVudC5waWVjZUxlbmd0aFxuICB2YXIgcmFuZ2VTdGFydCA9IHBpZWNlT2Zmc2V0ICsgb2Zmc2V0IC8qIG9mZnNldCB3aXRoaW4gd2hvbGUgdG9ycmVudCAqL1xuICB2YXIgcmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgbGVuZ3RoIC0gMVxuXG4gIC8vIFdlYiBzZWVkIFVSTCBmb3JtYXQ6XG4gIC8vIEZvciBzaW5nbGUtZmlsZSB0b3JyZW50cywgbWFrZSBIVFRQIHJhbmdlIHJlcXVlc3RzIGRpcmVjdGx5IHRvIHRoZSB3ZWIgc2VlZCBVUkxcbiAgLy8gRm9yIG11bHRpLWZpbGUgdG9ycmVudHMsIGFkZCB0aGUgdG9ycmVudCBmb2xkZXIgYW5kIGZpbGUgbmFtZSB0byB0aGUgVVJMXG4gIHZhciBmaWxlcyA9IHNlbGYuX3RvcnJlbnQuZmlsZXNcbiAgdmFyIHJlcXVlc3RzXG4gIGlmIChmaWxlcy5sZW5ndGggPD0gMSkge1xuICAgIHJlcXVlc3RzID0gW3tcbiAgICAgIHVybDogc2VsZi51cmwsXG4gICAgICBzdGFydDogcmFuZ2VTdGFydCxcbiAgICAgIGVuZDogcmFuZ2VFbmRcbiAgICB9XVxuICB9IGVsc2Uge1xuICAgIHZhciByZXF1ZXN0ZWRGaWxlcyA9IGZpbGVzLmZpbHRlcihmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgcmV0dXJuIGZpbGUub2Zmc2V0IDw9IHJhbmdlRW5kICYmIChmaWxlLm9mZnNldCArIGZpbGUubGVuZ3RoKSA+IHJhbmdlU3RhcnRcbiAgICB9KVxuICAgIGlmIChyZXF1ZXN0ZWRGaWxlcy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBmaWxlIGNvcnJlc3Bvbm5kaW5nIHRvIHdlYiBzZWVkIHJhbmdlIHJlcXVlc3QnKSlcbiAgICB9XG5cbiAgICByZXF1ZXN0cyA9IHJlcXVlc3RlZEZpbGVzLm1hcChmdW5jdGlvbiAocmVxdWVzdGVkRmlsZSkge1xuICAgICAgdmFyIGZpbGVFbmQgPSByZXF1ZXN0ZWRGaWxlLm9mZnNldCArIHJlcXVlc3RlZEZpbGUubGVuZ3RoIC0gMVxuICAgICAgdmFyIHVybCA9IHNlbGYudXJsICtcbiAgICAgICAgKHNlbGYudXJsW3NlbGYudXJsLmxlbmd0aCAtIDFdID09PSAnLycgPyAnJyA6ICcvJykgK1xuICAgICAgICByZXF1ZXN0ZWRGaWxlLnBhdGhcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBmaWxlT2Zmc2V0SW5SYW5nZTogTWF0aC5tYXgocmVxdWVzdGVkRmlsZS5vZmZzZXQgLSByYW5nZVN0YXJ0LCAwKSxcbiAgICAgICAgc3RhcnQ6IE1hdGgubWF4KHJhbmdlU3RhcnQgLSByZXF1ZXN0ZWRGaWxlLm9mZnNldCwgMCksXG4gICAgICAgIGVuZDogTWF0aC5taW4oZmlsZUVuZCwgcmFuZ2VFbmQgLSByZXF1ZXN0ZWRGaWxlLm9mZnNldClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYWxsIHRoZSBIVFRQIHJlcXVlc3RzIHdlIG5lZWQgaW4gb3JkZXIgdG8gbG9hZCB0aGlzIHBpZWNlXG4gIC8vIFVzdWFsbHkgdGhhdCdzIG9uZSByZXF1ZXN0cywgYnV0IHNvbWV0aW1lcyBpdCB3aWxsIGJlIG11bHRpcGxlXG4gIC8vIFNlbmQgcmVxdWVzdHMgaW4gcGFyYWxsZWwgYW5kIHdhaXQgZm9yIHRoZW0gYWxsIHRvIGNvbWUgYmFja1xuICB2YXIgbnVtUmVxdWVzdHNTdWNjZWVkZWQgPSAwXG4gIHZhciBoYXNFcnJvciA9IGZhbHNlXG5cbiAgdmFyIHJldFxuICBpZiAocmVxdWVzdHMubGVuZ3RoID4gMSkge1xuICAgIHJldCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpXG4gIH1cblxuICByZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgdmFyIHVybCA9IHJlcXVlc3QudXJsXG4gICAgdmFyIHN0YXJ0ID0gcmVxdWVzdC5zdGFydFxuICAgIHZhciBlbmQgPSByZXF1ZXN0LmVuZFxuICAgIGRlYnVnKFxuICAgICAgJ1JlcXVlc3RpbmcgdXJsPSVzIHBpZWNlSW5kZXg9JWQgb2Zmc2V0PSVkIGxlbmd0aD0lZCBzdGFydD0lZCBlbmQ9JWQnLFxuICAgICAgdXJsLCBwaWVjZUluZGV4LCBvZmZzZXQsIGxlbmd0aCwgc3RhcnQsIGVuZFxuICAgIClcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ3VzZXItYWdlbnQnOiAnV2ViVG9ycmVudC8nICsgVkVSU0lPTiArICcgKGh0dHBzOi8vd2VidG9ycmVudC5pbyknLFxuICAgICAgICByYW5nZTogJ2J5dGVzPScgKyBzdGFydCArICctJyArIGVuZFxuICAgICAgfVxuICAgIH1cbiAgICBnZXQuY29uY2F0KG9wdHMsIGZ1bmN0aW9uIChlcnIsIHJlcywgZGF0YSkge1xuICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaGFzRXJyb3IgPSB0cnVlXG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzLnN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZVxuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdVbmV4cGVjdGVkIEhUVFAgc3RhdHVzIGNvZGUgJyArIHJlcy5zdGF0dXNDb2RlKSlcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdHb3QgZGF0YSBvZiBsZW5ndGggJWQnLCBkYXRhLmxlbmd0aClcblxuICAgICAgaWYgKHJlcXVlc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBDb21tb24gY2FzZTogZmV0Y2ggcGllY2UgaW4gYSBzaW5nbGUgSFRUUCByZXF1ZXN0LCByZXR1cm4gZGlyZWN0bHlcbiAgICAgICAgY2IobnVsbCwgZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJhcmUgY2FzZTogcmVjb25zdHJ1Y3QgbXVsdGlwbGUgSFRUUCByZXF1ZXN0cyBhY3Jvc3MgMisgZmlsZXMgaW50byBvbmVcbiAgICAgICAgLy8gcGllY2UgYnVmZmVyXG4gICAgICAgIGRhdGEuY29weShyZXQsIHJlcXVlc3QuZmlsZU9mZnNldEluUmFuZ2UpXG4gICAgICAgIGlmICgrK251bVJlcXVlc3RzU3VjY2VlZGVkID09PSByZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYihudWxsLCByZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5XZWJDb25uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBXaXJlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcylcbiAgdGhpcy5fdG9ycmVudCA9IG51bGxcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcInZlcnNpb25cIjpcIjAuOTQuNFwifSIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiLyoqXG4gKiBHaXZlbiBhIG51bWJlciwgcmV0dXJuIGEgemVyby1maWxsZWQgc3RyaW5nLlxuICogRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNjcyODMvXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG51bWJlclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHplcm9GaWxsICh3aWR0aCwgbnVtYmVyLCBwYWQpIHtcbiAgaWYgKG51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXIsIHBhZCkge1xuICAgICAgcmV0dXJuIHplcm9GaWxsKHdpZHRoLCBudW1iZXIsIHBhZClcbiAgICB9XG4gIH1cbiAgaWYgKHBhZCA9PT0gdW5kZWZpbmVkKSBwYWQgPSAnMCdcbiAgd2lkdGggLT0gbnVtYmVyLnRvU3RyaW5nKCkubGVuZ3RoXG4gIGlmICh3aWR0aCA+IDApIHJldHVybiBuZXcgQXJyYXkod2lkdGggKyAoL1xcLi8udGVzdChudW1iZXIpID8gMiA6IDEpKS5qb2luKHBhZCkgKyBudW1iZXJcbiAgcmV0dXJuIG51bWJlciArICcnXG59XG4iXX0=
