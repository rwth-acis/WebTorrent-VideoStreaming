(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (Buffer){
var http = require('http');
var MultiStream = require('multistream');
var util = require('util');
var readableStream = require('readable-stream');
var Videostream = require('videostream');
var ut_pex = require('ut_pex');
var WebTorrent = require('webtorrent');
var SimplePeer = require('simple-peer');
//var parseTorrent = require('parse-torrent'); // unnötig
//var createTorrent = require('create-torrent'); // unnötig


/**
 * @module FVSL
 */
module.exports = FVSL;


 /**
 * Creates a new FVSL instance which has the methods streamVideo, loadVideo, createSignalingData, createSignalingDataResponse, processSignalingResponse and several simple get methods  
 * @constructor
 */ 
function FVSL(OakName){
   var self = this;
   (function(){
      var peerId = Math.floor(Math.random() * Math.pow(10,300) + 1);   
      console.log("Version: Shams        In OakStreaming constructor. this.name: " + OakName);
      var OakName = OakName || "NoName FVSL instance";
      
      // Only methods should be part of the API, i.e. only methods should be publically accessible.
      // Every method should have access to these variables. Therefore they are definied at this high scope.
      var simplePeerCreationCounter = 0;
      var connectionsWaitingForSignalingData = [];
      var theTorrent = null;
      var peersToAdd = [];
      var bytesReceivedFromServer = 0;
      var notificationsBecauseNewWires = 0;
      var SIZE_OF_VIDEO_FILE = 0;
      
      self.streamVideo = streamVideo;
      self.loadVideo = loadVideo;
      self.forTesting_connectedToNewWebTorrentPeer = null;
                
      self.get_number_of_bytes_downloaded_from_server = function(){
         return bytesReceivedFromServer;
      };
      
      self.get_number_of_bystes_downloaded_P2P = function(){
         if(theTorrent){
            return theTorrent.downloaded;
         } else {
            return 0;
         }
      };
      
      self.get_number_of_bytes_uploaded_P2P = function(){
         if(theTorrent){
            return theTorrent.uploaded;
         } else {
            return 0;
         }
      };
      
      self.get_percentage_downloaded_of_torrent = function(){
         if(theTorrent){
            return theTorrent.progress;
         } else {
            return 0;
         }
      };
      
      self.get_file_size = function(){
         return SIZE_OF_VIDEO_FILE;
      };
      
      // This method creates (WebRTC-)signaling data that can be put into createSignalingDataResponse method of another FVSL instance to manually connected FVSL instances 
      self.createSignalingData = function (callback){
         var alreadyCalledCallback = false;
         var oakNumber = simplePeerCreationCounter;
         console.log("In createSignalingData for oakNumber: " + oakNumber);
         connectionsWaitingForSignalingData[oakNumber] = new SimplePeer({initiator: true, tickle: false});
         simplePeerCreationCounter++;
         
         connectionsWaitingForSignalingData[oakNumber].on('signal', function (signalingData){
            if(!alreadyCalledCallback){
               alreadyCalledCallback = true;
               signalingData.oakNumber = oakNumber;
               callback(signalingData);
            }
         });
      };
 
      // This method creates (WebRTC-)signaling data as a response to singaling data from createSignalingDataResponse method of another FVSL instance.
      // This mehtod returns new (WebRTC-)signaling data which has to put into processSignalingResponse method of the FVSL instance which created the original singaling data.
      self.createSignalingDataResponse = function (signalingData, callback){
         var oakNumber = signalingData.oakNumber;
         console.log("In createSignalingDataResponse. In the beginning oakNumber: " + oakNumber);
         delete signalingData.oakNumber;
         
         var myPeer = new SimplePeer({initiator: false, tickle: false});
         var index = simplePeerCreationCounter;
         connectionsWaitingForSignalingData[index] = myPeer;
         simplePeerCreationCounter++;
         
         myPeer.on('signal', function (answerSignalingData){
            console.log("In createSignalingDataResponse, after onSignal oakNumber: " + oakNumber);
            answerSignalingData.oakNumber = oakNumber;
            console.log("In createSignalingDataResponse,  object that is returned with callback: " + JSON.stringify(answerSignalingData));
            callback(answerSignalingData);
         });
         myPeer.signal(signalingData);
         
         var self = this;
         myPeer.on('connect', function(){
            self.addSimplePeerInstance(connectionsWaitingForSignalingData[index], {}, function(){console.log("addSimplePeerInstance ended");});
         });
      };
      

      // This method finally establishes a Web-RTC connection between the two FVSL instances. From now on both FVSL instances exchange video fragments.
      self.processSignalingResponse = function (signalingData, callback){
         console.log("In processSignalingResponse,  signalingData paramter: " + JSON.stringify(signalingData));
         var oakNumber = signalingData.oakNumber;
         delete signalingData.oakNumber;
         console.log("In processSignalingResponse,  oakNumber: " + oakNumber);
         console.log("connectionsWaitingForSignalingData: " + connectionsWaitingForSignalingData);
         var self = this;
         (connectionsWaitingForSignalingData[oakNumber]).on('connect', function (){
            console.log('Established a simple-peer connection');
            self.addSimplePeerInstance(connectionsWaitingForSignalingData[oakNumber]);
            connectionsWaitingForSignalingData[oakNumber] = undefined;
            callback();
         });
         console.log("In processSignalingResponse,  object that is passed to .signal(): " + JSON.stringify(signalingData));
         connectionsWaitingForSignalingData[oakNumber].signal(signalingData);
      };
       
       /**
       * @typedef Stream_Information_Object
       * @type {object}
       * @property {number} video_file_size - The size in byte of the video file that was passed as an argument.
       */
       
      /**
       * @callback OakStreaming~streamVideoFinished
       * @param {Stream_Information_Object} stream_information_object - An object that other clients/peers can pass as an argument to their loadVideo method to download the video from other clients/peers and/or a Web Server.
       */ 

      /**
       * Streams a video file to all other clients/peers.
       * @param {object} video_file - The video file that should be streamed to the other clients/peers. This paramter can either be a {@link https://developer.mozilla.org/en-US/docs/Web/API/File |W3C File object}, a {@link https://developer.mozilla.org/en-US/docs/Web/API/FileList |W3C FileList}, a {@link https://nodejs.org/api/buffer.html |Node Buffer object} or a {@link https://nodejs.org/api/stream.html#stream_class_stream_readable |Readable stream object}.
       * @param {object} [options] - Options for the creation of the Stream_Information_Object, that after its creation gets passed as an argument to the callback function.
       * @param {string} options.path_to_file_on_XHR_server - The path that will be used for the XML HTTP Request (XHR). A valid path would be, for example, "/videos/aVideoFile.mp4". It is not necessary to set both the pathToFileOnXHRServer and the hashValue paramter for successfull XHR requests. If this property and the hashValue property is undefined, no video data will be requested from the server.
       * @param {string} options.hash_value - Hash value of the video file that should by requested from the SVSL WebServer. It is not necessary to set both the pathToFileOnXHRServer and the hashValue paramter for successfull XHR requests. If this property and the hashValue property is undefined, no video data will be requested from the server. 
       * @param {string} options.XHR_server_URL - URL of a XHR server that can serve the video file. If this property is not set, XHR will be send to the Web server that served the Web page.
       * @param {number} options.XHR_port - Port that will be used when communicating with the XHR server that was specified in the XHRServerURL property. This property should only be set when the XHRServerURL property is set too. The default value is 80.
       * @param {number} options.download_from_p2p_time_range - How many seconds of video playback must be buffered in advance such that no more data streams are requested from the WebTorrent network. The default value is 20 (seconds).
       * @param {number} options.create_readStream_request_size - The size of the byte range requests to the WebTorrent network. The default value is 5000000 (bytes).
       * @param {number} options.download_from_server_time_range - How many seconds of video playback must be buffered in advance such that no more data is requested from the XHR server. The default value is 5 (seconds).
       * @param {number} options.peer_upload_limit_multiplier - The FVSL client will severly throttle the video data upload to other peers when (bytes_uploaded_to_other_peers * peer_upload_limit_multiplier + peer_upload_limit_addition >=  bytes_downloaded_from_other_peers) and stop the throtting as soon as this inequality is no longer true. The default value for peer_upload_limit_multiplier is 2.
       * @param {number} options.peer_upload_limit_addition - The FVSL client will severly throttle the video data upload to other peers when (bytes_uploaded_to_other_peers * peer_upload_limit_multiplier + peer_upload_limit_addition >=  bytes_downloaded_from_other_peers) and stop the throtting as soon as this inequality is no longer true. the default value for peer_upload_limit_addition is 500000 (byte).
       * @param {string[][]} options.webTorrent_trackers - Array of arrays of WebTorrent tracking server URLs (strings). These WebTorrent trackers will be used to connect to other FVSL instances.
       * @param {OakStreaming~streamVideoFinished} callback - This callback function gets called with the generated Stream_Information_Object at the end of the execution of streamVideo.
       */
      function streamVideo(video_file, options, callback, returnTorrent, destroyTorrent){ 
         var webTorrentClient = new WebTorrent();
         //console.log("streamVideo is executed");
         //console.log("videoFile: " + videoFile);
         //console.log("options: " + options);
         //console.log("callback: " + callback);         
          
         var stream_information_object = options;
             
         if(video_file){
            var seedingOptions = {
               name: "OakStreaming_Torrent"
            };
            if(options.webTorrent_trackers){
               seedingOptions.announceList = options.webTorrent_trackers;
            }

            var self = this; 
            webTorrentClient.seed(video_file, seedingOptions, function(torrent){
               console.log("torrent file is seeded");
               
               /* K42 Maybe I will need this later
               var torrentFileAsBlobURL = torrent.torrentFileBlobURL;
               var xhr = new XMLHttpRequest();
               var XHROrMethodEndHappend = false;
               xhr.open('GET', torrentFileAsBlobURL, true);
               xhr.responseType = 'blob';
               xhr.onload = function(e) {
                 if (this.status == 200) {
                   stream_information_object.torrentAsBlob = this.response;
                   if(XHROrMethodEndHappend){
                      callback(stream_information_object);
                   } else {
                      XHROrMethodEndHappend = true;
                   }
                 }
               };
               xhr.send();
               */
               SIZE_OF_VIDEO_FILE = 0;
               stream_information_object.size_of_video_file = 0;
               for(var i=0, length=torrent.files.length; i<length; i++){
                  SIZE_OF_VIDEO_FILE += torrent.files[i].length;
                  stream_information_object.size_of_video_file += torrent.files[i].length;
               }
               
               stream_information_object.magnetURI = torrent.magnetURI;
               console.log("torrent.magnetURI: " + torrent.magnetURI);
               stream_information_object.infoHash = torrent.infoHash;
               
              
               stream_information_object.torrentFile = torrent.torrentFile.toString('base64');
               console.log("Creaded stream_information_object:\n" + JSON.stringify(stream_information_object));

               
               // var bufferTorrent = parseTorrent(stream_information_object.parsedTorrent); K42
              
               
               console.log("In streamVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
               // This function calls the callback function when this FVSL instance already connected to another peer
               // or as soon as it connects to another peer.
               self.forTesting_connectedToNewWebTorrentPeer = function(callback){
                  console.log("In streamVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets executed");
                  if(notificationsBecauseNewWires <= 0){
                     notificationsBecauseNewWires--;
                     var callbackCalled = false;
                     
                     torrent.on('wire', function(wire){
                        if(!callbackCalled){
                           callback();
                           callbackCalled = true;
                        }
                     });
                  } else {
                     notificationsBecauseNewWires--;            
                     callback();
                  }
               };
               
               // This is necessary such that the forTesting_connectedToNewWebTorrentPeer function knows how many peers already connected to this FVSL instance.
               torrent.on('wire', function (wire){
                  notificationsBecauseNewWires++;  
               });
               // For some Jasmine tests it is appropriate that the torrent gets destroyed immediately after the stream_information_object has been created. The destruction of the torrent stops the seeding.
               if(returnTorrent === "It's a test"){
                  if(destroyTorrent){
                     notificationsBecauseNewWires = 0;
                     torrent.destroy();
                     delete webTorrentClient;
                  }
                  callback(stream_information_object, torrent);
               } else {
                  callback(stream_information_object);
                  return stream_information_object;
               }    
            });
         } else {
            callback(stream_information_object);
            /* K42
            if(XHROrMethodEndHappend){
               callback(stream_information_object);
            } else {
                XHROrMethodEndHappend = true;
            }
            */
         }  
      }


      /**
       * @callback OakStreaming~loadedVideoFinished
       */ 
       
      /**
       * Streams a video file to all other clients/peers.
       * @param {Stream_Information_Object} stream_information_object - This object contains all data that is needed to initiate loading the video from other peers and/or a Web server. Stream_Information_Object's can be created by the {@link streamVideo|streamVideo} method.
       * @param {OakStreaming~loadedVideoFinished} callback - This callback gets called when the video has been loaded entirely into the buffer of the video player.
       * @param {boolean} end_streaming_when_video_loaded - If this argument is true, all uploading to other peers is permanently cancelled and all processing of the loadVideo method permanently stopped as soon as the video has been loaded completely into the buffer of the video player.
       */
      function loadVideo(stream_information_object, callback, end_streaming_when_video_loaded){       
         console.log("loadVideo is called");
         //console.log("option paramter:\n" + JSON.stringify(stream_information_object));
         
         // All these declared varibales until 'var self = this' are intended to be constants
         var deliveryByServer = (stream_information_object.path_to_file_on_XHR_server || stream_information_object.hash_value) ? true : false;
         var deliveryByWebtorrent = stream_information_object.torrentFile ? true : false;
         var XHRServerURL = stream_information_object.XHR_server_URL || false;
         var XHR_PORT = stream_information_object.XHR_port || 80;
         var pathToFileOnXHRServer = stream_information_object.path_to_file_on_XHR_server;      
         var hashValue = stream_information_object.hash_value;
         //var webTorrentTrackers = stream_information_object.webTorrent_trackers;
         var MAGNET_URI = stream_information_object.magnetURI;
         console.log("MAGNET_URI: "  + MAGNET_URI);
         var THE_RECEIVED_TORRENT_FILE = Buffer.from(stream_information_object.torrentFile, 'base64');
         SIZE_OF_VIDEO_FILE = stream_information_object.size_of_video_file;
         console.log("stream_information_object.size_of_video_file: "  + stream_information_object.size_of_video_file);

         var DOWNLOAD_FROM_P2P_TIME_RANGE = stream_information_object.download_from_p2p_time_range || 20;
         var CREATE_READSTREAM_REQUEST_SIZE = stream_information_object.create_readStream_request_size || 10000000;
         
         var DOWNLOAD_FROM_SERVER_TIME_RANGE = stream_information_object.download_from_server_time_range || 3;
         var UPLOAD_LIMIT = stream_information_object.peer_upload_limit_multiplier || 2;
         var ADDITION_TO_UPLOAD_LIMIT = stream_information_object.peer_upload_limit_addition || 500000;
         
         
         var XHR_REQUEST_SIZE = stream_information_object.xhrRequestSize || 500000; // in byte
         var THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM = stream_information_object.thresholdForReturningAnswerStream || 500000; // in byte
         var WATERMARK_HEIGHT_OF_ANSWERSTREAM = stream_information_object.watermarkHeightOfAnswerStream || 5000000; // in byte
         
         
         var CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL = stream_information_object.checkIfBufferFullEnoughInterval || 200; // in miliseconds
         var CHECK_IF_ANSWERSTREAM_READY_INTERVAL = stream_information_object.checkIfAnswerstreamReadyInterval || 500; // in miliseconds
         var UPDATE_CHART_INTERVAL = stream_information_object.updateChartInterval || 1000; // in miliseconds
         var CHOKE_IF_NECESSARY_INTERVAL = stream_information_object.chokeIfNecessaryInterval || 500; // in miliseconds
         var CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL = stream_information_object.checkIfNewCreateReadstreamInterval || 2000 ;
         
         
         // From here on most newly declared variables are not indeted to function as constants
         // These variables are declared in this high scope in order to allow every function that is declared in loadVideo to access and manipulate these variables
         var self = this;
         var endStreaming = false;
         var webTorrentClient = null;
         var wires = []; // a wire is a connection to another peer out of the WebTorrent network
         var globalvideostreamRequestNumber = 0;
         bytesReceivedFromServer = 0; // This variable gets only initialized not declared
         var webTorrentFile;
         var videostreamRequestHandlers = [];
         var inCritical = true; // incritical means that XHR requests will be conducted because there is less than DOWNLOAD_FROM_SERVER_TIME_RANGE seconds of video playback buffered.
         var videoCompletelyLoaded = false;
         var bytesTakenFromWebTorrent = 0;
         var bytesTakenFromServer = 0;
         var consoleCounter = 0; // This variable is only for debugging purposes
         
      
         var myVideo = document.querySelector('video');
         myVideo.addEventListener('error', function (err){
            console.error(myVideo.error);
         });
         
         // Node.js readable streams are used to buffer video data before it gets put into the source buffer
         function MyReadableStream(options){
            readableStream.Readable.call(this, options);
         }
         util.inherits(MyReadableStream, readableStream.Readable);
         MyReadableStream.prototype._read = function(size){};
         
        
         if(deliveryByWebtorrent){
            console.log("entered if(deliveryByWebtorrent)");
            webTorrentClient = new WebTorrent();
                    
            var webTorrentOptions = {};
            
            /* Weiß nicht mehr warum das hier steht
            if(stream_information_object.pathToFileToSeed){
               webTorrentOptions.path = stream_information_object.pathToFileToSeed;
            }
            */
            
            
            // A magnetURI contains URLs to tracking servers and the info hash of the torrent.
            //The client receives the complete torrent file from a tracking server.
            webTorrentClient.add(THE_RECEIVED_TORRENT_FILE, webTorrentOptions, function (torrent){
               // From this point on the WebTorrent instance will download video data from the WebTorrent network in the background in a rarest-peace-first manner as fast as possible.
               // Sequential stream request like createreadstrime are prioritized over this rarest-peace-first background downloading.
               
               console.log("webTorrentClient.add   torrent meta data ready");         
               theTorrent = torrent;
               webTorrentFile = torrent.files[0];
               
               // Peers which used the offered methods to manually connect to this FVSL instance
               // before a torrent file was loaded are added now to the set of peers that are used for video data exchange.
               for(var j=0; j< peersToAdd.length; j++){
                  theTorrent.addPeer(peersToAdd[j][0]);
                  if(peersToAdd[j][1]){
                     (peersToAdd[j][1])();
                  }
               } 

               // This function has the same purpose 
               console.log("In loadVideo    " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer gets created");
               // This function calls the callback function when this FVSL instance already connected to another peer
               // or as soon as it connects to another peer.
               self.forTesting_connectedToNewWebTorrentPeer = function(callback){
                  console.log("In loadVideo     " + self.OakName + ".forTesting_connectedToNewWebTorrentPeer   gets called");
                  if(notificationsBecauseNewWires <= 0){
                     notificationsBecauseNewWires--;
                     var callbackCalled = false;
                     
                     torrent.on('wire', function(wire){
                        if(!callbackCalled){
                           callback();
                           callbackCalled = true;
                        }
                     });
                  } else {
                     notificationsBecauseNewWires--;            
                     callback();
                  }
               };
               
               torrent.on('wire', function (wire){
                  console.log("torrent.on('wire', ..) is fired");
                  wires.push(wire);
                  if(!window.firstWire){
                     window.firstWire = wire;
                  }
                  notificationsBecauseNewWires++;
                  
                  // This activates the ut_pex extension for this peer
                  // which is necessary to exchange peers between WebTorrent instances
                  wire.use(ut_pex());
                  //wire.ut_pex.start();
                  
                  /*
                  wire.ut_pex.on('peer', function (peer){
                     theTorrent.addPeer(peer);
                     // got a peer
                     // probably add it to peer connections queue
                  });
                  */
               });

               // The Videostream object conducts, depending on the current playback position, creaReadstream requests for video data that the loadVideo method has to answer in order to play back the video successfully
               // The Videostream object probably has been created during the time webTorrentClient.add was called until its called the callback function.
               // In this time the VideoStream object created by the videostream library probably has conducted some createReadstream requests whose handlers are saved in the videostreamRequestHandlers array.
               // For these requests we now intialize WebTorrent streams.
               for(var i=0, length=videostreamRequestHandlers.length; i<length; i++){
                  var thisRequest = videostreamRequestHandlers[i];
                  
                  // To answer a createReadStream request a Multistream (https://www.npmjs.com/package/multistream) is returned which requests a Node readableStream as soon as its buffer has went dry.
                  // The current callback which should be called with the created readableStream is saved in currentlyExpectedCallback
                  if(thisRequest.currentlyExpectedCallback !== null){
                     console.log("In onTorrent nachträglich webtorrent stream erzeugen  thisRequest.start: " + thisRequest.start);
                     //console.log("In onTorrent  webTorrentFile.length: " + webTorrentFile.length);
                                 
                     var endCreateReadStream;
                     if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE > webTorrentFile.length-1){
                        endCreateReadStream = webTorrentFile.length-1;
                     } else {
                        endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                     }
                         
                     thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                     /*
                     thisRequest.on('end', function(){
                        if(thisRequest.currentlyExpectedCallback !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < thisRequest.videoFileSize){
                           var endCreateReadStream;
                           if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                              endCreateReadStream = webTorrentFile.length-1;
                           } else {
                              endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                           }                
                           thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                           thisRequest.oldStartWebTorrent = thisRequest.start;
                           thisRequest.webTorrentStream.unpipe();
                           thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                        }             
                     });
                     */
                     
                     // Every videostreamRequestHandler has to save the byte index that it expects next
                     thisRequest.oldStartWebTorrent = thisRequest.start;
                     
                     // Data that is received from the WebTorrent readable gets immmediately pumped into a writeable stream called  collectorStreamForWebtorrent which processes the new data.
                     thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                  }
               }
            });
         }
         
         
         
         var fileLikeObject = function (pathToFileOnXHRServer){
            this.pathToFileOnXHRServer = pathToFileOnXHRServer;
         };
         // The VideoStream object will call createReadStream several times with different values for the start property of ops.
         fileLikeObject.prototype.createReadStream = function (opts){
            if(opts.start >= SIZE_OF_VIDEO_FILE){
               console.log("opts.start > SIZE_OF_VIDEO_FILE therefore cb(null,null) every time");
               return (new MultiStream(function (cb){cb(null, null);}));
            }
            inCritical = true;
            /*
            console.log(consoleCounter++ + " called createreadStream ");
            console.log(consoleCounter++ + " opts.start: " + opts.start);
            console.log(consoleCounter++ + " opts.end: " + opts.end);
            */
            var thisRequest = new VideostreamRequestHandler(++globalvideostreamRequestNumber, opts, this);
           
            // Everytime I printed out the value of opts.end is was NaN.
            // I suppose that should be interpreted as "till the end of the file"
            // Of course, our returned stream should, nevertheless, not buffer a giant amount of video data in advance but instead retrieve and put out chunks of video data on-demand
            
            if(opts.end && !isNaN(opts.end)){
               thisRequest.end = opts.end + 1;
            } else {
               if(SIZE_OF_VIDEO_FILE !== 0){
                  thisRequest.end = SIZE_OF_VIDEO_FILE;
               }
            }
            
            
            // This writeable Node.js stream will process every data that is received from sequential WebTorrent streams
            var MyWriteableStream = function(highWaterMark){
               readableStream.Writable.call(this, highWaterMark);
            };
            util.inherits(MyWriteableStream, readableStream.Writable);
            MyWriteableStream.prototype._write = function(chunk, encoding, done){
               console.log("A byte range request to the WebTorrent network received a chunk");
               //console.log("MyWriteableStream _write is called");       
               if(thisRequest.start-thisRequest.oldStartWebTorrent < chunk.length){
                  ////////console.log("MyWriteableStream _write: pushing received data in answerStream")
                  bytesTakenFromWebTorrent += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
                  var streamHasMemoryLeft = thisRequest.answerStream.push(chunk.slice(thisRequest.start-thisRequest.oldStartWebTorrent, chunk.length));
                  thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
                  
                  if(streamHasMemoryLeft){            
                     if(thisRequest.currentlyExpectedCallback !== null && thisRequest.start >= thisRequest.end){
                        var theCallbackFunction = thisRequest.currentlyExpectedCallback;
                        thisRequest.currentlyExpectedCallback = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: WATERMARK_HEIGHT_OF_ANSWERSTREAM});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.createReadStreamNumber);
                        if (thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                        theCallbackFunction(null, res);
                     }
                  } else {
                     if(thisRequest.currentlyExpectedCallback === null){
                        if(thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                        thisRequest.noMoreData = true;
                     } else {
                        var theCallbackFunction = thisRequest.currentlyExpectedCallback;
                        thisRequest.currentlyExpectedCallback = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: WATERMARK_HEIGHT_OF_ANSWERSTREAM});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.createReadStreamNumber);
                        if (thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                        theCallbackFunction(null, res);
                     }
                  }
                  thisRequest.start += chunk.length - (thisRequest.start-thisRequest.oldStartWebTorrent);
               }
               //ceckIfAnswerStreamReady(thisRequest);
               thisRequest.oldStartWebTorrent += chunk.length;
               done();
            };
            thisRequest.collectorStreamForWebtorrent = new MyWriteableStream({highWaterMark: 16});
            videostreamRequestHandlers.push(thisRequest);

            if(webTorrentFile){ // Um Einhaltung des Upload limits kümmert sich doch chokeIfNecessary   && theTorrent.uploaded <= UPLOAD_LIMIT * theTorrent.downloaded + ADDITION_TO_UPLOAD_LIMIT){
               ////////console.log("after new videostreamRequest creating a corresponding webtorrent stream");
               ////console.log("opts.start: " + opts.start);
               ////console.log("webTorrentFile.length: " + webTorrentFile.length);
                
               var endCreateReadStream;
               if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                  endCreateReadStream = webTorrentFile.length-1;
               } else {
                  endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
               }
               thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
               thisRequest.lastEndCreateReadStream = endCreateReadStream;
               thisRequest.oldStartWebTorrent = thisRequest.start;
               
               thisRequest.webTorrentStream.unpipe();
               thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
            }

            function factoryFunctionForStreamCreation(cb){
               console.log("ReadableStream request number " + thisRequest.createReadStreamNumber + "    does a cb request");         
               if(thisRequest.end >= 0 && thisRequest.start >= thisRequest.end){
                  console.log("called cb(null,null) from " + thisRequest.createReadStreamNumber);             
                  // !!!!!!!!!!!!!!!!!!! Testeshalber rausgenommen     thisRequest.req = null;
                  if (thisRequest.req) {
                     thisRequest.req.destroy();
                     thisRequest.req = null;
                  }
                  console.log("cb(null, null) is called");
                  return cb(null, null);
               }
              
               thisRequest.CallbackNumber++;
               if(consoleCounter<20){
                  //////console.log(consoleCounter++ + "    " + thisRequest.CallbackNumber + ". call of function(cb) from " + videostreamRequestNumber);
                  ////////console.log(consoleCounter++ + "    start: " + thisRequest.start);
               }
               thisRequest.currentlyExpectedCallback = cb;
               thisRequest.noMoreData = false;
            
               if(!ceckIfAnswerStreamReady(thisRequest)){
                  if(thisRequest.webTorrentStream){
                     thisRequest.webTorrentStream.resume();
                  } else if(webTorrentFile){
                     ////////console.log("New cb function was called and I subsequently create a new torrentStream for it because non existed before for this videostreamRequest");
                     ////console.log("After new Multistream. thisRequest.start: " + thisRequest.start);
                     ////console.log("webTorrentFile.length: " + webTorrentFile.length);
                     var endCreateReadStream;
                     if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                        endCreateReadStream = webTorrentFile.length-1;
                     } else {
                        endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                     }
                     thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                     thisRequest.lastEndCreateReadStream = endCreateReadStream;
                     thisRequest.oldStartWebTorrent = thisRequest.start;
                     
                     thisRequest.webTorrentStream.unpipe();
                     thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                  }

                  if(deliveryByServer && inCritical && !thisRequest.XHRConducted){
                     if(!theTorrent || theTorrent.progress <1){
                        conductXHR(thisRequest);                      
                     }
                  }
               }
            }
            
            // A new Multistream gets created which will be the answer the the request from the VideoStream request
            var multi = new MultiStream(factoryFunctionForStreamCreation);
            
            var deconstructorAlreadyCalled = false;
            ////////console.log(consoleCounter++ + " terminate createReadStream");
            var destroy = multi.destroy;
            multi.destroy = function(){
               if(deconstructorAlreadyCalled){
                  console.log("Deconstructor of " + thisRequest.createReadStreamNumber + " has already been called");
                  return;
               }
               console.log("Deconstructor of " + thisRequest.createReadStreamNumber + " is called");
               console.log("In deconstructor call thisRequest.start has value: " + thisRequest.start);
               console.log("In deconstructor call thisRequest.end has value: " + thisRequest.end);
               console.log("In deconstructor call thisRequest.currentlyExpectedCallback === null: " + (thisRequest.currentlyExpectedCallback === null));
               deconstructorAlreadyCalled = true;
               if (thisRequest.req) {
                  thisRequest.req.destroy();
               }
               var theCallback = thisRequest.currentlyExpectedCallback;
               thisRequest.currentlyExpectedCallback = null;
               thisRequest.noMoreData = true;
               thisRequest.webTorrentStream.pause();
               thisRequest.webTorrentStream.unpipe();
               
               for(var i=0; i<videostreamRequestHandlers.length; i++){
                  if(videostreamRequestHandlers[i] === thisRequest){
                     videostreamRequestHandlers.splice(i, 1);
                  }
               }
               /*
               if(theCallback){
                  theCallback(null,null);
               }
               */
               // thisRequest.webTorrentStream.destroy();                  Glaube ich unnötig!!!!
               //thisRequest.answerStream.destroy();         Glaube ich auch unnötig ! Wird ja eh übergeben. Sollte sich also Feross drum kümmern. 
               // thisRequest.collectorStreamForWebtorrent.destroy(); Verbraucht ja eh nur ein paar byte
               destroy.call(multi);
            };
            return multi;
         };
        
         
         // This function frequently checks if less than DOWNLOAD_FROM_P2P_TIME_RANGE seconds of video data is buffered in advance.
         // If it is the case this function conducts a new sequential byte range request to the WebTorrent network
         function frequentlyCheckIfNewCreateReadStreamNecessary(){
            if(videoCompletelyLoaded){
               return;
            }        
            if(myVideo.duration){
               var timeRanges = myVideo.buffered;          
               for (var i = 0, length = timeRanges.length; i < length; i++){
                  if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)+3) {
                     if (timeRanges.end(i) - myVideo.currentTime <= DOWNLOAD_FROM_P2P_TIME_RANGE) {
                        for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
                           var thisRequest = videostreamRequestHandlers[i];
                           
                           if(thisRequest.currentlyExpectedCallback !== null && thisRequest.start > thisRequest.lastEndCreateReadStream && thisRequest.start < SIZE_OF_VIDEO_FILE){
                              var endCreateReadStream;videoFileSize
                              if(thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE >= webTorrentFile.length-1){
                                 endCreateReadStream = webTorrentFile.length-1;
                              } else {
                                 endCreateReadStream = thisRequest.start + CREATE_READSTREAM_REQUEST_SIZE;
                              }                
                              thisRequest.webTorrentStream = webTorrentFile.createReadStream({"start" : thisRequest.start, "end" : endCreateReadStream});
                              thisRequest.oldStartWebTorrent = thisRequest.start;
                              thisRequest.webTorrentStream.unpipe();
                              thisRequest.webTorrentStream.pipe(thisRequest.collectorStreamForWebtorrent);
                           }
                        }
                     }
                  }
               }
               setTimeout(frequentlyCheckIfNewCreateReadStreamNecessary, CHECK_IF_NEW_CREATE_READSTREAM_NECESSARY_INTERVAL);
            }
         }   
         
         // The final version of the library should not include this function. This function updates the statistics that are shown above the video. This version shows values which are not intended for end user use.
         function updateChart(){
            if(endStreaming){
               return;
            }
            if(theTorrent && webTorrentFile){
               document.getElementById("WebTorrent-received").innerHTML = "webTorrentFile.length: " + webTorrentFile.length + "\n torrent.downloaded: " + theTorrent.downloaded + "\n torrent.uploaded: " + theTorrent.uploaded + "\n torrent.progress: " + theTorrent.progress + "\n Bytes received from server: " + bytesReceivedFromServer + "\n Bytes taken from server delivery: " + bytesTakenFromServer + "\n Bytes taken from WebTorrent delivery: " + bytesTakenFromWebTorrent;
            }
            setTimeout(updateChart, UPDATE_CHART_INTERVAL);
         }         
         
         
         // This function checks for a given videostreamRequestHandler if we have called enough video data to call the callback function.
         // If it is the case, the callback function gets called togehter with the buffered data.
         function ceckIfAnswerStreamReady(thisRequest){
            ////////console.log("At the beginning of thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream);
            ////////console.log("In ceckIfAnswerStreamReady of videostreamRequest number " + thisRequest.createReadStreamNumber +  ". thisRequest.bytesInAnswerStream: " + thisRequest.bytesInAnswerStream + "     thisRequest.currentlyExpectedCallback: " + thisRequest.currentlyExpectedCallback);
            if (thisRequest.currentlyExpectedCallback && ((thisRequest.bytesInAnswerStream >= THRESHOLD_FOR_RETURNING_OF_ANSWER_STREAM) || (thisRequest.start >= SIZE_OF_VIDEO_FILE))){
               ////////console.log("answerStream from videostream Request number " + thisRequest.createReadStreamNumber + " and CB number " + thisRequest.CallbackNumber + " gets returned");
               // //////console.log("Returing answerStream out of ceckIfAnswerStreamReady()");
               var theCallbackFunction = thisRequest.currentlyExpectedCallback;
               thisRequest.currentlyExpectedCallback = null;
               thisRequest.answerStream.push(null);
               if (thisRequest.webTorrentStream){
                  thisRequest.webTorrentStream.pause();
               }
               thisRequest.bytesInAnswerStream = 0;
               var res = thisRequest.answerStream;
               thisRequest.answerStream = new MyReadableStream({highWaterMark: WATERMARK_HEIGHT_OF_ANSWERSTREAM});
               //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.createReadStreamNumber);
               theCallbackFunction(null, res);
               return true;
            }
            return false;
         }

         // This function frequently checks if video data upload should be throttled because the peer_upload_limit is reached
         // If it should be throttled, then every peer gets choked which means there will be no more data send to other peers for approximately 800 milliseconds.
         function chokeIfNecessary(){
            if (theTorrent && theTorrent.uploaded >= theTorrent.downloaded * UPLOAD_LIMIT + ADDITION_TO_UPLOAD_LIMIT) {
               /* mache ich schon in einer anderen frequent methode
               if(videoCompletelyLoaded){
                  theTorrent.destroy();
                  delete webTorrentClient;
                  endStreaming = true;
                  return;
               }
               */
               for (var i = 0, length = wires.length; i < length; i++){
                  //console.log("I choked a peer");
                  wires[i].choke();
               }
            }
            setTimeout(chokeIfNecessary, CHOKE_IF_NECESSARY_INTERVAL);
         }
         
         function VideostreamRequestHandler(createReadStreamNumber, opts, self) {
            this.createReadStreamNumber = createReadStreamNumber;
            this.opts = opts;
            this.start = opts.start || 0;
            this.oldStartWebTorrent = -42;
            this.oldStartServer = -42;
            this.currentlyExpectedCallback = null;
            this.CallbackNumber = 0;
            this.webTorrentStream = null;
            this.answerStream = new MyReadableStream({highWaterMark: WATERMARK_HEIGHT_OF_ANSWERSTREAM});
            this.bytesInAnswerStream = 0;
            this.collectorStreamForWebtorrent = null;
            this.XHRConducted = false;
            this.end = -42;
            this.self = self;
            this.bytesTakenFromWebTorrent = 0;
            this.bytesTakenFromServer = 0;
            this.noMoreData = false;
            this.req = null;
            this.lastEndCreateReadStream = -42;
            this.XHR_filesize = -42;
         }

         // This function frequently checks for every videostreamRequestHandler if there is enough data buffer to call the corresponding callback function with the buffered data
         function frequentlyCeckIfAnswerStreamReady(){
            if(videoCompletelyLoaded){
               return;
            }
            for (var i = 0, length = videostreamRequestHandlers.length; i < length; i++) {
               ceckIfAnswerStreamReady(videostreamRequestHandlers[i]);
            }
            setTimeout(frequentlyCeckIfAnswerStreamReady, CHECK_IF_ANSWERSTREAM_READY_INTERVAL);
         }

         // The job of this function is to frequently check to things.
         // First, if the video is completely loaded.
         // Second, if less than DOWNLOAD_FROM_SERVER_TIME_RANGE seconds of video playback are buffered in advance.
         function checkIfBufferFullEnough(){
            //console.log("checkIfBufferFullEnough is called");
            if(videoCompletelyLoaded){
               return;
            }
            //console.log("video.duration: " + myVideo.duration);
            if(myVideo.duration){
               var timeRanges = myVideo.buffered;
               if(timeRanges.length >= 1){
                  //console.log("timeRanges.start(0): " + timeRanges.start(0));
                  //console.log("timeRanges.end(0): " + timeRanges.end(0));
                  if(theTorrent.progress === 1){
                     videoCompletelyLoaded = true;
                  } else {
                     if(timeRanges.start(0) == 0 && timeRanges.end(0) == myVideo.duration){
                       // console.log("In checkIfBufferFullEnough: callback should be called");
                        videoCompletelyLoaded = true;
                        if(callback){
                           if(end_streaming_when_video_loaded){
                              callback();
                           } else {
                              callback(theTorrent);
                           }
                        }
                        if(end_streaming_when_video_loaded){
                           if(theTorrent){
                              theTorrent.destroy();
                              delete webTorrentClient;
                           }
                           endStreaming = true;
                           return;                 
                        } 
                     }
                  }
               }
               
               // From here on it is checked wether there are less seconds buffered than DOWNLOAD_FROM_SERVER_TIME_RANGE
               inCritical = true;              
               for (var i = 0, length = timeRanges.length; i < length; i++) {
                  ////////console.log("Time range number " + i + ": start(" + timeRanges.start(i) + ") end(" + timeRanges.end(i) + ")");
                  if (myVideo.currentTime >= timeRanges.start(i) && myVideo.currentTime <= timeRanges.end(i)) {
                     if (timeRanges.end(i) - myVideo.currentTime >= DOWNLOAD_FROM_SERVER_TIME_RANGE) {
                        inCritical = false;
                        ////////console.log("I set inCritical to false");
                     }
                  }
               }
               if (deliveryByServer && inCritical) {
                  for (var j = 0, length = videostreamRequestHandlers.length; j < length; j++) {
                     if (videostreamRequestHandlers[j].currentlyExpectedCallback !== null && videostreamRequestHandlers[j].XHRConducted === false) {
                        conductXHR(videostreamRequestHandlers[j]);
                     }
                  }
               }
            }
            setTimeout(checkIfBufferFullEnough, CHECK_IF_BUFFER_FULL_ENOUGH_INTERVAL);
         }

         
         // This function conductes a XHR reuqest for the videostreamRequestHandler which is handed over to the function as its first and only paramter.
         function conductXHR(thisRequest) {
            if(thisRequest.currentlyExpectedCallback === null){
               return;
            }
            thisRequest.XHRConducted = true;
            var reqStart = thisRequest.start;
            var reqEnd = reqStart + XHR_REQUEST_SIZE;
   
            if(thisRequest.XHR_filesize > 0 && reqEnd > thisRequest.XHR_filesize){
               reqEnd = thisRequest.XHR_filesize;
            } else if (thisRequest.end >= 0 && reqEnd > thisRequest.end) {
               reqEnd = thisRequest.end;
            }
            
            if (reqStart >= reqEnd){
               //console.log("called cb(null,null)");
               
               // !!!!!!!!! dieser if block neu fix versuch
               if(thisRequest.req){
                  thisRequest.req.destroy();
               }
               thisRequest.XHRConducted = false;
               
               
               if(thisRequest.currentlyExpectedCallback){
                  return thisRequest.currentlyExpectedCallback(null, null);
               } else {
                  return;
               }                  
            }

            /* glaube ich unnötiger und/oder gefährlicher müll
            if (reqStart >= reqEnd) {
            req = null;
            return thisRequest.currentlyExpectedCallback(null, null);
            }
            */
            if (consoleCounter < 10000000) {
               //////////console.log(consoleCounter++ + "  videoStream " + thisRequest.createReadStreamNumber + "  CB number " + thisRequest.CallbackNumber + "    reqStart: " + reqStart);
               //////////console.log(consoleCounter++ + "  Multistream " + thisRequest.createReadStreamNumber + "   CB number " + thisRequest.CallbackNumber + "    reqEnd: " + reqEnd);
            }

            var XHRDataHandler = function (chunk){
               bytesReceivedFromServer += chunk.length;
               //console.log("ReadableStream request number " + thisRequest.createReadStreamNumber + " received a chunk of length " + chunk.length);
               if(thisRequest.noMoreData){
                  thisRequest.oldStartServer += chunk.length;
                  return;
               }
               if (thisRequest.start - thisRequest.oldStartServer < chunk.length){         
                  bytesTakenFromServer += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
                  thisRequest.bytesInAnswerStream += chunk.length - (thisRequest.start - thisRequest.oldStartServer);
                  var myBuffer = chunk.slice(thisRequest.start - thisRequest.oldStartServer, chunk.length);
                  //console.log("In XHRDataHandler   myBuffer.length: " + myBuffer.length);
                  var StreamHasMemoryLeft = thisRequest.answerStream.push(myBuffer);         
                  if(!StreamHasMemoryLeft){
                     if(thisRequest.currentlyExpectedCallback !== null){
                        var theCallbackFunction = thisRequest.currentlyExpectedCallback;
                        thisRequest.currentlyExpectedCallback = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: WATERMARK_HEIGHT_OF_ANSWERSTREAM});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.createReadStreamNumber);
                        if (thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                        theCallbackFunction(null, res); 
                     } else {
                        thisRequest.noMoreData = true;
                        if(thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                     }
                  } else {
                     if (thisRequest.start >= thisRequest.end && thisRequest.currentlyExpectedCallback !== null){
                        var theCallbackFunction = thisRequest.currentlyExpectedCallback;
                        thisRequest.currentlyExpectedCallback = null;
                        thisRequest.answerStream.push(null);
                        thisRequest.bytesInAnswerStream = 0;
                        var res = thisRequest.answerStream;
                        thisRequest.answerStream = new MyReadableStream({highWaterMark: WATERMARK_HEIGHT_OF_ANSWERSTREAM});
                        //console.log("called CB with data out of answerStream from videostreamRequest number " + thisRequest.createReadStreamNumber);
                        if (thisRequest.webTorrentStream){
                           thisRequest.webTorrentStream.pause();
                        }
                        theCallbackFunction(null, res);
                     }
                  } 
                  thisRequest.start += chunk.length - (thisRequest.start - thisRequest.oldStartServer);            
               }
               thisRequest.oldStartServer += chunk.length;
            }

            var XHREnd = function (){
               console.log("ReadableStream request number " + thisRequest.createReadStreamNumber + " XHREnd");
               if (consoleCounter < 1000000000000){
                  //////////console.log("XHREnd from videostreamRequest number " + thisRequest.createReadStreamNumber);
               }
               /* Want to solve example_application.js:14013 Uncaught Error: Data too short   Daher das hier auskommentiert
               if(thisRequest.bytesInAnswerStream > 0 && thisRequest.currentlyExpectedCallback !== null){
                  thisRequest.answerStream.push(null);
                  thisRequest.bytesInAnswerStream = 0;
                  var res = thisRequest.answerStream;
                  thisRequest.answerStream = new MyReadableStream({highWaterMark: WATERMARK_HEIGHT_OF_ANSWERSTREAM});
                  var theCallbackFunction = thisRequest.currentlyExpectedCallback;
                  thisRequest.currentlyExpectedCallback = null;
                  //console.log("XHREnd: called CB with data out of answerStream from videostreamRequest number " + thisRequest.createReadStreamNumber);
                  theCallbackFunction(null, res);
               }
               */
               
               /*
               if(thisRequest.currentlyExpectedCallback){
                  if(thisRequest.start < SIZE_OF_VIDEO_FILE && thisRequest.start < thisRequest.XHR_filesize){
                     if(thisRequest.end > 0 ){
                        if(thisRequest.start < thisRequest.end){
                           conductXHR(thisRequest); // try to solve example_application.js:14013 Uncaught Error: Data too short
                        }
                     } else {
                        conductXHR(thisRequest);
                     }
                  }
               } else {
                  */
                  //console.log("XHREnd from videostreamRequest number " + thisRequest.createReadStreamNumber + " thisRequest.currentlyExpectedCallback === null : " + (thisRequest.currentlyExpectedCallback === null));
                  thisRequest.XHRConducted = false;
               //}                 
            }
            thisRequest.oldStartServer = reqStart;
            
            //console.log("At htto.get   reqStart: " + reqStart + "     reqEnd: " + reqEnd);

                  
            var XHROptionObject = {
               path: thisRequest.self.pathToFileOnXHRServer,
               headers: {
                  range: 'bytes=' + reqStart + '-' + (reqEnd-1)
               }
            };
            if(XHRServerURL){
               XHROptionObject.hostname = XHRServerURL;
               XHROptionObject.port = XHR_PORT;
            }
            
            thisRequest.req = http.get(XHROptionObject, function (res){
                  var contentRange = res.headers['content-range'];
                  if (contentRange) {
                     //console.log("parseInt(contentRange.split('/')[1], 10) XHR: " + parseInt(contentRange.split('/')[1], 10));
                     // Hat zu bugs geführt. Hat geringe priorität einzubauen das file_size auch vom XHR server erfragt wird.
                     //SIZE_OF_VIDEO_FILE = parseInt(contentRange.split('/')[1], 10);
                     //if(thisRequest.end === 0){
                     thisRequest.XHR_filesize = parseInt(contentRange.split('/')[1], 10);
                     //}
                     
                  }
                  //////////console.log("I return currentlyExpectedCallback with http response stream");
                  ////////////console.log("function(res) is executed from readstream number " + createReadStreamCounter + " and CB number " + thisCallbackNumber);
                  res.on('end', XHREnd);
                  res.on('data', XHRDataHandler);
               }
            );
         }
         frequentlyCheckIfNewCreateReadStreamNecessary();
         chokeIfNecessary();
         updateChart();
         frequentlyCeckIfAnswerStreamReady();
         checkIfBufferFullEnough();

         //////console.log("I call Videostream constructor");
         if(hashValue){
            Videostream(new fileLikeObject(hashValue), myVideo);
         } else {
            Videostream(new fileLikeObject(pathToFileOnXHRServer), myVideo);
         }
      }

      // This function adds a simple-peer connection to the WebTorrent swarm of the FVSL instance.
      // A simple-peer is a wrapper for a Web-RTC connection.
      function addSimplePeerInstance(simplePeerInstance, options, callback){
         // The method add a simplePeer to the WebTorrent swarm instance
         if(theTorrent){
            if(theTorrent.infoHash){
               theTorrent.addPeer(simplePeerInstance);
               if(callback){
                  callback();
               }
            } else {
               theTorrent.on('infoHash', function() {theTorrent.addPeer(simplePeerInstance); if(callback){callback()}});
            }
         } else {
            var pair = [];
            pair.push(simplePeerInstance);
            pair.push(callback);
            peersToAdd.push(pair);
         }
      }
   })();
}
}).call(this,require("buffer").Buffer)

},{"buffer":24,"http":139,"multistream":87,"readable-stream":115,"simple-peer":124,"ut_pex":161,"util":169,"videostream":171,"webtorrent":172}],2:[function(require,module,exports){
var Y = require("yjs");
require("y-array")(Y);
require("y-memory")(Y);
require("y-websockets-client")(Y);
require("y-map")(Y);
var OakStreaming = require('./OakStreaming');
var myStreaming = new OakStreaming();

var theSharedMap = null;
var theSharedArray = null;
var streamSource = false;

/*
document.querySelector('form').addEventListener('submit', function (ev) {
  ev.preventDefault();
   myStreaming.loadVideo(JSON.parse(document.querySelector('#incoming').value), function(){console.log("All video data has been received");});
});
*/

Y({
  db: {
    name: 'memory'
  },
  connector: {
     //url : "https://yjs.dbis.rwth-aachen.de:5078",
    name: 'websockets-client',
    room: 'WebTorrent-Streaming-yeah'
  },
  share: {
     //myMap : 'Map',
     myArray : 'Array'
  }
}).then(function (y){
  //theSharedMap = y.share.myMap;
  theSharedArray = y.share.myArray;
  /*
  y.share.myMap.observe(function(event){
      console.log("The following event-type was thrown: "+ event.type)
      console.log("The event was executed on: "+ event.name)
      console.log("The event object has more information:")
      console.log(event);
      if(!streamSource){
         console.log("Video gets loaded");
         myStreaming.loadVideo(theSharedMap.getPrimitive("streamInformationObject"), function(){console.log("All video data has been received");});
         console.log("After myStreaming.loadVideo(..) in myMap.observe(..)");    
      }
  });
  */
   theSharedArray.observe(function(event){
      console.log("The following event-type was thrown: "+ event.type)
      console.log("The event was executed on: "+ event.name)
      console.log("The event object has more information:")
      console.log(event);
      if(!streamSource){
         console.log("Video gets loaded");
         myStreaming.loadVideo(theSharedArray.get(0), function(){console.log("All video data has been received");});
         console.log("After myStreaming.loadVideo(..) in myMap.observe(..)");    
      }
   });
});

window.handleFiles = function(files){     // ,["wss://tracker.webtorrent.io"]   "ws://localhost:8081"    "http://gaudi.informatik.rwth-aachen.de/WebTorrentVideo/:9917"  XHR_server_URL : "localhost"     hash_value : "/" + "ebe51389538b7e58cb5c9d2a9148a57d45f3238c61248513979a70ec8a6a084e", webTorrent_trackers: [["wss://tracker.webtorrent.io"]]}, 
   streamSource = true;
   myStreaming.streamVideo(files[0], {XHR_server_URL : "localhost", XHR_port: 8080, path_to_file_on_XHR_server: "/videos/" + files[0].name}, function(streamInformationObject){
      //console.log("streamInformationObject:\n" + JSON.stringify(streamInformationObject));
      console.log("In example.js video file got seeded.");
      theSharedArray.insert(0, [streamInformationObject]);
   });
}

// This function updates the statistics that is shown above the video
// updateChart in loadVideo shows more infos but is not indent for enduser use. This is intended as enduser example.
/*
function updateChart(){
   document.getElementById("WebTorrent-received").innerHTML = "webTorrentFile.length: " + myStreaming.get_file_size() + "\n torrent.downloaded: " + myStreaming.get_number_of_bystes_downloaded_P2P() + "\n torrent.uploaded: " + myStreaming.get_number_of_bytes_uploaded_P2P() + "\n torrent.progress: " + myStreaming.get_percentage_downloaded_of_torrent() + "\n Bytes received from server: " + myStreaming.get_number_of_bytes_downloaded_from_server();
   setTimeout(updateChart, 500);
}
updateChart();
*/   
},{"./OakStreaming":1,"y-array":183,"y-map":184,"y-memory":185,"y-websockets-client":187,"yjs":195}],3:[function(require,module,exports){
var ADDR_RE = /^\[?([^\]]+)\]?:(\d+)$/ // ipv4/ipv6/hostname + port

var cache = {}

// reset cache when it gets to 100,000 elements (~ 600KB of ipv4 addresses)
// so it will not grow to consume all memory in long-running processes
var size = 0

module.exports = function addrToIPPort (addr) {
  if (size === 100000) module.exports.reset()
  if (!cache[addr]) {
    var m = ADDR_RE.exec(addr)
    if (!m) throw new Error('invalid addr: ' + addr)
    cache[addr] = [ m[1], Number(m[2]) ]
    size += 1
  }
  return cache[addr]
}

module.exports.reset = function reset () {
  cache = {}
  size = 0
}

},{}],4:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],5:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],6:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],7:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],8:[function(require,module,exports){
(function (Buffer){
/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode (data, start, end, encoding) {
  if (typeof start !== 'number' && encoding == null) {
    encoding = start
    start = undefined
  }

  if (typeof end !== 'number' && encoding == null) {
    encoding = end
    end = undefined
  }

  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !(Buffer.isBuffer(data))
    ? new Buffer(data)
    : data.slice(start, end)

  decode.bytes = decode.data.length

  return decode.next()
}

decode.bytes = 0
decode.position = 0
decode.data = null
decode.encoding = null

decode.next = function () {
  switch (decode.data[decode.position]) {
    case 0x64:
      return decode.dictionary()
    case 0x6C:
      return decode.list()
    case 0x69:
      return decode.integer()
    default:
      return decode.buffer()
  }
}

decode.find = function (chr) {
  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while (i < c) {
    if (d[i] === chr) return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode(chr) + '" [0x' +
    chr.toString(16) + ']'
  )
}

decode.dictionary = function () {
  decode.position++

  var dict = {}

  while (decode.data[decode.position] !== 0x65) {
    dict[decode.buffer()] = decode.next()
  }

  decode.position++

  return dict
}

decode.list = function () {
  decode.position++

  var lst = []

  while (decode.data[decode.position] !== 0x65) {
    lst.push(decode.next())
  }

  decode.position++

  return lst
}

decode.integer = function () {
  var end = decode.find(0x65)
  var number = decode.data.toString('ascii', decode.position + 1, end)

  decode.position += end + 1 - decode.position

  return parseInt(number, 10)
}

decode.buffer = function () {
  var sep = decode.find(0x3A)
  var length = parseInt(decode.data.toString('ascii', decode.position, sep), 10)
  var end = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString(decode.encoding, sep, end)
    : decode.data.slice(sep, end)
}

module.exports = decode

}).call(this,require("buffer").Buffer)

},{"buffer":24}],9:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode (data, buffer, offset) {
  var buffers = []
  var result = null

  encode._encode(buffers, data)
  result = Buffer.concat(buffers)
  encode.bytes = result.length

  if (Buffer.isBuffer(buffer)) {
    result.copy(buffer, offset)
    return buffer
  }

  return result
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function (buffers, data) {
  if (Buffer.isBuffer(data)) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return
  }

  switch (typeof data) {
    case 'string':
      encode.buffer(buffers, data)
      break
    case 'number':
      encode.number(buffers, data)
      break
    case 'object':
      data.constructor === Array
        ? encode.list(buffers, data)
        : encode.dict(buffers, data)
      break
    case 'boolean':
      encode.number(buffers, data ? 1 : 0)
      break
  }
}

var buffE = new Buffer('e')
var buffD = new Buffer('d')
var buffL = new Buffer('l')

encode.buffer = function (buffers, data) {
  buffers.push(new Buffer(Buffer.byteLength(data) + ':' + data))
}

encode.number = function (buffers, data) {
  var maxLo = 0x80000000
  var hi = (data / maxLo) << 0
  var lo = (data % maxLo) << 0
  var val = hi * maxLo + lo

  buffers.push(new Buffer('i' + val + 'e'))

  if (val !== data && !encode._floatConversionDetected) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "' + data + '":',
      'Bencoding only defines support for integers, value was converted to "' + val + '"'
    )
    console.trace()
  }
}

encode.dict = function (buffers, data) {
  buffers.push(buffD)

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys(data).sort()
  var kl = keys.length

  for (; j < kl; j++) {
    k = keys[j]
    encode.buffer(buffers, k)
    encode._encode(buffers, data[k])
  }

  buffers.push(buffE)
}

encode.list = function (buffers, data) {
  var i = 0
  var c = data.length
  buffers.push(buffL)

  for (; i < c; i++) {
    encode._encode(buffers, data[i])
  }

  buffers.push(buffE)
}

module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":24}],10:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require('./encode')
bencode.decode = require('./decode')

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function (value) {
  return bencode.encode(value).length
}

},{"./decode":8,"./encode":9}],11:[function(require,module,exports){
module.exports = function(haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low < 0 || low >= haystack.length)
      throw new RangeError("invalid lower bound");
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high < low || high >= haystack.length)
      throw new RangeError("invalid upper bound");
  }

  while(low <= high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle, mid, haystack);

    /* Too low. */
    if(cmp < 0.0)
      low  = mid + 1;

    /* Too high. */
    else if(cmp > 0.0)
      high = mid - 1;

    /* Key found. */
    else
      return mid;
  }

  /* Key not found. */
  return ~low;
}

},{}],12:[function(require,module,exports){
(function (Buffer){
var Container = typeof Buffer !== "undefined" ? Buffer //in node, use buffers
		: typeof Int8Array !== "undefined" ? Int8Array //in newer browsers, use webgl int8arrays
		: function(l){ var a = new Array(l); for(var i = 0; i < l; i++) a[i]=0; }; //else, do something similar

function BitField(data, opts){
	if(!(this instanceof BitField)) {
		return new BitField(data, opts);
	}

	if(arguments.length === 0){
		data = 0;
	}

	this.grow = opts && (isFinite(opts.grow) && getByteSize(opts.grow) || opts.grow) || 0;

	if(typeof data === "number" || data === undefined){
		data = new Container(getByteSize(data));
		if(data.fill && !data._isBuffer) data.fill(0); // clear node buffers of garbage
	}
	this.buffer = data;
}

function getByteSize(num){
	var out = num >> 3;
	if(num % 8 !== 0) out++;
	return out;
}

BitField.prototype.get = function(i){
	var j = i >> 3;
	return (j < this.buffer.length) &&
		!!(this.buffer[j] & (128 >> (i % 8)));
};

BitField.prototype.set = function(i, b){
	var j = i >> 3;
	if (b || arguments.length === 1){
		if (this.buffer.length < j + 1) this._grow(Math.max(j + 1, Math.min(2 * this.buffer.length, this.grow)));
		// Set
		this.buffer[j] |= 128 >> (i % 8);
	} else if (j < this.buffer.length) {
		/// Clear
		this.buffer[j] &= ~(128 >> (i % 8));
	}
};

BitField.prototype._grow = function(length) {
	if (this.buffer.length < length && length <= this.grow) {
		var newBuffer = new Container(length);
		if (newBuffer.fill) newBuffer.fill(0);
		if (this.buffer.copy) this.buffer.copy(newBuffer, 0);
		else {
			for(var i = 0; i < this.buffer.length; i++) {
				newBuffer[i] = this.buffer[i];
			}
		}
		this.buffer = newBuffer;
	}
};

if(typeof module !== "undefined") module.exports = BitField;

}).call(this,require("buffer").Buffer)

},{"buffer":24}],13:[function(require,module,exports){
module.exports = Wire

var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-protocol')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var speedometer = require('speedometer')
var stream = require('readable-stream')

var BITFIELD_GROW = 400000
var KEEP_ALIVE_TIMEOUT = 55000

var MESSAGE_PROTOCOL = Buffer.from('\u0013BitTorrent protocol')
var MESSAGE_KEEP_ALIVE = Buffer.from([0x00, 0x00, 0x00, 0x00])
var MESSAGE_CHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x00])
var MESSAGE_UNCHOKE = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x01])
var MESSAGE_INTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x02])
var MESSAGE_UNINTERESTED = Buffer.from([0x00, 0x00, 0x00, 0x01, 0x03])

var MESSAGE_RESERVED = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
var MESSAGE_PORT = [0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00]

function Request (piece, offset, length, callback) {
  this.piece = piece
  this.offset = offset
  this.length = length
  this.callback = callback
}

inherits(Wire, stream.Duplex)

function Wire () {
  if (!(this instanceof Wire)) return new Wire()
  stream.Duplex.call(this)

  this._debugId = hat(32)
  this._debug('new wire')

  this.peerId = null // remote peer id (hex string)
  this.peerIdBuffer = null // remote peer id (buffer)
  this.type = null // connection type ('webrtc', 'tcpIncoming', 'tcpOutgoing', 'webSeed')

  this.amChoking = true // are we choking the peer?
  this.amInterested = false // are we interested in the peer?

  this.peerChoking = true // is the peer choking us?
  this.peerInterested = false // is the peer interested in us?

  // The largest torrent that I know of (the Geocities archive) is ~641 GB and has
  // ~41,000 pieces. Therefore, cap bitfield to 10x larger (400,000 bits) to support all
  // possible torrents but prevent malicious peers from growing bitfield to fill memory.
  this.peerPieces = new BitField(0, { grow: BITFIELD_GROW })

  this.peerExtensions = {}

  this.requests = [] // outgoing
  this.peerRequests = [] // incoming

  this.extendedMapping = {} // number -> string, ex: 1 -> 'ut_metadata'
  this.peerExtendedMapping = {} // string -> number, ex: 9 -> 'ut_metadata'

  // The extended handshake to send, minus the "m" field, which gets automatically
  // filled from `this.extendedMapping`
  this.extendedHandshake = {}

  this.peerExtendedHandshake = {} // remote peer's extended handshake

  this._ext = {}  // string -> function, ex 'ut_metadata' -> ut_metadata()
  this._nextExt = 1

  this.uploaded = 0
  this.downloaded = 0
  this.uploadSpeed = speedometer()
  this.downloadSpeed = speedometer()

  this._keepAliveInterval = null
  this._timeout = null
  this._timeoutMs = 0

  this.destroyed = false // was the wire ended by calling `destroy`?
  this._finished = false

  this._parserSize = 0 // number of needed bytes to parse next message from remote peer
  this._parser = null // function to call once `this._parserSize` bytes are available

  this._buffer = [] // incomplete message data
  this._bufferSize = 0 // cached total length of buffers in `this._buffer`

  this.on('finish', this._onFinish)

  this._parseHandshake()
}

/**
 * Set whether to send a "keep-alive" ping (sent every 55s)
 * @param {boolean} enable
 */
Wire.prototype.setKeepAlive = function (enable) {
  var self = this
  self._debug('setKeepAlive %s', enable)
  clearInterval(self._keepAliveInterval)
  if (enable === false) return
  self._keepAliveInterval = setInterval(function () {
    self.keepAlive()
  }, KEEP_ALIVE_TIMEOUT)
}

/**
 * Set the amount of time to wait before considering a request to be "timed out"
 * @param {number} ms
 * @param {boolean=} unref (should the timer be unref'd? default: false)
 */
Wire.prototype.setTimeout = function (ms, unref) {
  this._debug('setTimeout ms=%d unref=%s', ms, unref)
  this._clearTimeout()
  this._timeoutMs = ms
  this._timeoutUnref = !!unref
  this._updateTimeout()
}

Wire.prototype.destroy = function () {
  if (this.destroyed) return
  this.destroyed = true
  this._debug('destroy')
  this.emit('close')
  this.end()
}

Wire.prototype.end = function () {
  this._debug('end')
  this._onUninterested()
  this._onChoke()
  stream.Duplex.prototype.end.apply(this, arguments)
}

/**
 * Use the specified protocol extension.
 * @param  {function} Extension
 */
Wire.prototype.use = function (Extension) {
  var name = Extension.prototype.name
  if (!name) {
    throw new Error('Extension class requires a "name" property on the prototype')
  }
  this._debug('use extension.name=%s', name)

  var ext = this._nextExt
  var handler = new Extension(this)

  function noop () {}

  if (typeof handler.onHandshake !== 'function') {
    handler.onHandshake = noop
  }
  if (typeof handler.onExtendedHandshake !== 'function') {
    handler.onExtendedHandshake = noop
  }
  if (typeof handler.onMessage !== 'function') {
    handler.onMessage = noop
  }

  this.extendedMapping[ext] = name
  this._ext[name] = handler
  this[name] = handler

  this._nextExt += 1
}

//
// OUTGOING MESSAGES
//

/**
 * Message "keep-alive": <len=0000>
 */
Wire.prototype.keepAlive = function () {
  this._debug('keep-alive')
  this._push(MESSAGE_KEEP_ALIVE)
}

/**
 * Message: "handshake" <pstrlen><pstr><reserved><info_hash><peer_id>
 * @param  {Buffer|string} infoHash (as Buffer or *hex* string)
 * @param  {Buffer|string} peerId
 * @param  {Object} extensions
 */
Wire.prototype.handshake = function (infoHash, peerId, extensions) {
  var infoHashBuffer, peerIdBuffer
  if (typeof infoHash === 'string') {
    infoHashBuffer = Buffer.from(infoHash, 'hex')
  } else {
    infoHashBuffer = infoHash
    infoHash = infoHashBuffer.toString('hex')
  }
  if (typeof peerId === 'string') {
    peerIdBuffer = Buffer.from(peerId, 'hex')
  } else {
    peerIdBuffer = peerId
    peerId = peerIdBuffer.toString('hex')
  }

  if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
    throw new Error('infoHash and peerId MUST have length 20')
  }

  this._debug('handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  var reserved = Buffer.from(MESSAGE_RESERVED)

  // enable extended message
  reserved[5] |= 0x10

  if (extensions && extensions.dht) reserved[7] |= 1

  this._push(Buffer.concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]))
  this._handshakeSent = true

  if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
    // Peer's handshake indicated support already
    // (incoming connection)
    this._sendExtendedHandshake()
  }
}

/* Peer supports BEP-0010, send extended handshake.
 *
 * This comes after the 'handshake' event to give the user a chance to populate
 * `this.extendedHandshake` and `this.extendedMapping` before the extended handshake
 * is sent to the remote peer.
 */
Wire.prototype._sendExtendedHandshake = function () {
  // Create extended message object from registered extensions
  var msg = extend(this.extendedHandshake)
  msg.m = {}
  for (var ext in this.extendedMapping) {
    var name = this.extendedMapping[ext]
    msg.m[name] = Number(ext)
  }

  // Send extended handshake
  this.extended(0, bencode.encode(msg))
  this._extendedHandshakeSent = true
}

/**
 * Message "choke": <len=0001><id=0>
 */
Wire.prototype.choke = function () {
  if (this.amChoking) return
  this.amChoking = true
  this._debug('choke')
  this.peerRequests.splice(0, this.peerRequests.length)
  this._push(MESSAGE_CHOKE)
}

/**
 * Message "unchoke": <len=0001><id=1>
 */
Wire.prototype.unchoke = function () {
  if (!this.amChoking) return
  this.amChoking = false
  this._debug('unchoke')
  this._push(MESSAGE_UNCHOKE)
}

/**
 * Message "interested": <len=0001><id=2>
 */
Wire.prototype.interested = function () {
  if (this.amInterested) return
  this.amInterested = true
  this._debug('interested')
  this._push(MESSAGE_INTERESTED)
}

/**
 * Message "uninterested": <len=0001><id=3>
 */
Wire.prototype.uninterested = function () {
  if (!this.amInterested) return
  this.amInterested = false
  this._debug('uninterested')
  this._push(MESSAGE_UNINTERESTED)
}

/**
 * Message "have": <len=0005><id=4><piece index>
 * @param  {number} index
 */
Wire.prototype.have = function (index) {
  this._debug('have %d', index)
  this._message(4, [index], null)
}

/**
 * Message "bitfield": <len=0001+X><id=5><bitfield>
 * @param  {BitField|Buffer} bitfield
 */
Wire.prototype.bitfield = function (bitfield) {
  this._debug('bitfield')
  if (!Buffer.isBuffer(bitfield)) bitfield = bitfield.buffer
  this._message(5, [], bitfield)
}

/**
 * Message "request": <len=0013><id=6><index><begin><length>
 * @param  {number}   index
 * @param  {number}   offset
 * @param  {number}   length
 * @param  {function} cb
 */
Wire.prototype.request = function (index, offset, length, cb) {
  if (!cb) cb = function () {}
  if (this._finished) return cb(new Error('wire is closed'))
  if (this.peerChoking) return cb(new Error('peer is choking'))

  this._debug('request index=%d offset=%d length=%d', index, offset, length)

  this.requests.push(new Request(index, offset, length, cb))
  this._updateTimeout()
  this._message(6, [index, offset, length], null)
}

/**
 * Message "piece": <len=0009+X><id=7><index><begin><block>
 * @param  {number} index
 * @param  {number} offset
 * @param  {Buffer} buffer
 */
Wire.prototype.piece = function (index, offset, buffer) {
  this._debug('piece index=%d offset=%d', index, offset)
  this.uploaded += buffer.length
  this.uploadSpeed(buffer.length)
  this.emit('upload', buffer.length)
  this._message(7, [index, offset], buffer)
}

/**
 * Message "cancel": <len=0013><id=8><index><begin><length>
 * @param  {number} index
 * @param  {number} offset
 * @param  {number} length
 */
Wire.prototype.cancel = function (index, offset, length) {
  this._debug('cancel index=%d offset=%d length=%d', index, offset, length)
  this._callback(
    pull(this.requests, index, offset, length),
    new Error('request was cancelled'),
    null
  )
  this._message(8, [index, offset, length], null)
}

/**
 * Message: "port" <len=0003><id=9><listen-port>
 * @param {Number} port
 */
Wire.prototype.port = function (port) {
  this._debug('port %d', port)
  var message = Buffer.from(MESSAGE_PORT)
  message.writeUInt16BE(port, 5)
  this._push(message)
}

/**
 * Message: "extended" <len=0005+X><id=20><ext-number><payload>
 * @param  {number|string} ext
 * @param  {Object} obj
 */
Wire.prototype.extended = function (ext, obj) {
  this._debug('extended ext=%s', ext)
  if (typeof ext === 'string' && this.peerExtendedMapping[ext]) {
    ext = this.peerExtendedMapping[ext]
  }
  if (typeof ext === 'number') {
    var extId = Buffer.from([ext])
    var buf = Buffer.isBuffer(obj) ? obj : bencode.encode(obj)

    this._message(20, [], Buffer.concat([extId, buf]))
  } else {
    throw new Error('Unrecognized extension: ' + ext)
  }
}

/**
 * Duplex stream method. Called whenever the remote peer stream wants data. No-op
 * since we'll just push data whenever we get it.
 */
Wire.prototype._read = function () {}

/**
 * Send a message to the remote peer.
 */
Wire.prototype._message = function (id, numbers, data) {
  var dataLength = data ? data.length : 0
  var buffer = Buffer.allocUnsafe(5 + 4 * numbers.length)

  buffer.writeUInt32BE(buffer.length + dataLength - 4, 0)
  buffer[4] = id
  for (var i = 0; i < numbers.length; i++) {
    buffer.writeUInt32BE(numbers[i], 5 + 4 * i)
  }

  this._push(buffer)
  if (data) this._push(data)
}

Wire.prototype._push = function (data) {
  if (this._finished) return
  return this.push(data)
}

//
// INCOMING MESSAGES
//

Wire.prototype._onKeepAlive = function () {
  this._debug('got keep-alive')
  this.emit('keep-alive')
}

Wire.prototype._onHandshake = function (infoHashBuffer, peerIdBuffer, extensions) {
  var infoHash = infoHashBuffer.toString('hex')
  var peerId = peerIdBuffer.toString('hex')

  this._debug('got handshake i=%s p=%s exts=%o', infoHash, peerId, extensions)

  this.peerId = peerId
  this.peerIdBuffer = peerIdBuffer
  this.peerExtensions = extensions

  this.emit('handshake', infoHash, peerId, extensions)

  var name
  for (name in this._ext) {
    this._ext[name].onHandshake(infoHash, peerId, extensions)
  }

  if (extensions.extended && this._handshakeSent &&
      !this._extendedHandshakeSent) {
    // outgoing connection
    this._sendExtendedHandshake()
  }
}

Wire.prototype._onChoke = function () {
  this.peerChoking = true
  this._debug('got choke')
  this.emit('choke')
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('peer is choking'), null)
  }
}

Wire.prototype._onUnchoke = function () {
  this.peerChoking = false
  this._debug('got unchoke')
  this.emit('unchoke')
}

Wire.prototype._onInterested = function () {
  this.peerInterested = true
  this._debug('got interested')
  this.emit('interested')
}

Wire.prototype._onUninterested = function () {
  this.peerInterested = false
  this._debug('got uninterested')
  this.emit('uninterested')
}

Wire.prototype._onHave = function (index) {
  if (this.peerPieces.get(index)) return
  this._debug('got have %d', index)

  this.peerPieces.set(index, true)
  this.emit('have', index)
}

Wire.prototype._onBitField = function (buffer) {
  this.peerPieces = new BitField(buffer)
  this._debug('got bitfield')
  this.emit('bitfield', this.peerPieces)
}

Wire.prototype._onRequest = function (index, offset, length) {
  var self = this
  if (self.amChoking) return
  self._debug('got request index=%d offset=%d length=%d', index, offset, length)

  var respond = function (err, buffer) {
    if (request !== pull(self.peerRequests, index, offset, length)) return
    if (err) return self._debug('error satisfying request index=%d offset=%d length=%d (%s)', index, offset, length, err.message)
    self.piece(index, offset, buffer)
  }

  var request = new Request(index, offset, length, respond)
  self.peerRequests.push(request)
  self.emit('request', index, offset, length, respond)
}

Wire.prototype._onPiece = function (index, offset, buffer) {
  this._debug('got piece index=%d offset=%d', index, offset)
  this._callback(pull(this.requests, index, offset, buffer.length), null, buffer)
  this.downloaded += buffer.length
  this.downloadSpeed(buffer.length)
  this.emit('download', buffer.length)
  this.emit('piece', index, offset, buffer)
}

Wire.prototype._onCancel = function (index, offset, length) {
  this._debug('got cancel index=%d offset=%d length=%d', index, offset, length)
  pull(this.peerRequests, index, offset, length)
  this.emit('cancel', index, offset, length)
}

Wire.prototype._onPort = function (port) {
  this._debug('got port %d', port)
  this.emit('port', port)
}

Wire.prototype._onExtended = function (ext, buf) {
  if (ext === 0) {
    var info
    try {
      info = bencode.decode(buf)
    } catch (err) {
      this._debug('ignoring invalid extended handshake: %s', err.message || err)
    }

    if (!info) return
    this.peerExtendedHandshake = info

    var name
    if (typeof info.m === 'object') {
      for (name in info.m) {
        this.peerExtendedMapping[name] = Number(info.m[name].toString())
      }
    }
    for (name in this._ext) {
      if (this.peerExtendedMapping[name]) {
        this._ext[name].onExtendedHandshake(this.peerExtendedHandshake)
      }
    }
    this._debug('got extended handshake')
    this.emit('extended', 'handshake', this.peerExtendedHandshake)
  } else {
    if (this.extendedMapping[ext]) {
      ext = this.extendedMapping[ext] // friendly name for extension
      if (this._ext[ext]) {
        // there is an registered extension handler, so call it
        this._ext[ext].onMessage(buf)
      }
    }
    this._debug('got extended message ext=%s', ext)
    this.emit('extended', ext, buf)
  }
}

Wire.prototype._onTimeout = function () {
  this._debug('request timed out')
  this._callback(this.requests.shift(), new Error('request has timed out'), null)
  this.emit('timeout')
}

/**
 * Duplex stream method. Called whenever the remote peer has data for us. Data that the
 * remote peer sends gets buffered (i.e. not actually processed) until the right number
 * of bytes have arrived, determined by the last call to `this._parse(number, callback)`.
 * Once enough bytes have arrived to process the message, the callback function
 * (i.e. `this._parser`) gets called with the full buffer of data.
 * @param  {Buffer} data
 * @param  {string} encoding
 * @param  {function} cb
 */
Wire.prototype._write = function (data, encoding, cb) {
  this._bufferSize += data.length
  this._buffer.push(data)

  while (this._bufferSize >= this._parserSize) {
    var buffer = (this._buffer.length === 1)
      ? this._buffer[0]
      : Buffer.concat(this._buffer)
    this._bufferSize -= this._parserSize
    this._buffer = this._bufferSize
      ? [buffer.slice(this._parserSize)]
      : []
    this._parser(buffer.slice(0, this._parserSize))
  }

  cb(null) // Signal that we're ready for more data
}

Wire.prototype._callback = function (request, err, buffer) {
  if (!request) return

  this._clearTimeout()

  if (!this.peerChoking && !this._finished) this._updateTimeout()
  request.callback(err, buffer)
}

Wire.prototype._clearTimeout = function () {
  if (!this._timeout) return

  clearTimeout(this._timeout)
  this._timeout = null
}

Wire.prototype._updateTimeout = function () {
  var self = this
  if (!self._timeoutMs || !self.requests.length || self._timeout) return

  self._timeout = setTimeout(function () {
    self._onTimeout()
  }, self._timeoutMs)
  if (self._timeoutUnref && self._timeout.unref) self._timeout.unref()
}

/**
 * Takes a number of bytes that the local peer is waiting to receive from the remote peer
 * in order to parse a complete message, and a callback function to be called once enough
 * bytes have arrived.
 * @param  {number} size
 * @param  {function} parser
 */
Wire.prototype._parse = function (size, parser) {
  this._parserSize = size
  this._parser = parser
}

/**
 * Handle the first 4 bytes of a message, to determine the length of bytes that must be
 * waited for in order to have the whole message.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessageLength = function (buffer) {
  var length = buffer.readUInt32BE(0)
  if (length > 0) {
    this._parse(length, this._onMessage)
  } else {
    this._onKeepAlive()
    this._parse(4, this._onMessageLength)
  }
}

/**
 * Handle a message from the remote peer.
 * @param  {Buffer} buffer
 */
Wire.prototype._onMessage = function (buffer) {
  this._parse(4, this._onMessageLength)
  switch (buffer[0]) {
    case 0:
      return this._onChoke()
    case 1:
      return this._onUnchoke()
    case 2:
      return this._onInterested()
    case 3:
      return this._onUninterested()
    case 4:
      return this._onHave(buffer.readUInt32BE(1))
    case 5:
      return this._onBitField(buffer.slice(1))
    case 6:
      return this._onRequest(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 7:
      return this._onPiece(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.slice(9))
    case 8:
      return this._onCancel(buffer.readUInt32BE(1),
          buffer.readUInt32BE(5), buffer.readUInt32BE(9))
    case 9:
      return this._onPort(buffer.readUInt16BE(1))
    case 20:
      return this._onExtended(buffer.readUInt8(1), buffer.slice(2))
    default:
      this._debug('got unknown message')
      return this.emit('unknownmessage', buffer)
  }
}

Wire.prototype._parseHandshake = function () {
  var self = this
  self._parse(1, function (buffer) {
    var pstrlen = buffer.readUInt8(0)
    self._parse(pstrlen + 48, function (handshake) {
      var protocol = handshake.slice(0, pstrlen)
      if (protocol.toString() !== 'BitTorrent protocol') {
        self._debug('Error: wire not speaking BitTorrent protocol (%s)', protocol.toString())
        self.end()
        return
      }
      handshake = handshake.slice(pstrlen)
      self._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
        dht: !!(handshake[7] & 0x01), // see bep_0005
        extended: !!(handshake[5] & 0x10) // see bep_0010
      })
      self._parse(4, self._onMessageLength)
    })
  })
}

Wire.prototype._onFinish = function () {
  this._finished = true

  this.push(null) // stream cannot be half open, so signal the end of it
  while (this.read()) {} // consume and discard the rest of the stream data

  clearInterval(this._keepAliveInterval)
  this._parse(Number.MAX_VALUE, function () {})
  this.peerRequests = []
  while (this.requests.length) {
    this._callback(this.requests.shift(), new Error('wire was closed'), null)
  }
}

Wire.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

function pull (requests, piece, offset, length) {
  for (var i = 0; i < requests.length; i++) {
    var req = requests[i]
    if (req.piece !== piece || req.offset !== offset || req.length !== length) continue

    if (i === 0) requests.shift()
    else requests.splice(i, 1)

    return req
  }
  return null
}

},{"bencode":10,"bitfield":12,"debug":39,"hat":64,"inherits":69,"readable-stream":115,"safe-buffer":121,"speedometer":138,"xtend":181}],14:[function(require,module,exports){
(function (process){
module.exports = Client

var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('bittorrent-tracker')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var once = require('once')
var parallel = require('run-parallel')
var Peer = require('simple-peer')
var uniq = require('uniq')
var url = require('url')

var common = require('./lib/common')
var HTTPTracker = require('./lib/client/http-tracker') // empty object in browser
var UDPTracker = require('./lib/client/udp-tracker') // empty object in browser
var WebSocketTracker = require('./lib/client/websocket-tracker')

inherits(Client, EventEmitter)

/**
 * BitTorrent tracker client.
 *
 * Find torrent peers, to help a torrent client participate in a torrent swarm.
 *
 * @param {Object} opts                          options object
 * @param {string|Buffer} opts.infoHash          torrent info hash
 * @param {string|Buffer} opts.peerId            peer id
 * @param {string|Array.<string>} opts.announce  announce
 * @param {number} opts.port                     torrent client listening port
 * @param {function} opts.getAnnounceOpts        callback to provide data to tracker
 * @param {number} opts.rtcConfig                RTCPeerConnection configuration object
 * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)
 */
function Client (opts) {
  var self = this
  if (!(self instanceof Client)) return new Client(opts)
  EventEmitter.call(self)
  if (!opts) opts = {}

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  // required
  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self._peerIdBuffer = Buffer.from(self.peerId, 'hex')
  self._peerIdBinary = self._peerIdBuffer.toString('binary')

  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._infoHashBuffer = Buffer.from(self.infoHash, 'hex')
  self._infoHashBinary = self._infoHashBuffer.toString('binary')

  self._port = opts.port

  self.destroyed = false

  self._rtcConfig = opts.rtcConfig
  self._wrtc = opts.wrtc
  self._getAnnounceOpts = opts.getAnnounceOpts

  debug('new client %s', self.infoHash)

  var webrtcSupport = self._wrtc !== false && (!!self._wrtc || Peer.WEBRTC_SUPPORT)

  var announce = (typeof opts.announce === 'string')
    ? [ opts.announce ]
    : opts.announce == null
      ? []
      : opts.announce

  announce = announce.map(function (announceUrl) {
    announceUrl = announceUrl.toString()
    if (announceUrl[announceUrl.length - 1] === '/') {
      // remove trailing slash from trackers to catch duplicates
      announceUrl = announceUrl.substring(0, announceUrl.length - 1)
    }
    return announceUrl
  })

  announce = uniq(announce)

  self._trackers = announce
    .map(function (announceUrl) {
      var protocol = url.parse(announceUrl).protocol
      if ((protocol === 'http:' || protocol === 'https:') &&
          typeof HTTPTracker === 'function') {
        return new HTTPTracker(self, announceUrl)
      } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {
        return new UDPTracker(self, announceUrl)
      } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {
        // Skip ws:// trackers on https:// sites because they throw SecurityError
        if (protocol === 'ws:' && typeof window !== 'undefined' &&
            window.location.protocol === 'https:') {
          nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
          return null
        }
        return new WebSocketTracker(self, announceUrl)
      } else {
        nextTickWarn(new Error('Unsupported tracker protocol: ' + announceUrl))
        return null
      }
    })
    .filter(Boolean)

  function nextTickWarn (err) {
    process.nextTick(function () {
      self.emit('warning', err)
    })
  }
}

/**
 * Simple convenience function to scrape a tracker for an info hash without needing to
 * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple
 * torrents at the same time.
 * @params {Object} opts
 * @param  {string|Array.<string>} opts.infoHash
 * @param  {string} opts.announce
 * @param  {function} cb
 */
Client.scrape = function (opts, cb) {
  cb = once(cb)

  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!opts.announce) throw new Error('Option `announce` is required')

  var clientOpts = extend(opts, {
    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,
    peerId: Buffer.from('01234567890123456789'), // dummy value
    port: 6881 // dummy value
  })

  var client = new Client(clientOpts)
  client.once('error', cb)

  var len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1
  var results = {}
  client.on('scrape', function (data) {
    len -= 1
    results[data.infoHash] = data
    if (len === 0) {
      client.destroy()
      var keys = Object.keys(results)
      if (keys.length === 1) {
        cb(null, results[keys[0]])
      } else {
        cb(null, results)
      }
    }
  })

  opts.infoHash = Array.isArray(opts.infoHash)
    ? opts.infoHash.map(function (infoHash) {
      return Buffer.from(infoHash, 'hex')
    })
    : Buffer.from(opts.infoHash, 'hex')
  client.scrape({ infoHash: opts.infoHash })
  return client
}

/**
 * Send a `start` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.start = function (opts) {
  var self = this
  debug('send `start`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'started'
  self._announce(opts)

  // start announcing on intervals
  self._trackers.forEach(function (tracker) {
    tracker.setInterval()
  })
}

/**
 * Send a `stop` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.stop = function (opts) {
  var self = this
  debug('send `stop`')
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'stopped'
  self._announce(opts)
}

/**
 * Send a `complete` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.complete = function (opts) {
  var self = this
  debug('send `complete`')
  if (!opts) opts = {}
  opts = self._defaultAnnounceOpts(opts)
  opts.event = 'completed'
  self._announce(opts)
}

/**
 * Send a `update` announce to the trackers.
 * @param {Object} opts
 * @param {number=} opts.uploaded
 * @param {number=} opts.downloaded
 * @param {number=} opts.numwant
 * @param {number=} opts.left (if not set, calculated automatically)
 */
Client.prototype.update = function (opts) {
  var self = this
  debug('send `update`')
  opts = self._defaultAnnounceOpts(opts)
  if (opts.event) delete opts.event
  self._announce(opts)
}

Client.prototype._announce = function (opts) {
  var self = this
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.announce(opts)
  })
}

/**
 * Send a scrape request to the trackers.
 * @param {Object} opts
 */
Client.prototype.scrape = function (opts) {
  var self = this
  debug('send `scrape`')
  if (!opts) opts = {}
  self._trackers.forEach(function (tracker) {
    // tracker should not modify `opts` object, it's passed to all trackers
    tracker.scrape(opts)
  })
}

Client.prototype.setInterval = function (intervalMs) {
  var self = this
  debug('setInterval %d', intervalMs)
  self._trackers.forEach(function (tracker) {
    tracker.setInterval(intervalMs)
  })
}

Client.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  debug('destroy')

  var tasks = self._trackers.map(function (tracker) {
    return function (cb) {
      tracker.destroy(cb)
    }
  })

  parallel(tasks, cb)

  self._trackers = []
  self._getAnnounceOpts = null
}

Client.prototype._defaultAnnounceOpts = function (opts) {
  var self = this
  if (!opts) opts = {}

  if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS

  if (opts.uploaded == null) opts.uploaded = 0
  if (opts.downloaded == null) opts.downloaded = 0

  if (self._getAnnounceOpts) opts = extend(opts, self._getAnnounceOpts())
  return opts
}

}).call(this,require('_process'))

},{"./lib/client/http-tracker":21,"./lib/client/udp-tracker":21,"./lib/client/websocket-tracker":16,"./lib/common":17,"_process":102,"debug":39,"events":57,"inherits":69,"once":89,"run-parallel":119,"safe-buffer":121,"simple-peer":124,"uniq":156,"url":158,"xtend":181}],15:[function(require,module,exports){
module.exports = Tracker

var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

inherits(Tracker, EventEmitter)

function Tracker (client, announceUrl) {
  var self = this
  EventEmitter.call(self)
  self.client = client
  self.announceUrl = announceUrl

  self.interval = null
  self.destroyed = false
}

Tracker.prototype.setInterval = function (intervalMs) {
  var self = this
  if (intervalMs == null) intervalMs = self.DEFAULT_ANNOUNCE_INTERVAL

  clearInterval(self.interval)

  if (intervalMs) {
    self.interval = setInterval(function () {
      self.announce(self.client._defaultAnnounceOpts())
    }, intervalMs)
    if (self.interval.unref) self.interval.unref()
  }
}

},{"events":57,"inherits":69}],16:[function(require,module,exports){
module.exports = WebSocketTracker

var debug = require('debug')('bittorrent-tracker:websocket-tracker')
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var Peer = require('simple-peer')
var Socket = require('simple-websocket')

var common = require('../common')
var Tracker = require('./tracker')

// Use a socket pool, so tracker clients share WebSocket objects for the same server.
// In practice, WebSockets are pretty slow to establish, so this gives a nice performance
// boost, and saves browser resources.
var socketPool = {}

var RECONNECT_MINIMUM = 15 * 1000
var RECONNECT_MAXIMUM = 30 * 60 * 1000
var RECONNECT_VARIANCE = 30 * 1000
var OFFER_TIMEOUT = 50 * 1000

inherits(WebSocketTracker, Tracker)

function WebSocketTracker (client, announceUrl, opts) {
  var self = this
  Tracker.call(self, client, announceUrl)
  debug('new websocket tracker %s', announceUrl)

  self.peers = {} // peers (offer id -> peer)
  self.socket = null

  self.reconnecting = false
  self.retries = 0
  self.reconnectTimer = null

  self._openSocket()
}

WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1000 // 30 seconds

WebSocketTracker.prototype.announce = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.announce(opts)
    })
    return
  }

  var params = extend(opts, {
    action: 'announce',
    info_hash: self.client._infoHashBinary,
    peer_id: self.client._peerIdBinary
  })
  if (self._trackerId) params.trackerid = self._trackerId

  if (opts.event === 'stopped') {
    // Don't include offers with 'stopped' event
    self._send(params)
  } else {
    // Limit the number of offers that are generated, since it can be slow
    var numwant = Math.min(opts.numwant, 5)

    self._generateOffers(numwant, function (offers) {
      params.numwant = numwant
      params.offers = offers
      self._send(params)
    })
  }
}

WebSocketTracker.prototype.scrape = function (opts) {
  var self = this
  if (self.destroyed || self.reconnecting) return
  if (!self.socket.connected) {
    self.socket.once('connect', function () {
      self.scrape(opts)
    })
    return
  }

  var infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)
    ? opts.infoHash.map(function (infoHash) {
      return infoHash.toString('binary')
    })
    : (opts.infoHash && opts.infoHash.toString('binary')) || self.client._infoHashBinary
  var params = {
    action: 'scrape',
    info_hash: infoHashes
  }

  self._send(params)
}

WebSocketTracker.prototype.destroy = function (cb) {
  var self = this
  if (!cb) cb = noop
  if (self.destroyed) return cb(null)

  self.destroyed = true

  clearInterval(self.interval)
  clearTimeout(self.reconnectTimer)

  if (self.socket) {
    self.socket.removeListener('connect', self._onSocketConnectBound)
    self.socket.removeListener('data', self._onSocketDataBound)
    self.socket.removeListener('close', self._onSocketCloseBound)
    self.socket.removeListener('error', self._onSocketErrorBound)
  }

  self._onSocketConnectBound = null
  self._onSocketErrorBound = null
  self._onSocketDataBound = null
  self._onSocketCloseBound = null

  // Destroy peers
  for (var peerId in self.peers) {
    var peer = self.peers[peerId]
    clearTimeout(peer.trackerTimeout)
    peer.destroy()
  }
  self.peers = null

  if (socketPool[self.announceUrl]) {
    socketPool[self.announceUrl].consumers -= 1
  }

  if (socketPool[self.announceUrl].consumers === 0) {
    delete socketPool[self.announceUrl]

    try {
      self.socket.on('error', noop) // ignore all future errors
      self.socket.destroy(cb)
    } catch (err) {
      cb(null)
    }
  } else {
    cb(null)
  }

  self.socket = null
}

WebSocketTracker.prototype._openSocket = function () {
  var self = this
  self.destroyed = false

  if (!self.peers) self.peers = {}

  self._onSocketConnectBound = function () {
    self._onSocketConnect()
  }
  self._onSocketErrorBound = function (err) {
    self._onSocketError(err)
  }
  self._onSocketDataBound = function (data) {
    self._onSocketData(data)
  }
  self._onSocketCloseBound = function () {
    self._onSocketClose()
  }

  self.socket = socketPool[self.announceUrl]
  if (self.socket) {
    socketPool[self.announceUrl].consumers += 1
  } else {
    self.socket = socketPool[self.announceUrl] = new Socket(self.announceUrl)
    self.socket.consumers = 1
    self.socket.on('connect', self._onSocketConnectBound)
  }

  self.socket.on('data', self._onSocketDataBound)
  self.socket.on('close', self._onSocketCloseBound)
  self.socket.on('error', self._onSocketErrorBound)
}

WebSocketTracker.prototype._onSocketConnect = function () {
  var self = this
  if (self.destroyed) return

  if (self.reconnecting) {
    self.reconnecting = false
    self.retries = 0
    self.announce(self.client._defaultAnnounceOpts())
  }
}

WebSocketTracker.prototype._onSocketData = function (data) {
  var self = this
  if (self.destroyed) return

  try {
    data = JSON.parse(data)
  } catch (err) {
    self.client.emit('warning', new Error('Invalid tracker response'))
    return
  }

  if (data.action === 'announce') {
    self._onAnnounceResponse(data)
  } else if (data.action === 'scrape') {
    self._onScrapeResponse(data)
  } else {
    self._onSocketError(new Error('invalid action in WS response: ' + data.action))
  }
}

WebSocketTracker.prototype._onAnnounceResponse = function (data) {
  var self = this

  if (data.info_hash !== self.client._infoHashBinary) {
    debug(
      'ignoring websocket data from %s for %s (looking for %s: reused socket)',
      self.announceUrl, common.binaryToHex(data.info_hash), self.client.infoHash
    )
    return
  }

  if (data.peer_id && data.peer_id === self.client._peerIdBinary) {
    // ignore offers/answers from this client
    return
  }

  debug(
    'received %s from %s for %s',
    JSON.stringify(data), self.announceUrl, self.client.infoHash
  )

  var failure = data['failure reason']
  if (failure) return self.client.emit('warning', new Error(failure))

  var warning = data['warning message']
  if (warning) self.client.emit('warning', new Error(warning))

  var interval = data.interval || data['min interval']
  if (interval) self.setInterval(interval * 1000)

  var trackerId = data['tracker id']
  if (trackerId) {
    // If absent, do not discard previous trackerId value
    self._trackerId = trackerId
  }

  if (data.complete != null) {
    self.client.emit('update', {
      announce: self.announceUrl,
      complete: data.complete,
      incomplete: data.incomplete
    })
  }

  var peer
  if (data.offer && data.peer_id) {
    debug('creating peer (from remote offer)')
    peer = new Peer({
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.id = common.binaryToHex(data.peer_id)
    peer.once('signal', function (answer) {
      var params = {
        action: 'announce',
        info_hash: self.client._infoHashBinary,
        peer_id: self.client._peerIdBinary,
        to_peer_id: data.peer_id,
        answer: answer,
        offer_id: data.offer_id
      }
      if (self._trackerId) params.trackerid = self._trackerId
      self._send(params)
    })
    peer.signal(data.offer)
    self.client.emit('peer', peer)
  }

  if (data.answer && data.peer_id) {
    var offerId = common.binaryToHex(data.offer_id)
    peer = self.peers[offerId]
    if (peer) {
      peer.id = common.binaryToHex(data.peer_id)
      peer.signal(data.answer)
      self.client.emit('peer', peer)

      clearTimeout(peer.trackerTimeout)
      peer.trackerTimeout = null
      delete self.peers[offerId]
    } else {
      debug('got unexpected answer: ' + JSON.stringify(data.answer))
    }
  }
}

WebSocketTracker.prototype._onScrapeResponse = function (data) {
  var self = this
  data = data.files || {}

  var keys = Object.keys(data)
  if (keys.length === 0) {
    self.client.emit('warning', new Error('invalid scrape response'))
    return
  }

  keys.forEach(function (infoHash) {
    var response = data[infoHash]
    // TODO: optionally handle data.flags.min_request_interval
    // (separate from announce interval)
    self.client.emit('scrape', {
      announce: self.announceUrl,
      infoHash: common.binaryToHex(infoHash),
      complete: response.complete,
      incomplete: response.incomplete,
      downloaded: response.downloaded
    })
  })
}

WebSocketTracker.prototype._onSocketClose = function () {
  var self = this
  if (self.destroyed) return
  self.destroy()
  self._startReconnectTimer()
}

WebSocketTracker.prototype._onSocketError = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroy()
  // errors will often happen if a tracker is offline, so don't treat it as fatal
  self.client.emit('warning', err)
  self._startReconnectTimer()
}

WebSocketTracker.prototype._startReconnectTimer = function () {
  var self = this
  var ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, self.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)

  self.reconnecting = true
  clearTimeout(self.reconnectTimer)
  self.reconnectTimer = setTimeout(function () {
    self.retries++
    self._openSocket()
  }, ms)
  if (self.reconnectTimer.unref) self.reconnectTimer.unref()

  debug('reconnecting socket in %s ms', ms)
}

WebSocketTracker.prototype._send = function (params) {
  var self = this
  if (self.destroyed) return

  var message = JSON.stringify(params)
  debug('send %s', message)
  self.socket.send(message)
}

WebSocketTracker.prototype._generateOffers = function (numwant, cb) {
  var self = this
  var offers = []
  debug('generating %s offers', numwant)

  for (var i = 0; i < numwant; ++i) {
    generateOffer()
  }
  checkDone()

  function generateOffer () {
    var offerId = hat(160)
    debug('creating peer (from _generateOffers)')
    var peer = self.peers[offerId] = new Peer({
      initiator: true,
      trickle: false,
      config: self.client._rtcConfig,
      wrtc: self.client._wrtc
    })
    peer.once('signal', function (offer) {
      offers.push({
        offer: offer,
        offer_id: common.hexToBinary(offerId)
      })
      checkDone()
    })
    peer.trackerTimeout = setTimeout(function () {
      debug('tracker timeout: destroying peer')
      peer.trackerTimeout = null
      delete self.peers[offerId]
      peer.destroy()
    }, OFFER_TIMEOUT)
    if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()
  }

  function checkDone () {
    if (offers.length === numwant) {
      debug('generated %s offers', numwant)
      cb(offers)
    }
  }
}

function noop () {}

},{"../common":17,"./tracker":15,"debug":39,"hat":64,"inherits":69,"simple-peer":124,"simple-websocket":126,"xtend":181}],17:[function(require,module,exports){
/**
 * Functions/constants needed by both the client and server.
 */

var Buffer = require('safe-buffer').Buffer
var extend = require('xtend/mutable')

exports.DEFAULT_ANNOUNCE_PEERS = 50
exports.MAX_ANNOUNCE_PEERS = 82

exports.binaryToHex = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'binary').toString('hex')
}

exports.hexToBinary = function (str) {
  if (typeof str !== 'string') {
    str = String(str)
  }
  return Buffer.from(str, 'hex').toString('binary')
}

var config = require('./common-node')
extend(exports, config)

},{"./common-node":21,"safe-buffer":121,"xtend/mutable":182}],18:[function(require,module,exports){
(function (Buffer){
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  var reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, new Buffer(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this,require("buffer").Buffer)

},{"buffer":24}],19:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits');
var Transform = require('readable-stream').Transform;
var defined = require('defined');

module.exports = Block;
inherits(Block, Transform);

function Block (size, opts) {
    if (!(this instanceof Block)) return new Block(size, opts);
    Transform.call(this);
    if (!opts) opts = {};
    if (typeof size === 'object') {
        opts = size;
        size = opts.size;
    }
    this.size = size || 512;
    
    if (opts.nopad) this._zeroPadding = false;
    else this._zeroPadding = defined(opts.zeroPadding, true);
    
    this._buffered = [];
    this._bufferedBytes = 0;
}

Block.prototype._transform = function (buf, enc, next) {
    this._bufferedBytes += buf.length;
    this._buffered.push(buf);
    
    while (this._bufferedBytes >= this.size) {
        var b = Buffer.concat(this._buffered);
        this._bufferedBytes -= this.size;
        this.push(b.slice(0, this.size));
        this._buffered = [ b.slice(this.size, b.length) ];
    }
    next();
};

Block.prototype._flush = function () {
    if (this._bufferedBytes && this._zeroPadding) {
        var zeroes = new Buffer(this.size - this._bufferedBytes);
        zeroes.fill(0);
        this._buffered.push(zeroes);
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    else if (this._bufferedBytes) {
        this.push(Buffer.concat(this._buffered));
        this._buffered = null;
    }
    this.push(null);
};

}).call(this,require("buffer").Buffer)

},{"buffer":24,"defined":41,"inherits":69,"readable-stream":115}],21:[function(require,module,exports){

},{}],22:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],23:[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":24}],24:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  that.write(string, encoding)
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

function arrayIndexOf (arr, val, byteOffset, encoding) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var foundIndex = -1
  for (var i = byteOffset; i < arrLength; ++i) {
    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
      if (foundIndex === -1) foundIndex = i
      if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
    } else {
      if (foundIndex !== -1) i -= i - foundIndex
      foundIndex = -1
    }
  }

  return -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  if (Buffer.isBuffer(val)) {
    // special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(this, val, byteOffset, encoding)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset, encoding)
  }

  throw new TypeError('val must be string, number or Buffer')
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":25,"ieee754":66,"isarray":75}],25:[function(require,module,exports){
'use strict'

exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],26:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],27:[function(require,module,exports){
module.exports = ChunkStoreWriteStream

var BlockStream = require('block-stream2')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(ChunkStoreWriteStream, stream.Writable)

function ChunkStoreWriteStream (store, chunkLength, opts) {
  var self = this
  if (!(self instanceof ChunkStoreWriteStream)) {
    return new ChunkStoreWriteStream(store, chunkLength, opts)
  }
  stream.Writable.call(self, opts)
  if (!opts) opts = {}

  if (!store || !store.put || !store.get) {
    throw new Error('First argument must be an abstract-chunk-store compliant store')
  }
  chunkLength = Number(chunkLength)
  if (!chunkLength) throw new Error('Second argument must be a chunk length')

  self._blockstream = new BlockStream(chunkLength, { zeroPadding: false })

  self._blockstream
    .on('data', onData)
    .on('error', function (err) { self.destroy(err) })

  var index = 0
  function onData (chunk) {
    if (self.destroyed) return
    store.put(index, chunk)
    index += 1
  }

  self.on('finish', function () { this._blockstream.end() })
}

ChunkStoreWriteStream.prototype._write = function (chunk, encoding, callback) {
  this._blockstream.write(chunk, encoding, callback)
}

ChunkStoreWriteStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
}

},{"block-stream2":20,"inherits":69,"readable-stream":115}],28:[function(require,module,exports){
module.exports = function(target, numbers) {
  var closest = Infinity
  var difference = 0
  var winner = null

  numbers.sort(function(a, b) {
    return a - b
  })

  for (var i = 0, l = numbers.length; i < l; i++) {  
    difference = Math.abs(target - numbers[i])
    if (difference >= closest) {
      break
    }
    closest = difference
    winner = numbers[i]
  }

  return winner
}

},{}],29:[function(require,module,exports){
var ipaddr = require('ipaddr.js');

module.exports = compact2string = function (buf) {
  switch(buf.length) {
  case 6:
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3] + ":" + buf.readUInt16BE(4);
    break;
  case 18:
    var hexGroups = [];
    for(var i = 0; i < 8; i++) {
      hexGroups.push(buf.readUInt16BE(i * 2).toString(16));
    }
    var host = ipaddr.parse(hexGroups.join(":")).toString();
    return "[" + host + "]:" + buf.readUInt16BE(16);
  default:
    throw new Error("Invalid Compact IP/PORT, It should contain 6 or 18 bytes");
  }
};

compact2string.multi = function (buf) {
  if(buf.length % 6 !== 0)
    throw new Error("buf length isn't multiple of compact IP/PORTs (6 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 6) {
    output.push(compact2string(buf.slice(i, i + 6)));
  }

  return output;
};

compact2string.multi6 = function (buf) {
  if(buf.length % 18 !== 0)
    throw new Error("buf length isn't multiple of compact IP6/PORTs (18 bytes)");

  var output = [];
  for (var i = 0; i <= buf.length - 1; i = i + 18) {
    output.push(compact2string(buf.slice(i, i + 18)));
  }

  return output;
};

},{"ipaddr.js":70}],30:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],31:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],32:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],33:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":72}],34:[function(require,module,exports){
(function (process,global,Buffer){
module.exports = createTorrent
module.exports.parseInput = parseInput

module.exports.announceList = [
  [ 'udp://tracker.openbittorrent.com:80' ],
  [ 'udp://tracker.internetwarriors.net:1337' ],
  [ 'udp://tracker.leechers-paradise.org:6969' ],
  [ 'udp://tracker.coppersurfer.tk:6969' ],
  [ 'udp://exodus.desync.com:6969' ],
  [ 'wss://tracker.webtorrent.io' ],
  [ 'wss://tracker.btorrent.xyz' ],
  [ 'wss://tracker.openwebtorrent.com' ],
  [ 'wss://tracker.fastcast.nz' ]
]

var bencode = require('bencode')
var BlockStream = require('block-stream2')
var calcPieceLength = require('piece-length')
var corePath = require('path')
var extend = require('xtend')
var FileReadStream = require('filestream/read')
var flatten = require('flatten')
var fs = require('fs')
var isFile = require('is-file')
var junk = require('junk')
var MultiStream = require('multistream')
var once = require('once')
var parallel = require('run-parallel')
var sha1 = require('simple-sha1')
var stream = require('readable-stream')

/**
 * Create a torrent.
 * @param  {string|File|FileList|Buffer|Stream|Array.<string|File|Buffer|Stream>} input
 * @param  {Object} opts
 * @param  {string=} opts.name
 * @param  {Date=} opts.creationDate
 * @param  {string=} opts.comment
 * @param  {string=} opts.createdBy
 * @param  {boolean|number=} opts.private
 * @param  {number=} opts.pieceLength
 * @param  {Array.<Array.<string>>=} opts.announceList
 * @param  {Array.<string>=} opts.urlList
 * @param  {function} cb
 * @return {Buffer} buffer of .torrent file data
 */
function createTorrent (input, opts, cb) {
  if (typeof opts === 'function') return createTorrent(input, null, opts)
  opts = opts ? extend(opts) : {}

  _parseInput(input, opts, function (err, files, singleFileTorrent) {
    if (err) return cb(err)
    opts.singleFileTorrent = singleFileTorrent
    onFiles(files, opts, cb)
  })
}

function parseInput (input, opts, cb) {
  if (typeof opts === 'function') return parseInput(input, null, opts)
  opts = opts ? extend(opts) : {}
  _parseInput(input, opts, cb)
}

/**
 * Parse input file and return file information.
 */
function _parseInput (input, opts, cb) {
  if (Array.isArray(input) && input.length === 0) throw new Error('invalid input type')

  if (isFileList(input)) input = Array.prototype.slice.call(input)
  if (!Array.isArray(input)) input = [ input ]

  // In Electron, use the true file path
  input = input.map(function (item) {
    if (isBlob(item) && typeof item.path === 'string') return item.path
    return item
  })

  // If there's just one file, allow the name to be set by `opts.name`
  if (input.length === 1 && typeof input[0] !== 'string' && !input[0].name) input[0].name = opts.name

  var commonPrefix = null
  input.forEach(function (item, i) {
    if (typeof item === 'string') {
      return
    }

    var path = item.fullPath || item.name
    if (!path) {
      path = 'Unknown File ' + (i + 1)
      item.unknownName = true
    }

    item.path = path.split('/')

    // Remove initial slash
    if (!item.path[0]) {
      item.path.shift()
    }

    if (item.path.length < 2) { // No real prefix
      commonPrefix = null
    } else if (i === 0 && input.length > 1) { // The first file has a prefix
      commonPrefix = item.path[0]
    } else if (item.path[0] !== commonPrefix) { // The prefix doesn't match
      commonPrefix = null
    }
  })

  // remove junk files
  input = input.filter(function (item) {
    if (typeof item === 'string') {
      return true
    }
    var filename = item.path[item.path.length - 1]
    return notHidden(filename) && junk.not(filename)
  })

  if (commonPrefix) {
    input.forEach(function (item) {
      var pathless = (Buffer.isBuffer(item) || isReadable(item)) && !item.path
      if (typeof item === 'string' || pathless) return
      item.path.shift()
    })
  }

  if (!opts.name && commonPrefix) {
    opts.name = commonPrefix
  }

  if (!opts.name) {
    // use first user-set file name
    input.some(function (item) {
      if (typeof item === 'string') {
        opts.name = corePath.basename(item)
        return true
      } else if (!item.unknownName) {
        opts.name = item.path[item.path.length - 1]
        return true
      }
    })
  }

  if (!opts.name) {
    opts.name = 'Unnamed Torrent ' + Date.now()
  }

  var numPaths = input.reduce(function (sum, item) {
    return sum + Number(typeof item === 'string')
  }, 0)

  var isSingleFileTorrent = (input.length === 1)

  if (input.length === 1 && typeof input[0] === 'string') {
    if (typeof fs.stat !== 'function') {
      throw new Error('filesystem paths do not work in the browser')
    }
    // If there's a single path, verify it's a file before deciding this is a single
    // file torrent
    isFile(input[0], function (err, pathIsFile) {
      if (err) return cb(err)
      isSingleFileTorrent = pathIsFile
      processInput()
    })
  } else {
    process.nextTick(function () {
      processInput()
    })
  }

  function processInput () {
    parallel(input.map(function (item) {
      return function (cb) {
        var file = {}

        if (isBlob(item)) {
          file.getStream = getBlobStream(item)
          file.length = item.size
        } else if (Buffer.isBuffer(item)) {
          file.getStream = getBufferStream(item)
          file.length = item.length
        } else if (isReadable(item)) {
          file.getStream = getStreamStream(item, file)
          file.length = 0
        } else if (typeof item === 'string') {
          if (typeof fs.stat !== 'function') {
            throw new Error('filesystem paths do not work in the browser')
          }
          var keepRoot = numPaths > 1 || isSingleFileTorrent
          getFiles(item, keepRoot, cb)
          return // early return!
        } else {
          throw new Error('invalid input type')
        }
        file.path = item.path
        cb(null, file)
      }
    }), function (err, files) {
      if (err) return cb(err)
      files = flatten(files)
      cb(null, files, isSingleFileTorrent)
    })
  }
}

function getFiles (path, keepRoot, cb) {
  traversePath(path, getFileInfo, function (err, files) {
    if (err) return cb(err)

    if (Array.isArray(files)) files = flatten(files)
    else files = [ files ]

    path = corePath.normalize(path)
    if (keepRoot) {
      path = path.slice(0, path.lastIndexOf(corePath.sep) + 1)
    }
    if (path[path.length - 1] !== corePath.sep) path += corePath.sep

    files.forEach(function (file) {
      file.getStream = getFilePathStream(file.path)
      file.path = file.path.replace(path, '').split(corePath.sep)
    })
    cb(null, files)
  })
}

function getFileInfo (path, cb) {
  cb = once(cb)
  fs.stat(path, function (err, stat) {
    if (err) return cb(err)
    var info = {
      length: stat.size,
      path: path
    }
    cb(null, info)
  })
}

function traversePath (path, fn, cb) {
  fs.readdir(path, function (err, entries) {
    if (err && err.code === 'ENOTDIR') {
      // this is a file
      fn(path, cb)
    } else if (err) {
      // real error
      cb(err)
    } else {
      // this is a folder
      parallel(entries.filter(notHidden).filter(junk.not).map(function (entry) {
        return function (cb) {
          traversePath(corePath.join(path, entry), fn, cb)
        }
      }), cb)
    }
  })
}

function notHidden (file) {
  return file[0] !== '.'
}

function getPieceList (files, pieceLength, cb) {
  cb = once(cb)
  var pieces = []
  var length = 0

  var streams = files.map(function (file) {
    return file.getStream
  })

  var remainingHashes = 0
  var pieceNum = 0
  var ended = false

  var multistream = new MultiStream(streams)
  var blockstream = new BlockStream(pieceLength, { zeroPadding: false })

  multistream.on('error', onError)

  multistream
    .pipe(blockstream)
    .on('data', onData)
    .on('end', onEnd)
    .on('error', onError)

  function onData (chunk) {
    length += chunk.length

    var i = pieceNum
    sha1(chunk, function (hash) {
      pieces[i] = hash
      remainingHashes -= 1
      maybeDone()
    })
    remainingHashes += 1
    pieceNum += 1
  }

  function onEnd () {
    ended = true
    maybeDone()
  }

  function onError (err) {
    cleanup()
    cb(err)
  }

  function cleanup () {
    multistream.removeListener('error', onError)
    blockstream.removeListener('data', onData)
    blockstream.removeListener('end', onEnd)
    blockstream.removeListener('error', onError)
  }

  function maybeDone () {
    if (ended && remainingHashes === 0) {
      cleanup()
      cb(null, new Buffer(pieces.join(''), 'hex'), length)
    }
  }
}

function onFiles (files, opts, cb) {
  var announceList = opts.announceList

  if (!announceList) {
    if (typeof opts.announce === 'string') announceList = [ [ opts.announce ] ]
    else if (Array.isArray(opts.announce)) {
      announceList = opts.announce.map(function (u) { return [ u ] })
    }
  }

  if (!announceList) announceList = []

  if (global.WEBTORRENT_ANNOUNCE) {
    if (typeof global.WEBTORRENT_ANNOUNCE === 'string') {
      announceList.push([ [ global.WEBTORRENT_ANNOUNCE ] ])
    } else if (Array.isArray(global.WEBTORRENT_ANNOUNCE)) {
      announceList = announceList.concat(global.WEBTORRENT_ANNOUNCE.map(function (u) {
        return [ u ]
      }))
    }
  }

  // When no trackers specified, use some reasonable defaults
  if (opts.announce === undefined && opts.announceList === undefined) {
    announceList = announceList.concat(module.exports.announceList)
  }

  if (typeof opts.urlList === 'string') opts.urlList = [ opts.urlList ]

  var torrent = {
    info: {
      name: opts.name
    },
    'creation date': Math.ceil((Number(opts.creationDate) || Date.now()) / 1000),
    encoding: 'UTF-8'
  }

  if (announceList.length !== 0) {
    torrent.announce = announceList[0][0]
    torrent['announce-list'] = announceList
  }

  if (opts.comment !== undefined) torrent.comment = opts.comment

  if (opts.createdBy !== undefined) torrent['created by'] = opts.createdBy

  if (opts.private !== undefined) torrent.info.private = Number(opts.private)

  // "ssl-cert" key is for SSL torrents, see:
  //   - http://blog.libtorrent.org/2012/01/bittorrent-over-ssl/
  //   - http://www.libtorrent.org/manual-ref.html#ssl-torrents
  //   - http://www.libtorrent.org/reference-Create_Torrents.html
  if (opts.sslCert !== undefined) torrent.info['ssl-cert'] = opts.sslCert

  if (opts.urlList !== undefined) torrent['url-list'] = opts.urlList

  var pieceLength = opts.pieceLength || calcPieceLength(files.reduce(sumLength, 0))
  torrent.info['piece length'] = pieceLength

  getPieceList(files, pieceLength, function (err, pieces, torrentLength) {
    if (err) return cb(err)
    torrent.info.pieces = pieces

    files.forEach(function (file) {
      delete file.getStream
    })

    if (opts.singleFileTorrent) {
      torrent.info.length = torrentLength
    } else {
      torrent.info.files = files
    }

    cb(null, bencode.encode(torrent))
  })
}

/**
 * Accumulator to sum file lengths
 * @param  {number} sum
 * @param  {Object} file
 * @return {number}
 */
function sumLength (sum, file) {
  return sum + file.length
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

/**
 * Check if `obj` is a W3C `FileList` object
 * @param  {*} obj
 * @return {boolean}
 */
function isFileList (obj) {
  return typeof FileList === 'function' && obj instanceof FileList
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

/**
 * Convert a `File` to a lazy readable stream.
 * @param  {File|Blob} file
 * @return {function}
 */
function getBlobStream (file) {
  return function () {
    return new FileReadStream(file)
  }
}

/**
 * Convert a `Buffer` to a lazy readable stream.
 * @param  {Buffer} buffer
 * @return {function}
 */
function getBufferStream (buffer) {
  return function () {
    var s = new stream.PassThrough()
    s.end(buffer)
    return s
  }
}

/**
 * Convert a file path to a lazy readable stream.
 * @param  {string} path
 * @return {function}
 */
function getFilePathStream (path) {
  return function () {
    return fs.createReadStream(path)
  }
}

/**
 * Convert a readable stream to a lazy readable stream. Adds instrumentation to track
 * the number of bytes in the stream and set `file.length`.
 *
 * @param  {Stream} stream
 * @param  {Object} file
 * @return {function}
 */
function getStreamStream (readable, file) {
  return function () {
    var counter = new stream.Transform()
    counter._transform = function (buf, enc, done) {
      file.length += buf.length
      this.push(buf)
      done()
    }
    readable.pipe(counter)
    return counter
  }
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":102,"bencode":35,"block-stream2":20,"buffer":24,"filestream/read":58,"flatten":59,"fs":22,"is-file":73,"junk":76,"multistream":87,"once":89,"path":99,"piece-length":100,"readable-stream":115,"run-parallel":119,"simple-sha1":125,"xtend":181}],35:[function(require,module,exports){
var bencode = module.exports

bencode.encode = require( './lib/encode' )
bencode.decode = require( './lib/decode' )

/**
 * Determines the amount of bytes
 * needed to encode the given value
 * @param  {Object|Array|Buffer|String|Number|Boolean} value
 * @return {Number} byteCount
 */
bencode.byteLength = bencode.encodingLength = function( value ) {
  return bencode.encode( value ).length
}

},{"./lib/decode":36,"./lib/encode":38}],36:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":37,"buffer":24}],37:[function(require,module,exports){
var Dict = module.exports = function Dict() {
  Object.defineProperty(this, "_keys", {
    enumerable: false,
    value: [],
  })
}

Dict.prototype.binaryKeys = function binaryKeys() {
  return this._keys.slice()
}

Dict.prototype.binarySet = function binarySet(key, value) {
  this._keys.push(key)

  this[key] = value
}

},{}],38:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":24}],39:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":40}],40:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":86}],41:[function(require,module,exports){
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],42:[function(require,module,exports){
var once = require('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback();
	};

	var onend = function() {
		readable = false;
		if (!writable) callback();
	};

	var onexit = function(exitCode) {
		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;
},{"once":89}],43:[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":44}],44:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":45,"engine.io-parser":53}],45:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

  // other options for Node.js client
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }
  }

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function(){
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if('function' == typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' == typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close() {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose() {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade() {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./transport":46,"./transports":47,"component-emitter":31,"debug":39,"engine.io-parser":53,"indexof":68,"parsejson":96,"parseqs":97,"parseuri":98}],46:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":31,"engine.io-parser":53}],47:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling-jsonp":48,"./polling-xhr":49,"./websocket":51,"xmlhttprequest-ssl":52}],48:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  }
  else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":50,"component-inherit":32}],49:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":50,"component-emitter":31,"component-inherit":32,"debug":39,"xmlhttprequest-ssl":52}],50:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

},{"../transport":46,"component-inherit":32,"debug":39,"engine.io-parser":53,"parseqs":97,"xmlhttprequest-ssl":52,"yeast":188}],51:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  try {
    WebSocket = require('ws');
  } catch (e) { }
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }

  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'buffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function(packet) {
      parser.encodePacket(packet, self.supportsBinary, function(data) {
        if (!BrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        //Sometimes the websocket has already been closed but the browser didn't
        //have a chance of informing us about it yet, in that case send will
        //throw an error
        try {
          if (BrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e){
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done(){
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function(){
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../transport":46,"component-inherit":32,"debug":39,"engine.io-parser":53,"parseqs":97,"ws":21,"yeast":188}],52:[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":63}],53:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./keys":54,"after":4,"arraybuffer.slice":5,"base64-arraybuffer":7,"blob":19,"has-binary":55,"utf8":166}],54:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],55:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":56}],56:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],57:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],58:[function(require,module,exports){
var Readable = require('readable-stream').Readable;
var inherits = require('inherits');
var reExtension = /^.*\.(\w+)$/;
var toBuffer = require('typedarray-to-buffer');

function FileReadStream(file, opts) {
  var readStream = this;
  if (! (this instanceof FileReadStream)) {
    return new FileReadStream(file, opts);
  }
  opts = opts || {};

  // inherit readable
  Readable.call(this, opts);

  // save the read offset
  this._offset = 0;
  this._ready = false;
  this._file = file;
  this._size = file.size;
  this._chunkSize = opts.chunkSize || Math.max(this._size / 1000, 200 * 1024);

  // create the reader
  this.reader = new FileReader();

  // generate the header blocks that we will send as part of the initial payload
  this._generateHeaderBlocks(file, opts, function(err, blocks) {
    // if we encountered an error, emit it
    if (err) {
      return readStream.emit('error', err);
    }

    // push the header blocks out to the stream
    if (Array.isArray(blocks)) {
      blocks.forEach(function (block) {
        readStream.push(block);
      });
    }

    readStream._ready = true;
    readStream.emit('_ready');
  });
}

inherits(FileReadStream, Readable);
module.exports = FileReadStream;

FileReadStream.prototype._generateHeaderBlocks = function(file, opts, callback) {
  callback(null, []);
};

FileReadStream.prototype._read = function() {
  if (!this._ready) {
    this.once('_ready', this._read.bind(this));
    return;
  }
  var readStream = this;
  var reader = this.reader;

  var startOffset = this._offset;
  var endOffset = this._offset + this._chunkSize;
  if (endOffset > this._size) endOffset = this._size;

  if (startOffset === this._size) {
    this.destroy();
    this.push(null);
    return;
  }

  reader.onload = function() {
    // update the stream offset
    readStream._offset = endOffset;

    // get the data chunk
    readStream.push(toBuffer(reader.result));
  }
  reader.onerror = function() {
    readStream.emit('error', reader.error);
  }

  reader.readAsArrayBuffer(this._file.slice(startOffset, endOffset));
};

FileReadStream.prototype.destroy = function() {
  this._file = null;
  if (this.reader) {
    this.reader.onload = null;
    this.reader.onerror = null;
    try { this.reader.abort(); } catch (e) {};
  }
  this.reader = null;
}

},{"inherits":69,"readable-stream":115,"typedarray-to-buffer":154}],59:[function(require,module,exports){
module.exports = function flatten(list, depth) {
  depth = (typeof depth == 'number') ? depth : Infinity;

  if (!depth) {
    if (Array.isArray(list)) {
      return list.map(function(i) { return i; });
    }
    return list;
  }

  return _flatten(list, 1);

  function _flatten(list, d) {
    return list.reduce(function (acc, item) {
      if (Array.isArray(item) && d < depth) {
        return acc.concat(_flatten(item, d + 1));
      }
      else {
        return acc.concat(item);
      }
    }, []);
  }
};

},{}],60:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof window === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||
      window.webkitRTCPeerConnection,
    RTCSessionDescription: window.RTCSessionDescription ||
      window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
    RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||
      window.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],61:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":62}],62:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],63:[function(require,module,exports){

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{}],64:[function(require,module,exports){
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};

},{}],65:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":139}],66:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],67:[function(require,module,exports){
(function (process){
module.exports = ImmediateStore

function ImmediateStore (store) {
  if (!(this instanceof ImmediateStore)) return new ImmediateStore(store)

  this.store = store
  this.chunkLength = store.chunkLength

  if (!this.store || !this.store.get || !this.store.put) {
    throw new Error('First argument must be abstract-chunk-store compliant')
  }

  this.mem = []
}

ImmediateStore.prototype.put = function (index, buf, cb) {
  var self = this
  self.mem[index] = buf
  self.store.put(index, buf, function (err) {
    self.mem[index] = null
    if (cb) cb(err)
  })
}

ImmediateStore.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)

  var start = (opts && opts.offset) || 0
  var end = opts && opts.length && (start + opts.length)

  var buf = this.mem[index]
  if (buf) return nextTick(cb, null, opts ? buf.slice(start, end) : buf)

  this.store.get(index, opts, cb)
}

ImmediateStore.prototype.close = function (cb) {
  this.store.close(cb)
}

ImmediateStore.prototype.destroy = function (cb) {
  this.store.destroy(cb)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":102}],68:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],69:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],70:[function(require,module,exports){
(function() {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

  ipaddr = {};

  root = this;

  if ((typeof module !== "undefined" && module !== null) && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function(first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
    var rangeName, rangeSubnets, subnet, _i, _len;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
        subnet = rangeSubnets[_i];
        if (address.match.apply(address, subnet)) {
          return rangeName;
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = (function() {
    function IPv4(octets) {
      var octet, _i, _len;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (_i = 0, _len = octets.length; _i < _len; _i++) {
        octet = octets[_i];
        if (!((0 <= octet && octet <= 255))) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function() {
      return 'ipv4';
    };

    IPv4.prototype.toString = function() {
      return this.octets.join(".");
    };

    IPv4.prototype.toByteArray = function() {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function() {
      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function() {
      var cidr, i, octet, stop, zeros, zerotable, _i;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = _i = 3; _i >= 0; i = _i += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;

  })();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function(string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function(string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return (function() {
        var _i, _len, _ref, _results;
        _ref = match.slice(1, 6);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(parseIntAuto(part));
        }
        return _results;
      })();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return ((function() {
        var _i, _results;
        _results = [];
        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
          _results.push((value >> shift) & 0xff);
        }
        return _results;
      })()).reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = (function() {
    function IPv6(parts) {
      var i, part, _i, _j, _len, _ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = _i = 0; _i <= 14; i = _i += 2) {
          this.parts.push((parts[i] << 8) | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      _ref = this.parts;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        part = _ref[_j];
        if (!((0 <= part && part <= 0xffff))) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
    }

    IPv6.prototype.kind = function() {
      return 'ipv6';
    };

    IPv6.prototype.toString = function() {
      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
      stringParts = (function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this);
      compactStringParts = [];
      pushPart = function(part) {
        return compactStringParts.push(part);
      };
      state = 0;
      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
        part = stringParts[_i];
        switch (state) {
          case 0:
            if (part === '0') {
              pushPart('');
            } else {
              pushPart(part);
            }
            state = 1;
            break;
          case 1:
            if (part === '0') {
              state = 2;
            } else {
              pushPart(part);
            }
            break;
          case 2:
            if (part !== '0') {
              pushPart('');
              pushPart(part);
              state = 3;
            }
            break;
          case 3:
            pushPart(part);
        }
      }
      if (state === 2) {
        pushPart('');
        pushPart('');
      }
      return compactStringParts.join(":");
    };

    IPv6.prototype.toByteArray = function() {
      var bytes, part, _i, _len, _ref;
      bytes = [];
      _ref = this.parts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function() {
      var part;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.parts;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(16));
        }
        return _results;
      }).call(this)).join(":");
    };

    IPv6.prototype.match = function(other, cidrRange) {
      var _ref;
      if (cidrRange === void 0) {
        _ref = other, other = _ref[0], cidrRange = _ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function() {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function() {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function() {
      var high, low, _ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    return IPv6;

  })();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  ipv6Regexes = {
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
  };

  expandIPv6 = function(string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    return (function() {
      var _i, _len, _ref, _results;
      _ref = string.split(":");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        _results.push(parseInt(part, 16));
      }
      return _results;
    })();
  };

  ipaddr.IPv6.parser = function(string) {
    var match, octet, octets, parts, _i, _len;
    if (string.match(ipv6Regexes['native'])) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      parts = expandIPv6(match[1].slice(0, -1), 6);
      if (parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (_i = 0, _len = octets.length; _i < _len; _i++) {
          octet = octets[_i];
          if (!((0 <= octet && octet <= 255))) {
            return null;
          }
        }
        parts.push(octets[0] << 8 | octets[1]);
        parts.push(octets[2] << 8 | octets[3]);
        return parts;
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function(string) {
    var e;
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function(string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^\d+(\.\d+){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function(string) {
    var e;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      new this(this.parser(string));
      return true;
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv4.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv6.parseCIDR = function(string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function(string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function(string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function(string) {
    var e;
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (_error) {
      e = _error;
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (_error) {
        e = _error;
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function(bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function(string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };

}).call(this);

},{}],71:[function(require,module,exports){
/* (c) 2016 Ari Porad (@ariporad) <http://ariporad.com>. License: ariporad.mit-license.org */

// Partially from http://stackoverflow.com/a/94049/1928484, and from another SO answer, which told me that the highest
// char code that's ascii is 127, but I can't find the link for. Sorry.

var MAX_ASCII_CHAR_CODE = 127;

module.exports = function isAscii(str) {
  for (var i = 0, strLen = str.length; i < strLen; ++i) {
    if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE) return false;
  }
  return true;
};

},{}],72:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],73:[function(require,module,exports){
'use strict';

var fs = require('fs');

module.exports = function isFile(path, cb){
  if(!cb)return isFileSync(path);

  fs.stat(path, function(err, stats){
    if(err)return cb(err);
    return cb(null, stats.isFile());
  });
};

module.exports.sync = isFileSync;

function isFileSync(path){
  return fs.existsSync(path) && fs.statSync(path).isFile();
}

},{"fs":22}],74:[function(require,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],75:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],76:[function(require,module,exports){
'use strict';

// // All
// /^npm-debug\.log$/,   // npm error log
// /^\..*\.swp$/,        // vim state
// // macOS
// /^\.DS_Store$/,       // stores custom folder attributes
// /^\.AppleDouble$/,    // stores additional file resources
// /^\.LSOverride$/,     // contains the absolute path to the app to be used
// /^Icon\r$/,           // custom Finder icon: http://superuser.com/questions/298785/icon-file-on-os-x-desktop
// /^\._.*/,             // thumbnail
// /^\.Spotlight-V100$/,  // file that might appear on external disk
// /\.Trashes/,          // file that might appear on external disk
// /^__MACOSX$/,         // resource fork
// // Linux
// /~$/,                 // backup file
// // Windows
// /^Thumbs\.db$/,       // image file cache
// /^ehthumbs\.db$/,     // folder config file
// /^Desktop\.ini$/      // stores custom folder attributes

exports.re = /^npm-debug\.log$|^\..*\.swp$|^\.DS_Store$|^\.AppleDouble$|^\.LSOverride$|^Icon\r$|^\._.*|^\.Spotlight-V100$|\.Trashes|^__MACOSX$|~$|^Thumbs\.db$|^ehthumbs\.db$|^Desktop\.ini$/;

exports.is = function (filename) {
	return exports.re.test(filename);
};

exports.not = exports.isnt = function (filename) {
	return !exports.is(filename);
};

},{}],77:[function(require,module,exports){
(function (Buffer){
module.exports = magnetURIDecode
module.exports.decode = magnetURIDecode
module.exports.encode = magnetURIEncode

var base32 = require('thirty-two')
var extend = require('xtend')
var uniq = require('uniq')

/**
 * Parse a magnet URI and return an object of keys/values
 *
 * @param  {string} uri
 * @return {Object} parsed uri
 */
function magnetURIDecode (uri) {
  var result = {}

  // Support 'magnet:' and 'stream-magnet:' uris
  var data = uri.split('magnet:?')[1]

  var params = (data && data.length >= 0)
    ? data.split('&')
    : []

  params.forEach(function (param) {
    var keyval = param.split('=')

    // This keyval is invalid, skip it
    if (keyval.length !== 2) return

    var key = keyval[0]
    var val = keyval[1]

    // Clean up torrent name
    if (key === 'dn') val = decodeURIComponent(val).replace(/\+/g, ' ')

    // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded
    // URIs, so decode them
    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
      val = decodeURIComponent(val)
    }

    // Return keywords as an array
    if (key === 'kt') val = decodeURIComponent(val).split('+')

    // If there are repeated parameters, return an array of values
    if (result[key]) {
      if (Array.isArray(result[key])) {
        result[key].push(val)
      } else {
        var old = result[key]
        result[key] = [old, val]
      }
    } else {
      result[key] = val
    }
  })

  // Convenience properties for parity with `parse-torrent-file` module
  var m
  if (result.xt) {
    var xts = Array.isArray(result.xt) ? result.xt : [ result.xt ]
    xts.forEach(function (xt) {
      if ((m = xt.match(/^urn:btih:(.{40})/))) {
        result.infoHash = m[1].toLowerCase()
      } else if ((m = xt.match(/^urn:btih:(.{32})/))) {
        var decodedStr = base32.decode(m[1])
        result.infoHash = new Buffer(decodedStr, 'binary').toString('hex')
      }
    })
  }
  if (result.infoHash) result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  if (result.dn) result.name = result.dn
  if (result.kt) result.keywords = result.kt

  if (typeof result.tr === 'string') result.announce = [ result.tr ]
  else if (Array.isArray(result.tr)) result.announce = result.tr
  else result.announce = []

  result.urlList = []
  if (typeof result.as === 'string' || Array.isArray(result.as)) {
    result.urlList = result.urlList.concat(result.as)
  }
  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {
    result.urlList = result.urlList.concat(result.ws)
  }

  uniq(result.announce)
  uniq(result.urlList)

  return result
}

function magnetURIEncode (obj) {
  obj = extend(obj) // clone obj, so we can mutate it

  // support using convenience names, in addition to spec names
  // (example: `infoHash` for `xt`, `name` for `dn`)
  if (obj.infoHashBuffer) obj.xt = 'urn:btih:' + obj.infoHashBuffer.toString('hex')
  if (obj.infoHash) obj.xt = 'urn:btih:' + obj.infoHash
  if (obj.name) obj.dn = obj.name
  if (obj.keywords) obj.kt = obj.keywords
  if (obj.announce) obj.tr = obj.announce
  if (obj.urlList) {
    obj.ws = obj.urlList
    delete obj.as
  }

  var result = 'magnet:?'
  Object.keys(obj)
    .filter(function (key) {
      return key.length === 2
    })
    .forEach(function (key, i) {
      var values = Array.isArray(obj[key]) ? obj[key] : [ obj[key] ]
      values.forEach(function (val, j) {
        if ((i > 0 || j > 0) && (key !== 'kt' || j === 0)) result += '&'

        if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+')
        if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {
          val = encodeURIComponent(val)
        }
        if (key === 'kt') val = encodeURIComponent(val)

        if (key === 'kt' && j > 0) result += '+' + val
        else result += key + '=' + val
      })
    })

  return result
}

}).call(this,require("buffer").Buffer)

},{"buffer":24,"thirty-two":148,"uniq":156,"xtend":181}],78:[function(require,module,exports){
module.exports = MediaElementWrapper

var inherits = require('inherits')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var MediaSource = typeof window !== 'undefined' && window.MediaSource

var DEFAULT_BUFFER_DURATION = 60 // seconds

function MediaElementWrapper (elem, opts) {
  var self = this
  if (!(self instanceof MediaElementWrapper)) return new MediaElementWrapper(elem, opts)

  if (!MediaSource) throw new Error('web browser lacks MediaSource support')

  if (!opts) opts = {}
  self._bufferDuration = opts.bufferDuration || DEFAULT_BUFFER_DURATION
  self._elem = elem
  self._mediaSource = new MediaSource()
  self._streams = []
  self.detailedError = null

  self._errorHandler = function () {
    self._elem.removeEventListener('error', self._errorHandler)
    var streams = self._streams.slice()
    streams.forEach(function (stream) {
      stream.destroy(self._elem.error)
    })
  }
  self._elem.addEventListener('error', self._errorHandler)

  self._elem.src = window.URL.createObjectURL(self._mediaSource)
}

/*
 * `obj` can be a previous value returned by this function
 * or a string
 */
MediaElementWrapper.prototype.createWriteStream = function (obj) {
  var self = this

  return new MediaSourceStream(self, obj)
}

/*
 * Use to trigger an error on the underlying media element
 */
MediaElementWrapper.prototype.error = function (err) {
  var self = this

  // be careful not to overwrite any existing detailedError values
  if (!self.detailedError) {
    self.detailedError = err
  }
  try {
    self._mediaSource.endOfStream('decode')
  } catch (err) {}
}

inherits(MediaSourceStream, stream.Writable)

function MediaSourceStream (wrapper, obj) {
  var self = this
  stream.Writable.call(self)

  self._wrapper = wrapper
  self._elem = wrapper._elem
  self._mediaSource = wrapper._mediaSource
  self._allStreams = wrapper._streams
  self._allStreams.push(self)
  self._bufferDuration = wrapper._bufferDuration
  self._sourceBuffer = null

  self._openHandler = function () {
    self._onSourceOpen()
  }
  self._flowHandler = function () {
    self._flow()
  }

  if (typeof obj === 'string') {
    self._type = obj
    // Need to create a new sourceBuffer
    if (self._mediaSource.readyState === 'open') {
      self._createSourceBuffer()
    } else {
      self._mediaSource.addEventListener('sourceopen', self._openHandler)
    }
  } else if (obj._sourceBuffer === null) {
    obj.destroy()
    self._type = obj._type // The old stream was created but hasn't finished initializing
    self._mediaSource.addEventListener('sourceopen', self._openHandler)
  } else if (obj._sourceBuffer) {
    obj.destroy()
    self._type = obj._type
    self._sourceBuffer = obj._sourceBuffer // Copy over the old sourceBuffer
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
  } else {
    throw new Error('The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function')
  }

  self._elem.addEventListener('timeupdate', self._flowHandler)

  self.on('error', function (err) {
    self._wrapper.error(err)
  })

  self.on('finish', function () {
    if (self.destroyed) return
    self._finished = true
    if (self._allStreams.every(function (other) { return other._finished })) {
      try {
        self._mediaSource.endOfStream()
      } catch (err) {}
    }
  })
}

MediaSourceStream.prototype._onSourceOpen = function () {
  var self = this
  if (self.destroyed) return

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._createSourceBuffer()
}

MediaSourceStream.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  // Remove from allStreams
  self._allStreams.splice(self._allStreams.indexOf(self), 1)

  self._mediaSource.removeEventListener('sourceopen', self._openHandler)
  self._elem.removeEventListener('timeupdate', self._flowHandler)
  if (self._sourceBuffer) {
    self._sourceBuffer.removeEventListener('updateend', self._flowHandler)
    if (self._mediaSource.readyState === 'open') {
      self._sourceBuffer.abort()
    }
  }

  if (err) self.emit('error', err)
  self.emit('close')
}

MediaSourceStream.prototype._createSourceBuffer = function () {
  var self = this
  if (self.destroyed) return

  if (MediaSource.isTypeSupported(self._type)) {
    self._sourceBuffer = self._mediaSource.addSourceBuffer(self._type)
    self._sourceBuffer.addEventListener('updateend', self._flowHandler)
    if (self._cb) {
      var cb = self._cb
      self._cb = null
      cb()
    }
  } else {
    self.destroy(new Error('The provided type is not supported'))
  }
}

MediaSourceStream.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return
  if (!self._sourceBuffer) {
    self._cb = function (err) {
      if (err) return cb(err)
      self._write(chunk, encoding, cb)
    }
    return
  }

  if (self._sourceBuffer.updating) {
    return cb(new Error('Cannot append buffer while source buffer updating'))
  }

  try {
    self._sourceBuffer.appendBuffer(toArrayBuffer(chunk))
  } catch (err) {
    // appendBuffer can throw for a number of reasons, most notably when the data
    // being appended is invalid or if appendBuffer is called after another error
    // already occurred on the media element. In Chrome, there may be useful debugging
    // info in chrome://media-internals
    self.destroy(err)
    return
  }
  self._cb = cb
}

MediaSourceStream.prototype._flow = function () {
  var self = this

  if (self.destroyed || !self._sourceBuffer || self._sourceBuffer.updating) {
    return
  }

  if (self._mediaSource.readyState === 'open') {
    // check buffer size
    if (self._getBufferDuration() > self._bufferDuration) {
      return
    }
  }

  if (self._cb) {
    var cb = self._cb
    self._cb = null
    cb()
  }
}

// TODO: if zero actually works in all browsers, remove the logic associated with this below
var EPSILON = 0

MediaSourceStream.prototype._getBufferDuration = function () {
  var self = this

  var buffered = self._sourceBuffer.buffered
  var currentTime = self._elem.currentTime
  var bufferEnd = -1 // end of the buffer
  // This is a little over complex because some browsers seem to separate the
  // buffered region into multiple sections with slight gaps.
  for (var i = 0; i < buffered.length; i++) {
    var start = buffered.start(i)
    var end = buffered.end(i) + EPSILON

    if (start > currentTime) {
      // Reached past the joined buffer
      break
    } else if (bufferEnd >= 0 || currentTime <= end) {
      // Found the start/continuation of the joined buffer
      bufferEnd = end
    }
  }

  var bufferedTime = bufferEnd - currentTime
  if (bufferedTime < 0) {
    bufferedTime = 0
  }

  return bufferedTime
}

},{"inherits":69,"readable-stream":115,"to-arraybuffer":151}],79:[function(require,module,exports){
(function (process){
module.exports = Storage

function Storage (chunkLength, opts) {
  if (!(this instanceof Storage)) return new Storage(chunkLength, opts)
  if (!opts) opts = {}

  this.chunkLength = Number(chunkLength)
  if (!this.chunkLength) throw new Error('First argument must be a chunk length')

  this.chunks = []
  this.closed = false
  this.length = Number(opts.length) || Infinity

  if (this.length !== Infinity) {
    this.lastChunkLength = (this.length % this.chunkLength) || this.chunkLength
    this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1
  }
}

Storage.prototype.put = function (index, buf, cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))

  var isLastChunk = (index === this.lastChunkIndex)
  if (isLastChunk && buf.length !== this.lastChunkLength) {
    return nextTick(cb, new Error('Last chunk length must be ' + this.lastChunkLength))
  }
  if (!isLastChunk && buf.length !== this.chunkLength) {
    return nextTick(cb, new Error('Chunk length must be ' + this.chunkLength))
  }
  this.chunks[index] = buf
  nextTick(cb, null)
}

Storage.prototype.get = function (index, opts, cb) {
  if (typeof opts === 'function') return this.get(index, null, opts)
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  var buf = this.chunks[index]
  if (!buf) return nextTick(cb, new Error('Chunk not found'))
  if (!opts) return nextTick(cb, null, buf)
  var offset = opts.offset || 0
  var len = opts.length || (buf.length - offset)
  nextTick(cb, null, buf.slice(offset, len + offset))
}

Storage.prototype.close = Storage.prototype.destroy = function (cb) {
  if (this.closed) return nextTick(cb, new Error('Storage is closed'))
  this.closed = true
  this.chunks = null
  nextTick(cb, null)
}

function nextTick (cb, err, val) {
  process.nextTick(function () {
    if (cb) cb(err, val)
  })
}

}).call(this,require('_process'))

},{"_process":102}],80:[function(require,module,exports){
(function (Buffer){
// This is an intentionally recursive require. I don't like it either.
var Box = require('./index')
var Descriptor = require('./descriptor')

var TIME_OFFSET = 2082844800000

/*
TODO:
test these
add new box versions
*/

// These have 'version' and 'flags' fields in the headers
exports.fullBoxes = {}
var fullBoxes = [
  'mvhd',
  'tkhd',
  'mdhd',
  'vmhd',
  'smhd',
  'stsd',
  'esds',
  'stsz',
  'stco',
  'stss',
  'stts',
  'ctts',
  'stsc',
  'dref',
  'elst',
  'hdlr',
  'mehd',
  'trex',
  'mfhd',
  'tfhd',
  'tfdt',
  'trun'
]
fullBoxes.forEach(function (type) {
  exports.fullBoxes[type] = true
})

exports.ftyp = {}
exports.ftyp.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.ftyp.encodingLength(box))
  var brands = box.compatibleBrands || []
  buf.write(box.brand, 0, 4, 'ascii')
  buf.writeUInt32BE(box.brandVersion, 4)
  for (var i = 0; i < brands.length; i++) buf.write(brands[i], 8 + (i * 4), 4, 'ascii')
  exports.ftyp.encode.bytes = 8 + brands.length * 4
  return buf
}
exports.ftyp.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var brand = buf.toString('ascii', 0, 4)
  var version = buf.readUInt32BE(4)
  var compatibleBrands = []
  for (var i = 8; i < buf.length; i += 4) compatibleBrands.push(buf.toString('ascii', i, i + 4))
  return {
    brand: brand,
    brandVersion: version,
    compatibleBrands: compatibleBrands
  }
}
exports.ftyp.encodingLength = function (box) {
  return 8 + (box.compatibleBrands || []).length * 4
}

exports.mvhd = {}
exports.mvhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(96)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  writeFixed32(box.preferredRate || 0, buf, 16)
  writeFixed16(box.preferredVolume || 0, buf, 20)
  writeReserved(buf, 22, 32)
  writeMatrix(box.matrix, buf, 32)
  buf.writeUInt32BE(box.previewTime || 0, 68)
  buf.writeUInt32BE(box.previewDuration || 0, 72)
  buf.writeUInt32BE(box.posterTime || 0, 76)
  buf.writeUInt32BE(box.selectionTime || 0, 80)
  buf.writeUInt32BE(box.selectionDuration || 0, 84)
  buf.writeUInt32BE(box.currentTime || 0, 88)
  buf.writeUInt32BE(box.nextTrackId || 0, 92)
  exports.mvhd.encode.bytes = 96
  return buf
}
exports.mvhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    preferredRate: readFixed32(buf, 16),
    preferredVolume: readFixed16(buf, 20),
    matrix: readMatrix(buf.slice(32, 68)),
    previewTime: buf.readUInt32BE(68),
    previewDuration: buf.readUInt32BE(72),
    posterTime: buf.readUInt32BE(76),
    selectionTime: buf.readUInt32BE(80),
    selectionDuration: buf.readUInt32BE(84),
    currentTime: buf.readUInt32BE(88),
    nextTrackId: buf.readUInt32BE(92)
  }
}
exports.mvhd.encodingLength = function (box) {
  return 96
}

exports.tkhd = {}
exports.tkhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(80)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.trackId || 0, 8)
  writeReserved(buf, 12, 16)
  buf.writeUInt32BE(box.duration || 0, 16)
  writeReserved(buf, 20, 28)
  buf.writeUInt16BE(box.layer || 0, 28)
  buf.writeUInt16BE(box.alternateGroup || 0, 30)
  buf.writeUInt16BE(box.volume || 0, 32)
  writeMatrix(box.matrix, buf, 36)
  buf.writeUInt32BE(box.trackWidth || 0, 72)
  buf.writeUInt32BE(box.trackHeight || 0, 76)
  exports.tkhd.encode.bytes = 80
  return buf
}
exports.tkhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    trackId: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(16),
    layer: buf.readUInt16BE(28),
    alternateGroup: buf.readUInt16BE(30),
    volume: buf.readUInt16BE(32),
    matrix: readMatrix(buf.slice(36, 72)),
    trackWidth: buf.readUInt32BE(72),
    trackHeight: buf.readUInt32BE(76)
  }
}
exports.tkhd.encodingLength = function (box) {
  return 80
}

exports.mdhd = {}
exports.mdhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)
  writeDate(box.ctime || new Date(), buf, 0)
  writeDate(box.mtime || new Date(), buf, 4)
  buf.writeUInt32BE(box.timeScale || 0, 8)
  buf.writeUInt32BE(box.duration || 0, 12)
  buf.writeUInt16BE(box.language || 0, 16)
  buf.writeUInt16BE(box.quality || 0, 18)
  exports.mdhd.encode.bytes = 20
  return buf
}
exports.mdhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    ctime: readDate(buf, 0),
    mtime: readDate(buf, 4),
    timeScale: buf.readUInt32BE(8),
    duration: buf.readUInt32BE(12),
    language: buf.readUInt16BE(16),
    quality: buf.readUInt16BE(18)
  }
}
exports.mdhd.encodingLength = function (box) {
  return 20
}

exports.vmhd = {}
exports.vmhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8)
  buf.writeUInt16BE(box.graphicsMode || 0, 0)
  var opcolor = box.opcolor || [0, 0, 0]
  buf.writeUInt16BE(opcolor[0], 2)
  buf.writeUInt16BE(opcolor[1], 4)
  buf.writeUInt16BE(opcolor[2], 6)
  exports.vmhd.encode.bytes = 8
  return buf
}
exports.vmhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    graphicsMode: buf.readUInt16BE(0),
    opcolor: [buf.readUInt16BE(2), buf.readUInt16BE(4), buf.readUInt16BE(6)]
  }
}
exports.vmhd.encodingLength = function (box) {
  return 8
}

exports.smhd = {}
exports.smhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt16BE(box.balance || 0, 0)
  writeReserved(buf, 2, 4)
  exports.smhd.encode.bytes = 4
  return buf
}
exports.smhd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    balance: buf.readUInt16BE(0)
  }
}
exports.smhd.encodingLength = function (box) {
  return 4
}

exports.stsd = {}
exports.stsd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsd.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    Box.encode(entry, buf, ptr)
    ptr += Box.encode.bytes
  }

  exports.stsd.encode.bytes = ptr
  return buf
}
exports.stsd.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var entry = Box.decode(buf, ptr, end)
    entries[i] = entry
    ptr += entry.length
  }

  return {
    entries: entries
  }
}
exports.stsd.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    totalSize += Box.encodingLength(box.entries[i])
  }
  return totalSize
}

exports.avc1 = exports.VisualSampleEntry = {}
exports.VisualSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.VisualSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 24)
  buf.writeUInt16BE(box.width || 0, 24)
  buf.writeUInt16BE(box.height || 0, 26)
  buf.writeUInt32BE(box.hResolution || 0x480000, 28)
  buf.writeUInt32BE(box.vResolution || 0x480000, 32)
  writeReserved(buf, 36, 40)
  buf.writeUInt16BE(box.frameCount || 1, 40)
  var compressorName = box.compressorName || ''
  var nameLen = Math.min(compressorName.length, 31)
  buf.writeUInt8(nameLen, 42)
  buf.write(compressorName, 43, nameLen, 'utf8')
  buf.writeUInt16BE(box.depth || 0x18, 74)
  buf.writeInt16BE(-1, 76)

  var ptr = 78
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.VisualSampleEntry.encode.bytes = ptr
}
exports.VisualSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  var length = end - offset
  var nameLen = Math.min(buf.readUInt8(42), 31)
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    width: buf.readUInt16BE(24),
    height: buf.readUInt16BE(26),
    hResolution: buf.readUInt32BE(28),
    vResolution: buf.readUInt32BE(32),
    frameCount: buf.readUInt16BE(40),
    compressorName: buf.toString('utf8', 43, 43 + nameLen),
    depth: buf.readUInt16BE(74),
    children: []
  }

  var ptr = 78
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.VisualSampleEntry.encodingLength = function (box) {
  var len = 78
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.avcC = {}
exports.avcC.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf)
  exports.avcC.encode.bytes = box.buffer.length
}
exports.avcC.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  return {
    mimeCodec: buf.toString('hex', 1, 4),
    buffer: new Buffer(buf)
  }
}
exports.avcC.encodingLength = function (box) {
  return box.buffer.length
}

exports.mp4a = exports.AudioSampleEntry = {}
exports.AudioSampleEntry.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.AudioSampleEntry.encodingLength(box))

  writeReserved(buf, 0, 6)
  buf.writeUInt16BE(box.dataReferenceIndex || 0, 6)
  writeReserved(buf, 8, 16)
  buf.writeUInt16BE(box.channelCount || 2, 16)
  buf.writeUInt16BE(box.sampleSize || 16, 18)
  writeReserved(buf, 20, 24)
  buf.writeUInt32BE(box.sampleRate || 0, 24)

  var ptr = 28
  var children = box.children || []
  children.forEach(function (child) {
    Box.encode(child, buf, ptr)
    ptr += Box.encode.bytes
  })
  exports.AudioSampleEntry.encode.bytes = ptr
}
exports.AudioSampleEntry.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)
  var length = end - offset
  var box = {
    dataReferenceIndex: buf.readUInt16BE(6),
    channelCount: buf.readUInt16BE(16),
    sampleSize: buf.readUInt16BE(18),
    sampleRate: buf.readUInt32BE(24),
    children: []
  }

  var ptr = 28
  while (length - ptr >= 8) {
    var child = Box.decode(buf, ptr, length)
    box.children.push(child)
    box[child.type] = child
    ptr += child.length
  }

  return box
}
exports.AudioSampleEntry.encodingLength = function (box) {
  var len = 28
  var children = box.children || []
  children.forEach(function (child) {
    len += Box.encodingLength(child)
  })
  return len
}

exports.esds = {}
exports.esds.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : Buffer(box.buffer.length)

  box.buffer.copy(buf, 0)
  exports.esds.encode.bytes = box.buffer.length
}
exports.esds.decode = function (buf, offset, end) {
  buf = buf.slice(offset, end)

  var desc = Descriptor.Descriptor.decode(buf, 0, buf.length)
  var esd = (desc.tagName === 'ESDescriptor') ? desc : {}
  var dcd = esd.DecoderConfigDescriptor || {}
  var oti = dcd.oti || 0
  var dsi = dcd.DecoderSpecificInfo
  var audioConfig = dsi ? (dsi.buffer.readUInt8(0) & 0xf8) >> 3 : 0

  var mimeCodec = null
  if (oti) {
    mimeCodec = oti.toString(16)
    if (audioConfig) {
      mimeCodec += '.' + audioConfig
    }
  }

  return {
    mimeCodec: mimeCodec,
    buffer: new Buffer(buf.slice(0))
  }
}
exports.esds.encodingLength = function (box) {
  return box.buffer.length
}

// TODO: integrate the two versions in a saner way
exports.stsz = {}
exports.stsz.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : Buffer(exports.stsz.encodingLength(box))

  buf.writeUInt32BE(0, 0)
  buf.writeUInt32BE(entries.length, 4)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 8)
  }

  exports.stsz.encode.bytes = 8 + entries.length * 4
  return buf
}
exports.stsz.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var size = buf.readUInt32BE(0)
  var num = buf.readUInt32BE(4)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    if (size === 0) {
      entries[i] = buf.readUInt32BE(i * 4 + 8)
    } else {
      entries[i] = size
    }
  }

  return {
    entries: entries
  }
}
exports.stsz.encodingLength = function (box) {
  return 8 + box.entries.length * 4
}

exports.stss =
exports.stco = {}
exports.stco.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stco.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    buf.writeUInt32BE(entries[i], i * 4 + 4)
  }

  exports.stco.encode.bytes = 4 + entries.length * 4
  return buf
}
exports.stco.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    entries[i] = buf.readUInt32BE(i * 4 + 4)
  }

  return {
    entries: entries
  }
}
exports.stco.encodingLength = function (box) {
  return 4 + box.entries.length * 4
}

exports.stts = {}
exports.stts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].duration || 0, ptr + 4)
  }

  exports.stts.encode.bytes = 4 + box.entries.length * 8
  return buf
}
exports.stts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      duration: buf.readUInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.stts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.ctts = {}
exports.ctts.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.ctts.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 8 + 4
    buf.writeUInt32BE(entries[i].count || 0, ptr)
    buf.writeUInt32BE(entries[i].compositionOffset || 0, ptr + 4)
  }

  exports.ctts.encode.bytes = 4 + entries.length * 8
  return buf
}
exports.ctts.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 8 + 4
    entries[i] = {
      count: buf.readUInt32BE(ptr),
      compositionOffset: buf.readInt32BE(ptr + 4)
    }
  }

  return {
    entries: entries
  }
}
exports.ctts.encodingLength = function (box) {
  return 4 + box.entries.length * 8
}

exports.stsc = {}
exports.stsc.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.stsc.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].firstChunk || 0, ptr)
    buf.writeUInt32BE(entries[i].samplesPerChunk || 0, ptr + 4)
    buf.writeUInt32BE(entries[i].sampleDescriptionId || 0, ptr + 8)
  }

  exports.stsc.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.stsc.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      firstChunk: buf.readUInt32BE(ptr),
      samplesPerChunk: buf.readUInt32BE(ptr + 4),
      sampleDescriptionId: buf.readUInt32BE(ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.stsc.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.dref = {}
exports.dref.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.dref.encodingLength(box))
  var entries = box.entries || []

  buf.writeUInt32BE(entries.length, 0)

  var ptr = 4
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i]
    var size = (entry.buf ? entry.buf.length : 0) + 4 + 4

    buf.writeUInt32BE(size, ptr)
    ptr += 4

    buf.write(entry.type, ptr, 4, 'ascii')
    ptr += 4

    if (entry.buf) {
      entry.buf.copy(buf, ptr)
      ptr += entry.buf.length
    }
  }

  exports.dref.encode.bytes = ptr
  return buf
}
exports.dref.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)
  var ptr = 4

  for (var i = 0; i < num; i++) {
    var size = buf.readUInt32BE(ptr)
    var type = buf.toString('ascii', ptr + 4, ptr + 8)
    var tmp = buf.slice(ptr + 8, ptr + size)
    ptr += size

    entries[i] = {
      type: type,
      buf: tmp
    }
  }

  return {
    entries: entries
  }
}
exports.dref.encodingLength = function (box) {
  var totalSize = 4
  if (!box.entries) return totalSize
  for (var i = 0; i < box.entries.length; i++) {
    var buf = box.entries[i].buf
    totalSize += (buf ? buf.length : 0) + 4 + 4
  }
  return totalSize
}

exports.elst = {}
exports.elst.encode = function (box, buf, offset) {
  var entries = box.entries || []
  buf = buf ? buf.slice(offset) : new Buffer(exports.elst.encodingLength(box))

  buf.writeUInt32BE(entries.length, 0)

  for (var i = 0; i < entries.length; i++) {
    var ptr = i * 12 + 4
    buf.writeUInt32BE(entries[i].trackDuration || 0, ptr)
    buf.writeUInt32BE(entries[i].mediaTime || 0, ptr + 4)
    writeFixed32(entries[i].mediaRate || 0, buf, ptr + 8)
  }

  exports.elst.encode.bytes = 4 + entries.length * 12
  return buf
}
exports.elst.decode = function (buf, offset) {
  buf = buf.slice(offset)
  var num = buf.readUInt32BE(0)
  var entries = new Array(num)

  for (var i = 0; i < num; i++) {
    var ptr = i * 12 + 4
    entries[i] = {
      trackDuration: buf.readUInt32BE(ptr),
      mediaTime: buf.readInt32BE(ptr + 4),
      mediaRate: readFixed32(buf, ptr + 8)
    }
  }

  return {
    entries: entries
  }
}
exports.elst.encodingLength = function (box) {
  return 4 + box.entries.length * 12
}

exports.hdlr = {}
exports.hdlr.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(exports.hdlr.encodingLength(box))

  var len = 21 + (box.name || '').length
  buf.fill(0, 0, len)

  buf.write(box.handlerType || '', 4, 4, 'ascii')
  writeString(box.name || '', buf, 20)

  exports.hdlr.encode.bytes = len
  return buf
}
exports.hdlr.decode = function (buf, offset, end) {
  buf = buf.slice(offset)
  return {
    handlerType: buf.toString('ascii', 4, 8),
    name: readString(buf, 20, end)
  }
}
exports.hdlr.encodingLength = function (box) {
  return 21 + (box.name || '').length
}

exports.mehd = {}
exports.mehd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.fragmentDuration || 0, 0)
  exports.mehd.encode.bytes = 4
  return buf
}
exports.mehd.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    fragmentDuration: buf.readUInt32BE(0)
  }
}
exports.mehd.encodingLength = function (box) {
  return 4
}

exports.trex = {}
exports.trex.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(20)

  buf.writeUInt32BE(box.trackId || 0, 0)
  buf.writeUInt32BE(box.defaultSampleDescriptionIndex || 0, 4)
  buf.writeUInt32BE(box.defaultSampleDuration || 0, 8)
  buf.writeUInt32BE(box.defaultSampleSize || 0, 12)
  buf.writeUInt32BE(box.defaultSampleFlags || 0, 16)
  exports.trex.encode.bytes = 20
  return buf
}
exports.trex.decode = function (buf, offset) {
  buf = buf.slice(offset)
  return {
    trackId: buf.readUInt32BE(0),
    defaultSampleDescriptionIndex: buf.readUInt32BE(4),
    defaultSampleDuration: buf.readUInt32BE(8),
    defaultSampleSize: buf.readUInt32BE(12),
    defaultSampleFlags: buf.readUInt32BE(16)
  }
}
exports.trex.encodingLength = function (box) {
  return 20
}

exports.mfhd = {}
exports.mfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.sequenceNumber || 0, 0)
  exports.mfhd.encode.bytes = 4
  return buf
}
exports.mfhd.decode = function (buf, offset) {
  return {
    sequenceNumber: buf.readUint32BE(0)
  }
}
exports.mfhd.encodingLength = function (box) {
  return 4
}

exports.tfhd = {}
exports.tfhd.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)
  buf.writeUInt32BE(box.trackId, 0)
  exports.tfhd.encode.bytes = 4
  return buf
}
exports.tfhd.decode = function (buf, offset) {
  // TODO: this
}
exports.tfhd.encodingLength = function (box) {
  // TODO: this is wrong!
  return 4
}

exports.tfdt = {}
exports.tfdt.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(4)

  buf.writeUInt32BE(box.baseMediaDecodeTime || 0, 0)
  exports.tfdt.encode.bytes = 4
  return buf
}
exports.tfdt.decode = function (buf, offset) {
  // TODO: this
}
exports.tfdt.encodingLength = function (box) {
  return 4
}

exports.trun = {}
exports.trun.encode = function (box, buf, offset) {
  buf = buf ? buf.slice(offset) : new Buffer(8 + box.entries.length * 16)

  // TODO: this is wrong
  buf.writeUInt32BE(box.entries.length, 0)
  buf.writeInt32BE(box.dataOffset, 4)
  var ptr = 8
  for (var i = 0; i < box.entries.length; i++) {
    var entry = box.entries[i]
    buf.writeUInt32BE(entry.sampleDuration, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleSize, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleFlags, ptr)
    ptr += 4

    buf.writeUInt32BE(entry.sampleCompositionTimeOffset, ptr)
    ptr += 4
  }
  exports.trun.encode.bytes = ptr
}
exports.trun.decode = function (buf, offset) {
  // TODO: this
}
exports.trun.encodingLength = function (box) {
  // TODO: this is wrong
  return 8 + box.entries.length * 16
}

exports.mdat = {}
exports.mdat.encode = function (box, buf, offset) {
  if (box.buffer) {
    box.buffer.copy(buf, offset)
    exports.mdat.encode.bytes = box.buffer.length
  } else {
    exports.mdat.encode.bytes = exports.mdat.encodingLength(box)
  }
}
exports.mdat.decode = function (buf, start, end) {
  return {
    buffer: new Buffer(buf.slice(start, end))
  }
}
exports.mdat.encodingLength = function (box) {
  return box.buffer ? box.buffer.length : box.contentLength
}

function writeReserved (buf, offset, end) {
  for (var i = offset; i < end; i++) buf[i] = 0
}

function writeDate (date, buf, offset) {
  buf.writeUInt32BE(Math.floor((date.getTime() + TIME_OFFSET) / 1000), offset)
}

// TODO: think something is wrong here
function writeFixed32 (num, buf, offset) {
  buf.writeUInt16BE(Math.floor(num) % (256 * 256), offset)
  buf.writeUInt16BE(Math.floor(num * 256 * 256) % (256 * 256), offset + 2)
}

function writeFixed16 (num, buf, offset) {
  buf[offset] = Math.floor(num) % 256
  buf[offset + 1] = Math.floor(num * 256) % 256
}

function writeMatrix (list, buf, offset) {
  if (!list) list = [0, 0, 0, 0, 0, 0, 0, 0, 0]
  for (var i = 0; i < list.length; i++) {
    writeFixed32(list[i], buf, offset + i * 4)
  }
}

function writeString (str, buf, offset) {
  var strBuffer = new Buffer(str, 'utf8')
  strBuffer.copy(buf, offset)
  buf[offset + strBuffer.length] = 0
}

function readMatrix (buf) {
  var list = new Array(buf.length / 4)
  for (var i = 0; i < list.length; i++) list[i] = readFixed32(buf, i * 4)
  return list
}

function readDate (buf, offset) {
  return new Date(buf.readUInt32BE(offset) * 1000 - TIME_OFFSET)
}

function readFixed32 (buf, offset) {
  return buf.readUInt16BE(offset) + buf.readUInt16BE(offset + 2) / (256 * 256)
}

function readFixed16 (buf, offset) {
  return buf[offset] + buf[offset + 1] / 256
}

function readString (buf, offset, length) {
  var i
  for (i = 0; i < length; i++) {
    if (buf[offset + i] === 0) {
      break
    }
  }
  return buf.toString('utf8', offset, offset + i)
}

}).call(this,require("buffer").Buffer)

},{"./descriptor":81,"./index":82,"buffer":24}],81:[function(require,module,exports){
(function (Buffer){
var tagToName = {
  0x03: 'ESDescriptor',
  0x04: 'DecoderConfigDescriptor',
  0x05: 'DecoderSpecificInfo',
  0x06: 'SLConfigDescriptor'
}

exports.Descriptor = {}
exports.Descriptor.decode = function (buf, start, end) {
  var tag = buf.readUInt8(start)
  var ptr = start + 1
  var lenByte
  var len = 0
  do {
    lenByte = buf.readUInt8(ptr++)
    len = (len << 7) | (lenByte & 0x7f)
  } while (lenByte & 0x80)

  var obj
  var tagName = tagToName[tag] // May be undefined; that's ok
  if (exports[tagName]) {
    obj = exports[tagName].decode(buf, ptr, end)
  } else {
    obj = {
      buffer: new Buffer(buf.slice(ptr, ptr + len))
    }
  }

  obj.tag = tag
  obj.tagName = tagName
  obj.length = (ptr - start) + len
  obj.contentsLen = len
  return obj
}

exports.DescriptorArray = {}
exports.DescriptorArray.decode = function (buf, start, end) {
  var ptr = start
  var obj = {}
  while (ptr + 2 <= end) {
    var descriptor = exports.Descriptor.decode(buf, ptr, end)
    ptr += descriptor.length
    var tagName = tagToName[descriptor.tag] || ('Descriptor' + descriptor.tag)
    obj[tagName] = descriptor
  }
  return obj
}

exports.ESDescriptor = {}
exports.ESDescriptor.decode = function (buf, start, end) {
  var flags = buf.readUInt8(start + 2)
  var ptr = start + 3
  if (flags & 0x80) {
    ptr += 2
  }
  if (flags & 0x40) {
    var len = buf.readUInt8(ptr)
    ptr += len + 1
  }
  if (flags & 0x20) {
    ptr += 2
  }
  return exports.DescriptorArray.decode(buf, ptr, end)
}

exports.DecoderConfigDescriptor = {}
exports.DecoderConfigDescriptor.decode = function (buf, start, end) {
  var oti = buf.readUInt8(start)
  var obj = exports.DescriptorArray.decode(buf, start + 13, end)
  obj.oti = oti
  return obj
}

}).call(this,require("buffer").Buffer)

},{"buffer":24}],82:[function(require,module,exports){
(function (Buffer){
// var assert = require('assert')
var uint64be = require('uint64be')

var boxes = require('./boxes')

var UINT32_MAX = 4294967295

var Box = exports

/*
 * Lists the proper order for boxes inside containers.
 * Five-character names ending in 's' indicate arrays instead of single elements.
 */
var containers = exports.containers = {
  'moov': ['mvhd', 'meta', 'traks', 'mvex'],
  'trak': ['tkhd', 'tref', 'trgr', 'edts', 'meta', 'mdia', 'udta'],
  'edts': ['elst'],
  'mdia': ['mdhd', 'hdlr', 'elng', 'minf'],
  'minf': ['vmhd', 'smhd', 'hmhd', 'sthd', 'nmhd', 'dinf', 'stbl'],
  'dinf': ['dref'],
  'stbl': ['stsd', 'stts', 'ctts', 'cslg', 'stsc', 'stsz', 'stz2', 'stco', 'co64', 'stss', 'stsh', 'padb', 'stdp', 'sdtp', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios'],
  'mvex': ['mehd', 'trexs', 'leva'],
  'moof': ['mfhd', 'meta', 'trafs'],
  'traf': ['tfhd', 'trun', 'sbgps', 'sgpds', 'subss', 'saizs', 'saios', 'tfdt', 'meta']
}

Box.encode = function (obj, buffer, offset) {
  Box.encodingLength(obj) // sets every level appropriately
  offset = offset || 0
  buffer = buffer || new Buffer(obj.length)
  return Box._encode(obj, buffer, offset)
}

Box._encode = function (obj, buffer, offset) {
  var type = obj.type
  var len = obj.length
  if (len > UINT32_MAX) {
    len = 1
  }
  buffer.writeUInt32BE(len, offset)
  buffer.write(obj.type, offset + 4, 4, 'ascii')
  var ptr = offset + 8
  if (len === 1) {
    uint64be.encode(obj.length, buffer, ptr)
    ptr += 8
  }
  if (boxes.fullBoxes[type]) {
    buffer.writeUInt32BE(obj.flags || 0, ptr)
    buffer.writeUInt8(obj.version || 0, ptr)
    ptr += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          Box._encode(child, buffer, ptr)
          ptr += Box.encode.bytes
        })
      } else if (obj[childType]) {
        Box._encode(obj[childType], buffer, ptr)
        ptr += Box.encode.bytes
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        Box._encode(child, buffer, ptr)
        ptr += Box.encode.bytes
      })
    }
  } else if (boxes[type]) {
    var encode = boxes[type].encode
    encode(obj, buffer, ptr)
    ptr += encode.bytes
  } else if (obj.buffer) {
    var buf = obj.buffer
    buf.copy(buffer, ptr)
    ptr += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  Box.encode.bytes = ptr - offset
  // assert.equal(ptr - offset, obj.length, 'Error encoding \'' + type + '\': wrote ' + ptr - offset + ' bytes, expecting ' + obj.length)
  return buffer
}

/*
 * Returns an object with `type` and `size` fields,
 * or if there isn't enough data, returns the total
 * number of bytes needed to read the headers
 */
Box.readHeaders = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  if (end - start < 8) {
    return 8
  }

  var len = buffer.readUInt32BE(start)
  var type = buffer.toString('ascii', start + 4, start + 8)
  var ptr = start + 8

  if (len === 1) {
    if (end - start < 16) {
      return 16
    }

    len = uint64be.decode(buffer, ptr)
    ptr += 8
  }

  var version
  var flags
  if (boxes.fullBoxes[type]) {
    version = buffer.readUInt8(ptr)
    flags = buffer.readUInt32BE(ptr) & 0xffffff
    ptr += 4
  }

  return {
    length: len,
    headersLen: ptr - start,
    contentLen: len - (ptr - start),
    type: type,
    version: version,
    flags: flags
  }
}

Box.decode = function (buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var headers = Box.readHeaders(buffer, start, end)
  if (!headers || headers.length > end - start) {
    throw new Error('Data too short')
  }

  return Box.decodeWithoutHeaders(headers, buffer, start + headers.headersLen, start + headers.length)
}

Box.decodeWithoutHeaders = function (headers, buffer, start, end) {
  start = start || 0
  end = end || buffer.length
  var type = headers.type
  var obj = {}
  if (containers[type]) {
    obj.otherBoxes = []
    var contents = containers[type]
    var ptr = start
    while (end - ptr >= 8) {
      var child = Box.decode(buffer, ptr, end)
      ptr += child.length
      if (contents.indexOf(child.type) >= 0) {
        obj[child.type] = child
      } else if (contents.indexOf(child.type + 's') >= 0) {
        var childType = child.type + 's'
        var entry = obj[childType] = obj[childType] || []
        entry.push(child)
      } else {
        obj.otherBoxes.push(child)
      }
    }
  } else if (boxes[type]) {
    var decode = boxes[type].decode
    obj = decode(buffer, start, end)
  } else {
    obj.buffer = new Buffer(buffer.slice(start, end))
  }

  obj.length = headers.length
  obj.contentLen = headers.contentLen
  obj.type = headers.type
  obj.version = headers.version
  obj.flags = headers.flags
  return obj
}

Box.encodingLength = function (obj) {
  var type = obj.type

  var len = 8
  if (boxes.fullBoxes[type]) {
    len += 4
  }

  if (containers[type]) {
    var contents = containers[type]
    contents.forEach(function (childType) {
      if (childType.length === 5) {
        var entry = obj[childType] || []
        childType = childType.substr(0, 4)
        entry.forEach(function (child) {
          child.type = childType
          len += Box.encodingLength(child)
        })
      } else if (obj[childType]) {
        var child = obj[childType]
        child.type = childType
        len += Box.encodingLength(child)
      }
    })
    if (obj.otherBoxes) {
      obj.otherBoxes.forEach(function (child) {
        len += Box.encodingLength(child)
      })
    }
  } else if (boxes[type]) {
    len += boxes[type].encodingLength(obj)
  } else if (obj.buffer) {
    len += obj.buffer.length
  } else {
    throw new Error('Either `type` must be set to a known type (not\'' + type + '\') or `buffer` must be set')
  }

  if (len > UINT32_MAX) {
    len += 8
  }

  obj.length = len
  return len
}

}).call(this,require("buffer").Buffer)

},{"./boxes":80,"buffer":24,"uint64be":155}],83:[function(require,module,exports){
(function (Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var nextEvent = require('next-event')
var Box = require('mp4-box-encoding')

var EMPTY = new Buffer(0)

module.exports = Decoder

function Decoder () {
  if (!(this instanceof Decoder)) return new Decoder()
  stream.Writable.call(this)

  this.destroyed = false

  this._pending = 0
  this._missing = 0
  this._buf = null
  this._str = null
  this._cb = null
  this._ondrain = null
  this._writeBuffer = null
  this._writeCb = null

  this._ondrain = null
  this._kick()
}

inherits(Decoder, stream.Writable)

Decoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (err) this.emit('error', err)
  this.emit('close')
}

Decoder.prototype._write = function (data, enc, next) {
  if (this.destroyed) return
  var drained = !this._str || !this._str._writableState.needDrain

  while (data.length && !this.destroyed) {
    if (!this._missing) {
      this._writeBuffer = data
      this._writeCb = next
      return
    }

    var consumed = data.length < this._missing ? data.length : this._missing
    if (this._buf) data.copy(this._buf, this._buf.length - this._missing)
    else if (this._str) drained = this._str.write(consumed === data.length ? data : data.slice(0, consumed))

    this._missing -= consumed

    if (!this._missing) {
      var buf = this._buf
      var cb = this._cb
      var stream = this._str

      this._buf = this._cb = this._str = this._ondrain = null
      drained = true

      if (stream) stream.end()
      if (cb) cb(buf)
    }

    data = consumed === data.length ? EMPTY : data.slice(consumed)
  }

  if (this._pending && !this._missing) {
    this._writeBuffer = data
    this._writeCb = next
    return
  }

  if (drained) next()
  else this._ondrain(next)
}

Decoder.prototype._buffer = function (size, cb) {
  this._missing = size
  this._buf = new Buffer(size)
  this._cb = cb
}

Decoder.prototype._stream = function (size, cb) {
  var self = this
  this._missing = size
  this._str = new MediaData(this)
  this._ondrain = nextEvent(this._str, 'drain')
  this._pending++
  this._str.on('end', function () {
    self._pending--
    self._kick()
  })
  this._cb = cb
  return this._str
}

Decoder.prototype._readBox = function () {
  var self = this
  bufferHeaders(8)

  function bufferHeaders (len, buf) {
    self._buffer(len, function (additionalBuf) {
      if (buf) {
        buf = Buffer.concat(buf, additionalBuf)
      } else {
        buf = additionalBuf
      }
      var headers = Box.readHeaders(buf)
      if (typeof headers === 'number') {
        bufferHeaders(headers - buf.length, buf)
      } else {
        self._pending++
        self._headers = headers
        self.emit('box', headers)
      }
    })
  }
}

Decoder.prototype.stream = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  return self._stream(headers.contentLen, null)
}

Decoder.prototype.decode = function (cb) {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  self._buffer(headers.contentLen, function (buf) {
    var box = Box.decodeWithoutHeaders(headers, buf)
    cb(box)
    self._pending--
    self._kick()
  })
}

Decoder.prototype.ignore = function () {
  var self = this
  if (!self._headers) throw new Error('this function can only be called once after \'box\' is emitted')
  var headers = self._headers
  self._headers = null

  this._missing = headers.contentLen
  this._cb = function () {
    self._pending--
    self._kick()
  }
}

Decoder.prototype._kick = function () {
  if (this._pending) return
  if (!this._buf && !this._str) this._readBox()
  if (this._writeBuffer) {
    var next = this._writeCb
    var buffer = this._writeBuffer
    this._writeBuffer = null
    this._writeCb = null
    this._write(buffer, null, next)
  }
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require("buffer").Buffer)

},{"buffer":24,"inherits":69,"mp4-box-encoding":82,"next-event":88,"readable-stream":115}],84:[function(require,module,exports){
(function (process,Buffer){
var stream = require('readable-stream')
var inherits = require('inherits')
var Box = require('mp4-box-encoding')

module.exports = Encoder

function noop () {}

function Encoder () {
  if (!(this instanceof Encoder)) return new Encoder()
  stream.Readable.call(this)

  this.destroyed = false

  this._reading = false
  this._stream = null
  this._drain = null
  this._want = false
  this._onreadable = onreadable
  this._onend = onend

  var self = this

  function onreadable () {
    if (!self._want) return
    self._want = false
    self._read()
  }

  function onend () {
    self._stream = null
  }
}

inherits(Encoder, stream.Readable)

Encoder.prototype.mediaData =
Encoder.prototype.mdat = function (size, cb) {
  var stream = new MediaData(this)
  this.box({type: 'mdat', contentLength: size, encodeBufferLen: 8, stream: stream}, cb)
  return stream
}

Encoder.prototype.box = function (box, cb) {
  if (!cb) cb = noop
  if (this.destroyed) return cb(new Error('Encoder is destroyed'))

  var buf
  if (box.encodeBufferLen) {
    buf = new Buffer(box.encodeBufferLen)
  }
  if (box.stream) {
    box.buffer = null
    buf = Box.encode(box, buf)
    this.push(buf)
    this._stream = box.stream
    this._stream.on('readable', this._onreadable)
    this._stream.on('end', this._onend)
    this._stream.on('end', cb)
    this._forward()
  } else {
    buf = Box.encode(box, buf)
    var drained = this.push(buf)
    if (drained) return process.nextTick(cb)
    this._drain = cb
  }
}

Encoder.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  if (this._stream && this._stream.destroy) this._stream.destroy()
  this._stream = null
  if (this._drain) {
    var cb = this._drain
    this._drain = null
    cb(err)
  }
  if (err) this.emit('error', err)
  this.emit('close')
}

Encoder.prototype.finalize = function () {
  this.push(null)
}

Encoder.prototype._forward = function () {
  if (!this._stream) return

  while (!this.destroyed) {
    var buf = this._stream.read()

    if (!buf) {
      this._want = !!this._stream
      return
    }

    if (!this.push(buf)) return
  }
}

Encoder.prototype._read = function () {
  if (this._reading || this.destroyed) return
  this._reading = true

  if (this._stream) this._forward()
  if (this._drain) {
    var drain = this._drain
    this._drain = null
    drain()
  }

  this._reading = false
}

function MediaData (parent) {
  this._parent = parent
  this.destroyed = false
  stream.PassThrough.call(this)
}

inherits(MediaData, stream.PassThrough)

MediaData.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true
  this._parent.destroy(err)
  if (err) this.emit('error', err)
  this.emit('close')
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":102,"buffer":24,"inherits":69,"mp4-box-encoding":82,"readable-stream":115}],85:[function(require,module,exports){
exports.decode = require('./decode')
exports.encode = require('./encode')

},{"./decode":83,"./encode":84}],86:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],87:[function(require,module,exports){
module.exports = MultiStream

var inherits = require('inherits')
var stream = require('readable-stream')

inherits(MultiStream, stream.Readable)

function MultiStream (streams, opts) {
  if (!(this instanceof MultiStream)) return new MultiStream(streams, opts)
  stream.Readable.call(this, opts)

  this.destroyed = false

  this._drained = false
  this._forwarding = false
  this._current = null
  this._queue = (typeof streams === 'function' ? streams : streams.map(toStreams2))

  this._next()
}

MultiStream.obj = function (streams) {
  return new MultiStream(streams, { objectMode: true, highWaterMark: 16 })
}

MultiStream.prototype._read = function () {
  this._drained = true
  this._forward()
}

MultiStream.prototype._forward = function () {
  if (this._forwarding || !this._drained || !this._current) return
  this._forwarding = true

  var chunk
  while ((chunk = this._current.read()) !== null) {
    this._drained = this.push(chunk)
  }

  this._forwarding = false
}

MultiStream.prototype.destroy = function (err) {
  if (this.destroyed) return
  this.destroyed = true

  if (this._current && this._current.destroy) this._current.destroy()
  if (typeof this._queue !== 'function') {
    this._queue.forEach(function (stream) {
      if (stream.destroy) stream.destroy()
    })
  }

  if (err) this.emit('error', err)
  this.emit('close')
}

MultiStream.prototype._next = function () {
  var self = this
  self._current = null

  if (typeof self._queue === 'function') {
    self._queue(function (err, stream) {
      if (err) return self.destroy(err)
      self._gotNextStream(toStreams2(stream))
    })
  } else {
    var stream = self._queue.shift()
    if (typeof stream === 'function') stream = toStreams2(stream())
    self._gotNextStream(stream)
  }
}

MultiStream.prototype._gotNextStream = function (stream) {
  var self = this

  if (!stream) {
    self.push(null)
    self.destroy()
    return
  }

  self._current = stream
  self._forward()

  stream.on('readable', onReadable)
  stream.on('end', onEnd)
  stream.on('error', onError)
  stream.on('close', onClose)

  function onReadable () {
    self._forward()
  }

  function onClose () {
    if (!stream._readableState.ended) {
      self.destroy()
    }
  }

  function onEnd () {
    self._current = null
    stream.removeListener('readable', onReadable)
    stream.removeListener('end', onEnd)
    stream.removeListener('error', onError)
    stream.removeListener('close', onClose)
    self._next()
  }

  function onError (err) {
    self.destroy(err)
  }
}

function toStreams2 (s) {
  if (!s || typeof s === 'function' || s._readableState) return s

  var wrap = new stream.Readable().wrap(s)
  if (s.destroy) {
    wrap.destroy = s.destroy.bind(s)
  }
  return wrap
}

},{"inherits":69,"readable-stream":115}],88:[function(require,module,exports){
module.exports = nextEvent

function nextEvent (emitter, name) {
  var next = null
  emitter.on(name, function (data) {
    if (!next) return
    var fn = next
    next = null
    fn(data)
  })

  return function (once) {
    next = once
  }
}

},{}],89:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":180}],90:[function(require,module,exports){
(function (Buffer){
module.exports = decodeTorrentFile
module.exports.decode = decodeTorrentFile
module.exports.encode = encodeTorrentFile

var bencode = require('bencode')
var path = require('path')
var sha1 = require('simple-sha1')
var uniq = require('uniq')

/**
 * Parse a torrent. Throws an exception if the torrent is missing required fields.
 * @param  {Buffer|Object} torrent
 * @return {Object}        parsed torrent
 */
function decodeTorrentFile (torrent) {
  if (Buffer.isBuffer(torrent)) {
    torrent = bencode.decode(torrent)
  }

  // sanity check
  ensure(torrent.info, 'info')
  ensure(torrent.info['name.utf-8'] || torrent.info.name, 'info.name')
  ensure(torrent.info['piece length'], 'info[\'piece length\']')
  ensure(torrent.info.pieces, 'info.pieces')

  if (torrent.info.files) {
    torrent.info.files.forEach(function (file) {
      ensure(typeof file.length === 'number', 'info.files[0].length')
      ensure(file['path.utf-8'] || file.path, 'info.files[0].path')
    })
  } else {
    ensure(typeof torrent.info.length === 'number', 'info.length')
  }

  var result = {}
  result.info = torrent.info
  result.infoBuffer = bencode.encode(torrent.info)
  result.infoHash = sha1.sync(result.infoBuffer)
  result.infoHashBuffer = new Buffer(result.infoHash, 'hex')

  result.name = (torrent.info['name.utf-8'] || torrent.info.name).toString()

  if (torrent.info.private !== undefined) result.private = !!torrent.info.private

  if (torrent['creation date']) result.created = new Date(torrent['creation date'] * 1000)
  if (torrent['created by']) result.createdBy = torrent['created by'].toString()

  if (Buffer.isBuffer(torrent.comment)) result.comment = torrent.comment.toString()

  // announce and announce-list will be missing if metadata fetched via ut_metadata
  result.announce = []
  if (torrent['announce-list'] && torrent['announce-list'].length) {
    torrent['announce-list'].forEach(function (urls) {
      urls.forEach(function (url) {
        result.announce.push(url.toString())
      })
    })
  } else if (torrent.announce) {
    result.announce.push(torrent.announce.toString())
  }

  // handle url-list (BEP19 / web seeding)
  if (Buffer.isBuffer(torrent['url-list'])) {
    // some clients set url-list to empty string
    torrent['url-list'] = torrent['url-list'].length > 0
      ? [ torrent['url-list'] ]
      : []
  }
  result.urlList = (torrent['url-list'] || []).map(function (url) {
    return url.toString()
  })

  uniq(result.announce)
  uniq(result.urlList)

  var files = torrent.info.files || [ torrent.info ]
  result.files = files.map(function (file, i) {
    var parts = [].concat(result.name, file['path.utf-8'] || file.path || []).map(function (p) {
      return p.toString()
    })
    return {
      path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
      name: parts[parts.length - 1],
      length: file.length,
      offset: files.slice(0, i).reduce(sumLength, 0)
    }
  })

  result.length = files.reduce(sumLength, 0)

  var lastFile = result.files[result.files.length - 1]

  result.pieceLength = torrent.info['piece length']
  result.lastPieceLength = ((lastFile.offset + lastFile.length) % result.pieceLength) || result.pieceLength
  result.pieces = splitPieces(torrent.info.pieces)

  return result
}

/**
 * Convert a parsed torrent object back into a .torrent file buffer.
 * @param  {Object} parsed parsed torrent
 * @return {Buffer}
 */
function encodeTorrentFile (parsed) {
  var torrent = {
    info: parsed.info
  }

  torrent['announce-list'] = (parsed.announce || []).map(function (url) {
    if (!torrent.announce) torrent.announce = url
    url = new Buffer(url, 'utf8')
    return [ url ]
  })

  torrent['url-list'] = parsed.urlList || []

  if (parsed.created) {
    torrent['creation date'] = (parsed.created.getTime() / 1000) | 0
  }

  if (parsed.createdBy) {
    torrent['created by'] = parsed.createdBy
  }

  if (parsed.comment) {
    torrent.comment = parsed.comment
  }

  return bencode.encode(torrent)
}

function sumLength (sum, file) {
  return sum + file.length
}

function splitPieces (buf) {
  var pieces = []
  for (var i = 0; i < buf.length; i += 20) {
    pieces.push(buf.slice(i, i + 20).toString('hex'))
  }
  return pieces
}

function ensure (bool, fieldName) {
  if (!bool) throw new Error('Torrent is missing required field: ' + fieldName)
}

}).call(this,require("buffer").Buffer)

},{"bencode":91,"buffer":24,"path":99,"simple-sha1":125,"uniq":156}],91:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./lib/decode":92,"./lib/encode":94,"dup":35}],92:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":93,"buffer":24}],93:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],94:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":24}],95:[function(require,module,exports){
(function (process,Buffer){
/* global Blob */

module.exports = parseTorrent
module.exports.remote = parseTorrentRemote

var blobToBuffer = require('blob-to-buffer')
var fs = require('fs') // browser exclude
var get = require('simple-get')
var magnet = require('magnet-uri')
var parseTorrentFile = require('parse-torrent-file')

module.exports.toMagnetURI = magnet.encode
module.exports.toTorrentFile = parseTorrentFile.encode

/**
 * Parse a torrent identifier (magnet uri, .torrent file, info hash)
 * @param  {string|Buffer|Object} torrentId
 * @return {Object}
 */
function parseTorrent (torrentId) {
  if (typeof torrentId === 'string' && /^(stream-)?magnet:/.test(torrentId)) {
    // magnet uri (string)
    return magnet(torrentId)
  } else if (typeof torrentId === 'string' && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
    // info hash (hex/base-32 string)
    return magnet('magnet:?xt=urn:btih:' + torrentId)
  } else if (Buffer.isBuffer(torrentId) && torrentId.length === 20) {
    // info hash (buffer)
    return magnet('magnet:?xt=urn:btih:' + torrentId.toString('hex'))
  } else if (Buffer.isBuffer(torrentId)) {
    // .torrent file (buffer)
    return parseTorrentFile(torrentId) // might throw
  } else if (torrentId && torrentId.infoHash) {
    // parsed torrent (from `parse-torrent`, `parse-torrent-file`, or `magnet-uri`)
    if (!torrentId.announce) torrentId.announce = []
    if (typeof torrentId.announce === 'string') {
      torrentId.announce = [ torrentId.announce ]
    }
    if (!torrentId.urlList) torrentId.urlList = []
    return torrentId
  } else {
    throw new Error('Invalid torrent identifier')
  }
}

function parseTorrentRemote (torrentId, cb) {
  var parsedTorrent
  if (typeof cb !== 'function') throw new Error('second argument must be a Function')

  try {
    parsedTorrent = parseTorrent(torrentId)
  } catch (err) {
    // If torrent fails to parse, it could be a Blob, http/https URL or
    // filesystem path, so don't consider it an error yet.
  }

  if (parsedTorrent && parsedTorrent.infoHash) {
    process.nextTick(function () {
      cb(null, parsedTorrent)
    })
  } else if (isBlob(torrentId)) {
    blobToBuffer(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Error converting Blob: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof get === 'function' && /^https?:/.test(torrentId)) {
    // http, or https url to torrent file
    get.concat({
      url: torrentId,
      headers: { 'user-agent': 'WebTorrent (http://webtorrent.io)' }
    }, function (err, res, torrentBuf) {
      if (err) return cb(new Error('Error downloading torrent: ' + err.message))
      parseOrThrow(torrentBuf)
    })
  } else if (typeof fs.readFile === 'function' && typeof torrentId === 'string') {
    // assume it's a filesystem path
    fs.readFile(torrentId, function (err, torrentBuf) {
      if (err) return cb(new Error('Invalid torrent identifier'))
      parseOrThrow(torrentBuf)
    })
  } else {
    process.nextTick(function () {
      cb(new Error('Invalid torrent identifier'))
    })
  }

  function parseOrThrow (torrentBuf) {
    try {
      parsedTorrent = parseTorrent(torrentBuf)
    } catch (err) {
      return cb(err)
    }
    if (parsedTorrent && parsedTorrent.infoHash) cb(null, parsedTorrent)
    else cb(new Error('Invalid torrent identifier'))
  }
}

/**
 * Check if `obj` is a W3C `Blob` or `File` object
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

// Workaround Browserify v13 bug
// https://github.com/substack/node-browserify/issues/1483
;(function () { Buffer(0) })()

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":102,"blob-to-buffer":18,"buffer":24,"fs":22,"magnet-uri":77,"parse-torrent-file":90,"simple-get":123}],96:[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],97:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],98:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],99:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":102}],100:[function(require,module,exports){
var closest = require('closest-to')

// Create a range from 16kb–4mb
var sizes = []
for (var i = 14; i <= 22; i++) {
  sizes.push(Math.pow(2, i))
}

module.exports = function(size) {
  return closest(
    size / Math.pow(2, 10), sizes 
  )
}

},{"closest-to":28}],101:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":102}],102:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],103:[function(require,module,exports){
var once = require('once')
var eos = require('end-of-stream')
var fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close() // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

},{"end-of-stream":42,"fs":22,"once":89}],104:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],105:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],106:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],107:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":105,"./encode":106}],108:[function(require,module,exports){
var iterate = function (list) {
  var offset = 0
  return function () {
    if (offset === list.length) return null

    var len = list.length - offset
    var i = (Math.random() * len) | 0
    var el = list[offset + i]

    var tmp = list[offset]
    list[offset] = el
    list[offset + i] = tmp
    offset++

    return el
  }
}

module.exports = iterate

},{}],109:[function(require,module,exports){
/*
Instance of writable stream.

call .get(length) or .discard(length) to get a stream (relative to the last end)

emits 'stalled' once everything is written


*/
var inherits = require('inherits')
var stream = require('readable-stream')

module.exports = RangeSliceStream

inherits(RangeSliceStream, stream.Writable)

function RangeSliceStream (offset) {
	var self = this
	if (!(self instanceof RangeSliceStream)) return new RangeSliceStream(offset)
	stream.Writable.call(self)

	self.destroyed = false
	self._queue = []
	self._position = offset || 0
	self._cb = null
	self._buffer = null
	self._out = null
}

RangeSliceStream.prototype._write = function (chunk, encoding, cb) {
	var self = this

	var drained = true

	while (true) {
		if (self.destroyed) {
			return
		}

		// Wait for more queue entries
		if (self._queue.length === 0) {
			self._buffer = chunk
			self._cb = cb
			return
		}

		self._buffer = null
		var currRange = self._queue[0]
		// Relative to the start of chunk, what data do we need?
		var writeStart = Math.max(currRange.start - self._position, 0)
		var writeEnd = currRange.end - self._position

		// Check if we need to throw it all away
		if (writeStart >= chunk.length) {
			self._position += chunk.length
			return cb(null)
		}

		// Check if we need to use it all
		var toWrite
		if (writeEnd > chunk.length) {
			self._position += chunk.length
			if (writeStart === 0) {
				toWrite = chunk
			} else {
				toWrite = chunk.slice(writeStart)
			}
			drained = currRange.stream.write(toWrite) && drained
			break
		}

		self._position += writeEnd
		if (writeStart === 0 && writeEnd === chunk.length) {
			toWrite = chunk
		} else {
			toWrite = chunk.slice(writeStart, writeEnd)
		}
		drained = currRange.stream.write(toWrite) && drained
		if (currRange.last) {
			currRange.stream.end()
		}
		chunk = chunk.slice(writeEnd)
		self._queue.shift()
	}

	if (drained) {
		cb(null)
	} else {
		currRange.stream.once('drain', cb.bind(null, null))
	}
}

RangeSliceStream.prototype.slice = function (ranges) {
	var self = this

	if (self.destroyed) return null

	if (!(ranges instanceof Array)) {
		ranges = [ranges]
	}

	var str = new stream.PassThrough()

	ranges.forEach(function (range, i) {
		self._queue.push({
			start: range.start,
			end: range.end,
			stream: str,
			last: i === (ranges.length - 1)
		})
	})
	if (self._buffer) {
		self._write(self._buffer, null, self._cb)
	}

	return str
}

RangeSliceStream.prototype.destroy = function (err) {
	var self = this
	if (self.destroyed) return
	self.destroyed = true

	if (err) self.emit('error', err)
}

},{"inherits":69,"readable-stream":115}],110:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":112,"./_stream_writable":114,"core-util-is":33,"inherits":69,"process-nextick-args":101}],111:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":113,"core-util-is":33,"inherits":69}],112:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var hasPrependListener = typeof EE.prototype.prependListener === 'function';

function prependListener(emitter, event, fn) {
  if (hasPrependListener) return emitter.prependListener(event, fn);

  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS. This is here
  // only because this code needs to continue to work with older versions
  // of Node.js that do not include the prependListener() method. The goal
  // is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var _buf = list[0];
        var cpy = Math.min(n - c, _buf.length);

        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);

        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":110,"_process":102,"buffer":24,"buffer-shims":23,"core-util-is":33,"events":57,"inherits":69,"isarray":75,"process-nextick-args":101,"string_decoder/":147,"util":21}],113:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":110,"core-util-is":33,"inherits":69}],114:[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":110,"_process":102,"buffer":24,"buffer-shims":23,"core-util-is":33,"events":57,"inherits":69,"process-nextick-args":101,"util-deprecate":167}],115:[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":110,"./lib/_stream_passthrough.js":111,"./lib/_stream_readable.js":112,"./lib/_stream_transform.js":113,"./lib/_stream_writable.js":114,"_process":102}],116:[function(require,module,exports){
exports.render = render
exports.append = append
var mime = exports.mime = require('./lib/mime.json')

var debug = require('debug')('render-media')
var isAscii = require('is-ascii')
var MediaElementWrapper = require('mediasource')
var path = require('path')
var streamToBlobURL = require('stream-to-blob-url')
var videostream = require('videostream')

var VIDEOSTREAM_EXTS = [ '.mp4', '.m4v', '.m4a' ]

var MEDIASOURCE_VIDEO_EXTS = [ '.mp4', '.m4v', '.webm', '.mkv' ]
var MEDIASOURCE_AUDIO_EXTS = [ '.m4a', '.mp3' ]
var MEDIASOURCE_EXTS = MEDIASOURCE_VIDEO_EXTS.concat(MEDIASOURCE_AUDIO_EXTS)

var AUDIO_EXTS = [ '.wav', '.aac', '.ogg', '.oga' ]
var IMAGE_EXTS = [ '.jpg', '.jpeg', '.png', '.gif', '.bmp' ]
var IFRAME_EXTS = [ '.css', '.html', '.js', '.md', '.pdf', '.txt' ]

var MediaSource = typeof window !== 'undefined' && window.MediaSource

function render (file, elem, cb) {
  validateFile(file)
  if (typeof elem === 'string') elem = document.querySelector(elem)

  renderMedia(file, function (tagName) {
    if (elem.nodeName !== tagName.toUpperCase()) {
      var extname = path.extname(file.name).toLowerCase()

      throw new Error(
        'Cannot render "' + extname + '" inside a "' +
        elem.nodeName.toLowerCase() + '" element, expected "' + tagName + '"'
      )
    }

    return elem
  }, cb)
}

function append (file, rootElem, cb) {
  if (!cb) cb = function () {}
  validateFile(file)
  if (typeof rootElem === 'string') rootElem = document.querySelector(rootElem)

  if (rootElem && (rootElem.nodeName === 'VIDEO' || rootElem.nodeName === 'AUDIO')) {
    throw new Error(
      'Invalid video/audio node argument. Argument must be root element that ' +
      'video/audio tag will be appended to.'
    )
  }

  renderMedia(file, function (tagName) {
    if (tagName === 'video' || tagName === 'audio') return createMedia(tagName)
    else return createElem(tagName)
  }, function (err, elem) {
    if (err && elem) elem.remove()
    cb(err, elem)
  })

  function createMedia (tagName) {
    var elem = createElem(tagName)
    elem.controls = true
    elem.autoplay = true
    rootElem.appendChild(elem)
    return elem
  }

  function createElem (tagName) {
    var elem = document.createElement(tagName)
    rootElem.appendChild(elem)
    return elem
  }
}

function renderMedia (file, getElem, cb) {
  if (!cb) cb = function () {}
  var extname = path.extname(file.name).toLowerCase()
  var currentTime = 0
  var elem

  if (MEDIASOURCE_EXTS.indexOf(extname) >= 0) {
    renderMediaSource()
  } else if (AUDIO_EXTS.indexOf(extname) >= 0) {
    renderAudio()
  } else if (IMAGE_EXTS.indexOf(extname) >= 0) {
    renderImage()
  } else if (IFRAME_EXTS.indexOf(extname) >= 0) {
    renderIframe()
  } else {
    tryRenderIframe()
  }

  function renderMediaSource () {
    var tagName = MEDIASOURCE_VIDEO_EXTS.indexOf(extname) >= 0 ? 'video' : 'audio'

    if (MediaSource) {
      if (VIDEOSTREAM_EXTS.indexOf(extname) >= 0) {
        useVideostream()
      } else {
        useMediaSource()
      }
    } else {
      useBlobURL()
    }

    function useVideostream () {
      debug('Use `videostream` package for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToMediaSource)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      videostream(file, elem)
    }

    function useMediaSource () {
      debug('Use MediaSource API for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fallbackToBlobURL)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)

      var wrapper = new MediaElementWrapper(elem)
      var writable = wrapper.createWriteStream(getCodec(file.name))
      file.createReadStream().pipe(writable)

      if (currentTime) elem.currentTime = currentTime
    }

    function useBlobURL () {
      debug('Use Blob URL for ' + file.name)
      prepareElem()
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      getBlobURL(file, function (err, url) {
        if (err) return fatalError(err)
        elem.src = url
        if (currentTime) elem.currentTime = currentTime
      })
    }

    function fallbackToMediaSource (err) {
      debug('videostream error: fallback to MediaSource API: %o', err.message || err)
      elem.removeEventListener('error', fallbackToMediaSource)
      elem.removeEventListener('canplay', onCanPlay)

      useMediaSource()
    }

    function fallbackToBlobURL (err) {
      debug('MediaSource API error: fallback to Blob URL: %o', err.message || err)
      elem.removeEventListener('error', fallbackToBlobURL)
      elem.removeEventListener('canplay', onCanPlay)

      useBlobURL()
    }

    function prepareElem () {
      if (!elem) {
        elem = getElem(tagName)

        elem.addEventListener('progress', function () {
          currentTime = elem.currentTime
        })
      }
    }
  }

  function renderAudio () {
    elem = getElem('audio')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.addEventListener('error', fatalError)
      elem.addEventListener('loadstart', onLoadStart)
      elem.addEventListener('canplay', onCanPlay)
      elem.src = url
    })
  }

  function onLoadStart () {
    elem.removeEventListener('loadstart', onLoadStart)
    elem.play()
  }

  function onCanPlay () {
    elem.removeEventListener('canplay', onCanPlay)
    cb(null, elem)
  }

  function renderImage () {
    elem = getElem('img')
    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      elem.alt = file.name
      cb(null, elem)
    })
  }

  function renderIframe () {
    elem = getElem('iframe')

    getBlobURL(file, function (err, url) {
      if (err) return fatalError(err)
      elem.src = url
      if (extname !== '.pdf') elem.sandbox = 'allow-forms allow-scripts'
      cb(null, elem)
    })
  }

  function tryRenderIframe () {
    debug('Unknown file extension "%s" - will attempt to render into iframe', extname)

    var str = ''
    file.createReadStream({ start: 0, end: 1000 })
      .setEncoding('utf8')
      .on('data', function (chunk) {
        str += chunk
      })
      .on('end', done)
      .on('error', cb)

    function done () {
      if (isAscii(str)) {
        debug('File extension "%s" appears ascii, so will render.', extname)
        renderIframe()
      } else {
        debug('File extension "%s" appears non-ascii, will not render.', extname)
        cb(new Error('Unsupported file type "' + extname + '": Cannot append to DOM'))
      }
    }
  }

  function fatalError (err) {
    err.message = 'Error rendering file "' + file.name + '": ' + err.message
    debug(err.message)
    cb(err)
  }
}

function getBlobURL (file, cb) {
  var extname = path.extname(file.name).toLowerCase()
  streamToBlobURL(file.createReadStream(), mime[extname], cb)
}

function validateFile (file) {
  if (file == null) {
    throw new Error('file cannot be null or undefined')
  }
  if (typeof file.name !== 'string') {
    throw new Error('missing or invalid file.name property')
  }
  if (typeof file.createReadStream !== 'function') {
    throw new Error('missing or invalid file.createReadStream property')
  }
}

function getCodec (name) {
  var extname = path.extname(name).toLowerCase()
  return {
    '.m4a': 'audio/mp4; codecs="mp4a.40.5"',
    '.m4v': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.mkv': 'video/webm; codecs="avc1.640029, mp4a.40.5"',
    '.mp3': 'audio/mpeg',
    '.mp4': 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
    '.webm': 'video/webm; codecs="vorbis, vp8"'
  }[extname]
}

},{"./lib/mime.json":117,"debug":39,"is-ascii":71,"mediasource":78,"path":99,"stream-to-blob-url":143,"videostream":171}],117:[function(require,module,exports){
module.exports={
  ".3gp": "video/3gpp",
  ".aac": "audio/aac",
  ".aif": "audio/x-aiff",
  ".aiff": "audio/x-aiff",
  ".atom": "application/atom+xml",
  ".avi": "video/x-msvideo",
  ".bmp": "image/bmp",
  ".bz2": "application/x-bzip2",
  ".conf": "text/plain",
  ".css": "text/css",
  ".csv": "text/csv",
  ".diff": "text/x-diff",
  ".doc": "application/msword",
  ".flv": "video/x-flv",
  ".gif": "image/gif",
  ".gz": "application/x-gzip",
  ".htm": "text/html",
  ".html": "text/html",
  ".ico": "image/vnd.microsoft.icon",
  ".ics": "text/calendar",
  ".iso": "application/octet-stream",
  ".jar": "application/java-archive",
  ".jpeg": "image/jpeg",
  ".jpg": "image/jpeg",
  ".js": "application/javascript",
  ".json": "application/json",
  ".less": "text/css",
  ".log": "text/plain",
  ".m3u": "audio/x-mpegurl",
  ".m4a": "audio/mp4",
  ".m4v": "video/mp4",
  ".manifest": "text/cache-manifest",
  ".markdown": "text/x-markdown",
  ".mathml": "application/mathml+xml",
  ".md": "text/x-markdown",
  ".mid": "audio/midi",
  ".midi": "audio/midi",
  ".mov": "video/quicktime",
  ".mp3": "audio/mpeg",
  ".mp4": "video/mp4",
  ".mp4v": "video/mp4",
  ".mpeg": "video/mpeg",
  ".mpg": "video/mpeg",
  ".odp": "application/vnd.oasis.opendocument.presentation",
  ".ods": "application/vnd.oasis.opendocument.spreadsheet",
  ".odt": "application/vnd.oasis.opendocument.text",
  ".oga": "audio/ogg",
  ".ogg": "application/ogg",
  ".pdf": "application/pdf",
  ".png": "image/png",
  ".pps": "application/vnd.ms-powerpoint",
  ".ppt": "application/vnd.ms-powerpoint",
  ".ps": "application/postscript",
  ".psd": "image/vnd.adobe.photoshop",
  ".qt": "video/quicktime",
  ".rar": "application/x-rar-compressed",
  ".rdf": "application/rdf+xml",
  ".rss": "application/rss+xml",
  ".rtf": "application/rtf",
  ".svg": "image/svg+xml",
  ".svgz": "image/svg+xml",
  ".swf": "application/x-shockwave-flash",
  ".tar": "application/x-tar",
  ".tbz": "application/x-bzip-compressed-tar",
  ".text": "text/plain",
  ".tif": "image/tiff",
  ".tiff": "image/tiff",
  ".torrent": "application/x-bittorrent",
  ".ttf": "application/x-font-ttf",
  ".txt": "text/plain",
  ".wav": "audio/wav",
  ".webm": "video/webm",
  ".wma": "audio/x-ms-wma",
  ".wmv": "video/x-ms-wmv",
  ".xls": "application/vnd.ms-excel",
  ".xml": "application/xml",
  ".yaml": "text/yaml",
  ".yml": "text/yaml",
  ".zip": "application/zip"
}

},{}],118:[function(require,module,exports){
(function (process){
module.exports = function (tasks, limit, cb) {
  if (typeof limit !== 'number') throw new Error('second argument must be a Number')
  var results, len, pending, keys, isErrored
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = len = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = len = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (err) isErrored = true
    if (--pending === 0 || err) {
      done(err)
    } else if (!isErrored && next < len) {
      var key
      if (keys) {
        key = keys[next]
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      } else {
        key = next
        next += 1
        tasks[key](function (err, result) { each(key, err, result) })
      }
    }
  }

  var next = limit
  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.some(function (key, i) {
      tasks[key](function (err, result) { each(key, err, result) })
      if (i === limit - 1) return true // early return
    })
  } else {
    // array
    tasks.some(function (task, i) {
      task(function (err, result) { each(i, err, result) })
      if (i === limit - 1) return true // early return
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":102}],119:[function(require,module,exports){
(function (process){
module.exports = function (tasks, cb) {
  var results, pending, keys
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}

}).call(this,require('_process'))

},{"_process":102}],120:[function(require,module,exports){
(function (global){
/*
 * Rusha, a JavaScript implementation of the Secure Hash Algorithm, SHA-1,
 * as defined in FIPS PUB 180-1, tuned for high performance with large inputs.
 * (http://github.com/srijs/rusha)
 *
 * Inspired by Paul Johnstons implementation (http://pajhome.org.uk/crypt/md5).
 *
 * Copyright (c) 2013 Sam Rijs (http://awesam.de).
 * Released under the terms of the MIT license as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
(function () {
    var util = {
            getDataType: function (data) {
                if (typeof data === 'string') {
                    return 'string';
                }
                if (data instanceof Array) {
                    return 'array';
                }
                if (typeof global !== 'undefined' && global.Buffer && global.Buffer.isBuffer(data)) {
                    return 'buffer';
                }
                if (data instanceof ArrayBuffer) {
                    return 'arraybuffer';
                }
                if (data.buffer instanceof ArrayBuffer) {
                    return 'view';
                }
                if (data instanceof Blob) {
                    return 'blob';
                }
                throw new Error('Unsupported data type.');
            }
        };
    // The Rusha object is a wrapper around the low-level RushaCore.
    // It provides means of converting different inputs to the
    // format accepted by RushaCore as well as other utility methods.
    function Rusha(chunkSize) {
        'use strict';
        // Private object structure.
        var self$2 = { fill: 0 };
        // Calculate the length of buffer that the sha1 routine uses
        // including the padding.
        var padlen = function (len) {
            for (len += 9; len % 64 > 0; len += 1);
            return len;
        };
        var padZeroes = function (bin, len) {
            for (var i = len >> 2; i < bin.length; i++)
                bin[i] = 0;
        };
        var padData = function (bin, chunkLen, msgLen) {
            bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
            bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen >> 29;
            bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
        };
        // Convert a binary string and write it to the heap.
        // A binary string is expected to only contain char codes < 256.
        var convStr = function (H8, H32, start, len, off) {
            var str = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = str.charCodeAt(start);
                case 1:
                    H8[off + 2 | 0] = str.charCodeAt(start + 1);
                case 2:
                    H8[off + 1 | 0] = str.charCodeAt(start + 2);
                case 3:
                    H8[off | 0] = str.charCodeAt(start + 3);
                }
            }
            for (i = om; i < j; i = i + 4 | 0) {
                H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
            case 2:
                H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
            case 1:
                H8[off + j + 3 | 0] = str.charCodeAt(start + j);
            }
        };
        // Convert a buffer or array and write it to the heap.
        // The buffer or array is expected to only contain elements < 256.
        var convBuf = function (H8, H32, start, len, off) {
            var buf = this, i, om = off % 4, lm = len % 4, j = len - lm;
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[start];
                case 1:
                    H8[off + 2 | 0] = buf[start + 1];
                case 2:
                    H8[off + 1 | 0] = buf[start + 2];
                case 3:
                    H8[off | 0] = buf[start + 3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[start + j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[start + j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[start + j];
            }
        };
        var convBlob = function (H8, H32, start, len, off) {
            var blob = this, i, om = off % 4, lm = len % 4, j = len - lm;
            var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
            if (j > 0) {
                switch (om) {
                case 0:
                    H8[off + 3 | 0] = buf[0];
                case 1:
                    H8[off + 2 | 0] = buf[1];
                case 2:
                    H8[off + 1 | 0] = buf[2];
                case 3:
                    H8[off | 0] = buf[3];
                }
            }
            for (i = 4 - om; i < j; i = i += 4 | 0) {
                H32[off + i >> 2] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[j];
            }
        };
        var convFn = function (data) {
            switch (util.getDataType(data)) {
            case 'string':
                return convStr.bind(data);
            case 'array':
                return convBuf.bind(data);
            case 'buffer':
                return convBuf.bind(data);
            case 'arraybuffer':
                return convBuf.bind(new Uint8Array(data));
            case 'view':
                return convBuf.bind(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            case 'blob':
                return convBlob.bind(data);
            }
        };
        var slice = function (data, offset) {
            switch (util.getDataType(data)) {
            case 'string':
                return data.slice(offset);
            case 'array':
                return data.slice(offset);
            case 'buffer':
                return data.slice(offset);
            case 'arraybuffer':
                return data.slice(offset);
            case 'view':
                return data.buffer.slice(offset);
            }
        };
        // Convert an ArrayBuffer into its hexadecimal string representation.
        var hex = function (arrayBuffer) {
            var i, x, hex_tab = '0123456789abcdef', res = [], binarray = new Uint8Array(arrayBuffer);
            for (i = 0; i < binarray.length; i++) {
                x = binarray[i];
                res[i] = hex_tab.charAt(x >> 4 & 15) + hex_tab.charAt(x >> 0 & 15);
            }
            return res.join('');
        };
        var ceilHeapSize = function (v) {
            // The asm.js spec says:
            // The heap object's byteLength must be either
            // 2^n for n in [12, 24) or 2^24 * n for n ≥ 1.
            // Also, byteLengths smaller than 2^16 are deprecated.
            var p;
            // If v is smaller than 2^16, the smallest possible solution
            // is 2^16.
            if (v <= 65536)
                return 65536;
            // If v < 2^24, we round up to 2^n,
            // otherwise we round up to 2^24 * n.
            if (v < 16777216) {
                for (p = 1; p < v; p = p << 1);
            } else {
                for (p = 16777216; p < v; p += 16777216);
            }
            return p;
        };
        // Initialize the internal data structures to a new capacity.
        var init = function (size) {
            if (size % 64 > 0) {
                throw new Error('Chunk size must be a multiple of 128 bit');
            }
            self$2.maxChunkLen = size;
            self$2.padMaxChunkLen = padlen(size);
            // The size of the heap is the sum of:
            // 1. The padded input message size
            // 2. The extended space the algorithm needs (320 byte)
            // 3. The 160 bit state the algoritm uses
            self$2.heap = new ArrayBuffer(ceilHeapSize(self$2.padMaxChunkLen + 320 + 20));
            self$2.h32 = new Int32Array(self$2.heap);
            self$2.h8 = new Int8Array(self$2.heap);
            self$2.core = new Rusha._core({
                Int32Array: Int32Array,
                DataView: DataView
            }, {}, self$2.heap);
            self$2.buffer = null;
        };
        // Iinitializethe datastructures according
        // to a chunk siyze.
        init(chunkSize || 64 * 1024);
        var initState = function (heap, padMsgLen) {
            var io = new Int32Array(heap, padMsgLen + 320, 5);
            io[0] = 1732584193;
            io[1] = -271733879;
            io[2] = -1732584194;
            io[3] = 271733878;
            io[4] = -1009589776;
        };
        var padChunk = function (chunkLen, msgLen) {
            var padChunkLen = padlen(chunkLen);
            var view = new Int32Array(self$2.heap, 0, padChunkLen >> 2);
            padZeroes(view, chunkLen);
            padData(view, chunkLen, msgLen);
            return padChunkLen;
        };
        // Write data to the heap.
        var write = function (data, chunkOffset, chunkLen) {
            convFn(data)(self$2.h8, self$2.h32, chunkOffset, chunkLen, 0);
        };
        // Initialize and call the RushaCore,
        // assuming an input buffer of length len * 4.
        var coreCall = function (data, chunkOffset, chunkLen, msgLen, finalize) {
            var padChunkLen = chunkLen;
            if (finalize) {
                padChunkLen = padChunk(chunkLen, msgLen);
            }
            write(data, chunkOffset, chunkLen);
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
        };
        var getRawDigest = function (heap, padMaxChunkLen) {
            var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
            var out = new Int32Array(5);
            var arr = new DataView(out.buffer);
            arr.setInt32(0, io[0], false);
            arr.setInt32(4, io[1], false);
            arr.setInt32(8, io[2], false);
            arr.setInt32(12, io[3], false);
            arr.setInt32(16, io[4], false);
            return out;
        };
        // Calculate the hash digest as an array of 5 32bit integers.
        var rawDigest = this.rawDigest = function (str) {
                var msgLen = str.byteLength || str.length || str.size || 0;
                initState(self$2.heap, self$2.padMaxChunkLen);
                var chunkOffset = 0, chunkLen = self$2.maxChunkLen, last;
                for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                    coreCall(str, chunkOffset, chunkLen, msgLen, false);
                }
                coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                return getRawDigest(self$2.heap, self$2.padMaxChunkLen);
            };
        // The digest and digestFrom* interface returns the hash digest
        // as a hex string.
        this.digest = this.digestFromString = this.digestFromBuffer = this.digestFromArrayBuffer = function (str) {
            return hex(rawDigest(str).buffer);
        };
    }
    ;
    // The low-level RushCore module provides the heart of Rusha,
    // a high-speed sha1 implementation working on an Int32Array heap.
    // At first glance, the implementation seems complicated, however
    // with the SHA1 spec at hand, it is obvious this almost a textbook
    // implementation that has a few functions hand-inlined and a few loops
    // hand-unrolled.
    Rusha._core = function RushaCore(stdlib, foreign, heap) {
        'use asm';
        var H = new stdlib.Int32Array(heap);
        function hash(k, x) {
            // k in bytes
            k = k | 0;
            x = x | 0;
            var i = 0, j = 0, y0 = 0, z0 = 0, y1 = 0, z1 = 0, y2 = 0, z2 = 0, y3 = 0, z3 = 0, y4 = 0, z4 = 0, t0 = 0, t1 = 0;
            y0 = H[x + 320 >> 2] | 0;
            y1 = H[x + 324 >> 2] | 0;
            y2 = H[x + 328 >> 2] | 0;
            y3 = H[x + 332 >> 2] | 0;
            y4 = H[x + 336 >> 2] | 0;
            for (i = 0; (i | 0) < (k | 0); i = i + 64 | 0) {
                z0 = y0;
                z1 = y1;
                z2 = y2;
                z3 = y3;
                z4 = y4;
                for (j = 0; (j | 0) < 64; j = j + 4 | 0) {
                    t1 = H[i + j >> 2] | 0;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[k + j >> 2] = t1;
                }
                for (j = k + 64 | 0; (j | 0) < (k + 80 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 80 | 0; (j | 0) < (k + 160 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) + 1859775393 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 160 | 0; (j | 0) < (k + 240 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | y1 & y3 | y2 & y3) | 0) + ((t1 + y4 | 0) - 1894007588 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 240 | 0; (j | 0) < (k + 320 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) - 899497514 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                y0 = y0 + z0 | 0;
                y1 = y1 + z1 | 0;
                y2 = y2 + z2 | 0;
                y3 = y3 + z3 | 0;
                y4 = y4 + z4 | 0;
            }
            H[x + 320 >> 2] = y0;
            H[x + 324 >> 2] = y1;
            H[x + 328 >> 2] = y2;
            H[x + 332 >> 2] = y3;
            H[x + 336 >> 2] = y4;
        }
        return { hash: hash };
    };
    // If we'e running in Node.JS, export a module.
    if (typeof module !== 'undefined') {
        module.exports = Rusha;
    } else if (typeof window !== 'undefined') {
        window.Rusha = Rusha;
    }
    // If we're running in a webworker, accept
    // messages containing a jobid and a buffer
    // or blob object, and return the hash result.
    if (typeof FileReaderSync !== 'undefined') {
        var reader = new FileReaderSync(), hasher = new Rusha(4 * 1024 * 1024);
        self.onmessage = function onMessage(event) {
            var hash, data = event.data.data;
            try {
                hash = hasher.digest(data);
                self.postMessage({
                    id: event.data.id,
                    hash: hash
                });
            } catch (e) {
                self.postMessage({
                    id: event.data.id,
                    error: e.name
                });
            }
        };
    }
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],121:[function(require,module,exports){
module.exports = require('buffer')

},{"buffer":24}],122:[function(require,module,exports){
(function (Buffer){
module.exports = function (stream, cb) {
  var chunks = []
  stream.on('data', function (chunk) {
    chunks.push(chunk)
  })
  stream.once('end', function () {
    if (cb) cb(null, Buffer.concat(chunks))
    cb = null
  })
  stream.once('error', function (err) {
    if (cb) cb(err)
    cb = null
  })
}

}).call(this,require("buffer").Buffer)

},{"buffer":24}],123:[function(require,module,exports){
(function (Buffer){
module.exports = simpleGet

var extend = require('xtend')
var http = require('http')
var https = require('https')
var once = require('once')
var unzipResponse = require('unzip-response') // excluded from browser build
var url = require('url')

function simpleGet (opts, cb) {
  opts = typeof opts === 'string' ? { url: opts } : extend(opts)
  cb = once(cb)

  if (opts.url) parseOptsUrl(opts)
  if (opts.headers == null) opts.headers = {}
  if (opts.maxRedirects == null) opts.maxRedirects = 10

  var body = opts.json ? JSON.stringify(opts.body) : opts.body
  opts.body = undefined
  if (body && !opts.method) opts.method = 'POST'

  if (opts.json) opts.headers.accept = 'application/json'
  if (opts.json && body) opts.headers['content-type'] = 'application/json'

  // Request gzip/deflate
  var customAcceptEncoding = Object.keys(opts.headers).some(function (h) {
    return h.toLowerCase() === 'accept-encoding'
  })
  if (!customAcceptEncoding) opts.headers['accept-encoding'] = 'gzip, deflate'

  // Support http: and https: urls
  var protocol = opts.protocol === 'https:' ? https : http
  var req = protocol.request(opts, function (res) {
    // Follow 3xx redirects
    if (res.statusCode >= 300 && res.statusCode < 400 && 'location' in res.headers) {
      opts.url = res.headers.location
      parseOptsUrl(opts)
      res.resume() // Discard response

      opts.maxRedirects -= 1
      if (opts.maxRedirects > 0) simpleGet(opts, cb)
      else cb(new Error('too many redirects'))

      return
    }

    cb(null, typeof unzipResponse === 'function' ? unzipResponse(res) : res)
  })
  req.on('error', cb)
  req.end(body)
  return req
}

module.exports.concat = function (opts, cb) {
  return simpleGet(opts, function (err, res) {
    if (err) return cb(err)
    var chunks = []
    res.on('data', function (chunk) {
      chunks.push(chunk)
    })
    res.on('end', function () {
      var data = Buffer.concat(chunks)
      if (opts.json) {
        try {
          data = JSON.parse(data.toString())
        } catch (err) {
          return cb(err, res, data)
        }
      }
      cb(null, res, data)
    })
  })
}

;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(function (method) {
  module.exports[method] = function (opts, cb) {
    if (typeof opts === 'string') opts = { url: opts }
    opts.method = method.toUpperCase()
    return simpleGet(opts, cb)
  }
})

function parseOptsUrl (opts) {
  var loc = url.parse(opts.url)
  if (loc.hostname) opts.hostname = loc.hostname
  if (loc.port) opts.port = loc.port
  if (loc.protocol) opts.protocol = loc.protocol
  if (loc.auth) opts.auth = loc.auth
  opts.path = loc.path
  delete opts.url
}

}).call(this,require("buffer").Buffer)

},{"buffer":24,"http":139,"https":65,"once":89,"unzip-response":21,"url":158,"xtend":181}],124:[function(require,module,exports){
(function (Buffer){
module.exports = Peer

var debug = require('debug')('simple-peer')
var getBrowserRTC = require('get-browser-rtc')
var hat = require('hat')
var inherits = require('inherits')
var once = require('once')
var stream = require('readable-stream')

inherits(Peer, stream.Duplex)

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer (opts) {
  var self = this
  if (!(self instanceof Peer)) return new Peer(opts)
  self._debug('new peer %o', opts)

  if (!opts) opts = {}
  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.initiator = opts.initiator || false
  self.channelConfig = opts.channelConfig || Peer.channelConfig
  self.channelName = opts.initiator ? (opts.channelName || hat(160)) : null
  self.config = opts.config || Peer.config
  self.constraints = opts.constraints || Peer.constraints
  self.offerConstraints = opts.offerConstraints
  self.answerConstraints = opts.answerConstraints
  self.reconnectTimer = opts.reconnectTimer || false
  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
  self.stream = opts.stream || false
  self.trickle = opts.trickle !== undefined ? opts.trickle : true

  self.destroyed = false
  self.connected = false

  // so Peer object always has same shape (V8 optimization)
  self.remoteAddress = undefined
  self.remoteFamily = undefined
  self.remotePort = undefined
  self.localAddress = undefined
  self.localPort = undefined

  self._isWrtc = !!opts.wrtc // HACK: to fix `wrtc` bug. See issue: #60
  self._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
    ? opts.wrtc
    : getBrowserRTC()
  if (!self._wrtc) {
    if (typeof window === 'undefined') {
      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment')
    } else {
      throw new Error('No WebRTC support: Not a supported browser')
    }
  }

  self._maxBufferedAmount = opts.highWaterMark
  self._pcReady = false
  self._channelReady = false
  self._iceComplete = false // ice candidate trickle done (got null candidate)
  self._channel = null
  self._pendingCandidates = []

  self._chunk = null
  self._cb = null
  self._interval = null
  self._reconnectTimeout = null

  self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)
  self._pc.oniceconnectionstatechange = function () {
    self._onIceConnectionStateChange()
  }
  self._pc.onsignalingstatechange = function () {
    self._onSignalingStateChange()
  }
  self._pc.onicecandidate = function (event) {
    self._onIceCandidate(event)
  }

  if (self.stream) self._pc.addStream(self.stream)
  self._pc.onaddstream = function (event) {
    self._onAddStream(event)
  }

  if (self.initiator) {
    self._setupData({
      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)
    })
    self._pc.onnegotiationneeded = once(function () {
      self._createOffer()
    })
    // Only Chrome triggers "negotiationneeded"; this is a workaround for other
    // implementations
    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {
      self._pc.onnegotiationneeded()
    }
  } else {
    self._pc.ondatachannel = function (event) {
      self._setupData(event)
    }
  }

  self.on('finish', function () {
    if (self.connected) {
      // When local peer is finished writing, close connection to remote peer.
      // Half open connections are currently not supported.
      // Wait a bit before destroying so the datachannel flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If data channel is not connected when local peer is finished writing, wait until
      // data is flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose config, constraints, and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      url: 'stun:23.21.150.121', // deprecated, replaced by `urls`
      urls: 'stun:23.21.150.121'
    }
  ]
}
Peer.constraints = {}
Peer.channelConfig = {}

Object.defineProperty(Peer.prototype, 'bufferSize', {
  get: function () {
    var self = this
    return (self._channel && self._channel.bufferedAmount) || 0
  }
})

Peer.prototype.address = function () {
  var self = this
  return { port: self.localPort, family: 'IPv4', address: self.localAddress }
}

Peer.prototype.signal = function (data) {
  var self = this
  if (self.destroyed) throw new Error('cannot signal after peer is destroyed')
  if (typeof data === 'string') {
    try {
      data = JSON.parse(data)
    } catch (err) {
      data = {}
    }
  }
  self._debug('signal()')

  function addIceCandidate (candidate) {
    try {
      self._pc.addIceCandidate(
        new self._wrtc.RTCIceCandidate(candidate),
        noop,
        function (err) { self._onError(err) }
      )
    } catch (err) {
      self._destroy(new Error('error adding candidate: ' + err.message))
    }
  }

  if (data.sdp) {
    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data), function () {
      if (self.destroyed) return
      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()

      self._pendingCandidates.forEach(addIceCandidate)
      self._pendingCandidates = []
    }, function (err) { self._onError(err) })
  }
  if (data.candidate) {
    if (self._pc.remoteDescription) addIceCandidate(data.candidate)
    else self._pendingCandidates.push(data.candidate)
  }
  if (!data.sdp && !data.candidate) {
    self._destroy(new Error('signal() called with invalid signal data'))
  }
}

/**
 * Send text/binary data to the remote peer.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Peer.prototype.send = function (chunk) {
  var self = this

  // HACK: `wrtc` module doesn't accept node.js buffer. See issue: #60
  if (Buffer.isBuffer(chunk) && self._isWrtc) {
    chunk = new Uint8Array(chunk)
  }

  var len = chunk.length || chunk.byteLength || chunk.size
  self._channel.send(chunk)
  self._debug('write: %d bytes', len)
}

Peer.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Peer.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  self._debug('destroy (error: %s)', err && err.message)

  self.readable = self.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.destroyed = true
  self.connected = false
  self._pcReady = false
  self._channelReady = false

  self._chunk = null
  self._cb = null
  clearInterval(self._interval)
  clearTimeout(self._reconnectTimeout)

  if (self._pc) {
    try {
      self._pc.close()
    } catch (err) {}

    self._pc.oniceconnectionstatechange = null
    self._pc.onsignalingstatechange = null
    self._pc.onicecandidate = null
    self._pc.onaddstream = null
    self._pc.onnegotiationneeded = null
    self._pc.ondatachannel = null
  }

  if (self._channel) {
    try {
      self._channel.close()
    } catch (err) {}

    self._channel.onmessage = null
    self._channel.onopen = null
    self._channel.onclose = null
  }
  self._pc = null
  self._channel = null

  if (err) self.emit('error', err)
  self.emit('close')
}

Peer.prototype._setupData = function (event) {
  var self = this
  self._channel = event.channel
  self.channelName = self._channel.label

  self._channel.binaryType = 'arraybuffer'
  self._channel.onmessage = function (event) {
    self._onChannelMessage(event)
  }
  self._channel.onopen = function () {
    self._onChannelOpen()
  }
  self._channel.onclose = function () {
    self._onChannelClose()
  }
}

Peer.prototype._read = function () {}

Peer.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (self._channel.bufferedAmount > self._maxBufferedAmount) {
      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    self._debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Peer.prototype._createOffer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createOffer(function (offer) {
    if (self.destroyed) return
    offer.sdp = self.sdpTransform(offer.sdp)
    self._pc.setLocalDescription(offer, noop, function (err) { self._onError(err) })
    var sendOffer = function () {
      var signal = self._pc.localDescription || offer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendOffer()
    else self.once('_iceComplete', sendOffer) // wait for candidates
  }, function (err) { self._onError(err) }, self.offerConstraints)
}

Peer.prototype._createAnswer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createAnswer(function (answer) {
    if (self.destroyed) return
    answer.sdp = self.sdpTransform(answer.sdp)
    self._pc.setLocalDescription(answer, noop, function (err) { self._onError(err) })
    var sendAnswer = function () {
      var signal = self._pc.localDescription || answer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
    if (self.trickle || self._iceComplete) sendAnswer()
    else self.once('_iceComplete', sendAnswer)
  }, function (err) { self._onError(err) }, self.answerConstraints)
}

Peer.prototype._onIceConnectionStateChange = function () {
  var self = this
  if (self.destroyed) return
  var iceGatheringState = self._pc.iceGatheringState
  var iceConnectionState = self._pc.iceConnectionState
  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState)
  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState)
  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
    clearTimeout(self._reconnectTimeout)
    self._pcReady = true
    self._maybeReady()
  }
  if (iceConnectionState === 'disconnected') {
    if (self.reconnectTimer) {
      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect
      clearTimeout(self._reconnectTimeout)
      self._reconnectTimeout = setTimeout(function () {
        self._destroy()
      }, self.reconnectTimer)
    } else {
      self._destroy()
    }
  }
  if (iceConnectionState === 'failed') {
    self._destroy()
  }
  if (iceConnectionState === 'closed') {
    self._destroy()
  }
}

Peer.prototype.getStats = function (cb) {
  var self = this
  if (!self._pc.getStats) { // No ability to call stats
    cb([])
  } else if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) { // Mozilla
    self._pc.getStats(null, function (res) {
      var items = []
      res.forEach(function (item) {
        items.push(item)
      })
      cb(items)
    }, function (err) { self._onError(err) })
  } else {
    self._pc.getStats(function (res) { // Chrome
      var items = []
      res.result().forEach(function (result) {
        var item = {}
        result.names().forEach(function (name) {
          item[name] = result.stat(name)
        })
        item.id = result.id
        item.type = result.type
        item.timestamp = result.timestamp
        items.push(item)
      })
      cb(items)
    })
  }
}

Peer.prototype._maybeReady = function () {
  var self = this
  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return
  self._connecting = true

  self.getStats(function (items) {
    self._connecting = false
    self.connected = true

    var remoteCandidates = {}
    var localCandidates = {}

    function setActiveCandidates (item) {
      var local = localCandidates[item.localCandidateId]
      var remote = remoteCandidates[item.remoteCandidateId]

      if (local) {
        self.localAddress = local.ipAddress
        self.localPort = Number(local.portNumber)
      } else if (typeof item.googLocalAddress === 'string') {
        // Sometimes `item.id` is undefined in `wrtc` and Chrome
        // See: https://github.com/feross/simple-peer/issues/66
        local = item.googLocalAddress.split(':')
        self.localAddress = local[0]
        self.localPort = Number(local[1])
      }
      self._debug('connect local: %s:%s', self.localAddress, self.localPort)

      if (remote) {
        self.remoteAddress = remote.ipAddress
        self.remotePort = Number(remote.portNumber)
        self.remoteFamily = 'IPv4'
      } else if (typeof item.googRemoteAddress === 'string') {
        remote = item.googRemoteAddress.split(':')
        self.remoteAddress = remote[0]
        self.remotePort = Number(remote[1])
        self.remoteFamily = 'IPv4'
      }
      self._debug('connect remote: %s:%s', self.remoteAddress, self.remotePort)
    }

    items.forEach(function (item) {
      if (item.type === 'remotecandidate') remoteCandidates[item.id] = item
      if (item.type === 'localcandidate') localCandidates[item.id] = item
    })

    items.forEach(function (item) {
      var isCandidatePair = (
        (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
        (item.type === 'candidatepair' && item.selected)
      )
      if (isCandidatePair) setActiveCandidates(item)
    })

    if (self._chunk) {
      try {
        self.send(self._chunk)
      } catch (err) {
        return self._onError(err)
      }
      self._chunk = null
      self._debug('sent chunk from "write before connect"')

      var cb = self._cb
      self._cb = null
      cb(null)
    }

    self._interval = setInterval(function () {
      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return
      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()

    self._debug('connect')
    self.emit('connect')
  })
}

Peer.prototype._onSignalingStateChange = function () {
  var self = this
  if (self.destroyed) return
  self._debug('signalingStateChange %s', self._pc.signalingState)
  self.emit('signalingStateChange', self._pc.signalingState)
}

Peer.prototype._onIceCandidate = function (event) {
  var self = this
  if (self.destroyed) return
  if (event.candidate && self.trickle) {
    self.emit('signal', {
      candidate: {
        candidate: event.candidate.candidate,
        sdpMLineIndex: event.candidate.sdpMLineIndex,
        sdpMid: event.candidate.sdpMid
      }
    })
  } else if (!event.candidate) {
    self._iceComplete = true
    self.emit('_iceComplete')
  }
}

Peer.prototype._onChannelMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  self._debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Peer.prototype._onChannelOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self._debug('on channel open')
  self._channelReady = true
  self._maybeReady()
}

Peer.prototype._onChannelClose = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on channel close')
  self._destroy()
}

Peer.prototype._onAddStream = function (event) {
  var self = this
  if (self.destroyed) return
  self._debug('on add stream')
  self.emit('stream', event.stream)
}

Peer.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  self._debug('error %s', err.message || err)
  self._destroy(err)
}

Peer.prototype._debug = function () {
  var self = this
  var args = [].slice.call(arguments)
  var id = self.channelName && self.channelName.substring(0, 7)
  args[0] = '[' + id + '] ' + args[0]
  debug.apply(null, args)
}

function noop () {}

}).call(this,require("buffer").Buffer)

},{"buffer":24,"debug":39,"get-browser-rtc":60,"hat":64,"inherits":69,"once":89,"readable-stream":115}],125:[function(require,module,exports){
var Rusha = require('rusha')

var rusha = new Rusha
var crypto = window.crypto || window.msCrypto || {}
var subtle = crypto.subtle || crypto.webkitSubtle

function sha1sync (buf) {
  return rusha.digest(buf)
}

// Browsers throw if they lack support for an algorithm.
// Promise will be rejected on non-secure origins. (http://goo.gl/lq4gCo)
try {
  subtle.digest({ name: 'sha-1' }, new Uint8Array).catch(function () {
    subtle = false
  })
} catch (err) { subtle = false }

function sha1 (buf, cb) {
  if (!subtle) {
    // Use Rusha
    setTimeout(cb, 0, sha1sync(buf))
    return
  }

  if (typeof buf === 'string') {
    buf = uint8array(buf)
  }

  subtle.digest({ name: 'sha-1' }, buf)
    .then(function succeed (result) {
      cb(hex(new Uint8Array(result)))
    },
    function fail (error) {
      cb(sha1sync(buf))
    })
}

function uint8array (s) {
  var l = s.length
  var array = new Uint8Array(l)
  for (var i = 0; i < l; i++) {
    array[i] = s.charCodeAt(i)
  }
  return array
}

function hex (buf) {
  var l = buf.length
  var chars = []
  for (var i = 0; i < l; i++) {
    var bite = buf[i]
    chars.push((bite >>> 4).toString(16))
    chars.push((bite & 0x0f).toString(16))
  }
  return chars.join('')
}

module.exports = sha1
module.exports.sync = sha1sync

},{"rusha":120}],126:[function(require,module,exports){
(function (process,Buffer){
/* global WebSocket */

module.exports = Socket

var debug = require('debug')('simple-websocket')
var inherits = require('inherits')
var stream = require('readable-stream')
var ws = require('ws') // websockets in node - will be empty object in browser

var _WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : ws

inherits(Socket, stream.Duplex)

/**
 * WebSocket. Same API as node core `net.Socket`. Duplex stream.
 * @param {string} url websocket server url
 * @param {Object} opts options to stream.Duplex
 */
function Socket (url, opts) {
  var self = this
  if (!(self instanceof Socket)) return new Socket(url, opts)
  if (!opts) opts = {}
  debug('new websocket: %s %o', url, opts)

  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.url = url
  self.connected = false
  self.destroyed = false

  self._maxBufferedAmount = opts.highWaterMark
  self._chunk = null
  self._cb = null
  self._interval = null

  try {
    if (typeof WebSocket === 'undefined') {
      // `ws` package accepts options
      self._ws = new _WebSocket(self.url, opts)
    } else {
      self._ws = new _WebSocket(self.url)
    }
  } catch (err) {
    process.nextTick(function () {
      self._onError(err)
    })
    return
  }
  self._ws.binaryType = 'arraybuffer'
  self._ws.onopen = function () {
    self._onOpen()
  }
  self._ws.onmessage = function (event) {
    self._onMessage(event)
  }
  self._ws.onclose = function () {
    self._onClose()
  }
  self._ws.onerror = function () {
    self._onError(new Error('connection error to ' + self.url))
  }

  self.on('finish', function () {
    if (self.connected) {
      // When stream is finished writing, close socket connection. Half open connections
      // are currently not supported.
      // Wait a bit before destroying so the socket flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If socket is not connected when stream is finished writing, wait until data is
      // flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Socket.WEBSOCKET_SUPPORT = !!_WebSocket

/**
 * Send text/binary data to the WebSocket server.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Socket.prototype.send = function (chunk) {
  var self = this

  var len = chunk.length || chunk.byteLength || chunk.size
  self._ws.send(chunk)
  debug('write: %d bytes', len)
}

Socket.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Socket.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  debug('destroy (error: %s)', err && err.message)

  this.readable = this.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.connected = false
  self.destroyed = true

  clearInterval(self._interval)
  self._interval = null
  self._chunk = null
  self._cb = null

  if (self._ws) {
    var ws = self._ws
    var onClose = function () {
      ws.onclose = null
      self.emit('close')
    }
    if (ws.readyState === _WebSocket.CLOSED) {
      onClose()
    } else {
      try {
        ws.onclose = onClose
        ws.close()
      } catch (err) {
        onClose()
      }
    }

    ws.onopen = null
    ws.onmessage = null
    ws.onerror = null
  }
  self._ws = null

  if (err) self.emit('error', err)
}

Socket.prototype._read = function () {}

Socket.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after socket is destroyed'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self._onError(err)
    }
    if (typeof ws !== 'function' && self._ws.bufferedAmount > self._maxBufferedAmount) {
      debug('start backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Socket.prototype._onMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) data = new Buffer(data)
  self.push(data)
}

Socket.prototype._onOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self.connected = true

  if (self._chunk) {
    try {
      self.send(self._chunk)
    } catch (err) {
      return self._onError(err)
    }
    self._chunk = null
    debug('sent chunk from "write before connect"')

    var cb = self._cb
    self._cb = null
    cb(null)
  }

  // No backpressure in node. The `ws` module has a buggy `bufferedAmount` property.
  // See: https://github.com/websockets/ws/issues/492
  if (typeof ws !== 'function') {
    self._interval = setInterval(function () {
      if (!self._cb || !self._ws || self._ws.bufferedAmount > self._maxBufferedAmount) {
        return
      }
      debug('ending backpressure: bufferedAmount %d', self._ws.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()
  }

  debug('connect')
  self.emit('connect')
}

Socket.prototype._onClose = function () {
  var self = this
  if (self.destroyed) return
  debug('on close')
  self._destroy()
}

Socket.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  debug('error: %s', err.message || err)
  self._destroy(err)
}

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":102,"buffer":24,"debug":39,"inherits":69,"readable-stream":115,"ws":21}],127:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":128,"./socket":130,"./url":131,"debug":39,"socket.io-parser":134}],128:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function(){
  this.lastPing = new Date;
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function(){
  this.emitAll('pong', new Date - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function(){
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting() {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  debug('cleanup');

  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' == this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":129,"./socket":130,"backo2":6,"component-bind":30,"component-emitter":132,"debug":39,"engine.io-client":43,"indexof":68,"socket.io-parser":134}],129:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],130:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function(compress){
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};

},{"./on":129,"component-bind":30,"component-emitter":132,"debug":39,"has-binary":61,"socket.io-parser":134,"to-array":150}],131:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"debug":39,"parseuri":98}],132:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],133:[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./is-buffer":135,"isarray":136}],134:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":133,"./is-buffer":135,"component-emitter":31,"debug":39,"isarray":136,"json3":137}],135:[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],136:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],137:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],138:[function(require,module,exports){
var tick = 1
var maxTick = 65535
var resolution = 4
var inc = function () {
  tick = (tick + 1) & maxTick
}

var timer = setInterval(inc, (1000 / resolution) | 0)
if (timer.unref) timer.unref()

module.exports = function (seconds) {
  var size = resolution * (seconds || 5)
  var buffer = [0]
  var pointer = 1
  var last = (tick - 1) & maxTick

  return function (delta) {
    var dist = (tick - last) & maxTick
    if (dist > size) dist = size
    last = tick

    while (dist--) {
      if (pointer === size) pointer = 0
      buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1]
      pointer++
    }

    if (delta) buffer[pointer - 1] += delta

    var top = buffer[pointer - 1]
    var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer]

    return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length
  }
}

},{}],139:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/request":141,"builtin-status-codes":26,"url":158,"xtend":181}],140:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

var xhr = new global.XMLHttpRequest()
// If location.host is empty, e.g. if this page/worker was loaded
// from a Blob, then use example.com to avoid an error
xhr.open('GET', global.location.host ? '/' : 'https://example.com')

function checkTypeSupport (type) {
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

exports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')
// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')
exports.overrideMimeType = isFunction(xhr.overrideMimeType)
exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
  return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],141:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary) {
	if (capability.fetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary)

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var self = this
	return self._headers[name.toLowerCase()].value
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body
	if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {
		if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	if (self._mode === 'fetch') {
		var headers = Object.keys(headersObj).map(function (name) {
			return [headersObj[name].name, headersObj[name].value]
		})

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headers,
			body: body,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin'
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		Object.keys(headersObj).forEach(function (name) {
			xhr.setRequestHeader(headersObj[name].name, headersObj[name].value)
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	// Currently, there isn't a way to truly abort a fetch.
	// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":140,"./response":142,"_process":102,"buffer":24,"inherits":69,"readable-stream":115,"to-arraybuffer":151}],142:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		// backwards compatible version of for (<item> of <iterable>):
		// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
		for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
			self.headers[header[0].toLowerCase()] = header[1]
			self.rawHeaders.push(header[0], header[1])
		}

		// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			})
		}
		read()

	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":140,"_process":102,"buffer":24,"inherits":69,"readable-stream":115}],143:[function(require,module,exports){
/* global URL */

var getBlob = require('stream-to-blob')

module.exports = function getBlobURL (stream, mimeType, cb) {
  if (typeof mimeType === 'function') return getBlobURL(stream, null, mimeType)
  getBlob(stream, mimeType, function (err, blob) {
    if (err) return cb(err)
    var url = URL.createObjectURL(blob)
    cb(null, url)
  })
}

},{"stream-to-blob":144}],144:[function(require,module,exports){
/* global Blob */

var once = require('once')

module.exports = function getBlob (stream, mimeType, cb) {
  if (typeof mimeType === 'function') return getBlob(stream, null, mimeType)
  cb = once(cb)
  var chunks = []
  stream
    .on('data', function (chunk) {
      chunks.push(chunk)
    })
    .on('end', function () {
      var blob = mimeType
        ? new Blob(chunks, { type: mimeType })
        : new Blob(chunks)
      cb(null, blob)
    })
    .on('error', cb)
}

},{"once":89}],145:[function(require,module,exports){
(function (Buffer){
var once = require('once')

module.exports = function getBuffer (stream, length, cb) {
  cb = once(cb)
  var buf = new Buffer(length)
  var offset = 0
  stream
    .on('data', function (chunk) {
      chunk.copy(buf, offset)
      offset += chunk.length
    })
    .on('end', function () { cb(null, buf) })
    .on('error', cb)
}

}).call(this,require("buffer").Buffer)

},{"buffer":24,"once":89}],146:[function(require,module,exports){
(function (Buffer){
var addrToIPPort = require('addr-to-ip-port')
var ipaddr = require('ipaddr.js')

module.exports = function (addrs) {
  if (typeof addrs === 'string') {
    addrs = [ addrs ]
  }

  return Buffer.concat(addrs.map(function (addr) {
    var s = addrToIPPort(addr)
    if (s.length !== 2) {
      throw new Error('invalid address format, expecting: 10.10.10.5:128')
    }

    var ip = ipaddr.parse(s[0])
    var ipBuf = new Buffer(ip.toByteArray())
    var port = Number(s[1])
    var portBuf = new Buffer(2)
    portBuf.writeUInt16BE(port, 0)
    return Buffer.concat([ipBuf, portBuf])
  }))
}

/**
 * Also support this usage:
 *   string2compact.multi([ '10.10.10.5:128', '100.56.58.99:28525' ])
 *
 * for parallelism with the `compact2string` module.
 */
module.exports.multi = module.exports
module.exports.multi6 = module.exports

}).call(this,require("buffer").Buffer)

},{"addr-to-ip-port":3,"buffer":24,"ipaddr.js":70}],147:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":24}],148:[function(require,module,exports){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in      
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE.
*/

var base32 = require('./thirty-two');

exports.encode = base32.encode;
exports.decode = base32.decode;

},{"./thirty-two":149}],149:[function(require,module,exports){
(function (Buffer){
/*                                                                              
Copyright (c) 2011, Chris Umbel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.                                                                   
*/

var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var byteTable = [
    0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff
];

function quintetCount(buff) {
    var quintets = Math.floor(buff.length / 5);
    return buff.length % 5 == 0 ? quintets: quintets + 1;
}

exports.encode = function(plain) {
    if(!Buffer.isBuffer(plain)){
    	plain = new Buffer(plain);
    }
    var i = 0;
    var j = 0;
    var shiftIndex = 0;
    var digit = 0;
    var encoded = new Buffer(quintetCount(plain) * 8);

    /* byte by byte isn't as pretty as quintet by quintet but tests a bit
        faster. will have to revisit. */
    while(i < plain.length) {
        var current = plain[i];
    
        if(shiftIndex > 3) {
            digit = current & (0xff >> shiftIndex);
            shiftIndex = (shiftIndex + 5) % 8;
            digit = (digit << shiftIndex) | ((i + 1 < plain.length) ?
                plain[i + 1] : 0) >> (8 - shiftIndex);
            i++;
        } else {
            digit = (current >> (8 - (shiftIndex + 5))) & 0x1f;
            shiftIndex = (shiftIndex + 5) % 8;            
            if(shiftIndex == 0) i++;
        }
        
        encoded[j] = charTable.charCodeAt(digit);
        j++;
    }

    for(i = j; i < encoded.length; i++)
        encoded[i] = 0x3d; //'='.charCodeAt(0)
        
    return encoded;
};

exports.decode = function(encoded) {
    var shiftIndex = 0;
    var plainDigit = 0;
    var plainChar;
    var plainPos = 0;
    if(!Buffer.isBuffer(encoded)){
    	encoded = new Buffer(encoded);
    }
    var decoded = new Buffer(Math.ceil(encoded.length * 5 / 8));
    
    /* byte by byte isn't as pretty as octet by octet but tests a bit
        faster. will have to revisit. */    
    for(var i = 0; i < encoded.length; i++) {
    	if(encoded[i] == 0x3d){ //'='
    		break;
    	}
    		
        var encodedByte = encoded[i] - 0x30;
        
        if(encodedByte < byteTable.length) {
            plainDigit = byteTable[encodedByte];
            
            if(shiftIndex <= 3) {
                shiftIndex = (shiftIndex + 5) % 8;
                
                if(shiftIndex == 0) {
                    plainChar |= plainDigit;
                    decoded[plainPos] = plainChar;
                    plainPos++;
                    plainChar = 0;
                } else {
                    plainChar |= 0xff & (plainDigit << (8 - shiftIndex));
                }
            } else {
                shiftIndex = (shiftIndex + 5) % 8;
                plainChar |= 0xff & (plainDigit >>> shiftIndex);
                decoded[plainPos] = plainChar;
                plainPos++;

                plainChar = 0xff & (plainDigit << (8 - shiftIndex));
            }
        } else {
        	throw new Error('Invalid input - it is not base32 encoded string');
        }
    }
    return decoded.slice(0, plainPos);
};

}).call(this,require("buffer").Buffer)

},{"buffer":24}],150:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],151:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":24}],152:[function(require,module,exports){
(function (process){
module.exports = Discovery

var debug = require('debug')('torrent-discovery')
var DHT = require('bittorrent-dht/client') // empty object in browser
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var inherits = require('inherits')
var parallel = require('run-parallel')
var Tracker = require('bittorrent-tracker/client')

inherits(Discovery, EventEmitter)

function Discovery (opts) {
  var self = this
  if (!(self instanceof Discovery)) return new Discovery(opts)
  EventEmitter.call(self)

  if (!opts.peerId) throw new Error('Option `peerId` is required')
  if (!opts.infoHash) throw new Error('Option `infoHash` is required')
  if (!process.browser && !opts.port) throw new Error('Option `port` is required')

  self.peerId = typeof opts.peerId === 'string'
    ? opts.peerId
    : opts.peerId.toString('hex')
  self.infoHash = typeof opts.infoHash === 'string'
    ? opts.infoHash
    : opts.infoHash.toString('hex')
  self._port = opts.port // torrent port

  self.destroyed = false

  self._announce = opts.announce || []
  self._intervalMs = opts.intervalMs || (15 * 60 * 1000)
  self._trackerOpts = null
  self._dhtAnnouncing = false
  self._dhtTimeout = false
  self._internalDHT = false // is the DHT created internally?

  self._onWarning = function (err) {
    self.emit('warning', err)
  }
  self._onError = function (err) {
    self.emit('error', err)
  }
  self._onDHTPeer = function (peer, infoHash) {
    if (infoHash.toString('hex') !== self.infoHash) return
    self.emit('peer', peer.host + ':' + peer.port)
  }
  self._onTrackerPeer = function (peer) {
    self.emit('peer', peer)
  }
  self._onTrackerAnnounce = function () {
    self.emit('trackerAnnounce')
  }

  if (opts.tracker === false) {
    self.tracker = null
  } else if (opts.tracker && typeof opts.tracker === 'object') {
    self._trackerOpts = extend(opts.tracker)
    self.tracker = self._createTracker()
  } else {
    self.tracker = self._createTracker()
  }

  if (opts.dht === false || typeof DHT !== 'function') {
    self.dht = null
  } else if (opts.dht && typeof opts.dht.addNode === 'function') {
    self.dht = opts.dht
  } else if (opts.dht && typeof opts.dht === 'object') {
    self.dht = createDHT(opts.dhtPort, opts.dht)
  } else {
    self.dht = createDHT(opts.dhtPort)
  }

  if (self.dht) {
    self.dht.on('peer', self._onDHTPeer)
    self._dhtAnnounce()
  }

  function createDHT (port, opts) {
    var dht = new DHT(opts)
    dht.on('warning', self._onWarning)
    dht.on('error', self._onError)
    dht.listen(port)
    self._internalDHT = true
    return dht
  }
}

Discovery.prototype.updatePort = function (port) {
  var self = this
  if (port === self._port) return
  self._port = port

  if (self.dht) self._dhtAnnounce()

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.destroy(function () {
      self.tracker = self._createTracker()
    })
  }
}

Discovery.prototype.destroy = function (cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true

  clearTimeout(self._dhtTimeout)

  var tasks = []

  if (self.tracker) {
    self.tracker.stop()
    self.tracker.removeListener('warning', self._onWarning)
    self.tracker.removeListener('error', self._onError)
    self.tracker.removeListener('peer', self._onTrackerPeer)
    self.tracker.removeListener('update', self._onTrackerAnnounce)
    tasks.push(function (cb) {
      self.tracker.destroy(cb)
    })
  }

  if (self.dht) {
    self.dht.removeListener('peer', self._onDHTPeer)
  }

  if (self._internalDHT) {
    self.dht.removeListener('warning', self._onWarning)
    self.dht.removeListener('error', self._onError)
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  // cleanup
  self.dht = null
  self.tracker = null
  self._announce = null
}

Discovery.prototype._createTracker = function () {
  var self = this

  var opts = extend(self._trackerOpts, {
    infoHash: self.infoHash,
    announce: self._announce,
    peerId: self.peerId,
    port: self._port
  })

  var tracker = new Tracker(opts)
  tracker.on('warning', self._onWarning)
  tracker.on('error', self._onError)
  tracker.on('peer', self._onTrackerPeer)
  tracker.on('update', self._onTrackerAnnounce)
  tracker.setInterval(self._intervalMs)
  tracker.start()
  return tracker
}

Discovery.prototype._dhtAnnounce = function () {
  var self = this
  if (self._dhtAnnouncing) return
  debug('dht announce')

  self._dhtAnnouncing = true
  clearTimeout(self._dhtTimeout)

  self.dht.announce(self.infoHash, self._port, function (err) {
    self._dhtAnnouncing = false
    debug('dht announce complete')

    if (err) self.emit('warning', err)
    self.emit('dhtAnnounce')

    if (!self.destroyed) {
      self._dhtTimeout = setTimeout(function () {
        self._dhtAnnounce()
      }, getRandomTimeout())
      if (self._dhtTimeout.unref) self._dhtTimeout.unref()
    }
  })

  // Returns timeout interval, with some random jitter
  function getRandomTimeout () {
    return self._intervalMs + Math.floor(Math.random() * self._intervalMs / 5)
  }
}

}).call(this,require('_process'))

},{"_process":102,"bittorrent-dht/client":21,"bittorrent-tracker/client":14,"debug":39,"events":57,"inherits":69,"run-parallel":119,"xtend":181}],153:[function(require,module,exports){
(function (Buffer){
module.exports = Piece

var BLOCK_LENGTH = 1 << 14

function Piece (length) {
  if (!(this instanceof Piece)) return new Piece(length)

  this.length = length
  this.missing = length
  this.sources = null

  this._chunks = Math.ceil(length / BLOCK_LENGTH)
  this._remainder = (length % BLOCK_LENGTH) || BLOCK_LENGTH
  this._buffered = 0
  this._buffer = null
  this._cancellations = null
  this._reservations = 0
  this._flushed = false
}

Piece.BLOCK_LENGTH = BLOCK_LENGTH

Piece.prototype.chunkLength = function (i) {
  return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH
}

Piece.prototype.chunkLengthRemaining = function (i) {
  return this.length - (i * BLOCK_LENGTH)
}

Piece.prototype.chunkOffset = function (i) {
  return i * BLOCK_LENGTH
}

Piece.prototype.reserve = function () {
  if (!this.init()) return -1
  if (this._cancellations.length) return this._cancellations.pop()
  if (this._reservations < this._chunks) return this._reservations++
  return -1
}

Piece.prototype.reserveRemaining = function () {
  if (!this.init()) return -1
  if (this._reservations < this._chunks) {
    var min = this._reservations
    this._reservations = this._chunks
    return min
  }
  return -1
}

Piece.prototype.cancel = function (i) {
  if (!this.init()) return
  this._cancellations.push(i)
}

Piece.prototype.cancelRemaining = function (i) {
  if (!this.init()) return
  this._reservations = i
}

Piece.prototype.get = function (i) {
  if (!this.init()) return null
  return this._buffer[i]
}

Piece.prototype.set = function (i, data, source) {
  if (!this.init()) return false
  var len = data.length
  var blocks = Math.ceil(len / BLOCK_LENGTH)
  for (var j = 0; j < blocks; j++) {
    if (!this._buffer[i + j]) {
      var offset = j * BLOCK_LENGTH
      var splitData = data.slice(offset, offset + BLOCK_LENGTH)
      this._buffered++
      this._buffer[i + j] = splitData
      this.missing -= splitData.length
      if (this.sources.indexOf(source) === -1) {
        this.sources.push(source)
      }
    }
  }
  return this._buffered === this._chunks
}

Piece.prototype.flush = function () {
  if (!this._buffer || this._chunks !== this._buffered) return null
  var buffer = Buffer.concat(this._buffer, this.length)
  this._buffer = null
  this._cancellations = null
  this.sources = null
  this._flushed = true
  return buffer
}

Piece.prototype.init = function () {
  if (this._flushed) return false
  if (this._buffer) return true
  this._buffer = new Array(this._chunks)
  this._cancellations = []
  this.sources = []
  return true
}

}).call(this,require("buffer").Buffer)

},{"buffer":24}],154:[function(require,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = new Buffer(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to the `Buffer` constructor
    return new Buffer(arr)
  }
}

}).call(this,require("buffer").Buffer)

},{"buffer":24,"is-typedarray":74}],155:[function(require,module,exports){
(function (Buffer){
var UINT_32_MAX = 0xffffffff

exports.encodingLength = function () {
  return 8
}

exports.encode = function (num, buf, offset) {
  if (!buf) buf = new Buffer(8)
  if (!offset) offset = 0

  var top = Math.floor(num / UINT_32_MAX)
  var rem = num - top * UINT_32_MAX

  buf.writeUInt32BE(top, offset)
  buf.writeUInt32BE(rem, offset + 4)
  return buf
}

exports.decode = function (buf, offset) {
  if (!offset) offset = 0

  if (!buf) buf = new Buffer(4)
  if (!offset) offset = 0

  var top = buf.readUInt32BE(offset)
  var rem = buf.readUInt32BE(offset + 4)

  return top * UINT_32_MAX + rem
}

exports.encode.bytes = 8
exports.decode.bytes = 8

}).call(this,require("buffer").Buffer)

},{"buffer":24}],156:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],157:[function(require,module,exports){
module.exports = remove

function remove (arr, i) {
  if (i >= arr.length || i < 0) return
  var last = arr.pop()
  if (i < arr.length) {
    var tmp = arr[i]
    arr[i] = last
    return tmp
  }
  return last
}

},{}],158:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":159,"punycode":104,"querystring":107}],159:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],160:[function(require,module,exports){
var bencode = require('bencode')
var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('ut_metadata')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var sha1 = require('simple-sha1')

var MAX_METADATA_SIZE = 10000000 // 10MB
var BITFIELD_GROW = 1000
var PIECE_LENGTH = 16 * 1024

module.exports = function (metadata) {
  inherits(utMetadata, EventEmitter)

  function utMetadata (wire) {
    EventEmitter.call(this)

    this._wire = wire

    this._metadataComplete = false
    this._metadataSize = null
    this._remainingRejects = null // how many reject messages to tolerate before quitting
    this._fetching = false

    // The largest .torrent file that I know of is ~1-2MB, which is ~100 pieces.
    // Therefore, cap the bitfield to 10x that (1000 pieces) so a malicious peer can't
    // make it grow to fill all memory.
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })

    if (Buffer.isBuffer(metadata)) {
      this.setMetadata(metadata)
    }
  }

  // Name of the bittorrent-protocol extension
  utMetadata.prototype.name = 'ut_metadata'

  utMetadata.prototype.onHandshake = function (infoHash, peerId, extensions) {
    this._infoHash = infoHash
  }

  utMetadata.prototype.onExtendedHandshake = function (handshake) {
    if (!handshake.m || !handshake.m.ut_metadata) {
      return this.emit('warning', new Error('Peer does not support ut_metadata'))
    }
    if (!handshake.metadata_size) {
      return this.emit('warning', new Error('Peer does not have metadata'))
    }
    if (typeof handshake.metadata_size !== 'number' ||
        MAX_METADATA_SIZE < handshake.metadata_size ||
        handshake.metadata_size <= 0) {
      return this.emit('warning', new Error('Peer gave invalid metadata size'))
    }

    this._metadataSize = handshake.metadata_size
    this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH)
    this._remainingRejects = this._numPieces * 2

    if (this._fetching) {
      this._requestPieces()
    }
  }

  utMetadata.prototype.onMessage = function (buf) {
    var dict, trailer
    try {
      var str = buf.toString()
      var trailerIndex = str.indexOf('ee') + 2
      dict = bencode.decode(str.substring(0, trailerIndex))
      trailer = buf.slice(trailerIndex)
    } catch (err) {
      // drop invalid messages
      return
    }

    switch (dict.msg_type) {
      case 0:
        // ut_metadata request (from peer)
        // example: { 'msg_type': 0, 'piece': 0 }
        this._onRequest(dict.piece)
        break
      case 1:
        // ut_metadata data (in response to our request)
        // example: { 'msg_type': 1, 'piece': 0, 'total_size': 3425 }
        this._onData(dict.piece, trailer, dict.total_size)
        break
      case 2:
        // ut_metadata reject (peer doesn't have piece we requested)
        // { 'msg_type': 2, 'piece': 0 }
        this._onReject(dict.piece)
        break
    }
  }

  /**
   * Ask the peer to send metadata.
   * @public
   */
  utMetadata.prototype.fetch = function () {
    if (this._metadataComplete) {
      return
    }
    this._fetching = true
    if (this._metadataSize) {
      this._requestPieces()
    }
  }

  /**
   * Stop asking the peer to send metadata.
   * @public
   */
  utMetadata.prototype.cancel = function () {
    this._fetching = false
  }

  utMetadata.prototype.setMetadata = function (metadata) {
    if (this._metadataComplete) return true
    debug('set metadata')

    // if full torrent dictionary was passed in, pull out just `info` key
    try {
      var info = bencode.decode(metadata).info
      if (info) {
        metadata = bencode.encode(info)
      }
    } catch (err) {}

    // check hash
    if (this._infoHash && this._infoHash !== sha1.sync(metadata)) {
      return false
    }

    this.cancel()

    this.metadata = metadata
    this._metadataComplete = true
    this._metadataSize = this.metadata.length
    this._wire.extendedHandshake.metadata_size = this._metadataSize

    this.emit('metadata', bencode.encode({ info: bencode.decode(this.metadata) }))

    return true
  }

  utMetadata.prototype._send = function (dict, trailer) {
    var buf = bencode.encode(dict)
    if (Buffer.isBuffer(trailer)) {
      buf = Buffer.concat([buf, trailer])
    }
    this._wire.extended('ut_metadata', buf)
  }

  utMetadata.prototype._request = function (piece) {
    this._send({ msg_type: 0, piece: piece })
  }

  utMetadata.prototype._data = function (piece, buf, totalSize) {
    var msg = { msg_type: 1, piece: piece }
    if (typeof totalSize === 'number') {
      msg.total_size = totalSize
    }
    this._send(msg, buf)
  }

  utMetadata.prototype._reject = function (piece) {
    this._send({ msg_type: 2, piece: piece })
  }

  utMetadata.prototype._onRequest = function (piece) {
    if (!this._metadataComplete) {
      this._reject(piece)
      return
    }
    var start = piece * PIECE_LENGTH
    var end = start + PIECE_LENGTH
    if (end > this._metadataSize) {
      end = this._metadataSize
    }
    var buf = this.metadata.slice(start, end)
    this._data(piece, buf, this._metadataSize)
  }

  utMetadata.prototype._onData = function (piece, buf, totalSize) {
    if (buf.length > PIECE_LENGTH) {
      return
    }
    buf.copy(this.metadata, piece * PIECE_LENGTH)
    this._bitfield.set(piece)
    this._checkDone()
  }

  utMetadata.prototype._onReject = function (piece) {
    if (this._remainingRejects > 0 && this._fetching) {
      // If we haven't been rejected too much, then try to request the piece again
      this._request(piece)
      this._remainingRejects -= 1
    } else {
      this.emit('warning', new Error('Peer sent "reject" too much'))
    }
  }

  utMetadata.prototype._requestPieces = function () {
    this.metadata = Buffer.alloc(this._metadataSize)
    for (var piece = 0; piece < this._numPieces; piece++) {
      this._request(piece)
    }
  }

  utMetadata.prototype._checkDone = function () {
    var done = true
    for (var piece = 0; piece < this._numPieces; piece++) {
      if (!this._bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) return

    // attempt to set metadata -- may fail sha1 check
    var success = this.setMetadata(this.metadata)

    if (!success) {
      this._failedMetadata()
    }
  }

  utMetadata.prototype._failedMetadata = function () {
    // reset bitfield & try again
    this._bitfield = new BitField(0, { grow: BITFIELD_GROW })
    this._remainingRejects -= this._numPieces
    if (this._remainingRejects > 0) {
      this._requestPieces()
    } else {
      this.emit('warning', new Error('Peer sent invalid metadata'))
    }
  }

  return utMetadata
}

},{"bencode":10,"bitfield":12,"debug":39,"events":57,"inherits":69,"safe-buffer":121,"simple-sha1":125}],161:[function(require,module,exports){
(function (Buffer){
/* jshint camelcase: false */

// TODO: ipv6 support
// TODO: parse and send peer flags (currently unused)
// NOTE: addPeer should take in an optional second argument, flags
// TODO: destroy wire if peer sends PEX messages too frequently

var EventEmitter = require('events').EventEmitter
var compact2string = require('compact2string')
var string2compact = require('string2compact')
var bencode = require('bencode')
var inherits = require('inherits')

var PEX_INTERVAL = 65000 // just over one minute
var PEX_MAX_PEERS = 50    // max number of peers to advertise per PEX message

module.exports = function () {
  inherits(ut_pex, EventEmitter)

  function ut_pex (wire) {
    var self = this
    EventEmitter.call(self)

    self._wire = wire
    self._intervalId = null

    self.reset()
  }

  ut_pex.prototype.name = 'ut_pex'

  /**
   * Start sending regular PEX updates to remote peer.
   */
  ut_pex.prototype.start = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = setInterval(self._sendMessage.bind(self), PEX_INTERVAL)
    if (self._intervalId.unref) self._intervalId.unref()
  }

  /**
   * Stop sending PEX updates to the remote peer.
   */
  ut_pex.prototype.stop = function () {
    var self = this
    clearInterval(self._intervalId)
    self._intervalId = null
  }

  /**
   * Stops sending updates to the remote peer and resets internal state of peers seen.
   */
  ut_pex.prototype.reset = function () {
    var self = this
    self._remoteAddedPeers = {}
    self._remoteDroppedPeers = {}
    self._localAddedPeers = {}
    self._localDroppedPeers = {}
    self.stop()
  }

  /**
   * Adds a peer to the locally discovered peer list for the next PEX message.
   */
  ut_pex.prototype.addPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteAddedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localDroppedPeers) delete self._localDroppedPeers[peer]
    self._localAddedPeers[peer] = true
  }

  /**
   * Adds a peer to the locally dropped peer list for the next PEX message.
   */
  ut_pex.prototype.dropPeer = function (peer) {
    var self = this
    if (peer.indexOf(':') < 0) return // disregard invalid peers
    if (peer in self._remoteDroppedPeers) return // never advertise peer the remote wire already sent us
    if (peer in self._localAddedPeers) delete self._localAddedPeers[peer]
    self._localDroppedPeers[peer] = true
  }

  ut_pex.prototype.onExtendedHandshake = function (handshake) {
    var self = this
    if (!handshake.m || !handshake.m.ut_pex) {
      return self.emit('warning', new Error('Peer does not support ut_pex'))
    }
  }

  /**
   * PEX messages are bencoded dictionaries with the following keys:
   * 'added'     : array of peers met since last PEX message
   * 'added.f'   : array of flags per peer
   *  '0x01'     : peer prefers encryption
   *  '0x02'     : peer is seeder
   * 'dropped'   : array of peers locally dropped from swarm since last PEX message
   * 'added6'    : ipv6 version of 'added'
   * 'added6.f'  : ipv6 version of 'added.f'
   * 'dropped.f' : ipv6 version of 'dropped'
   *
   * @param {Buffer} buf bencoded PEX dictionary
   */
  ut_pex.prototype.onMessage = function (buf) {
    var self = this
    var message

    try {
      message = bencode.decode(buf)
    } catch (err) {
      // drop invalid messages
      return
    }

    if (message.added) {
      compact2string.multi(message.added).forEach(function (peer) {
        delete self._remoteDroppedPeers[peer]
        if (!(peer in self._remoteAddedPeers)) {
          self._remoteAddedPeers[peer] = true
          self.emit('peer', peer)
        }
      })
    }

    if (message.dropped) {
      compact2string.multi(message.dropped).forEach(function (peer) {
        delete self._remoteAddedPeers[peer]
        if (!(peer in self._remoteDroppedPeers)) {
          self._remoteDroppedPeers[peer] = true
          self.emit('dropped', peer)
        }
      })
    }
  }

  /**
   * Sends a PEX message to the remote peer including information about any locally
   * added / dropped peers.
   */
  ut_pex.prototype._sendMessage = function () {
    var self = this

    var localAdded = Object.keys(self._localAddedPeers).slice(0, PEX_MAX_PEERS)
    var localDropped = Object.keys(self._localDroppedPeers).slice(0, PEX_MAX_PEERS)

    var added = Buffer.concat(localAdded.map(string2compact))
    var dropped = Buffer.concat(localDropped.map(string2compact))

    var addedFlags = Buffer.concat(localAdded.map(function () {
      // TODO: support flags
      return new Buffer([0])
    }))

    // update local deltas
    localAdded.forEach(function (peer) { delete self._localAddedPeers[peer] })
    localDropped.forEach(function (peer) { delete self._localDroppedPeers[peer] })

    // send PEX message
    self._wire.extended('ut_pex', {
      'added': added,
      'added.f': addedFlags,
      'dropped': dropped,
      'added6': new Buffer(0),
      'added6.f': new Buffer(0),
      'dropped6': new Buffer(0)
    })
  }

  return ut_pex
}

}).call(this,require("buffer").Buffer)

},{"bencode":162,"buffer":24,"compact2string":29,"events":57,"inherits":69,"string2compact":146}],162:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./lib/decode":163,"./lib/encode":165,"dup":35}],163:[function(require,module,exports){
(function (Buffer){
var Dict = require("./dict")

/**
 * Decodes bencoded data.
 *
 * @param  {Buffer} data
 * @param  {Number} start (optional)
 * @param  {Number} end (optional)
 * @param  {String} encoding (optional)
 * @return {Object|Array|Buffer|String|Number}
 */
function decode( data, start, end, encoding ) {
  
  if( typeof start !== 'number' && encoding == null ) {
    encoding = start
    start = undefined
  }
  
  if( typeof end !== 'number' && encoding == null ) {
    encoding = end
    end = undefined
  }
  
  decode.position = 0
  decode.encoding = encoding || null

  decode.data = !( Buffer.isBuffer(data) )
    ? new Buffer( data )
    : data.slice( start, end )
  
  decode.bytes = decode.data.length
  
  return decode.next()

}

decode.bytes = 0
decode.position = 0
decode.data     = null
decode.encoding = null

decode.next = function() {

  switch( decode.data[decode.position] ) {
    case 0x64: return decode.dictionary(); break
    case 0x6C: return decode.list(); break
    case 0x69: return decode.integer(); break
    default:   return decode.buffer(); break
  }

}

decode.find = function( chr ) {

  var i = decode.position
  var c = decode.data.length
  var d = decode.data

  while( i < c ) {
    if( d[i] === chr )
      return i
    i++
  }

  throw new Error(
    'Invalid data: Missing delimiter "' +
    String.fromCharCode( chr ) + '" [0x' +
    chr.toString( 16 ) + ']'
  )

}

decode.dictionary = function() {

  decode.position++

  var dict = new Dict()

  while( decode.data[decode.position] !== 0x65 ) {
    dict.binarySet(decode.buffer(), decode.next())
  }

  decode.position++

  return dict

}

decode.list = function() {

  decode.position++

  var lst = []

  while( decode.data[decode.position] !== 0x65 ) {
    lst.push( decode.next() )
  }

  decode.position++

  return lst

}

decode.integer = function() {

  var end    = decode.find( 0x65 )
  var number = decode.data.toString( 'ascii', decode.position + 1, end )

  decode.position += end + 1 - decode.position

  return parseInt( number, 10 )

}

decode.buffer = function() {

  var sep    = decode.find( 0x3A )
  var length = parseInt( decode.data.toString( 'ascii', decode.position, sep ), 10 )
  var end    = ++sep + length

  decode.position = end

  return decode.encoding
    ? decode.data.toString( decode.encoding, sep, end )
    : decode.data.slice( sep, end )

}

// Exports
module.exports = decode

}).call(this,require("buffer").Buffer)

},{"./dict":164,"buffer":24}],164:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],165:[function(require,module,exports){
(function (Buffer){
/**
 * Encodes data in bencode.
 *
 * @param  {Buffer|Array|String|Object|Number|Boolean} data
 * @return {Buffer}
 */
function encode( data, buffer, offset ) {
  
  var buffers = []
  var result = null
  
  encode._encode( buffers, data )
  result = Buffer.concat( buffers )
  encode.bytes = result.length
  
  if( Buffer.isBuffer( buffer ) ) {
    result.copy( buffer, offset )
    return buffer
  }
  
  return result
  
}

encode.bytes = -1
encode._floatConversionDetected = false

encode._encode = function( buffers, data ) {

  if( Buffer.isBuffer(data) ) {
    buffers.push(new Buffer(data.length + ':'))
    buffers.push(data)
    return;
  }

  switch( typeof data ) {
    case 'string':
      encode.buffer( buffers, data )
      break
    case 'number':
      encode.number( buffers, data )
      break
    case 'object':
      data.constructor === Array
        ? encode.list( buffers, data )
        : encode.dict( buffers, data )
      break
    case 'boolean':
      encode.number( buffers, data ? 1 : 0 )
      break
  }

}

var buff_e = new Buffer('e')
  , buff_d = new Buffer('d')
  , buff_l = new Buffer('l')

encode.buffer = function( buffers, data ) {

  buffers.push( new Buffer(Buffer.byteLength( data ) + ':' + data) )
}

encode.number = function( buffers, data ) {
  var maxLo = 0x80000000
  var hi = ( data / maxLo ) << 0
  var lo = ( data % maxLo  ) << 0
  var val = hi * maxLo + lo

  buffers.push( new Buffer( 'i' + val + 'e' ))

  if( val !== data && !encode._floatConversionDetected ) {
    encode._floatConversionDetected = true
    console.warn(
      'WARNING: Possible data corruption detected with value "'+data+'":',
      'Bencoding only defines support for integers, value was converted to "'+val+'"'
    )
    console.trace()
  }

}

encode.dict = function( buffers, data ) {

  buffers.push( buff_d )

  var j = 0
  var k
  // fix for issue #13 - sorted dicts
  var keys = Object.keys( data ).sort()
  var kl = keys.length

  for( ; j < kl ; j++) {
    k=keys[j]
    encode.buffer( buffers, k )
    encode._encode( buffers, data[k] )
  }

  buffers.push( buff_e )
}

encode.list = function( buffers, data ) {

  var i = 0, j = 1
  var c = data.length
  buffers.push( buff_l )

  for( ; i < c; i++ ) {
    encode._encode( buffers, data[i] )
  }

  buffers.push( buff_e )

}

// Expose
module.exports = encode

}).call(this,require("buffer").Buffer)

},{"buffer":24}],166:[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],167:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],168:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],169:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":168,"_process":102,"inherits":69}],170:[function(require,module,exports){
(function (Buffer){
var bs = require('binary-search')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var mp4 = require('mp4-stream')
var Box = require('mp4-box-encoding')
var RangeSliceStream = require('range-slice-stream')

module.exports = MP4Remuxer

function MP4Remuxer (file) {
	var self = this
	EventEmitter.call(self)
	self._tracks = []
	self._fragmentSequence = 1
	self._file = file
	self._decoder = null
	self._findMoov(0)
}

inherits(MP4Remuxer, EventEmitter)

MP4Remuxer.prototype._findMoov = function (offset) {
	var self = this

	if (self._decoder) {
		self._decoder.destroy()
	}

	self._decoder = mp4.decode()
	var fileStream = self._file.createReadStream({
		start: offset
	})
	fileStream.pipe(self._decoder)

	self._decoder.once('box', function (headers) {
		if (headers.type === 'moov') {
			self._decoder.decode(function (moov) {
				fileStream.destroy()
				try {
					self._processMoov(moov)
				} catch (err) {
					err.message = 'Cannot parse mp4 file: ' + err.message
					self.emit('error', err)
				}
			})
		} else {
			fileStream.destroy()
			self._findMoov(offset + headers.length)
		}
	})
}

function RunLengthIndex (entries, countName) {
	var self = this
	self._entries = entries
	self._countName = countName || 'count'
	self._index = 0
	self._offset = 0

	self.value = self._entries[0]
}

RunLengthIndex.prototype.inc = function () {
	var self = this
	self._offset++
	if (self._offset >= self._entries[self._index][self._countName]) {
		self._index++
		self._offset = 0
	}

	self.value = self._entries[self._index]
}

MP4Remuxer.prototype._processMoov = function (moov) {
	var self = this

	var traks = moov.traks
	self._tracks = []
	self._hasVideo = false
	self._hasAudio = false
	for (var i = 0; i < traks.length; i++) {
		var trak = traks[i]
		var stbl = trak.mdia.minf.stbl
		var stsdEntry = stbl.stsd.entries[0]
		var handlerType = trak.mdia.hdlr.handlerType
		var codec
		var mime
		if (handlerType === 'vide' && stsdEntry.type === 'avc1') {
			if (self._hasVideo) {
				continue
			}
			self._hasVideo = true
			codec = 'avc1'
			if (stsdEntry.avcC) {
				codec += '.' + stsdEntry.avcC.mimeCodec
			}
			mime = 'video/mp4; codecs="' + codec + '"'
		} else if (handlerType === 'soun' && stsdEntry.type === 'mp4a') {
			if (self._hasAudio) {
				continue
			}
			self._hasAudio = true
			codec = 'mp4a'
			if (stsdEntry.esds && stsdEntry.esds.mimeCodec) {
				codec += '.' + stsdEntry.esds.mimeCodec
			}
			mime = 'audio/mp4; codecs="' + codec + '"'
		} else {
			continue
		}

		var samples = []
		var sample = 0

		// Chunk/position data
		var sampleInChunk = 0
		var chunk = 0
		var offsetInChunk = 0
		var sampleToChunkIndex = 0

		// Time data
		var dts = 0
		var decodingTimeEntry = new RunLengthIndex(stbl.stts.entries)
		var presentationOffsetEntry = null
		if (stbl.ctts) {
			presentationOffsetEntry = new RunLengthIndex(stbl.ctts.entries)
		}

		// Sync table index
		var syncSampleIndex = 0

		while (true) {
			var currChunkEntry = stbl.stsc.entries[sampleToChunkIndex]

			// Compute size
			var size = stbl.stsz.entries[sample]

			// Compute time data
			var duration = decodingTimeEntry.value.duration
			var presentationOffset = presentationOffsetEntry ? presentationOffsetEntry.value.compositionOffset : 0

			// Compute sync
			var sync = true
			if (stbl.stss) {
				sync = stbl.stss.entries[syncSampleIndex] === sample + 1
			}

			// Create new sample entry
			samples.push({
				size: size,
				duration: duration,
				dts: dts,
				presentationOffset: presentationOffset,
				sync: sync,
				offset: offsetInChunk + stbl.stco.entries[chunk]
			})

			// Go to next sample
			sample++
			if (sample >= stbl.stsz.entries.length) {
				break
			}

			// Move position/chunk
			sampleInChunk++
			offsetInChunk += size
			if (sampleInChunk >= currChunkEntry.samplesPerChunk) {
				// Move to new chunk
				sampleInChunk = 0
				offsetInChunk = 0
				chunk++
				// Move sample to chunk box index
				var nextChunkEntry = stbl.stsc.entries[sampleToChunkIndex + 1]
				if (nextChunkEntry && chunk + 1 >= nextChunkEntry.firstChunk) {
					sampleToChunkIndex++
				}
			}

			// Move time forward
			dts += duration
			decodingTimeEntry.inc()
			presentationOffsetEntry && presentationOffsetEntry.inc()

			// Move sync table index
			if (sync) {
				syncSampleIndex++
			}
		}

		trak.mdia.mdhd.duration = 0
		trak.tkhd.duration = 0

		var defaultSampleDescriptionIndex = currChunkEntry.sampleDescriptionId

		var trackMoov = {
			type: 'moov',
			mvhd: moov.mvhd,
			traks: [{
				tkhd: trak.tkhd,
				mdia: {
					mdhd: trak.mdia.mdhd,
					hdlr: trak.mdia.hdlr,
					elng: trak.mdia.elng,
					minf: {
						vmhd: trak.mdia.minf.vmhd,
						smhd: trak.mdia.minf.smhd,
						dinf: trak.mdia.minf.dinf,
						stbl: {
							stsd: stbl.stsd,
							stts: empty(),
							ctts: empty(),
							stsc: empty(),
							stsz: empty(),
							stco: empty(),
							stss: empty()
						}
					}
				}
			}],
			mvex: {
				mehd: {
					fragmentDuration: moov.mvhd.duration
				},
				trexs: [{
					trackId: trak.tkhd.trackId,
					defaultSampleDescriptionIndex: defaultSampleDescriptionIndex,
					defaultSampleDuration: 0,
					defaultSampleSize: 0,
					defaultSampleFlags: 0
				}]
			}
		}

		self._tracks.push({
			trackId: trak.tkhd.trackId,
			timeScale: trak.mdia.mdhd.timeScale,
			samples: samples,
			currSample: null,
			currTime: null,
			moov: trackMoov,
			mime: mime
		})
	}

	if (self._tracks.length === 0) {
		self.emit('error', new Error('no playable tracks'))
		return
	}

	// Must be set last since this is used above
	moov.mvhd.duration = 0

	self._ftyp = {
		type: 'ftyp',
		brand: 'iso5',
		brandVersion: 0,
		compatibleBrands: [
			'iso5'
		]
	}

	var ftypBuf = Box.encode(self._ftyp)
	var data = self._tracks.map(function (track) {
		var moovBuf = Box.encode(track.moov)
		return {
			mime: track.mime,
			init: Buffer.concat([ftypBuf, moovBuf])
		}
	})

	self.emit('ready', data)
}

function empty () {
	return {
		version: 0,
		flags: 0,
		entries: []
	}
}

MP4Remuxer.prototype.seek = function (time) {
	var self = this
	if (!self._tracks) {
		throw new Error('Not ready yet; wait for \'ready\' event')
	}

	if (self._fileStream) {
		self._fileStream.destroy()
		self._fileStream = null
	}

	var startOffset = -1
	self._tracks.map(function (track, i) {
		// find the keyframe before the time
		// stream from there
		if (track.outStream) {
			track.outStream.destroy()
		}
		if (track.inStream) {
			track.inStream.destroy()
			track.inStream = null
		}
		var outStream = track.outStream = mp4.encode()
		var fragment = self._generateFragment(i, time)
		if (!fragment) {
			return outStream.finalize()
		}

		if (startOffset === -1 || fragment.ranges[0].start < startOffset) {
			startOffset = fragment.ranges[0].start
		}

		writeFragment(fragment)

		function writeFragment (frag) {
			if (outStream.destroyed) return
			outStream.box(frag.moof, function (err) {
				if (err) return self.emit('error', err)
				if (outStream.destroyed) return
				var slicedStream = track.inStream.slice(frag.ranges)
				slicedStream.pipe(outStream.mediaData(frag.length, function (err) {
					if (err) return self.emit('error', err)
					if (outStream.destroyed) return
					var nextFrag = self._generateFragment(i)
					if (!nextFrag) {
						return outStream.finalize()
					}
					writeFragment(nextFrag)
				}))
			})
		}
	})

	if (startOffset >= 0) {
		var fileStream = self._fileStream = self._file.createReadStream({
			start: startOffset
		})

		self._tracks.forEach(function (track) {
			track.inStream = new RangeSliceStream(startOffset)
			fileStream.pipe(track.inStream)
		})
	}

	return self._tracks.map(function (track) {
		return track.outStream
	})
}

MP4Remuxer.prototype._findSampleBefore = function (trackInd, time) {
	var self = this

	var track = self._tracks[trackInd]
	var scaledTime = Math.floor(track.timeScale * time)
	var sample = bs(track.samples, scaledTime, function (sample, t) {
		var pts = sample.dts + sample.presentationOffset// - track.editShift
		return pts - t
	})
	if (sample === -1) {
		sample = 0
	} else if (sample < 0) {
		sample = -sample - 2
	}
	// sample is now the last sample with dts <= time
	// Find the preceeding sync sample
	while (!track.samples[sample].sync) {
		sample--
	}
	return sample
}

var MIN_FRAGMENT_DURATION = 1 // second

MP4Remuxer.prototype._generateFragment = function (track, time) {
	var self = this
	/*
	1. Find correct sample
	2. Process backward until sync sample found
	3. Process forward until next sync sample after MIN_FRAGMENT_DURATION found
	*/
	var currTrack = self._tracks[track]
	var firstSample
	if (time !== undefined) {
		firstSample = self._findSampleBefore(track, time)
	} else {
		firstSample = currTrack.currSample
	}

	if (firstSample >= currTrack.samples.length)
		return null

	var startDts = currTrack.samples[firstSample].dts

	var totalLen = 0
	var ranges = []
	for (var currSample = firstSample; currSample < currTrack.samples.length; currSample++) {
		var sample = currTrack.samples[currSample]
		if (sample.sync && sample.dts - startDts >= currTrack.timeScale * MIN_FRAGMENT_DURATION) {
			break // This is a reasonable place to end the fragment
		}

		totalLen += sample.size
		var currRange = ranges.length - 1
		if (currRange < 0 || ranges[currRange].end !== sample.offset) {
			// Push a new range
			ranges.push({
				start: sample.offset,
				end: sample.offset + sample.size
			})
		} else {
			ranges[currRange].end += sample.size
		}
	}

	currTrack.currSample = currSample

	return {
		moof: self._generateMoof(track, firstSample, currSample),
		ranges: ranges,
		length: totalLen
	}
}

MP4Remuxer.prototype._generateMoof = function (track, firstSample, lastSample) {
	var self = this

	var currTrack = self._tracks[track]

	var entries = []
	for (var j = firstSample; j < lastSample; j++) {
		var currSample = currTrack.samples[j]
		entries.push({
			sampleDuration: currSample.duration,
			sampleSize: currSample.size,
			sampleFlags: currSample.sync ? 0x2000000 : 0x1010000,
			sampleCompositionTimeOffset: currSample.presentationOffset
		})
	}

	var moof = {
		type: 'moof',
		mfhd: {
			sequenceNumber: self._fragmentSequence++
		},
		trafs: [{
			tfhd: {
				flags: 0x20000, // default-base-is-moof
				trackId: currTrack.trackId
			},
			tfdt: {
				baseMediaDecodeTime: currTrack.samples[firstSample].dts
			},
			trun: {
				flags: 0xf01,
				dataOffset: 8, // The moof size has to be added to this later as well
				entries: entries
			}
		}]
	}

	// Update the offset
	moof.trafs[0].trun.dataOffset += Box.encodingLength(moof)

	return moof
}

}).call(this,require("buffer").Buffer)

},{"binary-search":11,"buffer":24,"events":57,"inherits":69,"mp4-box-encoding":82,"mp4-stream":85,"range-slice-stream":109}],171:[function(require,module,exports){
var MediaElementWrapper = require('mediasource')
var pump = require('pump')

var MP4Remuxer = require('./mp4-remuxer')

module.exports = VideoStream

function VideoStream (file, mediaElem, opts) {
	var self = this
	if (!(this instanceof VideoStream)) return new VideoStream(file, mediaElem, opts)
	opts = opts || {}

	self._elem = mediaElem
	self._elemWrapper = new MediaElementWrapper(mediaElem)
	self._waitingFired = false
	self._trackMeta = null
	self._file = file
	self._tracks = null
	if (self._elem.preload !== 'none') {
		self._createMuxer()
	}

	self._onError = function (err) {
		self.destroy() // don't pass err though so the user doesn't need to listen for errors
	}
	self._onWaiting = function () {
		self._waitingFired = true
		if (!self._muxer) {
			self._createMuxer()
		} else if (self._tracks) {
			self._pump()
		}
	}
	self._elem.addEventListener('waiting', self._onWaiting)
	self._elem.addEventListener('error', self._onError)
}

VideoStream.prototype._createMuxer = function () {
	var self = this
	self._muxer = new MP4Remuxer(self._file)
	self._muxer.on('ready', function (data) {
		self._tracks = data.map(function (trackData) {
			var mediaSource = self._elemWrapper.createWriteStream(trackData.mime)
			mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
			mediaSource.write(trackData.init)
			return {
				muxed: null,
				mediaSource: mediaSource
			}
		})

		if (self._waitingFired || self._elem.preload === 'auto') {
			self._pump()
		}
	})

	self._muxer.on('error', function (err) {
		self._elemWrapper.error(err)
	})
}

VideoStream.prototype._pump = function () {
	var self = this

	var muxed = self._muxer.seek(self._elem.currentTime, !self._tracks)

	self._tracks.forEach(function (track, i) {
		if (track.muxed) {
			track.muxed.destroy()
			track.mediaSource = self._elemWrapper.createWriteStream(track.mediaSource)
			track.mediaSource.on('error', function (err) {
				self._elemWrapper.error(err)
			})
		}
		track.muxed = muxed[i]
		pump(track.muxed, track.mediaSource)
	})
}

VideoStream.prototype.destroy = function () {
	var self = this
	if (self.destroyed) {
		return
	}
	self.destroyed = true

	self._elem.removeEventListener('waiting', self._onWaiting)
	self._elem.removeEventListener('error', self._onError)

	if (self._tracks) {
		self._tracks.forEach(function (track) {
			track.muxed.destroy()
		})
	}

	self._elem.src = ''
}

},{"./mp4-remuxer":170,"mediasource":78,"pump":103}],172:[function(require,module,exports){
(function (process,global){
module.exports = WebTorrent

var Buffer = require('safe-buffer').Buffer
var concat = require('simple-concat')
var createTorrent = require('create-torrent')
var debug = require('debug')('webtorrent')
var DHT = require('bittorrent-dht/client') // browser exclude
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var hat = require('hat')
var inherits = require('inherits')
var loadIPSet = require('load-ip-set') // browser exclude
var parallel = require('run-parallel')
var parseTorrent = require('parse-torrent')
var path = require('path')
var Peer = require('simple-peer')
var speedometer = require('speedometer')
var zeroFill = require('zero-fill')

var TCPPool = require('./lib/tcp-pool') // browser exclude
var Torrent = require('./lib/torrent')

/**
 * WebTorrent version.
 */
var VERSION = require('./package.json').version

/**
 * Version number in Azureus-style. Generated from major and minor semver version.
 * For example:
 *   '0.16.1' -> '0016'
 *   '1.2.5' -> '0102'
 */
var VERSION_STR = VERSION.match(/([0-9]+)/g).slice(0, 2).map(zeroFill(2)).join('')

/**
 * Version prefix string (used in peer ID). WebTorrent uses the Azureus-style
 * encoding: '-', two characters for client id ('WW'), four ascii digits for version
 * number, '-', followed by random numbers.
 * For example:
 *   '-WW0102-'...
 */
var VERSION_PREFIX = '-WW' + VERSION_STR + '-'

inherits(WebTorrent, EventEmitter)

/**
 * WebTorrent Client
 * @param {Object=} opts
 */
function WebTorrent (opts) {
  var self = this
  if (!(self instanceof WebTorrent)) return new WebTorrent(opts)
  EventEmitter.call(self)

  if (!opts) opts = {}

  if (typeof opts.peerId === 'string') {
    self.peerId = opts.peerId
  } else if (Buffer.isBuffer(opts.peerId)) {
    self.peerId = opts.peerId.toString('hex')
  } else {
    self.peerId = Buffer.from(VERSION_PREFIX + hat(48))
  }
  self.peerIdBuffer = Buffer.from(self.peerId, 'hex')

  if (typeof opts.nodeId === 'string') {
    self.nodeId = opts.nodeId
  } else if (Buffer.isBuffer(opts.nodeId)) {
    self.nodeId = opts.nodeId.toString('hex')
  } else {
    self.nodeId = hat(160)
  }
  self.nodeIdBuffer = Buffer.from(self.nodeId, 'hex')

  self.destroyed = false
  self.listening = false
  self.torrentPort = opts.torrentPort || 0
  self.dhtPort = opts.dhtPort || 0
  self.tracker = opts.tracker !== undefined ? opts.tracker : {}
  self.torrents = []
  self.maxConns = Number(opts.maxConns) || 55

  if (self.tracker) {
    if (typeof self.tracker !== 'object') self.tracker = {}
    if (opts.rtcConfig) {
      // TODO: remove in v1
      console.warn('WebTorrent: opts.rtcConfig is deprecated. Use opts.tracker.rtcConfig instead')
      self.tracker.rtcConfig = opts.rtcConfig
    }
    if (opts.wrtc) {
      // TODO: remove in v1
      console.warn('WebTorrent: opts.wrtc is deprecated. Use opts.tracker.wrtc instead')
      self.tracker.wrtc = opts.wrtc // to support `webtorrent-hybrid` package
    }
    if (global.WRTC && !self.tracker.wrtc) self.tracker.wrtc = global.WRTC
  }

  if (typeof TCPPool === 'function') {
    self._tcpPool = new TCPPool(self)
  } else {
    process.nextTick(function () {
      self._onListening()
    })
  }

  // stats
  self._downloadSpeed = speedometer()
  self._uploadSpeed = speedometer()

  if (opts.dht !== false && typeof DHT === 'function' /* browser exclude */) {
    // use a single DHT instance for all torrents, so the routing table can be reused
    self.dht = new DHT(extend({ nodeId: self.nodeId }, opts.dht))

    self.dht.once('error', function (err) {
      self._destroy(err)
    })

    self.dht.once('listening', function () {
      var address = self.dht.address()
      if (address) self.dhtPort = address.port
    })

    // Ignore warning when there are > 10 torrents in the client
    self.dht.setMaxListeners(0)

    self.dht.listen(self.dhtPort)
  } else {
    self.dht = false
  }

  debug('new webtorrent (peerId %s, nodeId %s)', self.peerId, self.nodeId)

  if (typeof loadIPSet === 'function') {
    loadIPSet(opts.blocklist, {
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'
      }
    }, function (err, ipSet) {
      if (err) return self.error('Failed to load blocklist: ' + err.message)
      self.blocked = ipSet
      ready()
    })
  } else process.nextTick(ready)

  function ready () {
    if (self.destroyed) return
    self.ready = true
    self.emit('ready')
  }
}

WebTorrent.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT

Object.defineProperty(WebTorrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(WebTorrent.prototype, 'progress', {
  get: function () {
    var torrents = this.torrents.filter(function (torrent) {
      return torrent.progress !== 1
    })
    var downloaded = torrents.reduce(function (total, torrent) {
      return total + torrent.downloaded
    }, 0)
    var length = torrents.reduce(function (total, torrent) {
      return total + (torrent.length || 0)
    }, 0) || 1
    return downloaded / length
  }
})

Object.defineProperty(WebTorrent.prototype, 'ratio', {
  get: function () {
    var uploaded = this.torrents.reduce(function (total, torrent) {
      return total + torrent.uploaded
    }, 0)
    var received = this.torrents.reduce(function (total, torrent) {
      return total + torrent.received
    }, 0) || 1
    return uploaded / received
  }
})

/**
 * Returns the torrent with the given `torrentId`. Convenience method. Easier than
 * searching through the `client.torrents` array. Returns `null` if no matching torrent
 * found.
 *
 * @param  {string|Buffer|Object|Torrent} torrentId
 * @return {Torrent|null}
 */
WebTorrent.prototype.get = function (torrentId) {
  var self = this
  var i, torrent
  var len = self.torrents.length

  if (torrentId instanceof Torrent) {
    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent === torrentId) return torrent
    }
  } else {
    var parsed
    try { parsed = parseTorrent(torrentId) } catch (err) {}

    if (!parsed) return null
    if (!parsed.infoHash) throw new Error('Invalid torrent identifier')

    for (i = 0; i < len; i++) {
      torrent = self.torrents[i]
      if (torrent.infoHash === parsed.infoHash) return torrent
    }
  }
  return null
}

// TODO: remove in v1
WebTorrent.prototype.download = function (torrentId, opts, ontorrent) {
  console.warn('WebTorrent: client.download() is deprecated. Use client.add() instead')
  return this.add(torrentId, opts, ontorrent)
}

/**
 * Start downloading a new torrent. Aliased as `client.download`.
 * @param {string|Buffer|Object} torrentId
 * @param {Object} opts torrent-specific options
 * @param {function=} ontorrent called when the torrent is ready (has metadata)
 */
WebTorrent.prototype.add = function (torrentId, opts, ontorrent) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.add(torrentId, null, opts)

  debug('add')
  opts = opts ? extend(opts) : {}

  var torrent = new Torrent(torrentId, self, opts)
  self.torrents.push(torrent)

  torrent.once('_infoHash', onInfoHash)
  torrent.once('ready', onReady)
  torrent.once('close', onClose)

  function onInfoHash () {
    if (self.destroyed) return
    for (var i = 0, len = self.torrents.length; i < len; i++) {
      var t = self.torrents[i]
      if (t.infoHash === torrent.infoHash && t !== torrent) {
        torrent._destroy(new Error('Cannot add duplicate torrent ' + torrent.infoHash))
        return
      }
    }
  }

  function onReady () {
    if (self.destroyed) return
    if (typeof ontorrent === 'function') ontorrent(torrent)
    self.emit('torrent', torrent)
  }

  function onClose () {
    torrent.removeListener('_infoHash', onInfoHash)
    torrent.removeListener('ready', onReady)
    torrent.removeListener('close', onClose)
  }

  return torrent
}

/**
 * Start seeding a new file/folder.
 * @param  {string|File|FileList|Buffer|Array.<string|File|Buffer>} input
 * @param  {Object=} opts
 * @param  {function=} onseed called when torrent is seeding
 */
WebTorrent.prototype.seed = function (input, opts, onseed) {
  var self = this
  if (self.destroyed) throw new Error('client is destroyed')
  if (typeof opts === 'function') return self.seed(input, null, opts)

  debug('seed')
  opts = opts ? extend(opts) : {}

  // When seeding from fs path, initialize store from that path to avoid a copy
  if (typeof input === 'string') opts.path = path.dirname(input)
  if (!opts.createdBy) opts.createdBy = 'WebTorrent/' + VERSION_STR
  if (!self.tracker) opts.announce = []

  var torrent = self.add(null, opts, onTorrent)
  var streams

  if (!Array.isArray(input)) input = [ input ]
  parallel(input.map(function (item) {
    return function (cb) {
      if (isReadable(item)) concat(item, cb)
      else cb(null, item)
    }
  }), function (err, input) {
    if (self.destroyed) return
    if (err) return torrent._destroy(err)

    createTorrent.parseInput(input, opts, function (err, files) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)

      streams = files.map(function (file) {
        return file.getStream
      })

      createTorrent(input, opts, function (err, torrentBuf) {
        if (self.destroyed) return
        if (err) return torrent._destroy(err)

        var existingTorrent = self.get(torrentBuf)
        if (existingTorrent) {
          torrent._destroy(new Error('Cannot add duplicate torrent ' + existingTorrent.infoHash))
        } else {
          torrent._onTorrentId(torrentBuf)
        }
      })
    })
  })

  function onTorrent (torrent) {
    var tasks = [
      function (cb) {
        torrent.load(streams, cb)
      }
    ]
    if (self.dht) {
      tasks.push(function (cb) {
        torrent.once('dhtAnnounce', cb)
      })
    }
    parallel(tasks, function (err) {
      if (self.destroyed) return
      if (err) return torrent._destroy(err)
      _onseed(torrent)
    })
  }

  function _onseed (torrent) {
    debug('on seed')
    if (typeof onseed === 'function') onseed(torrent)
    self.emit('seed', torrent)
  }

  return torrent
}

/**
 * Remove a torrent from the client.
 * @param  {string|Buffer|Torrent}   torrentId
 * @param  {function} cb
 */
WebTorrent.prototype.remove = function (torrentId, cb) {
  debug('remove')
  var torrent = this.get(torrentId)
  if (!torrent) throw new Error('No torrent with id ' + torrentId)
  this._remove(torrentId, cb)
}

WebTorrent.prototype._remove = function (torrentId, cb) {
  var torrent = this.get(torrentId)
  if (!torrent) return
  this.torrents.splice(this.torrents.indexOf(torrent), 1)
  torrent.destroy(cb)
}

WebTorrent.prototype.address = function () {
  if (!this.listening) return null
  return this._tcpPool
    ? this._tcpPool.server.address()
    : { address: '0.0.0.0', family: 'IPv4', port: 0 }
}

/**
 * Destroy the client, including all torrents and connections to peers.
 * @param  {function} cb
 */
WebTorrent.prototype.destroy = function (cb) {
  if (this.destroyed) throw new Error('client already destroyed')
  this._destroy(null, cb)
}

WebTorrent.prototype._destroy = function (err, cb) {
  var self = this
  debug('client destroy')
  self.destroyed = true

  var tasks = self.torrents.map(function (torrent) {
    return function (cb) {
      torrent.destroy(cb)
    }
  })

  if (self._tcpPool) {
    tasks.push(function (cb) {
      self._tcpPool.destroy(cb)
    })
  }

  if (self.dht) {
    tasks.push(function (cb) {
      self.dht.destroy(cb)
    })
  }

  parallel(tasks, cb)

  if (err) self.emit('error', err)

  self.torrents = []
  self._tcpPool = null
  self.dht = null
}

WebTorrent.prototype._onListening = function () {
  this.listening = true

  if (this._tcpPool) {
    // Sometimes server.address() returns `null` in Docker.
    // WebTorrent issue: https://github.com/feross/bittorrent-swarm/pull/18
    var address = this._tcpPool.server.address()
    if (address) this.torrentPort = address.port
  }

  this.emit('listening')
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && obj != null && typeof obj.pipe === 'function'
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/tcp-pool":21,"./lib/torrent":177,"./package.json":179,"_process":102,"bittorrent-dht/client":21,"create-torrent":34,"debug":39,"events":57,"hat":64,"inherits":69,"load-ip-set":21,"parse-torrent":95,"path":99,"run-parallel":119,"safe-buffer":121,"simple-concat":122,"simple-peer":124,"speedometer":138,"xtend":181,"zero-fill":196}],173:[function(require,module,exports){
module.exports = FileStream

var debug = require('debug')('webtorrent:file-stream')
var inherits = require('inherits')
var stream = require('readable-stream')

inherits(FileStream, stream.Readable)

/**
 * Readable stream of a torrent file
 *
 * @param {File} file
 * @param {Object} opts
 * @param {number} opts.start stream slice of file, starting from this byte (inclusive)
 * @param {number} opts.end stream slice of file, ending with this byte (inclusive)
 */
function FileStream (file, opts) {
  stream.Readable.call(this, opts)

  this.destroyed = false
  this._torrent = file._torrent

  var start = (opts && opts.start) || 0
  var end = (opts && opts.end && opts.end < file.length)
    ? opts.end
    : file.length - 1

  var pieceLength = file._torrent.pieceLength

  this._startPiece = (start + file.offset) / pieceLength | 0
  this._endPiece = (end + file.offset) / pieceLength | 0

  this._piece = this._startPiece
  this._offset = (start + file.offset) - (this._startPiece * pieceLength)

  this._missing = end - start + 1
  this._reading = false
  this._notifying = false
  this._criticalLength = Math.min((1024 * 1024 / pieceLength) | 0, 2)
}

FileStream.prototype._read = function () {
  if (this._reading) return
  this._reading = true
  this._notify()
}

FileStream.prototype._notify = function () {
  var self = this

  if (!self._reading || self._missing === 0) return
  if (!self._torrent.bitfield.get(self._piece)) {
    return self._torrent.critical(self._piece, self._piece + self._criticalLength)
  }

  if (self._notifying) return
  self._notifying = true

  var p = self._piece
  self._torrent.store.get(p, function (err, buffer) {
    self._notifying = false
    if (self.destroyed) return
    if (err) return self._destroy(err)
    debug('read %s (length %s) (err %s)', p, buffer.length, err && err.message)

    if (self._offset) {
      buffer = buffer.slice(self._offset)
      self._offset = 0
    }

    if (self._missing < buffer.length) {
      buffer = buffer.slice(0, self._missing)
    }
    self._missing -= buffer.length

    debug('pushing buffer of length %s', buffer.length)
    self._reading = false
    self.push(buffer)

    if (self._missing === 0) self.push(null)
  })
  self._piece += 1
}

FileStream.prototype.destroy = function (onclose) {
  this._destroy(null, onclose)
}

FileStream.prototype._destroy = function (err, onclose) {
  if (this.destroyed) return
  this.destroyed = true

  if (!this._torrent.destroyed) {
    this._torrent.deselect(this._startPiece, this._endPiece, true)
  }

  if (err) this.emit('error', err)
  this.emit('close')
  if (onclose) onclose()
}

},{"debug":39,"inherits":69,"readable-stream":115}],174:[function(require,module,exports){
(function (process){
module.exports = File

var eos = require('end-of-stream')
var EventEmitter = require('events').EventEmitter
var FileStream = require('./file-stream')
var inherits = require('inherits')
var path = require('path')
var render = require('render-media')
var stream = require('readable-stream')
var streamToBlobURL = require('stream-to-blob-url')
var streamToBuffer = require('stream-with-known-length-to-buffer')

inherits(File, EventEmitter)

function File (torrent, file) {
  EventEmitter.call(this)

  this._torrent = torrent
  this._destroyed = false

  this.name = file.name
  this.path = file.path
  this.length = file.length
  this.offset = file.offset

  this.done = false

  var start = file.offset
  var end = start + file.length - 1

  this._startPiece = start / this._torrent.pieceLength | 0
  this._endPiece = end / this._torrent.pieceLength | 0

  if (this.length === 0) {
    this.done = true
    this.emit('done')
  }
}

File.prototype.select = function (priority) {
  if (this.length === 0) return
  this._torrent.select(this._startPiece, this._endPiece, priority)
}

File.prototype.deselect = function () {
  if (this.length === 0) return
  this._torrent.deselect(this._startPiece, this._endPiece, false)
}

File.prototype.createReadStream = function (opts) {
  var self = this
  if (this.length === 0) {
    var empty = new stream.PassThrough()
    process.nextTick(function () {
      empty.end()
    })
    return empty
  }

  var fileStream = new FileStream(self, opts)
  self._torrent.select(fileStream._startPiece, fileStream._endPiece, true, function () {
    fileStream._notify()
  })
  eos(fileStream, function () {
    if (self._destroyed) return
    if (!self._torrent.destroyed) {
      self._torrent.deselect(fileStream._startPiece, fileStream._endPiece, true)
    }
  })
  return fileStream
}

File.prototype.getBuffer = function (cb) {
  streamToBuffer(this.createReadStream(), this.length, cb)
}

File.prototype.getBlobURL = function (cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  var mime = render.mime[path.extname(this.name).toLowerCase()]
  streamToBlobURL(this.createReadStream(), mime, cb)
}

File.prototype.appendTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.append(this, elem, cb)
}

File.prototype.renderTo = function (elem, cb) {
  if (typeof window === 'undefined') throw new Error('browser-only method')
  render.render(this, elem, cb)
}

File.prototype._destroy = function () {
  this._destroyed = true
  this._torrent = null
}

}).call(this,require('_process'))

},{"./file-stream":173,"_process":102,"end-of-stream":42,"events":57,"inherits":69,"path":99,"readable-stream":115,"render-media":116,"stream-to-blob-url":143,"stream-with-known-length-to-buffer":145}],175:[function(require,module,exports){
var arrayRemove = require('unordered-array-remove')
var debug = require('debug')('webtorrent:peer')
var Wire = require('bittorrent-protocol')

var WebConn = require('./webconn')

var CONNECT_TIMEOUT_TCP = 5000
var CONNECT_TIMEOUT_WEBRTC = 25000
var HANDSHAKE_TIMEOUT = 25000

/**
 * WebRTC peer connections start out connected, because WebRTC peers require an
 * "introduction" (i.e. WebRTC signaling), and there's no equivalent to an IP address
 * that lets you refer to a WebRTC endpoint.
 */
exports.createWebRTCPeer = function (conn, swarm) {
  var peer = new Peer(conn.id, 'webrtc')
  peer.conn = conn
  peer.swarm = swarm

  if (peer.conn.connected) {
    peer.onConnect()
  } else {
    peer.conn.once('connect', function () { peer.onConnect() })
    peer.conn.once('error', function (err) { peer.destroy(err) })
    peer.startConnectTimeout()
  }

  return peer
}

/**
 * Incoming TCP peers start out connected, because the remote peer connected to the
 * listening port of the TCP server. Until the remote peer sends a handshake, we don't
 * know what swarm the connection is intended for.
 */
exports.createTCPIncomingPeer = function (conn) {
  var addr = conn.remoteAddress + ':' + conn.remotePort
  var peer = new Peer(addr, 'tcpIncoming')
  peer.conn = conn
  peer.addr = addr

  peer.onConnect()

  return peer
}

/**
 * Outgoing TCP peers start out with just an IP address. At some point (when there is an
 * available connection), the client can attempt to connect to the address.
 */
exports.createTCPOutgoingPeer = function (addr, swarm) {
  var peer = new Peer(addr, 'tcpOutgoing')
  peer.addr = addr
  peer.swarm = swarm

  return peer
}

/**
 * Peer that represents a Web Seed (BEP17 / BEP19).
 */
exports.createWebSeedPeer = function (url, swarm) {
  var peer = new Peer(url, 'webSeed')
  peer.swarm = swarm
  peer.conn = new WebConn(url, swarm)

  peer.onConnect()

  return peer
}

/**
 * Peer. Represents a peer in the torrent swarm.
 *
 * @param {string} id "ip:port" string, peer id (for WebRTC peers), or url (for Web Seeds)
 * @param {string} type the type of the peer
 */
function Peer (id, type) {
  var self = this
  self.id = id
  self.type = type

  debug('new Peer %s', id)

  self.addr = null
  self.conn = null
  self.swarm = null
  self.wire = null

  self.connected = false
  self.destroyed = false
  self.timeout = null // handshake timeout
  self.retries = 0 // outgoing TCP connection retry count

  self.sentHandshake = false
}

/**
 * Called once the peer is connected (i.e. fired 'connect' event)
 * @param {Socket} conn
 */
Peer.prototype.onConnect = function () {
  var self = this
  if (self.destroyed) return
  self.connected = true

  debug('Peer %s connected', self.id)

  clearTimeout(self.connectTimeout)

  var conn = self.conn
  conn.once('end', function () {
    self.destroy()
  })
  conn.once('close', function () {
    self.destroy()
  })
  conn.once('finish', function () {
    self.destroy()
  })
  conn.once('error', function (err) {
    self.destroy(err)
  })

  var wire = self.wire = new Wire()
  wire.type = self.type
  wire.once('end', function () {
    self.destroy()
  })
  wire.once('close', function () {
    self.destroy()
  })
  wire.once('finish', function () {
    self.destroy()
  })
  wire.once('error', function (err) {
    self.destroy(err)
  })

  wire.once('handshake', function (infoHash, peerId) {
    self.onHandshake(infoHash, peerId)
  })
  self.startHandshakeTimeout()

  conn.pipe(wire).pipe(conn)
  if (self.swarm && !self.sentHandshake) self.handshake()
}

/**
 * Called when handshake is received from remote peer.
 * @param {string} infoHash
 * @param {string} peerId
 */
Peer.prototype.onHandshake = function (infoHash, peerId) {
  var self = this
  if (!self.swarm) return // `self.swarm` not set yet, so do nothing
  if (self.destroyed) return

  if (self.swarm.destroyed) {
    return self.destroy(new Error('swarm already destroyed'))
  }
  if (infoHash !== self.swarm.infoHash) {
    return self.destroy(new Error('unexpected handshake info hash for this swarm'))
  }
  if (peerId === self.swarm.peerId) {
    return self.destroy(new Error('refusing to connect to ourselves'))
  }

  debug('Peer %s got handshake %s', self.id, infoHash)

  clearTimeout(self.handshakeTimeout)

  self.retries = 0

  var addr = self.addr
  if (!addr && self.conn.remoteAddress) {
    addr = self.conn.remoteAddress + ':' + self.conn.remotePort
  }
  self.swarm._onWire(self.wire, addr)

  // swarm could be destroyed in user's 'wire' event handler
  if (!self.swarm || self.swarm.destroyed) return

  if (!self.sentHandshake) self.handshake()
}

Peer.prototype.handshake = function () {
  var self = this
  var opts = {
    dht: self.swarm.private ? false : !!self.swarm.client.dht
  }
  self.wire.handshake(self.swarm.infoHash, self.swarm.client.peerId, opts)
  self.sentHandshake = true
}

Peer.prototype.startConnectTimeout = function () {
  var self = this
  clearTimeout(self.connectTimeout)
  self.connectTimeout = setTimeout(function () {
    self.destroy(new Error('connect timeout'))
  }, self.type === 'webrtc' ? CONNECT_TIMEOUT_WEBRTC : CONNECT_TIMEOUT_TCP)
  if (self.connectTimeout.unref) self.connectTimeout.unref()
}

Peer.prototype.startHandshakeTimeout = function () {
  var self = this
  clearTimeout(self.handshakeTimeout)
  self.handshakeTimeout = setTimeout(function () {
    self.destroy(new Error('handshake timeout'))
  }, HANDSHAKE_TIMEOUT)
  if (self.handshakeTimeout.unref) self.handshakeTimeout.unref()
}

Peer.prototype.destroy = function (err) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self.connected = false

  debug('destroy %s (error: %s)', self.id, err && (err.message || err))

  clearTimeout(self.connectTimeout)
  clearTimeout(self.handshakeTimeout)

  var swarm = self.swarm
  var conn = self.conn
  var wire = self.wire

  self.swarm = null
  self.conn = null
  self.wire = null

  if (swarm && wire) {
    arrayRemove(swarm.wires, swarm.wires.indexOf(wire))
  }
  if (conn) {
    conn.on('error', noop)
    conn.destroy()
  }
  if (wire) wire.destroy()
  if (swarm) swarm.removePeer(self.id)
}

function noop () {}

},{"./webconn":178,"bittorrent-protocol":13,"debug":39,"unordered-array-remove":157}],176:[function(require,module,exports){
module.exports = RarityMap

/**
 * Mapping of torrent pieces to their respective availability in the torrent swarm. Used
 * by the torrent manager for implementing the rarest piece first selection strategy.
 */
function RarityMap (torrent) {
  var self = this

  self._torrent = torrent
  self._numPieces = torrent.pieces.length
  self._pieces = []

  self._onWire = function (wire) {
    self.recalculate()
    self._initWire(wire)
  }
  self._onWireHave = function (index) {
    self._pieces[index] += 1
  }
  self._onWireBitfield = function () {
    self.recalculate()
  }

  self._torrent.wires.forEach(function (wire) {
    self._initWire(wire)
  })
  self._torrent.on('wire', self._onWire)
  self.recalculate()
}

/**
 * Get the index of the rarest piece. Optionally, pass a filter function to exclude
 * certain pieces (for instance, those that we already have).
 *
 * @param {function} pieceFilterFunc
 * @return {number} index of rarest piece, or -1
 */
RarityMap.prototype.getRarestPiece = function (pieceFilterFunc) {
  if (!pieceFilterFunc) pieceFilterFunc = trueFn

  var candidates = []
  var min = Infinity

  for (var i = 0; i < this._numPieces; ++i) {
    if (!pieceFilterFunc(i)) continue

    var availability = this._pieces[i]
    if (availability === min) {
      candidates.push(i)
    } else if (availability < min) {
      candidates = [ i ]
      min = availability
    }
  }

  if (candidates.length > 0) {
    // if there are multiple pieces with the same availability, choose one randomly
    return candidates[Math.random() * candidates.length | 0]
  } else {
    return -1
  }
}

RarityMap.prototype.destroy = function () {
  var self = this
  self._torrent.removeListener('wire', self._onWire)
  self._torrent.wires.forEach(function (wire) {
    self._cleanupWireEvents(wire)
  })
  self._torrent = null
  self._pieces = null

  self._onWire = null
  self._onWireHave = null
  self._onWireBitfield = null
}

RarityMap.prototype._initWire = function (wire) {
  var self = this

  wire._onClose = function () {
    self._cleanupWireEvents(wire)
    for (var i = 0; i < this._numPieces; ++i) {
      self._pieces[i] -= wire.peerPieces.get(i)
    }
  }

  wire.on('have', self._onWireHave)
  wire.on('bitfield', self._onWireBitfield)
  wire.once('close', wire._onClose)
}

/**
 * Recalculates piece availability across all peers in the torrent.
 */
RarityMap.prototype.recalculate = function () {
  var i
  for (i = 0; i < this._numPieces; ++i) {
    this._pieces[i] = 0
  }

  var numWires = this._torrent.wires.length
  for (i = 0; i < numWires; ++i) {
    var wire = this._torrent.wires[i]
    for (var j = 0; j < this._numPieces; ++j) {
      this._pieces[j] += wire.peerPieces.get(j)
    }
  }
}

RarityMap.prototype._cleanupWireEvents = function (wire) {
  wire.removeListener('have', this._onWireHave)
  wire.removeListener('bitfield', this._onWireBitfield)
  if (wire._onClose) wire.removeListener('close', wire._onClose)
  wire._onClose = null
}

function trueFn () {
  return true
}

},{}],177:[function(require,module,exports){
(function (process,global){
/* global URL, Blob */

module.exports = Torrent

var addrToIPPort = require('addr-to-ip-port')
var BitField = require('bitfield')
var ChunkStoreWriteStream = require('chunk-store-stream/write')
var debug = require('debug')('webtorrent:torrent')
var Discovery = require('torrent-discovery')
var EventEmitter = require('events').EventEmitter
var extend = require('xtend')
var extendMutable = require('xtend/mutable')
var fs = require('fs')
var FSChunkStore = require('fs-chunk-store') // browser: `memory-chunk-store`
var get = require('simple-get')
var ImmediateChunkStore = require('immediate-chunk-store')
var inherits = require('inherits')
var MultiStream = require('multistream')
var net = require('net') // browser exclude
var os = require('os') // browser exclude
var parallel = require('run-parallel')
var parallelLimit = require('run-parallel-limit')
var parseTorrent = require('parse-torrent')
var path = require('path')
var Piece = require('torrent-piece')
var pump = require('pump')
var randomIterate = require('random-iterate')
var sha1 = require('simple-sha1')
var speedometer = require('speedometer')
var uniq = require('uniq')
var utMetadata = require('ut_metadata')
var utPex = require('ut_pex') // browser exclude

var File = require('./file')
var Peer = require('./peer')
var RarityMap = require('./rarity-map')
var Server = require('./server') // browser exclude

var MAX_BLOCK_LENGTH = 128 * 1024
var PIECE_TIMEOUT = 30000
var CHOKE_TIMEOUT = 5000
var SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH

var PIPELINE_MIN_DURATION = 0.5
var PIPELINE_MAX_DURATION = 1

var RECHOKE_INTERVAL = 10000 // 10 seconds
var RECHOKE_OPTIMISTIC_DURATION = 2 // 30 seconds

var FILESYSTEM_CONCURRENCY = 2

var RECONNECT_WAIT = [ 1000, 5000, 15000 ]

var VERSION = require('../package.json').version

var TMP
try {
  TMP = path.join(fs.statSync('/tmp') && '/tmp', 'webtorrent')
} catch (err) {
  TMP = path.join(typeof os.tmpDir === 'function' ? os.tmpDir() : '/', 'webtorrent')
}

inherits(Torrent, EventEmitter)

function Torrent (torrentId, client, opts) {
  EventEmitter.call(this)

  this.client = client
  this._debugId = this.client.peerId.slice(32)

  this._debug('new torrent')

  this.announce = opts.announce
  this.urlList = opts.urlList

  this.path = opts.path
  this._store = opts.store || FSChunkStore
  this._getAnnounceOpts = opts.getAnnounceOpts

  this.strategy = opts.strategy || 'sequential'

  this.maxWebConns = opts.maxWebConns || 4

  this._rechokeNumSlots = (opts.uploads === false || opts.uploads === 0)
    ? 0
    : (+opts.uploads || 10)
  this._rechokeOptimisticWire = null
  this._rechokeOptimisticTime = 0
  this._rechokeIntervalId = null

  this.ready = false
  this.destroyed = false
  this.paused = false
  this.done = false

  this.metadata = null
  this.store = null
  this.files = []
  this.pieces = []

  this._amInterested = false
  this._selections = []
  this._critical = []

  this.wires = [] // open wires (added *after* handshake)

  this._queue = [] // queue of outgoing tcp peers to connect to
  this._peers = {} // connected peers (addr/peerId -> Peer)
  this._peersLength = 0 // number of elements in `this._peers` (cache, for perf)

  // stats
  this.received = 0
  this.uploaded = 0
  this._downloadSpeed = speedometer()
  this._uploadSpeed = speedometer()

  // for cleanup
  this._servers = []
  this._xsRequests = []

  // TODO: remove this and expose a hook instead
  // optimization: don't recheck every file if it hasn't changed
  this._fileModtimes = opts.fileModtimes

  if (torrentId !== null) this._onTorrentId(torrentId)
}

Object.defineProperty(Torrent.prototype, 'timeRemaining', {
  get: function () {
    if (this.done) return 0
    if (this.downloadSpeed === 0) return Infinity
    return ((this.length - this.downloaded) / this.downloadSpeed) * 1000
  }
})

Object.defineProperty(Torrent.prototype, 'downloaded', {
  get: function () {
    if (!this.bitfield) return 0
    var downloaded = 0
    for (var index = 0, len = this.pieces.length; index < len; ++index) {
      if (this.bitfield.get(index)) { // verified data
        downloaded += (index === len - 1) ? this.lastPieceLength : this.pieceLength
      } else { // "in progress" data
        var piece = this.pieces[index]
        downloaded += (piece.length - piece.missing)
      }
    }
    return downloaded
  }
})

// TODO: re-enable this. The number of missing pieces. Used to implement 'end game' mode.
// Object.defineProperty(Storage.prototype, 'numMissing', {
//   get: function () {
//     var self = this
//     var numMissing = self.pieces.length
//     for (var index = 0, len = self.pieces.length; index < len; index++) {
//       numMissing -= self.bitfield.get(index)
//     }
//     return numMissing
//   }
// })

Object.defineProperty(Torrent.prototype, 'downloadSpeed', {
  get: function () { return this._downloadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'uploadSpeed', {
  get: function () { return this._uploadSpeed() }
})

Object.defineProperty(Torrent.prototype, 'progress', {
  get: function () { return this.length ? this.downloaded / this.length : 0 }
})

Object.defineProperty(Torrent.prototype, 'ratio', {
  get: function () { return this.uploaded / (this.received || 1) }
})

Object.defineProperty(Torrent.prototype, 'numPeers', {
  get: function () { return this.wires.length }
})

Object.defineProperty(Torrent.prototype, 'torrentFileBlobURL', {
  get: function () {
    if (typeof window === 'undefined') throw new Error('browser-only property')
    if (!this.torrentFile) return null
    return URL.createObjectURL(
      new Blob([ this.torrentFile ], { type: 'application/x-bittorrent' })
    )
  }
})

Object.defineProperty(Torrent.prototype, '_numQueued', {
  get: function () {
    return this._queue.length + (this._peersLength - this._numConns)
  }
})

Object.defineProperty(Torrent.prototype, '_numConns', {
  get: function () {
    var self = this
    var numConns = 0
    for (var id in self._peers) {
      if (self._peers[id].connected) numConns += 1
    }
    return numConns
  }
})

// TODO: remove in v1
Object.defineProperty(Torrent.prototype, 'swarm', {
  get: function () {
    console.warn('WebTorrent: `torrent.swarm` is deprecated. Use `torrent` directly instead.')
    return this
  }
})

Torrent.prototype._onTorrentId = function (torrentId) {
  var self = this
  if (self.destroyed) return

  var parsedTorrent
  try { parsedTorrent = parseTorrent(torrentId) } catch (err) {}
  if (parsedTorrent) {
    // Attempt to set infoHash property synchronously
    self.infoHash = parsedTorrent.infoHash
    process.nextTick(function () {
      if (self.destroyed) return
      self._onParsedTorrent(parsedTorrent)
    })
  } else {
    // If torrentId failed to parse, it could be in a form that requires an async
    // operation, i.e. http/https link, filesystem path, or Blob.
    parseTorrent.remote(torrentId, function (err, parsedTorrent) {
      if (self.destroyed) return
      if (err) return self._destroy(err)
      self._onParsedTorrent(parsedTorrent)
    })
  }
}

Torrent.prototype._onParsedTorrent = function (parsedTorrent) {
  var self = this
  if (self.destroyed) return

  self._processParsedTorrent(parsedTorrent)

  if (!self.infoHash) {
    return self._destroy(new Error('Malformed torrent data: No info hash'))
  }

  if (!self.path) self.path = path.join(TMP, self.infoHash)

  self._rechokeIntervalId = setInterval(function () {
    self._rechoke()
  }, RECHOKE_INTERVAL)
  if (self._rechokeIntervalId.unref) self._rechokeIntervalId.unref()

  // Private 'infoHash' event allows client.add to check for duplicate torrents and
  // destroy them before the normal 'infoHash' event is emitted. Prevents user
  // applications from needing to deal with duplicate 'infoHash' events.
  self.emit('_infoHash', self.infoHash)
  if (self.destroyed) return

  self.emit('infoHash', self.infoHash)
  if (self.destroyed) return // user might destroy torrent in event handler

  if (self.client.listening) {
    self._onListening()
  } else {
    self.client.once('listening', function () {
      self._onListening()
    })
  }
}

Torrent.prototype._processParsedTorrent = function (parsedTorrent) {
  if (this.announce) {
    // Allow specifying trackers via `opts` parameter
    parsedTorrent.announce = parsedTorrent.announce.concat(this.announce)
  }

  if (this.client.tracker && global.WEBTORRENT_ANNOUNCE && !this.private) {
    // So `webtorrent-hybrid` can force specific trackers to be used
    parsedTorrent.announce = parsedTorrent.announce.concat(global.WEBTORRENT_ANNOUNCE)
  }

  if (this.urlList) {
    // Allow specifying web seeds via `opts` parameter
    parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList)
  }

  uniq(parsedTorrent.announce)
  uniq(parsedTorrent.urlList)

  extendMutable(this, parsedTorrent)

  this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent)
  this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent)
}

Torrent.prototype._onListening = function () {
  var self = this
  if (self.discovery || self.destroyed) return

  var trackerOpts = self.client.tracker
  if (trackerOpts) {
    trackerOpts = extend(self.client.tracker, {
      getAnnounceOpts: function () {
        var opts = {
          uploaded: self.uploaded,
          downloaded: self.downloaded,
          left: Math.max(self.length - self.downloaded, 0)
        }
        if (self.client.tracker.getAnnounceOpts) {
          extendMutable(opts, self.client.tracker.getAnnounceOpts())
        }
        if (self._getAnnounceOpts) {
          // TODO: consider deprecating this, as it's redundant with the former case
          extendMutable(opts, self._getAnnounceOpts())
        }
        return opts
      }
    })
  }

  // begin discovering peers via DHT and trackers
  self.discovery = new Discovery({
    infoHash: self.infoHash,
    announce: self.announce,
    peerId: self.client.peerId,
    dht: !self.private && self.client.dht,
    tracker: trackerOpts,
    port: self.client.torrentPort
  })

  self.discovery.on('error', onError)
  self.discovery.on('peer', onPeer)
  self.discovery.on('trackerAnnounce', onTrackerAnnounce)
  self.discovery.on('dhtAnnounce', onDHTAnnounce)
  self.discovery.on('warning', onWarning)

  function onError (err) {
    self._destroy(err)
  }

  function onPeer (peer) {
    // Don't create new outgoing TCP connections when torrent is done
    if (typeof peer === 'string' && self.done) return
    self.addPeer(peer)
  }

  function onTrackerAnnounce () {
    self.emit('trackerAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'tracker')
  }

  function onDHTAnnounce () {
    self.emit('dhtAnnounce')
    if (self.numPeers === 0) self.emit('noPeers', 'dht')
  }

  function onWarning (err) {
    self.emit('warning', err)
  }

  if (self.info) {
    // if full metadata was included in initial torrent id, use it immediately. Otherwise,
    // wait for torrent-discovery to find peers and ut_metadata to get the metadata.
    self._onMetadata(self)
  } else if (self.xs) {
    self._getMetadataFromServer()
  }
}

Torrent.prototype._getMetadataFromServer = function () {
  var self = this
  var urls = Array.isArray(self.xs) ? self.xs : [ self.xs ]

  var tasks = urls.map(function (url) {
    return function (cb) {
      getMetadataFromURL(url, cb)
    }
  })
  parallel(tasks)

  function getMetadataFromURL (url, cb) {
    if (url.indexOf('http://') !== 0 && url.indexOf('https://') !== 0) {
      self._debug('skipping non-http xs param: %s', url)
      return cb(null)
    }

    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)'
      }
    }
    var req
    try {
      req = get.concat(opts, onResponse)
    } catch (err) {
      self._debug('skipping invalid url xs param: %s', url)
      return cb(null)
    }

    self._xsRequests.push(req)

    function onResponse (err, res, torrent) {
      if (self.destroyed) return cb(null)
      if (self.metadata) return cb(null)

      if (err) {
        self._debug('http error from xs param: %s', url)
        return cb(null)
      }
      if (res.statusCode !== 200) {
        self._debug('non-200 status code %s from xs param: %s', res.statusCode, url)
        return cb(null)
      }

      var parsedTorrent
      try {
        parsedTorrent = parseTorrent(torrent)
      } catch (err) {}

      if (!parsedTorrent) {
        self._debug('got invalid torrent file from xs param: %s', url)
        return cb(null)
      }

      if (parsedTorrent.infoHash !== self.infoHash) {
        self._debug('got torrent file with incorrect info hash from xs param: %s', url)
        return cb(null)
      }

      self._onMetadata(parsedTorrent)
      cb(null)
    }
  }
}

/**
 * Called when the full torrent metadata is received.
 */
Torrent.prototype._onMetadata = function (metadata) {
  var self = this
  if (self.metadata || self.destroyed) return
  self._debug('got metadata')

  self._xsRequests.forEach(function (req) {
    req.abort()
  })
  self._xsRequests = []

  var parsedTorrent
  if (metadata && metadata.infoHash) {
    // `metadata` is a parsed torrent (from parse-torrent module)
    parsedTorrent = metadata
  } else {
    try {
      parsedTorrent = parseTorrent(metadata)
    } catch (err) {
      return self._destroy(err)
    }
  }

  self._processParsedTorrent(parsedTorrent)
  self.metadata = self.torrentFile

  // add web seed urls (BEP19)
  self.urlList.forEach(function (url) {
    self.addWebSeed(url)
  })

  self._rarityMap = new RarityMap(self)

  self.store = new ImmediateChunkStore(
    new self._store(self.pieceLength, {
      torrent: {
        infoHash: self.infoHash
      },
      files: self.files.map(function (file) {
        return {
          path: path.join(self.path, file.path),
          length: file.length,
          offset: file.offset
        }
      }),
      length: self.length
    })
  )

  self.files = self.files.map(function (file) {
    return new File(self, file)
  })

  self._hashes = self.pieces

  self.pieces = self.pieces.map(function (hash, i) {
    var pieceLength = (i === self.pieces.length - 1)
      ? self.lastPieceLength
      : self.pieceLength
    return new Piece(pieceLength)
  })

  self._reservations = self.pieces.map(function () {
    return []
  })

  self.bitfield = new BitField(self.pieces.length)

  self.wires.forEach(function (wire) {
    // If we didn't have the metadata at the time ut_metadata was initialized for this
    // wire, we still want to make it available to the peer in case they request it.
    if (wire.ut_metadata) wire.ut_metadata.setMetadata(self.metadata)

    self._onWireWithMetadata(wire)
  })

  self._debug('verifying existing torrent data')
  if (self._fileModtimes && self._store === FSChunkStore) {
    // don't verify if the files haven't been modified since we last checked
    self.getFileModtimes(function (err, fileModtimes) {
      if (err) return self._destroy(err)

      var unchanged = self.files.map(function (_, index) {
        return fileModtimes[index] === self._fileModtimes[index]
      }).every(function (x) {
        return x
      })

      if (unchanged) {
        for (var index = 0; index < self.pieces.length; index++) {
          self._markVerified(index)
        }
        self._onStore()
      } else {
        self._verifyPieces()
      }
    })
  } else {
    self._verifyPieces()
  }

  self.emit('metadata')
}

/*
 * TODO: remove this
 * Gets the last modified time of every file on disk for this torrent.
 * Only valid in Node, not in the browser.
 */
Torrent.prototype.getFileModtimes = function (cb) {
  var self = this
  var ret = []
  parallelLimit(self.files.map(function (file, index) {
    return function (cb) {
      fs.stat(path.join(self.path, file.path), function (err, stat) {
        if (err && err.code !== 'ENOENT') return cb(err)
        ret[index] = stat && stat.mtime.getTime()
        cb(null)
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    self._debug('done getting file modtimes')
    cb(err, ret)
  })
}

Torrent.prototype._verifyPieces = function () {
  var self = this
  parallelLimit(self.pieces.map(function (_, index) {
    return function (cb) {
      if (self.destroyed) return cb(new Error('torrent is destroyed'))
      self.store.get(index, function (err, buf) {
        if (err) return cb(null) // ignore error
        sha1(buf, function (hash) {
          if (hash === self._hashes[index]) {
            if (!self.pieces[index]) return
            self._debug('piece verified %s', index)
            self._markVerified(index)
          } else {
            self._debug('piece invalid %s', index)
          }
          cb(null)
        })
      })
    }
  }), FILESYSTEM_CONCURRENCY, function (err) {
    if (err) return self._destroy(err)
    self._debug('done verifying')
    self._onStore()
  })
}

Torrent.prototype._markVerified = function (index) {
  this.pieces[index] = null
  this._reservations[index] = null
  this.bitfield.set(index, true)
}

/**
 * Called when the metadata, listening server, and underlying chunk store is initialized.
 */
Torrent.prototype._onStore = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on store')

  // start off selecting the entire torrent with low priority
  if (self.pieces.length !== 0) {
    self.select(0, self.pieces.length - 1, false)
  }

  self.ready = true
  self.emit('ready')

  // Files may start out done if the file was already in the store
  self._checkDone()

  // In case any selections were made before torrent was ready
  self._updateSelections()
}

Torrent.prototype.destroy = function (cb) {
  var self = this
  self._destroy(null, cb)
}

Torrent.prototype._destroy = function (err, cb) {
  var self = this
  if (self.destroyed) return
  self.destroyed = true
  self._debug('destroy')

  self.client._remove(self)

  clearInterval(self._rechokeIntervalId)

  self._xsRequests.forEach(function (req) {
    req.abort()
  })

  if (self._rarityMap) {
    self._rarityMap.destroy()
  }

  for (var id in self._peers) {
    self.removePeer(id)
  }

  self.files.forEach(function (file) {
    if (file instanceof File) file._destroy()
  })

  var tasks = self._servers.map(function (server) {
    return function (cb) {
      server.destroy(cb)
    }
  })

  if (self.discovery) {
    tasks.push(function (cb) {
      self.discovery.destroy(cb)
    })
  }

  if (self.store) {
    tasks.push(function (cb) {
      self.store.close(cb)
    })
  }

  parallel(tasks, cb)

  if (err) {
    // Torrent errors are emitted at `torrent.on('error')`. If there are no 'error' event
    // handlers on the torrent instance, the error will be emitted at
    // `client.on('error')`. This prevents crashing the user's program, but it makes it
    // impossible to determine a client error versus a torrent error (where the client
    // is still usable afterwards). Users are recommended for errors in both places
    // to distinguish between the error types.
    if (self.listenerCount('error') === 0) {
      self.client.emit('error', err)
    } else {
      self.emit('error', err)
    }
  }

  self.emit('close')

  self.client = null
  self.files = []
  self.discovery = null
  self.store = null
  self._rarityMap = null
  self._peers = null
  self._servers = null
  self._xsRequests = null
}

Torrent.prototype.addPeer = function (peer) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.infoHash) throw new Error('addPeer() must not be called before the `infoHash` event')

  if (self.client.blocked) {
    var host
    if (typeof peer === 'string') {
      var parts
      try {
        parts = addrToIPPort(peer)
      } catch (e) {
        self._debug('ignoring peer: invalid %s', peer)
        self.emit('invalidPeer', peer)
        return false
      }
      host = parts[0]
    } else if (typeof peer.remoteAddress === 'string') {
      host = peer.remoteAddress
    }

    if (host && self.client.blocked.contains(host)) {
      self._debug('ignoring peer: blocked %s', peer)
      if (typeof peer !== 'string') peer.destroy()
      self.emit('blockedPeer', peer)
      return false
    }
  }

  var wasAdded = !!self._addPeer(peer)
  if (wasAdded) {
    self.emit('peer', peer)
  } else {
    self.emit('invalidPeer', peer)
  }
  return wasAdded
}

Torrent.prototype._addPeer = function (peer) {
  var self = this
  if (self.destroyed) {
    self._debug('ignoring peer: torrent is destroyed')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }
  if (typeof peer === 'string' && !self._validAddr(peer)) {
    self._debug('ignoring peer: invalid %s', peer)
    return null
  }

  var id = (peer && peer.id) || peer
  if (self._peers[id]) {
    self._debug('ignoring peer: duplicate (%s)', id)
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  if (self.paused) {
    self._debug('ignoring peer: torrent is paused')
    if (typeof peer !== 'string') peer.destroy()
    return null
  }

  self._debug('add peer %s', id)

  var newPeer
  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    newPeer = Peer.createTCPOutgoingPeer(peer, self)
  } else {
    // `peer` is a WebRTC connection (simple-peer)
    newPeer = Peer.createWebRTCPeer(peer, self)
  }

  self._peers[newPeer.id] = newPeer
  self._peersLength += 1

  if (typeof peer === 'string') {
    // `peer` is an addr ("ip:port" string)
    self._queue.push(newPeer)
    self._drain()
  }

  return newPeer
}

Torrent.prototype.addWebSeed = function (url) {
  if (this.destroyed) throw new Error('torrent is destroyed')

  if (!/^https?:\/\/.+/.test(url)) {
    this._debug('ignoring invalid web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  if (this._peers[url]) {
    this._debug('ignoring duplicate web seed %s', url)
    this.emit('invalidPeer', url)
    return
  }

  this._debug('add web seed %s', url)

  var newPeer = Peer.createWebSeedPeer(url, this)
  this._peers[newPeer.id] = newPeer
  this._peersLength += 1

  this.emit('peer', url)
}

/**
 * Called whenever a new incoming TCP peer connects to this torrent swarm. Called with a
 * peer that has already sent a handshake.
 */
Torrent.prototype._addIncomingPeer = function (peer) {
  var self = this
  if (self.destroyed) return peer.destroy(new Error('torrent is destroyed'))
  if (self.paused) return peer.destroy(new Error('torrent is paused'))

  this._debug('add incoming peer %s', peer.id)

  self._peers[peer.id] = peer
  self._peersLength += 1
}

Torrent.prototype.removePeer = function (peer) {
  var self = this
  var id = (peer && peer.id) || peer
  peer = self._peers[id]

  if (!peer) return

  this._debug('removePeer %s', id)

  delete self._peers[id]
  self._peersLength -= 1

  peer.destroy()

  // If torrent swarm was at capacity before, try to open a new connection now
  self._drain()
}

Torrent.prototype.select = function (start, end, priority, notify) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  if (start < 0 || end < start || self.pieces.length <= end) {
    throw new Error('invalid selection ', start, ':', end)
  }
  priority = Number(priority) || 0

  self._debug('select %s-%s (priority %s)', start, end, priority)

  self._selections.push({
    from: start,
    to: end,
    offset: 0,
    priority: priority,
    notify: notify || noop
  })

  self._selections.sort(function (a, b) {
    return b.priority - a.priority
  })

  self._updateSelections()
}

Torrent.prototype.deselect = function (start, end, priority) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  priority = Number(priority) || 0
  self._debug('deselect %s-%s (priority %s)', start, end, priority)

  for (var i = 0; i < self._selections.length; ++i) {
    var s = self._selections[i]
    if (s.from === start && s.to === end && s.priority === priority) {
      self._selections.splice(i--, 1)
      break
    }
  }

  self._updateSelections()
}

Torrent.prototype.critical = function (start, end) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')

  self._debug('critical %s-%s', start, end)

  for (var i = start; i <= end; ++i) {
    self._critical[i] = true
  }

  self._updateSelections()
}

Torrent.prototype._onWire = function (wire, addr) {
  var self = this
  self._debug('got wire %s (%s)', wire._debugId, addr || 'Unknown')

  wire.on('download', function (downloaded) {
    if (self.destroyed) return
    self.received += downloaded
    self._downloadSpeed(downloaded)
    self.client._downloadSpeed(downloaded)
    self.emit('download', downloaded)
    self.client.emit('download', downloaded)
  })

  wire.on('upload', function (uploaded) {
    if (self.destroyed) return
    self.uploaded += uploaded
    self._uploadSpeed(uploaded)
    self.client._uploadSpeed(uploaded)
    self.emit('upload', uploaded)
    self.client.emit('upload', uploaded)
  })

  self.wires.push(wire)

  if (addr) {
    // Sometimes RTCPeerConnection.getStats() doesn't return an ip:port for peers
    var parts = addrToIPPort(addr)
    wire.remoteAddress = parts[0]
    wire.remotePort = parts[1]
  }

  // When peer sends PORT message, add that DHT node to routing table
  if (self.client.dht && self.client.dht.listening) {
    wire.on('port', function (port) {
      if (self.destroyed || self.client.dht.destroyed) {
        return
      }
      if (!wire.remoteAddress) {
        return self._debug('ignoring PORT from peer with no address')
      }
      if (port === 0 || port > 65536) {
        return self._debug('ignoring invalid PORT from peer')
      }

      self._debug('port: %s (from %s)', port, addr)
      self.client.dht.addNode({ host: wire.remoteAddress, port: port })
    })
  }

  wire.on('timeout', function () {
    self._debug('wire timeout (%s)', addr)
    // TODO: this might be destroying wires too eagerly
    wire.destroy()
  })

  // Timeout for piece requests to this peer
  wire.setTimeout(PIECE_TIMEOUT, true)

  // Send KEEP-ALIVE (every 60s) so peers will not disconnect the wire
  wire.setKeepAlive(true)

  // use ut_metadata extension
  wire.use(utMetadata(self.metadata))

  wire.ut_metadata.on('warning', function (err) {
    self._debug('ut_metadata warning: %s', err.message)
  })

  if (!self.metadata) {
    wire.ut_metadata.on('metadata', function (metadata) {
      self._debug('got metadata via ut_metadata')
      self._onMetadata(metadata)
    })
    wire.ut_metadata.fetch()
  }

  // use ut_pex extension if the torrent is not flagged as private
  if (typeof utPex === 'function' && !self.private) {
    wire.use(utPex())

    wire.ut_pex.on('peer', function (peer) {
      // Only add potential new peers when we're not seeding
      if (self.done) return
      self._debug('ut_pex: got peer: %s (from %s)', peer, addr)
      self.addPeer(peer)
    })

    wire.ut_pex.on('dropped', function (peer) {
      // the remote peer believes a given peer has been dropped from the torrent swarm.
      // if we're not currently connected to it, then remove it from the queue.
      var peerObj = self._peers[peer]
      if (peerObj && !peerObj.connected) {
        self._debug('ut_pex: dropped peer: %s (from %s)', peer, addr)
        self.removePeer(peer)
      }
    })

    wire.once('close', function () {
      // Stop sending updates to remote peer
      wire.ut_pex.reset()
    })
  }

  // Hook to allow user-defined `bittorrent-protocol` extensions
  // More info: https://github.com/feross/bittorrent-protocol#extension-api
  self.emit('wire', wire, addr)

  if (self.metadata) {
    process.nextTick(function () {
      // This allows wire.handshake() to be called (by Peer.onHandshake) before any
      // messages get sent on the wire
      self._onWireWithMetadata(wire)
    })
  }
}

Torrent.prototype._onWireWithMetadata = function (wire) {
  var self = this
  var timeoutId = null

  function onChokeTimeout () {
    if (self.destroyed || wire.destroyed) return

    if (self._numQueued > 2 * (self._numConns - self.numPeers) &&
      wire.amInterested) {
      wire.destroy()
    } else {
      timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
      if (timeoutId.unref) timeoutId.unref()
    }
  }

  var i = 0
  function updateSeedStatus () {
    if (wire.peerPieces.length !== self.pieces.length) return
    for (; i < self.pieces.length; ++i) {
      if (!wire.peerPieces.get(i)) return
    }
    wire.isSeeder = true
    wire.choke() // always choke seeders
  }

  wire.on('bitfield', function () {
    updateSeedStatus()
    self._update()
  })

  wire.on('have', function () {
    updateSeedStatus()
    self._update()
  })

  wire.once('interested', function () {
    wire.unchoke()
  })

  wire.once('close', function () {
    clearTimeout(timeoutId)
  })

  wire.on('choke', function () {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
    if (timeoutId.unref) timeoutId.unref()
  })

  wire.on('unchoke', function () {
    clearTimeout(timeoutId)
    self._update()
  })

  wire.on('request', function (index, offset, length, cb) {
    if (length > MAX_BLOCK_LENGTH) {
      // Per spec, disconnect from peers that request >128KB
      return wire.destroy()
    }
    if (self.pieces[index]) return
    self.store.get(index, { offset: offset, length: length }, cb)
  })

  wire.bitfield(self.bitfield) // always send bitfield (required)
  wire.interested() // always start out interested

  // Send PORT message to peers that support DHT
  if (wire.peerExtensions.dht && self.client.dht && self.client.dht.listening) {
    wire.port(self.client.dht.address().port)
  }

  timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT)
  if (timeoutId.unref) timeoutId.unref()

  wire.isSeeder = false
  updateSeedStatus()
}

/**
 * Called on selection changes.
 */
Torrent.prototype._updateSelections = function () {
  var self = this
  if (!self.ready || self.destroyed) return

  process.nextTick(function () {
    self._gcSelections()
  })
  self._updateInterest()
  self._update()
}

/**
 * Garbage collect selections with respect to the store's current state.
 */
Torrent.prototype._gcSelections = function () {
  var self = this

  for (var i = 0; i < self._selections.length; i++) {
    var s = self._selections[i]
    var oldOffset = s.offset

    // check for newly downloaded pieces in selection
    while (self.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
      s.offset++
    }

    if (oldOffset !== s.offset) s.notify()
    if (s.to !== s.from + s.offset) continue
    if (!self.bitfield.get(s.from + s.offset)) continue

    // remove fully downloaded selection
    self._selections.splice(i--, 1) // decrement i to offset splice
    s.notify() // TODO: this may notify twice in a row. is this a problem?
    self._updateInterest()
  }

  if (!self._selections.length) self.emit('idle')
}

/**
 * Update interested status for all peers.
 */
Torrent.prototype._updateInterest = function () {
  var self = this

  var prev = self._amInterested
  self._amInterested = !!self._selections.length

  self.wires.forEach(function (wire) {
    // TODO: only call wire.interested if the wire has at least one piece we need
    if (self._amInterested) wire.interested()
    else wire.uninterested()
  })

  if (prev === self._amInterested) return
  if (self._amInterested) self.emit('interested')
  else self.emit('uninterested')
}

/**
 * Heartbeat to update all peers and their requests.
 */
Torrent.prototype._update = function () {
  var self = this
  if (self.destroyed) return

  // update wires in random order for better request distribution
  var ite = randomIterate(self.wires)
  var wire
  while ((wire = ite())) {
    self._updateWire(wire)
  }
}

/**
 * Attempts to update a peer's requests
 */
Torrent.prototype._updateWire = function (wire) {
  var self = this

  if (wire.peerChoking) return
  if (!wire.downloaded) return validateWire()

  var minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION)
  if (wire.requests.length >= minOutstandingRequests) return
  var maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  trySelectWire(false) || trySelectWire(true)

  function genPieceFilterFunc (start, end, tried, rank) {
    return function (i) {
      return i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i))
    }
  }

  // TODO: Do we need both validateWire and trySelectWire?
  function validateWire () {
    if (wire.requests.length) return

    var i = self._selections.length
    while (i--) {
      var next = self._selections[i]
      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break
          if (self._request(wire, piece, false)) return
          tried[piece] = true
          tries += 1
        }
      } else {
        for (piece = next.to; piece >= next.from + next.offset; --piece) {
          if (!wire.peerPieces.get(piece)) continue
          if (self._request(wire, piece, false)) return
        }
      }
    }

    // TODO: wire failed to validate as useful; should we close it?
    // probably not, since 'have' and 'bitfield' messages might be coming
  }

  function speedRanker () {
    var speed = wire.downloadSpeed() || 1
    if (speed > SPEED_THRESHOLD) return function () { return true }

    var secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed
    var tries = 10
    var ptr = 0

    return function (index) {
      if (!tries || self.bitfield.get(index)) return true

      var missing = self.pieces[index].missing

      for (; ptr < self.wires.length; ptr++) {
        var otherWire = self.wires[ptr]
        var otherSpeed = otherWire.downloadSpeed()

        if (otherSpeed < SPEED_THRESHOLD) continue
        if (otherSpeed <= speed) continue
        if (!otherWire.peerPieces.get(index)) continue
        if ((missing -= otherSpeed * secs) > 0) continue

        tries--
        return false
      }

      return true
    }
  }

  function shufflePriority (i) {
    var last = i
    for (var j = i; j < self._selections.length && self._selections[j].priority; j++) {
      last = j
    }
    var tmp = self._selections[i]
    self._selections[i] = self._selections[last]
    self._selections[last] = tmp
  }

  function trySelectWire (hotswap) {
    if (wire.requests.length >= maxOutstandingRequests) return true
    var rank = speedRanker()

    for (var i = 0; i < self._selections.length; i++) {
      var next = self._selections[i]

      var piece
      if (self.strategy === 'rarest') {
        var start = next.from + next.offset
        var end = next.to
        var len = end - start + 1
        var tried = {}
        var tries = 0
        var filter = genPieceFilterFunc(start, end, tried, rank)

        while (tries < len) {
          piece = self._rarityMap.getRarestPiece(filter)
          if (piece < 0) break

          // request all non-reserved blocks in this piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) {
            tried[piece] = true
            tries++
            continue
          }

          if (next.priority) shufflePriority(i)
          return true
        }
      } else {
        for (piece = next.from + next.offset; piece <= next.to; piece++) {
          if (!wire.peerPieces.get(piece) || !rank(piece)) continue

          // request all non-reserved blocks in piece
          while (self._request(wire, piece, self._critical[piece] || hotswap)) {}

          if (wire.requests.length < maxOutstandingRequests) continue

          if (next.priority) shufflePriority(i)
          return true
        }
      }
    }

    return false
  }
}

/**
 * Called periodically to update the choked status of all peers, handling optimistic
 * unchoking as described in BEP3.
 */
Torrent.prototype._rechoke = function () {
  var self = this
  if (!self.ready) return

  if (self._rechokeOptimisticTime > 0) self._rechokeOptimisticTime -= 1
  else self._rechokeOptimisticWire = null

  var peers = []

  self.wires.forEach(function (wire) {
    if (!wire.isSeeder && wire !== self._rechokeOptimisticWire) {
      peers.push({
        wire: wire,
        downloadSpeed: wire.downloadSpeed(),
        uploadSpeed: wire.uploadSpeed(),
        salt: Math.random(),
        isChoked: true
      })
    }
  })

  peers.sort(rechokeSort)

  var unchokeInterested = 0
  var i = 0
  for (; i < peers.length && unchokeInterested < self._rechokeNumSlots; ++i) {
    peers[i].isChoked = false
    if (peers[i].wire.peerInterested) unchokeInterested += 1
  }

  // Optimistically unchoke a peer
  if (!self._rechokeOptimisticWire && i < peers.length && self._rechokeNumSlots) {
    var candidates = peers.slice(i).filter(function (peer) { return peer.wire.peerInterested })
    var optimistic = candidates[randomInt(candidates.length)]

    if (optimistic) {
      optimistic.isChoked = false
      self._rechokeOptimisticWire = optimistic.wire
      self._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION
    }
  }

  // Unchoke best peers
  peers.forEach(function (peer) {
    if (peer.wire.amChoking !== peer.isChoked) {
      if (peer.isChoked) peer.wire.choke()
      else peer.wire.unchoke()
    }
  })

  function rechokeSort (peerA, peerB) {
    // Prefer higher download speed
    if (peerA.downloadSpeed !== peerB.downloadSpeed) {
      return peerB.downloadSpeed - peerA.downloadSpeed
    }

    // Prefer higher upload speed
    if (peerA.uploadSpeed !== peerB.uploadSpeed) {
      return peerB.uploadSpeed - peerA.uploadSpeed
    }

    // Prefer unchoked
    if (peerA.wire.amChoking !== peerB.wire.amChoking) {
      return peerA.wire.amChoking ? 1 : -1
    }

    // Random order
    return peerA.salt - peerB.salt
  }
}

/**
 * Attempts to cancel a slow block request from another wire such that the
 * given wire may effectively swap out the request for one of its own.
 */
Torrent.prototype._hotswap = function (wire, index) {
  var self = this

  var speed = wire.downloadSpeed()
  if (speed < Piece.BLOCK_LENGTH) return false
  if (!self._reservations[index]) return false

  var r = self._reservations[index]
  if (!r) {
    return false
  }

  var minSpeed = Infinity
  var minWire

  var i
  for (i = 0; i < r.length; i++) {
    var otherWire = r[i]
    if (!otherWire || otherWire === wire) continue

    var otherSpeed = otherWire.downloadSpeed()
    if (otherSpeed >= SPEED_THRESHOLD) continue
    if (2 * otherSpeed > speed || otherSpeed > minSpeed) continue

    minWire = otherWire
    minSpeed = otherSpeed
  }

  if (!minWire) return false

  for (i = 0; i < r.length; i++) {
    if (r[i] === minWire) r[i] = null
  }

  for (i = 0; i < minWire.requests.length; i++) {
    var req = minWire.requests[i]
    if (req.piece !== index) continue

    self.pieces[index].cancel((req.offset / Piece.BLOCK_LENGTH) | 0)
  }

  self.emit('hotswap', minWire, wire, index)
  return true
}

/**
 * Attempts to request a block from the given wire.
 */
Torrent.prototype._request = function (wire, index, hotswap) {
  var self = this
  var numRequests = wire.requests.length
  var isWebSeed = wire.type === 'webSeed'

  if (self.bitfield.get(index)) return false

  var maxOutstandingRequests = isWebSeed
    ? Math.min(
        getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self.pieceLength),
        self.maxWebConns
      )
    : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION)

  if (numRequests >= maxOutstandingRequests) return false
  // var endGame = (wire.requests.length === 0 && self.store.numMissing < 30)

  var piece = self.pieces[index]
  var reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()

  if (reservation === -1 && hotswap && self._hotswap(wire, index)) {
    reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve()
  }
  if (reservation === -1) return false

  var r = self._reservations[index]
  if (!r) r = self._reservations[index] = []
  var i = r.indexOf(null)
  if (i === -1) i = r.length
  r[i] = wire

  var chunkOffset = piece.chunkOffset(reservation)
  var chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation)

  wire.request(index, chunkOffset, chunkLength, function onChunk (err, chunk) {
    // TODO: what is this for?
    if (!self.ready) return self.once('ready', function () { onChunk(err, chunk) })

    if (r[i] === wire) r[i] = null

    if (piece !== self.pieces[index]) return onUpdateTick()

    if (err) {
      self._debug(
        'error getting piece %s (offset: %s length: %s) from %s: %s',
        index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort,
        err.message
      )
      isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation)
      onUpdateTick()
      return
    }

    self._debug(
      'got piece %s (offset: %s length: %s) from %s',
      index, chunkOffset, chunkLength, wire.remoteAddress + ':' + wire.remotePort
    )

    if (!piece.set(reservation, chunk, wire)) return onUpdateTick()

    var buf = piece.flush()

    // TODO: might need to set self.pieces[index] = null here since sha1 is async

    sha1(buf, function (hash) {
      if (hash === self._hashes[index]) {
        if (!self.pieces[index]) return
        self._debug('piece verified %s', index)

        self.pieces[index] = null
        self._reservations[index] = null
        self.bitfield.set(index, true)

        self.store.put(index, buf)

        self.wires.forEach(function (wire) {
          wire.have(index)
        })

        self._checkDone()
      } else {
        self.pieces[index] = new Piece(piece.length)
        self.emit('warning', new Error('Piece ' + index + ' failed verification'))
      }
      onUpdateTick()
    })
  })

  function onUpdateTick () {
    process.nextTick(function () { self._update() })
  }

  return true
}

Torrent.prototype._checkDone = function () {
  var self = this
  if (self.destroyed) return

  // are any new files done?
  self.files.forEach(function (file) {
    if (file.done) return
    for (var i = file._startPiece; i <= file._endPiece; ++i) {
      if (!self.bitfield.get(i)) return
    }
    file.done = true
    file.emit('done')
    self._debug('file done: ' + file.name)
  })

  // is the torrent done? (if all current selections are satisfied, or there are
  // no selections, then torrent is done)
  var done = true
  for (var i = 0; i < self._selections.length; i++) {
    var selection = self._selections[i]
    for (var piece = selection.from; piece <= selection.to; piece++) {
      if (!self.bitfield.get(piece)) {
        done = false
        break
      }
    }
    if (!done) break
  }
  if (!self.done && done) {
    self.done = true
    self._debug('torrent done: ' + self.infoHash)
    if (self.discovery.tracker) {
      self.discovery.tracker.complete()
    }
    self.emit('done')
  }

  self._gcSelections()
}

Torrent.prototype.load = function (streams, cb) {
  var self = this
  if (self.destroyed) throw new Error('torrent is destroyed')
  if (!self.ready) return self.once('ready', function () { self.load(streams, cb) })

  if (!Array.isArray(streams)) streams = [ streams ]
  if (!cb) cb = noop

  var readable = new MultiStream(streams)
  var writable = new ChunkStoreWriteStream(self.store, self.pieceLength)

  pump(readable, writable, function (err) {
    if (err) return cb(err)
    self.pieces.forEach(function (piece, index) {
      self.pieces[index] = null
      self._reservations[index] = null
      self.bitfield.set(index, true)
    })
    self._checkDone()
    cb(null)
  })
}

Torrent.prototype.createServer = function (opts) {
  if (typeof Server !== 'function') throw new Error('node.js-only method')
  if (this.destroyed) throw new Error('torrent is destroyed')
  var server = new Server(this, opts)
  this._servers.push(server)
  return server
}

Torrent.prototype.pause = function () {
  if (this.destroyed) return
  this._debug('pause')
  this.paused = true
}

Torrent.prototype.resume = function () {
  if (this.destroyed) return
  this._debug('resume')
  this.paused = false
  this._drain()
}

Torrent.prototype._debug = function () {
  var args = [].slice.call(arguments)
  args[0] = '[' + this._debugId + '] ' + args[0]
  debug.apply(null, args)
}

/**
 * Pop a peer off the FIFO queue and connect to it. When _drain() gets called,
 * the queue will usually have only one peer in it, except when there are too
 * many peers (over `this.maxConns`) in which case they will just sit in the
 * queue until another connection closes.
 */
Torrent.prototype._drain = function () {
  var self = this
  this._debug('_drain numConns %s maxConns %s', self._numConns, self.client.maxConns)
  if (typeof net.connect !== 'function' || self.destroyed || self.paused ||
      self._numConns >= self.client.maxConns) {
    return
  }
  this._debug('drain (%s queued, %s/%s peers)', self._numQueued, self.numPeers, self.client.maxConns)

  var peer = self._queue.shift()
  if (!peer) return // queue could be empty

  this._debug('tcp connect attempt to %s', peer.addr)

  var parts = addrToIPPort(peer.addr)
  var opts = {
    host: parts[0],
    port: parts[1]
  }

  var conn = peer.conn = net.connect(opts)

  conn.once('connect', function () { peer.onConnect() })
  conn.once('error', function (err) { peer.destroy(err) })
  peer.startConnectTimeout()

  // When connection closes, attempt reconnect after timeout (with exponential backoff)
  conn.on('close', function () {
    if (self.destroyed) return

    // TODO: If torrent is done, do not try to reconnect after a timeout

    if (peer.retries >= RECONNECT_WAIT.length) {
      self._debug(
        'conn %s closed: will not re-add (max %s attempts)',
        peer.addr, RECONNECT_WAIT.length
      )
      return
    }

    var ms = RECONNECT_WAIT[peer.retries]
    self._debug(
      'conn %s closed: will re-add to queue in %sms (attempt %s)',
      peer.addr, ms, peer.retries + 1
    )

    var reconnectTimeout = setTimeout(function reconnectTimeout () {
      var newPeer = self._addPeer(peer.addr)
      if (newPeer) newPeer.retries = peer.retries + 1
    }, ms)
    if (reconnectTimeout.unref) reconnectTimeout.unref()
  })
}

/**
 * Returns `true` if string is valid IPv4/6 address.
 * @param {string} addr
 * @return {boolean}
 */
Torrent.prototype._validAddr = function (addr) {
  var parts
  try {
    parts = addrToIPPort(addr)
  } catch (e) {
    return false
  }
  var host = parts[0]
  var port = parts[1]
  return port > 0 && port < 65535 &&
    !(host === '127.0.0.1' && port === this.client.torrentPort)
}

function getBlockPipelineLength (wire, duration) {
  return 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH)
}

function getPiecePipelineLength (wire, duration, pieceLength) {
  return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength)
}

/**
 * Returns a random integer in [0,high)
 */
function randomInt (high) {
  return Math.random() * high | 0
}

function noop () {}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":179,"./file":174,"./peer":175,"./rarity-map":176,"./server":21,"_process":102,"addr-to-ip-port":3,"bitfield":12,"chunk-store-stream/write":27,"debug":39,"events":57,"fs":22,"fs-chunk-store":79,"immediate-chunk-store":67,"inherits":69,"multistream":87,"net":21,"os":21,"parse-torrent":95,"path":99,"pump":103,"random-iterate":108,"run-parallel":119,"run-parallel-limit":118,"simple-get":123,"simple-sha1":125,"speedometer":138,"torrent-discovery":152,"torrent-piece":153,"uniq":156,"ut_metadata":160,"ut_pex":21,"xtend":181,"xtend/mutable":182}],178:[function(require,module,exports){
module.exports = WebConn

var BitField = require('bitfield')
var Buffer = require('safe-buffer').Buffer
var debug = require('debug')('webtorrent:webconn')
var get = require('simple-get')
var inherits = require('inherits')
var sha1 = require('simple-sha1')
var Wire = require('bittorrent-protocol')

var VERSION = require('../package.json').version

inherits(WebConn, Wire)

/**
 * Converts requests for torrent blocks into http range requests.
 * @param {string} url web seed url
 * @param {Object} torrent
 */
function WebConn (url, torrent) {
  Wire.call(this)

  this.url = url
  this.webPeerId = sha1.sync(url)
  this._torrent = torrent

  this._init()
}

WebConn.prototype._init = function () {
  var self = this
  self.setKeepAlive(true)

  self.once('handshake', function (infoHash, peerId) {
    if (self.destroyed) return
    self.handshake(infoHash, self.webPeerId)
    var numPieces = self._torrent.pieces.length
    var bitfield = new BitField(numPieces)
    for (var i = 0; i <= numPieces; i++) {
      bitfield.set(i, true)
    }
    self.bitfield(bitfield)
  })

  self.once('interested', function () {
    debug('interested')
    self.unchoke()
  })

  self.on('uninterested', function () { debug('uninterested') })
  self.on('choke', function () { debug('choke') })
  self.on('unchoke', function () { debug('unchoke') })
  self.on('bitfield', function () { debug('bitfield') })

  self.on('request', function (pieceIndex, offset, length, callback) {
    debug('request pieceIndex=%d offset=%d length=%d', pieceIndex, offset, length)
    self.httpRequest(pieceIndex, offset, length, callback)
  })
}

WebConn.prototype.httpRequest = function (pieceIndex, offset, length, cb) {
  var self = this
  var pieceOffset = pieceIndex * self._torrent.pieceLength
  var rangeStart = pieceOffset + offset /* offset within whole torrent */
  var rangeEnd = rangeStart + length - 1

  // Web seed URL format:
  // For single-file torrents, make HTTP range requests directly to the web seed URL
  // For multi-file torrents, add the torrent folder and file name to the URL
  var files = self._torrent.files
  var requests
  if (files.length <= 1) {
    requests = [{
      url: self.url,
      start: rangeStart,
      end: rangeEnd
    }]
  } else {
    var requestedFiles = files.filter(function (file) {
      return file.offset <= rangeEnd && (file.offset + file.length) > rangeStart
    })
    if (requestedFiles.length < 1) {
      return cb(new Error('Could not find file corresponnding to web seed range request'))
    }

    requests = requestedFiles.map(function (requestedFile) {
      var fileEnd = requestedFile.offset + requestedFile.length - 1
      var url = self.url +
        (self.url[self.url.length - 1] === '/' ? '' : '/') +
        requestedFile.path
      return {
        url: url,
        fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
        start: Math.max(rangeStart - requestedFile.offset, 0),
        end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
      }
    })
  }

  // Now make all the HTTP requests we need in order to load this piece
  // Usually that's one requests, but sometimes it will be multiple
  // Send requests in parallel and wait for them all to come back
  var numRequestsSucceeded = 0
  var hasError = false

  var ret
  if (requests.length > 1) {
    ret = Buffer.alloc(length)
  }

  requests.forEach(function (request) {
    var url = request.url
    var start = request.start
    var end = request.end
    debug(
      'Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d',
      url, pieceIndex, offset, length, start, end
    )
    var opts = {
      url: url,
      method: 'GET',
      headers: {
        'user-agent': 'WebTorrent/' + VERSION + ' (https://webtorrent.io)',
        range: 'bytes=' + start + '-' + end
      }
    }
    get.concat(opts, function (err, res, data) {
      if (hasError) return
      if (err) {
        hasError = true
        return cb(err)
      }
      if (res.statusCode < 200 || res.statusCode >= 300) {
        hasError = true
        return cb(new Error('Unexpected HTTP status code ' + res.statusCode))
      }
      debug('Got data of length %d', data.length)

      if (requests.length === 1) {
        // Common case: fetch piece in a single HTTP request, return directly
        cb(null, data)
      } else {
        // Rare case: reconstruct multiple HTTP requests across 2+ files into one
        // piece buffer
        data.copy(ret, request.fileOffsetInRange)
        if (++numRequestsSucceeded === requests.length) {
          cb(null, ret)
        }
      }
    })
  })
}

WebConn.prototype.destroy = function () {
  Wire.prototype.destroy.call(this)
  this._torrent = null
}

},{"../package.json":179,"bitfield":12,"bittorrent-protocol":13,"debug":39,"inherits":69,"safe-buffer":121,"simple-get":123,"simple-sha1":125}],179:[function(require,module,exports){
module.exports={"version":"0.94.4"}
},{}],180:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],181:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],182:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],183:[function(require,module,exports){
/* global Y */
'use strict'

function extend (Y) {
  class YArray {
    constructor (os, _model, _content) {
      this.os = os
      this._model = _model
      // Array of all the neccessary content
      this._content = _content
      this.eventHandler = new Y.utils.EventHandler((op) => {
        if (op.struct === 'Insert') {
          let pos
          // we check op.left only!,
          // because op.right might not be defined when this is called
          if (op.left === null) {
            pos = 0
          } else {
            pos = 1 + this._content.findIndex(function (c) {
              return Y.utils.compareIds(c.id, op.left)
            })
            if (pos <= 0) {
              throw new Error('Unexpected operation!')
            }
          }
          var values
          var length
          if (op.hasOwnProperty('opContent')) {
            this._content.splice(pos, 0, {
              id: op.id,
              type: op.opContent
            })
            let opContent = op.opContent
            length = 1
            values = () => {
              return new Promise((resolve) => {
                this.os.requestTransaction(function *() {
                  var type = yield* this.getType(opContent)
                  resolve([type])
                })
              })
            }
          } else {
            var contents = op.content.map(function (c, i) {
              return {
                id: [op.id[0], op.id[1] + i],
                val: c
              }
            })
            // insert value in _content
            this._content.splice.apply(this._content, [pos, 0].concat(contents))
            values = op.content
            length = op.content.length
          }
          this.eventHandler.callEventListeners({
            type: 'insert',
            object: this,
            index: pos,
            values: values,
            // valueId: valueId, // TODO: does this still work as expected?
            length: length
          })
        } else if (op.struct === 'Delete') {
          var i = 0 // current position in _content
          for (; i < this._content.length && op.length > 0; i++) {
            var c = this._content[i]
            if (Y.utils.inDeletionRange(op, c.id)) {
              // is in deletion range!
              var delLength
              // check how many character to delete in one flush
              for (delLength = 1;
                    delLength < op.length && i + delLength < this._content.length && Y.utils.inDeletionRange(op, this._content[i + delLength].id);
                    delLength++) {}
              // last operation thas will be deleted
              c = this._content[i + delLength - 1]
              // update delete operation
              op.length -= c.id[1] - op.target[1] + 1
              op.target = [c.id[0], c.id[1] + 1]
              // apply deletion & find send event
              let content = this._content.splice(i, delLength)
              // TODO: how about return types
              let values = content.map(function (c) { return c.val })
              this.eventHandler.callEventListeners({
                type: 'delete',
                object: this,
                index: i,
                values: values,
                _content: content,
                length: delLength
              })
              // with the fresh delete op, we can continue
              // note: we don't have to increment i, because the i-th content was deleted
              // but on the other had, the (i+delLength)-th was not in deletion range
              // So we don't do i--
            }
          }
        } else {
          throw new Error('Unexpected struct!')
        }
      })
    }
    _destroy () {
      this.eventHandler.destroy()
      this.eventHandler = null
      this._content = null
      this._model = null
      this.os = null
    }
    get length () {
      return this._content.length
    }
    get (pos) {
      if (pos == null || typeof pos !== 'number') {
        throw new Error('pos must be a number!')
      }
      if (pos >= this._content.length) {
        return undefined
      }
      if (this._content[pos].type == null) {
        return this._content[pos].val
      } else {
        var oid = this._content[pos].type
        return new Promise((resolve) => {
          this.os.requestTransaction(function *() {
            var type = yield* this.getType(oid)
            resolve(type)
          })
        })
      }
    }
    // only returns primitive values
    toArray () {
      return this._content.map(function (x, i) {
        return x.val
      })
    }
    push (contents) {
      return this.insert(this._content.length, contents)
    }
    insert (pos, contents) {
      if (typeof pos !== 'number') {
        throw new Error('pos must be a number!')
      }
      if (!(contents instanceof Array)) {
        throw new Error('contents must be an Array of objects!')
      }
      if (contents.length === 0) {
        return
      }
      if (pos > this._content.length || pos < 0) {
        throw new Error('This position exceeds the range of the array!')
      }
      var mostLeft = pos === 0 ? null : this._content[pos - 1].id

      var ops = []
      var newTypes = []
      var prevId = mostLeft
      for (var i = 0; i < contents.length;) {
        var op = {
          left: prevId,
          origin: prevId,
          // right: mostRight,
          // NOTE: I intentionally do not define right here, because it could be deleted
          // at the time of inserting this operation (when we get the transaction),
          // and would therefore not defined in this._content
          parent: this._model,
          struct: 'Insert'
        }
        var _content = []
        var typeDefinition
        while (i < contents.length) {
          var val = contents[i++]
          typeDefinition = Y.utils.isTypeDefinition(val)
          if (!typeDefinition) {
            _content.push(val)
          } else if (_content.length > 0) {
            i-- // come back again later
            break
          } else {
            break
          }
        }
        if (_content.length > 0) {
          // content is defined
          op.content = _content
          op.id = this.os.getNextOpId(_content.length)
        } else {
          // otherwise its a type
          var typeid = this.os.getNextOpId(1)
          newTypes.push([typeDefinition, typeid])
          op.opContent = typeid
          op.id = this.os.getNextOpId(1)
        }
        ops.push(op)
        prevId = op.id
      }
      var eventHandler = this.eventHandler
      this.os.requestTransaction(function *() {
        // now we can set the right reference.
        var mostRight
        if (mostLeft != null) {
          var ml = yield* this.getInsertionCleanEnd(mostLeft)
          mostRight = ml.right
        } else {
          mostRight = (yield* this.getOperation(ops[0].parent)).start
        }
        for (var i = 0; i < newTypes.length; i++) {
          yield* this.createType.apply(this, newTypes[i])
        }
        for (var j = 0; j < ops.length; j++) {
          var op = ops[j]
          op.right = mostRight
        }
        yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [ops])
      })
      eventHandler.awaitAndPrematurelyCall(ops)
    }
    delete (pos, length) {
      if (length == null) { length = 1 }
      if (typeof length !== 'number') {
        throw new Error('length must be a number!')
      }
      if (typeof pos !== 'number') {
        throw new Error('pos must be a number!')
      }
      if (pos + length > this._content.length || pos < 0 || length < 0) {
        throw new Error('The deletion range exceeds the range of the array!')
      }
      if (length === 0) {
        return
      }
      var eventHandler = this.eventHandler
      var dels = []
      for (var i = 0; i < length; i = i + delLength) {
        var targetId = this._content[pos + i].id
        var delLength
        // how many insertions can we delete in one deletion?
        for (delLength = 1; i + delLength < length; delLength++) {
          if (!Y.utils.compareIds(this._content[pos + i + delLength].id, [targetId[0], targetId[1] + delLength])) {
            break
          }
        }
        dels.push({
          target: targetId,
          struct: 'Delete',
          length: delLength
        })
      }
      eventHandler.awaitAndPrematurelyCall(dels)
      this.os.requestTransaction(function *() {
        yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [dels])
      })
    }
    observe (f) {
      this.eventHandler.addEventListener(f)
    }
    unobserve (f) {
      this.eventHandler.removeEventListener(f)
    }
    * _changed (transaction, op) {
      if (!op.deleted) {
        if (op.struct === 'Insert') {
          var l = op.left
          var left
          while (l != null) {
            left = yield* transaction.getInsertion(l)
            if (!left.deleted) {
              break
            }
            l = left.left
          }
          op.left = l
        }
        this.eventHandler.receivedOp(op)
      }
    }
  }

  Y.extend('Array', new Y.utils.CustomType({
    name: 'Array',
    class: YArray,
    struct: 'List',
    initType: function * YArrayInitializer (os, model) {
      var _content = []
      yield* Y.Struct.List.map.call(this, model, function (op) {
        if (op.hasOwnProperty('opContent')) {
          _content.push({
            id: op.id,
            type: op.opContent
          })
        } else {
          op.content.forEach(function (c, i) {
            _content.push({
              id: [op.id[0], op.id[1] + i],
              val: op.content[i]
            })
          })
        }
      })
      return new YArray(os, model.id, _content)
    }
  }))
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

},{}],184:[function(require,module,exports){
/* global Y */
'use strict'

function extend (Y /* :any */) {
  class YMap {
    /* ::
    _model: Id;
    os: Y.AbstractDatabase;
    map: Object;
    contents: any;
    opContents: Object;
    eventHandler: Function;
    */
    constructor (os, model, contents, opContents) {
      this._model = model.id
      this.os = os
      this.map = Y.utils.copyObject(model.map)
      this.contents = contents
      this.opContents = opContents
      this.eventHandler = new Y.utils.EventHandler(op => {
        var oldValue
        // key is the name to use to access (op)content
        var key = op.struct === 'Delete' ? op.key : op.parentSub

        // compute oldValue
        if (this.opContents[key] != null) {
          let prevType = this.opContents[key]
          oldValue = () => {// eslint-disable-line
            return new Promise((resolve) => {
              this.os.requestTransaction(function *() {// eslint-disable-line
                var type = yield* this.getType(prevType)
                resolve(type)
              })
            })
          }
        } else {
          oldValue = this.contents[key]
        }
        // compute op event
        if (op.struct === 'Insert') {
          if (op.left === null) {
            var value
            // TODO: what if op.deleted??? I partially handles this case here.. (maybe from the previous version)
            if (op.opContent != null) {
              value = () => {// eslint-disable-line
                return new Promise((resolve) => {
                  this.os.requestTransaction(function *() {// eslint-disable-line
                    var type = yield* this.getType(op.opContent)
                    resolve(type)
                  })
                })
              }
              delete this.contents[key]
              if (op.deleted) {
                delete this.opContents[key]
              } else {
                this.opContents[key] = op.opContent
              }
            } else {
              value = op.content[0]
              delete this.opContents[key]
              if (op.deleted) {
                delete this.contents[key]
              } else {
                this.contents[key] = op.content[0]
              }
            }
            this.map[key] = op.id
            if (oldValue === undefined) {
              this.eventHandler.callEventListeners({
                name: key,
                object: this,
                type: 'add',
                value: value
              })
            } else {
              this.eventHandler.callEventListeners({
                name: key,
                object: this,
                oldValue: oldValue,
                type: 'update',
                value: value
              })
            }
          }
        } else if (op.struct === 'Delete') {
          if (Y.utils.compareIds(this.map[key], op.target)) {
            delete this.opContents[key]
            delete this.contents[key]
            this.eventHandler.callEventListeners({
              name: key,
              object: this,
              oldValue: oldValue,
              type: 'delete'
            })
          }
        } else {
          throw new Error('Unexpected Operation!')
        }
      })
    }
    _destroy () {
      this.eventHandler.destroy()
      this.eventHandler = null
      this.contents = null
      this.opContents = null
      this._model = null
      this.os = null
      this.map = null
    }
    get (key) {
      // return property.
      // if property does not exist, return null
      // if property is a type, return a promise
      if (key == null || typeof key !== 'string') {
        throw new Error('You must specify a key (as string)!')
      }
      if (this.opContents[key] == null) {
        return this.contents[key]
      } else {
        return new Promise((resolve) => {
          var oid = this.opContents[key]
          this.os.requestTransaction(function *() {
            var type = yield* this.getType(oid)
            resolve(type)
          })
        })
      }
    }
    keys () {
      return Object.keys(this.contents).concat(Object.keys(this.opContents))
    }
    keysPrimitives () {
      return Object.keys(this.contents)
    }
    keysTypes () {
      return Object.keys(this.opContents)
    }
    /*
      If there is a primitive (not a custom type), then return it.
      Returns all primitive values, if propertyName is specified!
      Note: modifying the return value could result in inconsistencies!
        -- so make sure to copy it first!
    */
    getPrimitive (key) {
      if (key == null) {
        return Y.utils.copyObject(this.contents)
      } else if (typeof key !== 'string') {
        throw new Error('Key is expected to be a string!')
      } else {
        return this.contents[key]
      }
    }
    getType (key) {
      if (key == null || typeof key !== 'string') {
        throw new Error('You must specify a key (as string)!')
      } else if (this.opContents[key] != null) {
        return new Promise((resolve) => {
          var oid = this.opContents[key]
          this.os.requestTransaction(function *() {
            var type = yield* this.getType(oid)
            resolve(type)
          })
        })
      } else {
        return Promise.reject('No property specified for this key!')
      }
    }
    delete (key) {
      var right = this.map[key]
      if (right != null) {
        var del = {
          target: right,
          struct: 'Delete'
        }
        var eventHandler = this.eventHandler
        var modDel = Y.utils.copyObject(del)
        modDel.key = key
        this.os.requestTransaction(function *() {
          yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [[del]])
        })
        // always remember to do that after this.os.requestTransaction
        // (otherwise values might contain a undefined reference to type)
        eventHandler.awaitAndPrematurelyCall([modDel])
      }
    }
    set (key, value) {
      // set property.
      // if property is a type, return a promise
      // if not, apply immediately on this type an call event

      var right = this.map[key] || null
      var insert /* :any */ = {
        id: this.os.getNextOpId(1),
        left: null,
        right: right,
        origin: null,
        parent: this._model,
        parentSub: key,
        struct: 'Insert'
      }
      var eventHandler = this.eventHandler
      return new Promise((resolve) => {
        var typeDefinition = Y.utils.isTypeDefinition(value)
        if (typeDefinition !== false) {
          var typeid = this.os.getNextOpId(1)
          insert.opContent = typeid
          // construct a new type
          this.os.requestTransaction(function *() {
            var type = yield* this.createType(typeDefinition, typeid)
            yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [[insert]])
            resolve(type)
          })
          // always remember to do that after this.os.requestTransaction
          // (otherwise values might contain a undefined reference to type)
          eventHandler.awaitAndPrematurelyCall([insert])
        } else {
          insert.content = [value]
          this.os.requestTransaction(function * () {
            yield* eventHandler.awaitOps(this, this.applyCreatedOperations, [[insert]])
          })
          // always remember to do that after this.os.requestTransaction
          // (otherwise values might contain a undefined reference to type)
          eventHandler.awaitAndPrematurelyCall([insert])
          resolve(value)
        }
      })
    }
    observe (f) {
      this.eventHandler.addEventListener(f)
    }
    unobserve (f) {
      this.eventHandler.removeEventListener(f)
    }
    /*
      Observe a path.

      E.g.
      ```
      o.set('textarea', Y.TextBind)
      o.observePath(['textarea'], function(t){
        // is called whenever textarea is replaced
        t.bind(textarea)
      })

      returns a Promise that contains a function that removes the observer from the path.
    */
    observePath (path, f) {
      var self = this
      function observeProperty (event) {
        // call f whenever path changes
        if (event.name === propertyName) {
          // call this also for delete events!
          var property = self.get(propertyName)
          if (property instanceof Promise) {
            property.then(f)
          } else {
            f(property)
          }
        }
      }

      if (path.length < 1) {
        f(this)
        return Promise.resolve(function () {})
      } else if (path.length === 1) {
        var propertyName = path[0]
        var property = self.get(propertyName)
        if (property instanceof Promise) {
          property.then(f)
        } else {
          f(property)
        }
        this.observe(observeProperty)
        return Promise.resolve(function () {
          self.unobserve(f)
        })
      } else {
        var deleteChildObservers
        var resetObserverPath = function () {
          var promise = self.get(path[0])
          if (!promise instanceof Promise) {
            // its either not defined or a primitive value
            promise = self.set(path[0], Y.Map)
          }
          return promise.then(function (map) {
            return map.observePath(path.slice(1), f)
          }).then(function (_deleteChildObservers) {
            // update deleteChildObservers
            deleteChildObservers = _deleteChildObservers
            return Promise.resolve() // Promise does not return anything
          })
        }
        var observer = function (event) {
          if (event.name === path[0]) {
            if (deleteChildObservers != null) {
              deleteChildObservers()
            }
            if (event.type === 'add' || event.type === 'update') {
              resetObserverPath()
            }
            // TODO: what about the delete events?
          }
        }
        self.observe(observer)
        return resetObserverPath().then(function () {
          // this promise contains a function that deletes all the child observers
          // and how to unobserve the observe from this object
          return Promise.resolve(function () { // eslint-disable-line
            if (deleteChildObservers != null) {
              deleteChildObservers()
            }
            self.unobserve(observer)
          })
        })
      }
    }
    * _changed (transaction, op) {
      if (op.struct === 'Delete') {
        var target = yield* transaction.getOperation(op.target)
        op.key = target.parentSub
      }
      this.eventHandler.receivedOp(op)
    }
  }
  Y.extend('Map', new Y.utils.CustomType({
    name: 'Map',
    class: YMap,
    struct: 'Map',
    initType: function * YMapInitializer (os, model) {
      var contents = {}
      var opContents = {}
      var map = model.map
      for (var name in map) {
        var op = yield* this.getOperation(map[name])
        if (op.opContent != null) {
          opContents[name] = op.opContent
        } else {
          contents[name] = op.content[0]
        }
      }
      return new YMap(os, model, contents, opContents)
    }
  }))
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

},{}],185:[function(require,module,exports){
/* global Y */
'use strict'

function extend (Y) {
  require('./RedBlackTree.js')(Y)
  class Transaction extends Y.Transaction {
    constructor (store) {
      super(store)
      this.store = store
      this.ss = store.ss
      this.os = store.os
      this.ds = store.ds
    }
  }
  var Store = Y.utils.RBTree
  var BufferedStore = Y.utils.createSmallLookupBuffer(Store)

  class Database extends Y.AbstractDatabase {
    constructor (y, opts) {
      super(y, opts)
      this.os = new BufferedStore()
      this.ds = new Store()
      this.ss = new BufferedStore()
    }
    logTable () {
      var self = this
      self.requestTransaction(function * () {
        console.log('User: ', this.store.y.connector.userId, "==============================") // eslint-disable-line
        console.log("State Set (SS):", yield* this.getStateSet()) // eslint-disable-line
        console.log("Operation Store (OS):") // eslint-disable-line
        yield* this.os.logTable() // eslint-disable-line
        console.log("Deletion Store (DS):") //eslint-disable-line
        yield* this.ds.logTable() // eslint-disable-line
        if (this.store.gc1.length > 0 || this.store.gc2.length > 0) {
          console.warn('GC1|2 not empty!', this.store.gc1, this.store.gc2)
        }
        if (JSON.stringify(this.store.listenersById) !== '{}') {
          console.warn('listenersById not empty!')
        }
        if (JSON.stringify(this.store.listenersByIdExecuteNow) !== '[]') {
          console.warn('listenersByIdExecuteNow not empty!')
        }
        if (this.store.transactionInProgress) {
          console.warn('Transaction still in progress!')
        }
      }, true)
    }
    transact (makeGen) {
      var t = new Transaction(this)
      while (makeGen !== null) {
        var gen = makeGen.call(t)
        var res = gen.next()
        while (!res.done) {
          res = gen.next(res.value)
        }
        makeGen = this.getNextRequest()
      }
    }
    * destroy () {
      yield* super.destroy()
      delete this.os
      delete this.ss
      delete this.ds
    }
  }
  Y.extend('memory', Database)
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

},{"./RedBlackTree.js":186}],186:[function(require,module,exports){
'use strict'

/*
  This file contains a not so fancy implemantion of a Red Black Tree.
*/
module.exports = function (Y) {
  class N {
    // A created node is always red!
    constructor (val) {
      this.val = val
      this.color = true
      this._left = null
      this._right = null
      this._parent = null
      if (val.id === null) {
        throw new Error('You must define id!')
      }
    }
    isRed () { return this.color }
    isBlack () { return !this.color }
    redden () { this.color = true; return this }
    blacken () { this.color = false; return this }
    get grandparent () {
      return this.parent.parent
    }
    get parent () {
      return this._parent
    }
    get sibling () {
      return (this === this.parent.left)
        ? this.parent.right : this.parent.left
    }
    get left () {
      return this._left
    }
    get right () {
      return this._right
    }
    set left (n) {
      if (n !== null) {
        n._parent = this
      }
      this._left = n
    }
    set right (n) {
      if (n !== null) {
        n._parent = this
      }
      this._right = n
    }
    rotateLeft (tree) {
      var parent = this.parent
      var newParent = this.right
      var newRight = this.right.left
      newParent.left = this
      this.right = newRight
      if (parent === null) {
        tree.root = newParent
        newParent._parent = null
      } else if (parent.left === this) {
        parent.left = newParent
      } else if (parent.right === this) {
        parent.right = newParent
      } else {
        throw new Error('The elements are wrongly connected!')
      }
    }
    next () {
      if (this.right !== null) {
        // search the most left node in the right tree
        var o = this.right
        while (o.left !== null) {
          o = o.left
        }
        return o
      } else {
        var p = this
        while (p.parent !== null && p !== p.parent.left) {
          p = p.parent
        }
        return p.parent
      }
    }
    prev () {
      if (this.left !== null) {
        // search the most right node in the left tree
        var o = this.left
        while (o.right !== null) {
          o = o.right
        }
        return o
      } else {
        var p = this
        while (p.parent !== null && p !== p.parent.right) {
          p = p.parent
        }
        return p.parent
      }
    }
    rotateRight (tree) {
      var parent = this.parent
      var newParent = this.left
      var newLeft = this.left.right
      newParent.right = this
      this.left = newLeft
      if (parent === null) {
        tree.root = newParent
        newParent._parent = null
      } else if (parent.left === this) {
        parent.left = newParent
      } else if (parent.right === this) {
        parent.right = newParent
      } else {
        throw new Error('The elements are wrongly connected!')
      }
    }
    getUncle () {
      // we can assume that grandparent exists when this is called!
      if (this.parent === this.parent.parent.left) {
        return this.parent.parent.right
      } else {
        return this.parent.parent.left
      }
    }
  }

  class RBTree {
    constructor () {
      this.root = null
      this.length = 0
    }
    * findNext (id) {
      return yield* this.findWithLowerBound([id[0], id[1] + 1])
    }
    * findPrev (id) {
      return yield* this.findWithUpperBound([id[0], id[1] - 1])
    }
    findNodeWithLowerBound (from) {
      if (from === void 0) {
        throw new Error('You must define from!')
      }
      var o = this.root
      if (o === null) {
        return null
      } else {
        while (true) {
          if ((from === null || Y.utils.smaller(from, o.val.id)) && o.left !== null) {
            // o is included in the bound
            // try to find an element that is closer to the bound
            o = o.left
          } else if (from !== null && Y.utils.smaller(o.val.id, from)) {
            // o is not within the bound, maybe one of the right elements is..
            if (o.right !== null) {
              o = o.right
            } else {
              // there is no right element. Search for the next bigger element,
              // this should be within the bounds
              return o.next()
            }
          } else {
            return o
          }
        }
      }
    }
    findNodeWithUpperBound (to) {
      if (to === void 0) {
        throw new Error('You must define from!')
      }
      var o = this.root
      if (o === null) {
        return null
      } else {
        while (true) {
          if ((to === null || Y.utils.smaller(o.val.id, to)) && o.right !== null) {
            // o is included in the bound
            // try to find an element that is closer to the bound
            o = o.right
          } else if (to !== null && Y.utils.smaller(to, o.val.id)) {
            // o is not within the bound, maybe one of the left elements is..
            if (o.left !== null) {
              o = o.left
            } else {
              // there is no left element. Search for the prev smaller element,
              // this should be within the bounds
              return o.prev()
            }
          } else {
            return o
          }
        }
      }
    }
    findSmallestNode () {
      var o = this.root
      while (o != null && o.left != null) {
        o = o.left
      }
      return o
    }
    * findWithLowerBound (from) {
      var n = this.findNodeWithLowerBound(from)
      return n == null ? null : n.val
    }
    * findWithUpperBound (to) {
      var n = this.findNodeWithUpperBound(to)
      return n == null ? null : n.val
    }
    * iterate (t, from, to, f) {
      var o
      if (from === null) {
        o = this.findSmallestNode()
      } else {
        o = this.findNodeWithLowerBound(from)
      }
      while (o !== null && (to === null || Y.utils.smaller(o.val.id, to) || Y.utils.compareIds(o.val.id, to))) {
        yield* f.call(t, o.val)
        o = o.next()
      }
      return true
    }
    * logTable (from, to, filter) {
      if (filter == null) {
        filter = function () {
          return true
        }
      }
      if (from == null) { from = null }
      if (to == null) { to = null }
      var os = []
      yield* this.iterate(this, from, to, function * (o) {
        if (filter(o)) {
          var o_ = {}
          for (var key in o) {
            if (typeof o[key] === 'object') {
              o_[key] = JSON.stringify(o[key])
            } else {
              o_[key] = o[key]
            }
          }
          os.push(o_)
        }
      })
      if (console.table != null) {
        console.table(os)
      }
    }
    * find (id) {
      var n
      return (n = this.findNode(id)) ? n.val : null
    }
    findNode (id) {
      if (id == null || id.constructor !== Array) {
        throw new Error('Expect id to be an array!')
      }
      var o = this.root
      if (o === null) {
        return false
      } else {
        while (true) {
          if (o === null) {
            return false
          }
          if (Y.utils.smaller(id, o.val.id)) {
            o = o.left
          } else if (Y.utils.smaller(o.val.id, id)) {
            o = o.right
          } else {
            return o
          }
        }
      }
    }
    * delete (id) {
      if (id == null || id.constructor !== Array) {
        throw new Error('id is expected to be an Array!')
      }
      var d = this.findNode(id)
      if (d == null) {
        // throw new Error('Element does not exist!')
        return
      }
      this.length--
      if (d.left !== null && d.right !== null) {
        // switch d with the greates element in the left subtree.
        // o should have at most one child.
        var o = d.left
        // find
        while (o.right !== null) {
          o = o.right
        }
        // switch
        d.val = o.val
        d = o
      }
      // d has at most one child
      // let n be the node that replaces d
      var isFakeChild
      var child = d.left || d.right
      if (child === null) {
        isFakeChild = true
        child = new N({id: 0})
        child.blacken()
        d.right = child
      } else {
        isFakeChild = false
      }

      if (d.parent === null) {
        if (!isFakeChild) {
          this.root = child
          child.blacken()
          child._parent = null
        } else {
          this.root = null
        }
        return
      } else if (d.parent.left === d) {
        d.parent.left = child
      } else if (d.parent.right === d) {
        d.parent.right = child
      } else {
        throw new Error('Impossible!')
      }
      if (d.isBlack()) {
        if (child.isRed()) {
          child.blacken()
        } else {
          this._fixDelete(child)
        }
      }
      this.root.blacken()
      if (isFakeChild) {
        if (child.parent.left === child) {
          child.parent.left = null
        } else if (child.parent.right === child) {
          child.parent.right = null
        } else {
          throw new Error('Impossible #3')
        }
      }
    }
    _fixDelete (n) {
      function isBlack (node) {
        return node !== null ? node.isBlack() : true
      }
      function isRed (node) {
        return node !== null ? node.isRed() : false
      }
      if (n.parent === null) {
        // this can only be called after the first iteration of fixDelete.
        return
      }
      // d was already replaced by the child
      // d is not the root
      // d and child are black
      var sibling = n.sibling
      if (isRed(sibling)) {
        // make sibling the grandfather
        n.parent.redden()
        sibling.blacken()
        if (n === n.parent.left) {
          n.parent.rotateLeft(this)
        } else if (n === n.parent.right) {
          n.parent.rotateRight(this)
        } else {
          throw new Error('Impossible #2')
        }
        sibling = n.sibling
      }
      // parent, sibling, and children of n are black
      if (n.parent.isBlack() &&
        sibling.isBlack() &&
        isBlack(sibling.left) &&
        isBlack(sibling.right)
      ) {
        sibling.redden()
        this._fixDelete(n.parent)
      } else if (n.parent.isRed() &&
        sibling.isBlack() &&
        isBlack(sibling.left) &&
        isBlack(sibling.right)
      ) {
        sibling.redden()
        n.parent.blacken()
      } else {
        if (n === n.parent.left &&
          sibling.isBlack() &&
          isRed(sibling.left) &&
          isBlack(sibling.right)
        ) {
          sibling.redden()
          sibling.left.blacken()
          sibling.rotateRight(this)
          sibling = n.sibling
        } else if (n === n.parent.right &&
          sibling.isBlack() &&
          isRed(sibling.right) &&
          isBlack(sibling.left)
        ) {
          sibling.redden()
          sibling.right.blacken()
          sibling.rotateLeft(this)
          sibling = n.sibling
        }
        sibling.color = n.parent.color
        n.parent.blacken()
        if (n === n.parent.left) {
          sibling.right.blacken()
          n.parent.rotateLeft(this)
        } else {
          sibling.left.blacken()
          n.parent.rotateRight(this)
        }
      }
    }
    * put (v) {
      if (v == null || v.id == null || v.id.constructor !== Array) {
        throw new Error('v is expected to have an id property which is an Array!')
      }
      var node = new N(v)
      if (this.root !== null) {
        var p = this.root // p abbrev. parent
        while (true) {
          if (Y.utils.smaller(node.val.id, p.val.id)) {
            if (p.left === null) {
              p.left = node
              break
            } else {
              p = p.left
            }
          } else if (Y.utils.smaller(p.val.id, node.val.id)) {
            if (p.right === null) {
              p.right = node
              break
            } else {
              p = p.right
            }
          } else {
            p.val = node.val
            return p
          }
        }
        this._fixInsert(node)
      } else {
        this.root = node
      }
      this.length++
      this.root.blacken()
      return node
    }
    _fixInsert (n) {
      if (n.parent === null) {
        n.blacken()
        return
      } else if (n.parent.isBlack()) {
        return
      }
      var uncle = n.getUncle()
      if (uncle !== null && uncle.isRed()) {
        // Note: parent: red, uncle: red
        n.parent.blacken()
        uncle.blacken()
        n.grandparent.redden()
        this._fixInsert(n.grandparent)
      } else {
        // Note: parent: red, uncle: black or null
        // Now we transform the tree in such a way that
        // either of these holds:
        //   1) grandparent.left.isRed
        //     and grandparent.left.left.isRed
        //   2) grandparent.right.isRed
        //     and grandparent.right.right.isRed
        if (n === n.parent.right && n.parent === n.grandparent.left) {
          n.parent.rotateLeft(this)
          // Since we rotated and want to use the previous
          // cases, we need to set n in such a way that
          // n.parent.isRed again
          n = n.left
        } else if (n === n.parent.left && n.parent === n.grandparent.right) {
          n.parent.rotateRight(this)
          // see above
          n = n.right
        }
        // Case 1) or 2) hold from here on.
        // Now traverse grandparent, make parent a black node
        // on the highest level which holds two red nodes.
        n.parent.blacken()
        n.grandparent.redden()
        if (n === n.parent.left) {
          // Case 1
          n.grandparent.rotateRight(this)
        } else {
          // Case 2
          n.grandparent.rotateLeft(this)
        }
      }
    }
    * flush () {}
  }

  Y.utils.RBTree = RBTree
}

},{}],187:[function(require,module,exports){
(function (global){
/* global Y, global */
'use strict'

// socket.io requires utf8. This package checks if it is required by requirejs.
// If window.require is set, then it will define itself as a module. This is erratic behavior and
// results in socket.io having a "bad request".
// This is why we undefine global.define (it is set by requirejs) before we require socket.io-client.
var define = global.define
global.define = null
var io = require('socket.io-client')
// redefine global.define
global.define = define

function extend (Y) {
  class Connector extends Y.AbstractConnector {
    constructor (y, options) {
      if (options === undefined) {
        throw new Error('Options must not be undefined!')
      }
      if (options.room == null) {
        throw new Error('You must define a room name!')
      }
      options.role = 'slave'
      super(y, options)
      this.options = options
      options.url = options.url || 'https://yjs.dbis.rwth-aachen.de:5072'
      var socket = options.socket || io(options.url)
      this.socket = socket
      var self = this

      this._onConnect = function joinRoom () {
        socket.emit('joinRoom', options.room)
        self.userJoined('server', 'master')
      }

      socket.on('connect', this._onConnect)
      if (socket.connected) {
        this._onConnect()
      } else {
        socket.connect()
      }

      this._onYjsEvent = function (message) {
        if (message.type != null) {
          if (message.type === 'sync done') {
            var userId = socket.id
            if (socket._yjs_connection_counter == null) {
              socket._yjs_connection_counter = 1
            } else {
              userId += socket._yjs_connection_counter++
            }
            self.setUserId(userId)
          }
          if (message.room === options.room) {
            self.receiveMessage('server', message)
          }
        }
      }
      socket.on('yjsEvent', this._onYjsEvent)

      this._onDisconnect = function (peer) {
        self.userLeft('server')
      }
      socket.on('disconnect', this._onDisconnect)
    }
    disconnect () {
      this.socket.emit('leaveRoom', this.options.room)
      if (!this.options.socket) {
        this.socket.disconnect()
      }
      super.disconnect()
    }
    destroy () {
      this.disconnect()
      this.socket.off('disconnect', this._onDisconnect)
      this.socket.off('yjsEvent', this._onYjsEvent)
      this.socket.off('connect', this._onConnect)
      if (!this.options.socket) {
        this.socket.destroy()
      }
      this.socket = null
    }
    reconnect () {
      this.socket.connect()
      super.reconnect()
    }
    send (uid, message) {
      message.room = this.options.room
      this.socket.emit('yjsEvent', message)
    }
    broadcast (message) {
      message.room = this.options.room
      this.socket.emit('yjsEvent', message)
    }
    isDisconnected () {
      return this.socket.disconnected
    }
  }
  Connector.io = io
  Y.extend('websockets-client', Connector)
}

module.exports = extend
if (typeof Y !== 'undefined') {
  extend(Y)
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"socket.io-client":127}],188:[function(require,module,exports){
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

},{}],189:[function(require,module,exports){
/* @flow */
'use strict'

module.exports = function (Y/* :any */) {
  class AbstractConnector {
    /* ::
    y: YConfig;
    role: SyncRole;
    connections: Object;
    isSynced: boolean;
    userEventListeners: Array<Function>;
    whenSyncedListeners: Array<Function>;
    currentSyncTarget: ?UserId;
    syncingClients: Array<UserId>;
    forwardToSyncingClients: boolean;
    debug: boolean;
    broadcastedHB: boolean;
    syncStep2: Promise;
    userId: UserId;
    send: Function;
    broadcast: Function;
    broadcastOpBuffer: Array<Operation>;
    protocolVersion: number;
    */
    /*
      opts contains the following information:
       role : String Role of this client ("master" or "slave")
       userId : String Uniquely defines the user.
       debug: Boolean Whether to print debug messages (optional)
    */
    constructor (y, opts) {
      this.y = y
      if (opts == null) {
        opts = {}
      }
      if (opts.role == null || opts.role === 'master') {
        this.role = 'master'
      } else if (opts.role === 'slave') {
        this.role = 'slave'
      } else {
        throw new Error("Role must be either 'master' or 'slave'!")
      }
      this.y.db.forwardAppliedOperations = opts.forwardAppliedOperations || false
      this.role = opts.role
      this.connections = {}
      this.isSynced = false
      this.userEventListeners = []
      this.whenSyncedListeners = []
      this.currentSyncTarget = null
      this.syncingClients = []
      this.forwardToSyncingClients = opts.forwardToSyncingClients !== false
      this.debug = opts.debug === true
      this.broadcastedHB = false
      this.syncStep2 = Promise.resolve()
      this.broadcastOpBuffer = []
      this.protocolVersion = 11
    }
    reconnect () {
    }
    disconnect () {
      this.connections = {}
      this.isSynced = false
      this.currentSyncTarget = null
      this.broadcastedHB = false
      this.syncingClients = []
      this.whenSyncedListeners = []
      return this.y.db.stopGarbageCollector()
    }
    setUserId (userId) {
      if (this.userId == null) {
        this.userId = userId
        return this.y.db.setUserId(userId)
      } else {
        return null
      }
    }
    onUserEvent (f) {
      this.userEventListeners.push(f)
    }
    userLeft (user) {
      if (this.connections[user] != null) {
        delete this.connections[user]
        if (user === this.currentSyncTarget) {
          this.currentSyncTarget = null
          this.findNextSyncTarget()
        }
        this.syncingClients = this.syncingClients.filter(function (cli) {
          return cli !== user
        })
        for (var f of this.userEventListeners) {
          f({
            action: 'userLeft',
            user: user
          })
        }
      }
    }
    userJoined (user, role) {
      if (role == null) {
        throw new Error('You must specify the role of the joined user!')
      }
      if (this.connections[user] != null) {
        throw new Error('This user already joined!')
      }
      this.connections[user] = {
        isSynced: false,
        role: role
      }
      for (var f of this.userEventListeners) {
        f({
          action: 'userJoined',
          user: user,
          role: role
        })
      }
      if (this.currentSyncTarget == null) {
        this.findNextSyncTarget()
      }
    }
    // Execute a function _when_ we are connected.
    // If not connected, wait until connected
    whenSynced (f) {
      if (this.isSynced) {
        f()
      } else {
        this.whenSyncedListeners.push(f)
      }
    }
    /*

     returns false, if there is no sync target
     true otherwise
    */
    findNextSyncTarget () {
      if (this.currentSyncTarget != null || this.isSynced) {
        return // "The current sync has not finished!"
      }

      var syncUser = null
      for (var uid in this.connections) {
        if (!this.connections[uid].isSynced) {
          syncUser = uid
          break
        }
      }
      var conn = this
      if (syncUser != null) {
        this.currentSyncTarget = syncUser
        this.y.db.requestTransaction(function *() {
          var stateSet = yield* this.getStateSet()
          var deleteSet = yield* this.getDeleteSet()
          conn.send(syncUser, {
            type: 'sync step 1',
            stateSet: stateSet,
            deleteSet: deleteSet,
            protocolVersion: conn.protocolVersion
          })
        })
      } else {
        this.y.db.requestTransaction(function *() {
          // it is crucial that isSynced is set at the time garbageCollectAfterSync is called
          conn.isSynced = true
          yield* this.garbageCollectAfterSync()
          // call whensynced listeners
          for (var f of conn.whenSyncedListeners) {
            f()
          }
          conn.whenSyncedListeners = []
        })
      }
    }
    send (uid, message) {
      if (this.debug) {
        console.log(`send ${this.userId} -> ${uid}: ${message.type}`, message) // eslint-disable-line
      }
    }
    /*
      Buffer operations, and broadcast them when ready.
    */
    broadcastOps (ops) {
      ops = ops.map(function (op) {
        return Y.Struct[op.struct].encode(op)
      })
      var self = this
      function broadcastOperations () {
        if (self.broadcastOpBuffer.length > 0) {
          self.broadcast({
            type: 'update',
            ops: self.broadcastOpBuffer
          })
          self.broadcastOpBuffer = []
        }
      }
      if (this.broadcastOpBuffer.length === 0) {
        this.broadcastOpBuffer = ops
        if (this.y.db.transactionInProgress) {
          this.y.db.whenTransactionsFinished().then(broadcastOperations)
        } else {
          setTimeout(broadcastOperations, 0)
        }
      } else {
        this.broadcastOpBuffer = this.broadcastOpBuffer.concat(ops)
      }
    }
    /*
      You received a raw message, and you know that it is intended for Yjs. Then call this function.
    */
    receiveMessage (sender/* :UserId */, message/* :Message */) {
      if (sender === this.userId) {
        return
      }
      if (this.debug) {
        console.log(`receive ${sender} -> ${this.userId}: ${message.type}`, JSON.parse(JSON.stringify(message))) // eslint-disable-line
      }
      if (message.protocolVersion != null && message.protocolVersion !== this.protocolVersion) {
        console.error(
          `You tried to sync with a yjs instance that has a different protocol version
          (You: ${this.protocolVersion}, Client: ${message.protocolVersion}).
          The sync was stopped. You need to upgrade your dependencies (especially Yjs & the Connector)!
          `)
        this.send(sender, {
          type: 'sync stop',
          protocolVersion: this.protocolVersion
        })
        return
      }
      if (message.type === 'sync step 1') {
        let conn = this
        let m = message
        this.y.db.requestTransaction(function *() {
          var currentStateSet = yield* this.getStateSet()
          yield* this.applyDeleteSet(m.deleteSet)

          var ds = yield* this.getDeleteSet()
          var ops = yield* this.getOperations(m.stateSet)
          conn.send(sender, {
            type: 'sync step 2',
            os: ops,
            stateSet: currentStateSet,
            deleteSet: ds,
            protocolVersion: this.protocolVersion
          })
          if (this.forwardToSyncingClients) {
            conn.syncingClients.push(sender)
            setTimeout(function () {
              conn.syncingClients = conn.syncingClients.filter(function (cli) {
                return cli !== sender
              })
              conn.send(sender, {
                type: 'sync done'
              })
            }, 5000) // TODO: conn.syncingClientDuration)
          } else {
            conn.send(sender, {
              type: 'sync done'
            })
          }
          conn._setSyncedWith(sender)
        })
      } else if (message.type === 'sync step 2') {
        let conn = this
        var broadcastHB = !this.broadcastedHB
        this.broadcastedHB = true
        var db = this.y.db
        var defer = {}
        defer.promise = new Promise(function (resolve) {
          defer.resolve = resolve
        })
        this.syncStep2 = defer.promise
        let m /* :MessageSyncStep2 */ = message
        db.requestTransaction(function * () {
          yield* this.applyDeleteSet(m.deleteSet)
          this.store.apply(m.os)
          db.requestTransaction(function * () {
            var ops = yield* this.getOperations(m.stateSet)
            if (ops.length > 0) {
              if (!broadcastHB) { // TODO: consider to broadcast here..
                conn.send(sender, {
                  type: 'update',
                  ops: ops
                })
              } else {
                // broadcast only once!
                conn.broadcastOps(ops)
              }
            }
            defer.resolve()
          })
        })
      } else if (message.type === 'sync done') {
        var self = this
        this.syncStep2.then(function () {
          self._setSyncedWith(sender)
        })
      } else if (message.type === 'update') {
        if (this.forwardToSyncingClients) {
          for (var client of this.syncingClients) {
            this.send(client, message)
          }
        }
        if (this.y.db.forwardAppliedOperations) {
          var delops = message.ops.filter(function (o) {
            return o.struct === 'Delete'
          })
          if (delops.length > 0) {
            this.broadcastOps(delops)
          }
        }
        this.y.db.apply(message.ops)
      }
    }
    _setSyncedWith (user) {
      var conn = this.connections[user]
      if (conn != null) {
        conn.isSynced = true
      }
      if (user === this.currentSyncTarget) {
        this.currentSyncTarget = null
        this.findNextSyncTarget()
      }
    }
    /*
      Currently, the HB encodes operations as JSON. For the moment I want to keep it
      that way. Maybe we support encoding in the HB as XML in the future, but for now I don't want
      too much overhead. Y is very likely to get changed a lot in the future

      Because we don't want to encode JSON as string (with character escaping, wich makes it pretty much unreadable)
      we encode the JSON as XML.

      When the HB support encoding as XML, the format should look pretty much like this.

      does not support primitive values as array elements
      expects an ltx (less than xml) object
    */
    parseMessageFromXml (m/* :any */) {
      function parseArray (node) {
        for (var n of node.children) {
          if (n.getAttribute('isArray') === 'true') {
            return parseArray(n)
          } else {
            return parseObject(n)
          }
        }
      }
      function parseObject (node/* :any */) {
        var json = {}
        for (var attrName in node.attrs) {
          var value = node.attrs[attrName]
          var int = parseInt(value, 10)
          if (isNaN(int) || ('' + int) !== value) {
            json[attrName] = value
          } else {
            json[attrName] = int
          }
        }
        for (var n/* :any */ in node.children) {
          var name = n.name
          if (n.getAttribute('isArray') === 'true') {
            json[name] = parseArray(n)
          } else {
            json[name] = parseObject(n)
          }
        }
        return json
      }
      parseObject(m)
    }
    /*
      encode message in xml
      we use string because Strophe only accepts an "xml-string"..
      So {a:4,b:{c:5}} will look like
      <y a="4">
        <b c="5"></b>
      </y>
      m - ltx element
      json - Object
    */
    encodeMessageToXml (msg, obj) {
      // attributes is optional
      function encodeObject (m, json) {
        for (var name in json) {
          var value = json[name]
          if (name == null) {
            // nop
          } else if (value.constructor === Object) {
            encodeObject(m.c(name), value)
          } else if (value.constructor === Array) {
            encodeArray(m.c(name), value)
          } else {
            m.setAttribute(name, value)
          }
        }
      }
      function encodeArray (m, array) {
        m.setAttribute('isArray', 'true')
        for (var e of array) {
          if (e.constructor === Object) {
            encodeObject(m.c('array-element'), e)
          } else {
            encodeArray(m.c('array-element'), e)
          }
        }
      }
      if (obj.constructor === Object) {
        encodeObject(msg.c('y', { xmlns: 'http://y.ninja/connector-stanza' }), obj)
      } else if (obj.constructor === Array) {
        encodeArray(msg.c('y', { xmlns: 'http://y.ninja/connector-stanza' }), obj)
      } else {
        throw new Error("I can't encode this json!")
      }
    }
  }
  Y.AbstractConnector = AbstractConnector
}

},{}],190:[function(require,module,exports){
/* global getRandom, async */
'use strict'

module.exports = function (Y) {
  var globalRoom = {
    users: {},
    buffers: {}, // TODO: reimplement this idea. This does not cover all cases!! Here, you have a queue which is unrealistic (i.e. think about multiple incoming connections)
    removeUser: function (user) {
      for (var i in this.users) {
        this.users[i].userLeft(user)
      }
      delete this.users[user]
      delete this.buffers[user]
    },
    addUser: function (connector) {
      this.users[connector.userId] = connector
      this.buffers[connector.userId] = {}
      for (var uname in this.users) {
        if (uname !== connector.userId) {
          var u = this.users[uname]
          u.userJoined(connector.userId, 'master')
          connector.userJoined(u.userId, 'master')
        }
      }
    },
    whenTransactionsFinished: function () {
      var ps = []
      for (var name in this.users) {
        ps.push(this.users[name].y.db.whenTransactionsFinished())
      }
      return Promise.all(ps)
    },
    flushOne: function flushOne () {
      var bufs = []
      for (var receiver in globalRoom.buffers) {
        let buff = globalRoom.buffers[receiver]
        var push = false
        for (let sender in buff) {
          if (buff[sender].length > 0) {
            push = true
            break
          }
        }
        if (push) {
          bufs.push(receiver)
        }
      }
      if (bufs.length > 0) {
        var userId = getRandom(bufs)
        let buff = globalRoom.buffers[userId]
        let sender = getRandom(Object.keys(buff))
        var m = buff[sender].shift()
        if (buff[sender].length === 0) {
          delete buff[sender]
        }
        var user = globalRoom.users[userId]
        user.receiveMessage(m[0], m[1])
        return user.y.db.whenTransactionsFinished()
      } else {
        return false
      }
    },
    flushAll: function () {
      return new Promise(function (resolve) {
        // flushes may result in more created operations,
        // flush until there is nothing more to flush
        function nextFlush () {
          var c = globalRoom.flushOne()
          if (c) {
            while (c) {
              c = globalRoom.flushOne()
            }
            globalRoom.whenTransactionsFinished().then(nextFlush)
          } else {
            setTimeout(function () {
              var c = globalRoom.flushOne()
              if (c) {
                c.then(function () {
                  globalRoom.whenTransactionsFinished().then(nextFlush)
                })
              } else {
                resolve()
              }
            }, 0)
          }
        }
        globalRoom.whenTransactionsFinished().then(nextFlush)
      })
    }
  }
  Y.utils.globalRoom = globalRoom

  var userIdCounter = 0

  class Test extends Y.AbstractConnector {
    constructor (y, options) {
      if (options === undefined) {
        throw new Error('Options must not be undefined!')
      }
      options.role = 'master'
      options.forwardToSyncingClients = false
      super(y, options)
      this.setUserId((userIdCounter++) + '').then(() => {
        globalRoom.addUser(this)
      })
      this.globalRoom = globalRoom
      this.syncingClientDuration = 0
    }
    receiveMessage (sender, m) {
      super.receiveMessage(sender, JSON.parse(JSON.stringify(m)))
    }
    send (userId, message) {
      var buffer = globalRoom.buffers[userId]
      if (buffer != null) {
        if (buffer[this.userId] == null) {
          buffer[this.userId] = []
        }
        buffer[this.userId].push(JSON.parse(JSON.stringify([this.userId, message])))
      }
    }
    broadcast (message) {
      for (var key in globalRoom.buffers) {
        var buff = globalRoom.buffers[key]
        if (buff[this.userId] == null) {
          buff[this.userId] = []
        }
        buff[this.userId].push(JSON.parse(JSON.stringify([this.userId, message])))
      }
    }
    isDisconnected () {
      return globalRoom.users[this.userId] == null
    }
    reconnect () {
      if (this.isDisconnected()) {
        globalRoom.addUser(this)
        super.reconnect()
      }
      return Y.utils.globalRoom.flushAll()
    }
    disconnect () {
      if (!this.isDisconnected()) {
        globalRoom.removeUser(this.userId)
        super.disconnect()
      }
      return this.y.db.whenTransactionsFinished()
    }
    flush () {
      var self = this
      return async(function * () {
        var buff = globalRoom.buffers[self.userId]
        while (Object.keys(buff).length > 0) {
          var sender = getRandom(Object.keys(buff))
          var m = buff[sender].shift()
          if (buff[sender].length === 0) {
            delete buff[sender]
          }
          this.receiveMessage(m[0], m[1])
        }
        yield self.whenTransactionsFinished()
      })
    }
  }

  Y.Test = Test
}

},{}],191:[function(require,module,exports){
/* @flow */
'use strict'

module.exports = function (Y /* :any */) {
  /*
    Partial definition of an OperationStore.
    TODO: name it Database, operation store only holds operations.

    A database definition must alse define the following methods:
    * logTable() (optional)
      - show relevant information information in a table
    * requestTransaction(makeGen)
      - request a transaction
    * destroy()
      - destroy the database
  */
  class AbstractDatabase {
    /* ::
    y: YConfig;
    forwardAppliedOperations: boolean;
    listenersById: Object;
    listenersByIdExecuteNow: Array<Object>;
    listenersByIdRequestPending: boolean;
    initializedTypes: Object;
    whenUserIdSetListener: ?Function;
    waitingTransactions: Array<Transaction>;
    transactionInProgress: boolean;
    executeOrder: Array<Object>;
    gc1: Array<Struct>;
    gc2: Array<Struct>;
    gcTimeout: number;
    gcInterval: any;
    garbageCollect: Function;
    executeOrder: Array<any>; // for debugging only
    userId: UserId;
    opClock: number;
    transactionsFinished: ?{promise: Promise, resolve: any};
    transact: (x: ?Generator) => any;
    */
    constructor (y, opts) {
      this.y = y
      var os = this
      this.userId = null
      var resolve
      this.userIdPromise = new Promise(function (r) {
        resolve = r
      })
      this.userIdPromise.resolve = resolve
      // whether to broadcast all applied operations (insert & delete hook)
      this.forwardAppliedOperations = false
      // E.g. this.listenersById[id] : Array<Listener>
      this.listenersById = {}
      // Execute the next time a transaction is requested
      this.listenersByIdExecuteNow = []
      // A transaction is requested
      this.listenersByIdRequestPending = false
      /* To make things more clear, the following naming conventions:
         * ls : we put this.listenersById on ls
         * l : Array<Listener>
         * id : Id (can't use as property name)
         * sid : String (converted from id via JSON.stringify
                         so we can use it as a property name)

        Always remember to first overwrite
        a property before you iterate over it!
      */
      // TODO: Use ES7 Weak Maps. This way types that are no longer user,
      // wont be kept in memory.
      this.initializedTypes = {}
      this.waitingTransactions = []
      this.transactionInProgress = false
      this.transactionIsFlushed = false
      if (typeof YConcurrency_TestingMode !== 'undefined') {
        this.executeOrder = []
      }
      this.gc1 = [] // first stage
      this.gc2 = [] // second stage -> after that, remove the op
      this.gcTimeout = !opts.gcTimeout ? 50000 : opts.gcTimeouts
      function garbageCollect () {
        return os.whenTransactionsFinished().then(function () {
          if (os.gc1.length > 0 || os.gc2.length > 0) {
            if (!os.y.isConnected()) {
              console.warn('gc should be empty when disconnected!')
            }
            return new Promise((resolve) => {
              os.requestTransaction(function * () {
                if (os.y.connector != null && os.y.connector.isSynced) {
                  for (var i = 0; i < os.gc2.length; i++) {
                    var oid = os.gc2[i]
                    yield* this.garbageCollectOperation(oid)
                  }
                  os.gc2 = os.gc1
                  os.gc1 = []
                }
                // TODO: Use setInterval here instead (when garbageCollect is called several times there will be several timeouts..)
                if (os.gcTimeout > 0) {
                  os.gcInterval = setTimeout(garbageCollect, os.gcTimeout)
                }
                resolve()
              })
            })
          } else {
            // TODO: see above
            if (os.gcTimeout > 0) {
              os.gcInterval = setTimeout(garbageCollect, os.gcTimeout)
            }
            return Promise.resolve()
          }
        })
      }
      this.garbageCollect = garbageCollect
      if (this.gcTimeout > 0) {
        garbageCollect()
      }
    }
    queueGarbageCollector (id) {
      if (this.y.isConnected()) {
        this.gc1.push(id)
      }
    }
    emptyGarbageCollector () {
      return new Promise(resolve => {
        var check = () => {
          if (this.gc1.length > 0 || this.gc2.length > 0) {
            this.garbageCollect().then(check)
          } else {
            resolve()
          }
        }
        setTimeout(check, 0)
      })
    }
    addToDebug () {
      if (typeof YConcurrency_TestingMode !== 'undefined') {
        var command /* :string */ = Array.prototype.map.call(arguments, function (s) {
          if (typeof s === 'string') {
            return s
          } else {
            return JSON.stringify(s)
          }
        }).join('').replace(/"/g, "'").replace(/,/g, ', ').replace(/:/g, ': ')
        this.executeOrder.push(command)
      }
    }
    getDebugData () {
      console.log(this.executeOrder.join('\n'))
    }
    stopGarbageCollector () {
      var self = this
      return new Promise(function (resolve) {
        self.requestTransaction(function * () {
          var ungc /* :Array<Struct> */ = self.gc1.concat(self.gc2)
          self.gc1 = []
          self.gc2 = []
          for (var i = 0; i < ungc.length; i++) {
            var op = yield* this.getOperation(ungc[i])
            if (op != null) {
              delete op.gc
              yield* this.setOperation(op)
            }
          }
          resolve()
        })
      })
    }
    /*
      Try to add to GC.

      TODO: rename this function

      Rulez:
      * Only gc if this user is online
      * The most left element in a list must not be gc'd.
        => There is at least one element in the list

      returns true iff op was added to GC
    */
    * addToGarbageCollector (op, left) {
      if (
        op.gc == null &&
        op.deleted === true
      ) {
        var gc = false
        if (left != null && left.deleted === true) {
          gc = true
        } else if (op.content != null && op.content.length > 1) {
          op = yield* this.getInsertionCleanStart([op.id[0], op.id[1] + 1])
          gc = true
        }
        if (gc) {
          op.gc = true
          yield* this.setOperation(op)
          this.store.queueGarbageCollector(op.id)
          return true
        }
      }
      return false
    }
    removeFromGarbageCollector (op) {
      function filter (o) {
        return !Y.utils.compareIds(o, op.id)
      }
      this.gc1 = this.gc1.filter(filter)
      this.gc2 = this.gc2.filter(filter)
      delete op.gc
    }
    * destroy () {
      clearInterval(this.gcInterval)
      this.gcInterval = null
      for (var key in this.initializedTypes) {
        var type = this.initializedTypes[key]
        if (type._destroy != null) {
          type._destroy()
        } else {
          console.error('The type you included does not provide destroy functionality, it will remain in memory (updating your packages will help).')
        }
      }
    }
    setUserId (userId) {
      if (!this.userIdPromise.inProgress) {
        this.userIdPromise.inProgress = true
        var self = this
        self.requestTransaction(function * () {
          self.userId = userId
          var state = yield* this.getState(userId)
          self.opClock = state.clock
          self.userIdPromise.resolve(userId)
        })
      }
      return this.userIdPromise
    }
    whenUserIdSet (f) {
      this.userIdPromise.then(f)
    }
    getNextOpId (numberOfIds) {
      if (numberOfIds == null) {
        throw new Error('getNextOpId expects the number of created ids to create!')
      } else if (this.userId == null) {
        throw new Error('OperationStore not yet initialized!')
      } else {
        var id = [this.userId, this.opClock]
        this.opClock += numberOfIds
        return id
      }
    }
    /*
      Apply a list of operations.

      * get a transaction
      * check whether all Struct.*.requiredOps are in the OS
      * check if it is an expected op (otherwise wait for it)
      * check if was deleted, apply a delete operation after op was applied
    */
    apply (ops) {
      for (var i = 0; i < ops.length; i++) {
        var o = ops[i]
        if (o.id == null || o.id[0] !== this.y.connector.userId) {
          var required = Y.Struct[o.struct].requiredOps(o)
          if (o.requires != null) {
            required = required.concat(o.requires)
          }
          this.whenOperationsExist(required, o)
        }
      }
    }
    /*
      op is executed as soon as every operation requested is available.
      Note that Transaction can (and should) buffer requests.
    */
    whenOperationsExist (ids, op) {
      if (ids.length > 0) {
        let listener = {
          op: op,
          missing: ids.length
        }

        for (let i = 0; i < ids.length; i++) {
          let id = ids[i]
          let sid = JSON.stringify(id)
          let l = this.listenersById[sid]
          if (l == null) {
            l = []
            this.listenersById[sid] = l
          }
          l.push(listener)
        }
      } else {
        this.listenersByIdExecuteNow.push({
          op: op
        })
      }

      if (this.listenersByIdRequestPending) {
        return
      }

      this.listenersByIdRequestPending = true
      var store = this

      this.requestTransaction(function * () {
        var exeNow = store.listenersByIdExecuteNow
        store.listenersByIdExecuteNow = []

        var ls = store.listenersById
        store.listenersById = {}

        store.listenersByIdRequestPending = false

        for (let key = 0; key < exeNow.length; key++) {
          let o = exeNow[key].op
          yield* store.tryExecute.call(this, o)
        }

        for (var sid in ls) {
          var l = ls[sid]
          var id = JSON.parse(sid)
          var op
          if (typeof id[1] === 'string') {
            op = yield* this.getOperation(id)
          } else {
            op = yield* this.getInsertion(id)
          }
          if (op == null) {
            store.listenersById[sid] = l
          } else {
            for (let i = 0; i < l.length; i++) {
              let listener = l[i]
              let o = listener.op
              if (--listener.missing === 0) {
                yield* store.tryExecute.call(this, o)
              }
            }
          }
        }
      })
    }
    /*
      Actually execute an operation, when all expected operations are available.
    */
    /* :: // TODO: this belongs somehow to transaction
    store: Object;
    getOperation: any;
    isGarbageCollected: any;
    addOperation: any;
    whenOperationsExist: any;
    */
    * tryExecute (op) {
      this.store.addToDebug('yield* this.store.tryExecute.call(this, ', JSON.stringify(op), ')')
      if (op.struct === 'Delete') {
        yield* Y.Struct.Delete.execute.call(this, op)
        // this is now called in Transaction.deleteOperation!
        // yield* this.store.operationAdded(this, op)
      } else {
        // check if this op was defined
        var defined = yield* this.getInsertion(op.id)
        while (defined != null && defined.content != null) {
          // check if this op has a longer content in the case it is defined
          if (defined.id[1] + defined.content.length < op.id[1] + op.content.length) {
            var overlapSize = defined.content.length - (op.id[1] - defined.id[1])
            op.content.splice(0, overlapSize)
            op.id = [op.id[0], op.id[1] + overlapSize]
            op.left = Y.utils.getLastId(defined)
            op.origin = op.left
            defined = yield* this.getOperation(op.id) // getOperation suffices here
          } else {
            break
          }
        }
        if (defined == null) {
          var isGarbageCollected = yield* this.isGarbageCollected(op.id)
          if (!isGarbageCollected) {
            yield* Y.Struct[op.struct].execute.call(this, op)
            yield* this.addOperation(op)
            yield* this.store.operationAdded(this, op)

            // if insertion, try to combine with left
            yield* this.tryCombineWithLeft(op)
          }
        }
      }
    }
    /*
     * Called by a transaction when an operation is added.
     * This function is especially important for y-indexeddb, where several instances may share a single database.
     * Every time an operation is created by one instance, it is send to all other instances and operationAdded is called
     *
     * If it's not a Delete operation:
     *   * Checks if another operation is executable (listenersById)
     *   * Update state, if possible
     *
     * Always:
     *   * Call type
     */
    * operationAdded (transaction, op) {
      if (op.struct === 'Delete') {
        var target = yield* transaction.getInsertion(op.target)
        var type = this.initializedTypes[JSON.stringify(target.parent)]
        if (type != null) {
          yield* type._changed(transaction, op)
        }
      } else {
        // increase SS
        yield* transaction.updateState(op.id[0])
        var opLen = op.content != null ? op.content.length : 1
        for (let i = 0; i < opLen; i++) {
          // notify whenOperation listeners (by id)
          var sid = JSON.stringify([op.id[0], op.id[1] + i])
          var l = this.listenersById[sid]
          delete this.listenersById[sid]
          if (l != null) {
            for (var key in l) {
              var listener = l[key]
              if (--listener.missing === 0) {
                this.whenOperationsExist([], listener.op)
              }
            }
          }
        }
        var t = this.initializedTypes[JSON.stringify(op.parent)]

        // if parent is deleted, mark as gc'd and return
        if (op.parent != null) {
          var parentIsDeleted = yield* transaction.isDeleted(op.parent)
          if (parentIsDeleted) {
            yield* transaction.deleteList(op.id)
            return
          }
        }

        // notify parent, if it was instanciated as a custom type
        if (t != null) {
          let o = Y.utils.copyOperation(op)
          yield* t._changed(transaction, o)
        }
        if (!op.deleted) {
          // Delete if DS says this is actually deleted
          var len = op.content != null ? op.content.length : 1
          var startId = op.id // You must not use op.id in the following loop, because op will change when deleted
          for (let i = 0; i < len; i++) {
            var id = [startId[0], startId[1] + i]
            var opIsDeleted = yield* transaction.isDeleted(id)
            if (opIsDeleted) {
              var delop = {
                struct: 'Delete',
                target: id
              }
              yield* this.tryExecute.call(transaction, delop)
            }
          }
        }
      }
    }
    whenTransactionsFinished () {
      if (this.transactionInProgress) {
        if (this.transactionsFinished == null) {
          var resolve
          var promise = new Promise(function (r) {
            resolve = r
          })
          this.transactionsFinished = {
            resolve: resolve,
            promise: promise
          }
          return promise
        } else {
          return this.transactionsFinished.promise
        }
      } else {
        return Promise.resolve()
      }
    }
    // Check if there is another transaction request.
    // * the last transaction is always a flush :)
    getNextRequest () {
      if (this.waitingTransactions.length === 0) {
        if (this.transactionIsFlushed) {
          this.transactionInProgress = false
          this.transactionIsFlushed = false
          if (this.transactionsFinished != null) {
            this.transactionsFinished.resolve()
            this.transactionsFinished = null
          }
          return null
        } else {
          this.transactionIsFlushed = true
          return function * () {
            yield* this.flush()
          }
        }
      } else {
        this.transactionIsFlushed = false
        return this.waitingTransactions.shift()
      }
    }
    requestTransaction (makeGen/* :any */, callImmediately) {
      this.waitingTransactions.push(makeGen)
      if (!this.transactionInProgress) {
        this.transactionInProgress = true
        setTimeout(() => {
          this.transact(this.getNextRequest())
        }, 0)
      }
    }
  }
  Y.AbstractDatabase = AbstractDatabase
}

},{}],192:[function(require,module,exports){
/* @flow */
'use strict'

/*
 An operation also defines the structure of a type. This is why operation and
 structure are used interchangeably here.

 It must be of the type Object. I hope to achieve some performance
 improvements when working on databases that support the json format.

 An operation must have the following properties:

 * encode
     - Encode the structure in a readable format (preferably string- todo)
 * decode (todo)
     - decode structure to json
 * execute
     - Execute the semantics of an operation.
 * requiredOps
     - Operations that are required to execute this operation.
*/
module.exports = function (Y/* :any */) {
  var Struct = {
    /* This is the only operation that is actually not a structure, because
    it is not stored in the OS. This is why it _does not_ have an id

    op = {
      target: Id
    }
    */
    Delete: {
      encode: function (op) {
        return op
      },
      requiredOps: function (op) {
        return [] // [op.target]
      },
      execute: function * (op) {
        return yield* this.deleteOperation(op.target, op.length || 1)
      }
    },
    Insert: {
      /* {
          content: [any],
          opContent: Id,
          id: Id,
          left: Id,
          origin: Id,
          right: Id,
          parent: Id,
          parentSub: string (optional), // child of Map type
        }
      */
      encode: function (op/* :Insertion */) /* :Insertion */ {
        // TODO: you could not send the "left" property, then you also have to
        // "op.left = null" in $execute or $decode
        var e/* :any */ = {
          id: op.id,
          left: op.left,
          right: op.right,
          origin: op.origin,
          parent: op.parent,
          struct: op.struct
        }
        if (op.parentSub != null) {
          e.parentSub = op.parentSub
        }
        if (op.hasOwnProperty('opContent')) {
          e.opContent = op.opContent
        } else {
          e.content = op.content.slice()
        }

        return e
      },
      requiredOps: function (op) {
        var ids = []
        if (op.left != null) {
          ids.push(op.left)
        }
        if (op.right != null) {
          ids.push(op.right)
        }
        if (op.origin != null && !Y.utils.compareIds(op.left, op.origin)) {
          ids.push(op.origin)
        }
        // if (op.right == null && op.left == null) {
        ids.push(op.parent)

        if (op.opContent != null) {
          ids.push(op.opContent)
        }
        return ids
      },
      getDistanceToOrigin: function * (op) {
        if (op.left == null) {
          return 0
        } else {
          var d = 0
          var o = yield* this.getInsertion(op.left)
          while (!Y.utils.matchesId(o, op.origin)) {
            d++
            if (o.left == null) {
              break
            } else {
              o = yield* this.getInsertion(o.left)
            }
          }
          return d
        }
      },
      /*
      # $this has to find a unique position between origin and the next known character
      # case 1: $origin equals $o.origin: the $creator parameter decides if left or right
      #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4
      #         o2,o3 and o4 origin is 1 (the position of o2)
      #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator
      #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex
      #         therefore $this would be always to the right of o3
      # case 2: $origin < $o.origin
      #         if current $this insert_position > $o origin: $this ins
      #         else $insert_position will not change
      #         (maybe we encounter case 1 later, then this will be to the right of $o)
      # case 3: $origin > $o.origin
      #         $this insert_position is to the left of $o (forever!)
      */
      execute: function * (op) {
        var i // loop counter

        // during this function some ops may get split into two pieces (e.g. with getInsertionCleanEnd)
        // We try to merge them later, if possible
        var tryToRemergeLater = []

        if (op.origin != null) { // TODO: !== instead of !=
          // we save in origin that op originates in it
          // we need that later when we eventually garbage collect origin (see transaction)
          var origin = yield* this.getInsertionCleanEnd(op.origin)
          if (origin.originOf == null) {
            origin.originOf = []
          }
          origin.originOf.push(op.id)
          yield* this.setOperation(origin)
          if (origin.right != null) {
            tryToRemergeLater.push(origin.right)
          }
        }
        var distanceToOrigin = i = yield* Struct.Insert.getDistanceToOrigin.call(this, op) // most cases: 0 (starts from 0)

        // now we begin to insert op in the list of insertions..
        var o
        var parent
        var start

        // find o. o is the first conflicting operation
        if (op.left != null) {
          o = yield* this.getInsertionCleanEnd(op.left)
          if (!Y.utils.compareIds(op.left, op.origin) && o.right != null) {
            // only if not added previously
            tryToRemergeLater.push(o.right)
          }
          o = (o.right == null) ? null : yield* this.getOperation(o.right)
        } else { // left == null
          parent = yield* this.getOperation(op.parent)
          let startId = op.parentSub ? parent.map[op.parentSub] : parent.start
          start = startId == null ? null : yield* this.getOperation(startId)
          o = start
        }

        // make sure to split op.right if necessary (also add to tryCombineWithLeft)
        if (op.right != null) {
          tryToRemergeLater.push(op.right)
          yield* this.getInsertionCleanStart(op.right)
        }

        // handle conflicts
        while (true) {
          if (o != null && !Y.utils.compareIds(o.id, op.right)) {
            var oOriginDistance = yield* Struct.Insert.getDistanceToOrigin.call(this, o)
            if (oOriginDistance === i) {
              // case 1
              if (o.id[0] < op.id[0]) {
                op.left = Y.utils.getLastId(o)
                distanceToOrigin = i + 1 // just ignore o.content.length, doesn't make a difference
              }
            } else if (oOriginDistance < i) {
              // case 2
              if (i - distanceToOrigin <= oOriginDistance) {
                op.left = Y.utils.getLastId(o)
                distanceToOrigin = i + 1 // just ignore o.content.length, doesn't make a difference
              }
            } else {
              break
            }
            i++
            if (o.right != null) {
              o = yield* this.getInsertion(o.right)
            } else {
              o = null
            }
          } else {
            break
          }
        }

        // reconnect..
        var left = null
        var right = null
        if (parent == null) {
          parent = yield* this.getOperation(op.parent)
        }

        // reconnect left and set right of op
        if (op.left != null) {
          left = yield* this.getInsertion(op.left)
          // link left
          op.right = left.right
          left.right = op.id

          yield* this.setOperation(left)
        } else {
          // set op.right from parent, if necessary
          op.right = op.parentSub ? parent.map[op.parentSub] || null : parent.start
        }
        // reconnect right
        if (op.right != null) {
          // TODO: wanna connect right too?
          right = yield* this.getOperation(op.right)
          right.left = Y.utils.getLastId(op)

          // if right exists, and it is supposed to be gc'd. Remove it from the gc
          if (right.gc != null) {
            if (right.content != null && right.content.length > 1) {
              right = yield* this.getInsertionCleanEnd(right.id)
            }
            this.store.removeFromGarbageCollector(right)
          }
          yield* this.setOperation(right)
        }

        // update parents .map/start/end properties
        if (op.parentSub != null) {
          if (left == null) {
            parent.map[op.parentSub] = op.id
            yield* this.setOperation(parent)
          }
          // is a child of a map struct.
          // Then also make sure that only the most left element is not deleted
          // We do not call the type in this case (this is what the third parameter is for)
          if (op.right != null) {
            yield* this.deleteOperation(op.right, 1, true)
          }
          if (op.left != null) {
            yield* this.deleteOperation(op.id, 1, true)
          }
        } else {
          if (right == null || left == null) {
            if (right == null) {
              parent.end = Y.utils.getLastId(op)
            }
            if (left == null) {
              parent.start = op.id
            }
            yield* this.setOperation(parent)
          }
        }

        // try to merge original op.left and op.origin
        for (let i = 0; i < tryToRemergeLater.length; i++) {
          var m = yield* this.getOperation(tryToRemergeLater[i])
          yield* this.tryCombineWithLeft(m)
        }
      }
    },
    List: {
      /*
      {
        start: null,
        end: null,
        struct: "List",
        type: "",
        id: this.os.getNextOpId(1)
      }
      */
      create: function (id) {
        return {
          start: null,
          end: null,
          struct: 'List',
          id: id
        }
      },
      encode: function (op) {
        var e = {
          struct: 'List',
          id: op.id,
          type: op.type
        }
        if (op.requires != null) {
          e.requires = op.requires
        }
        if (op.info != null) {
          e.info = op.info
        }
        return e
      },
      requiredOps: function () {
        /*
        var ids = []
        if (op.start != null) {
          ids.push(op.start)
        }
        if (op.end != null){
          ids.push(op.end)
        }
        return ids
        */
        return []
      },
      execute: function * (op) {
        op.start = null
        op.end = null
      },
      ref: function * (op, pos) {
        if (op.start == null) {
          return null
        }
        var res = null
        var o = yield* this.getOperation(op.start)

        while (true) {
          if (!o.deleted) {
            res = o
            pos--
          }
          if (pos >= 0 && o.right != null) {
            o = yield* this.getOperation(o.right)
          } else {
            break
          }
        }
        return res
      },
      map: function * (o, f) {
        o = o.start
        var res = []
        while (o != null) { // TODO: change to != (at least some convention)
          var operation = yield* this.getOperation(o)
          if (!operation.deleted) {
            res.push(f(operation))
          }
          o = operation.right
        }
        return res
      }
    },
    Map: {
      /*
        {
          map: {},
          struct: "Map",
          type: "",
          id: this.os.getNextOpId(1)
        }
      */
      create: function (id) {
        return {
          id: id,
          map: {},
          struct: 'Map'
        }
      },
      encode: function (op) {
        var e = {
          struct: 'Map',
          type: op.type,
          id: op.id,
          map: {} // overwrite map!!
        }
        if (op.requires != null) {
          e.requires = op.requires
        }
        if (op.info != null) {
          e.info = op.info
        }
        return e
      },
      requiredOps: function () {
        return []
      },
      execute: function * () {},
      /*
        Get a property by name
      */
      get: function * (op, name) {
        var oid = op.map[name]
        if (oid != null) {
          var res = yield* this.getOperation(oid)
          if (res == null || res.deleted) {
            return void 0
          } else if (res.opContent == null) {
            return res.content[0]
          } else {
            return yield* this.getType(res.opContent)
          }
        }
      }
    }
  }
  Y.Struct = Struct
}

},{}],193:[function(require,module,exports){
/* @flow */
'use strict'

/*
  Partial definition of a transaction

  A transaction provides all the the async functionality on a database.

  By convention, a transaction has the following properties:
  * ss for StateSet
  * os for OperationStore
  * ds for DeleteStore

  A transaction must also define the following methods:
  * checkDeleteStoreForState(state)
    - When increasing the state of a user, an operation with an higher id
      may already be garbage collected, and therefore it will never be received.
      update the state to reflect this knowledge. This won't call a method to save the state!
  * getDeleteSet(id)
    - Get the delete set in a readable format:
      {
        "userX": [
          [5,1], // starting from position 5, one operations is deleted
          [9,4]  // starting from position 9, four operations are deleted
        ],
        "userY": ...
      }
  * getOpsFromDeleteSet(ds) -- TODO: just call this.deleteOperation(id) here
    - get a set of deletions that need to be applied in order to get to
      achieve the state of the supplied ds
  * setOperation(op)
    - write `op` to the database.
      Note: this is allowed to return an in-memory object.
      E.g. the Memory adapter returns the object that it has in-memory.
      Changing values on this object will be stored directly in the database
      without calling this function. Therefore,
      setOperation may have no functionality in some adapters. This also has
      implications on the way we use operations that were served from the database.
      We try not to call copyObject, if not necessary.
  * addOperation(op)
    - add an operation to the database.
      This may only be called once for every op.id
      Must return a function that returns the next operation in the database (ordered by id)
  * getOperation(id)
  * removeOperation(id)
    - remove an operation from the database. This is called when an operation
      is garbage collected.
  * setState(state)
    - `state` is of the form
      {
        user: "1",
        clock: 4
      } <- meaning that we have four operations from user "1"
           (with these id's respectively: 0, 1, 2, and 3)
  * getState(user)
  * getStateVector()
    - Get the state of the OS in the form
    [{
      user: "userX",
      clock: 11
    },
     ..
    ]
  * getStateSet()
    - Get the state of the OS in the form
    {
      "userX": 11,
      "userY": 22
    }
   * getOperations(startSS)
     - Get the all the operations that are necessary in order to achive the
       stateSet of this user, starting from a stateSet supplied by another user
   * makeOperationReady(ss, op)
     - this is called only by `getOperations(startSS)`. It makes an operation
       applyable on a given SS.
*/
module.exports = function (Y/* :any */) {
  class TransactionInterface {
    /* ::
    store: Y.AbstractDatabase;
    ds: Store;
    os: Store;
    ss: Store;
    */
    /*
      Get a type based on the id of its model.
      If it does not exist yes, create it.
      TODO: delete type from store.initializedTypes[id] when corresponding id was deleted!
    */
    * getType (id, args) {
      var sid = JSON.stringify(id)
      var t = this.store.initializedTypes[sid]
      if (t == null) {
        var op/* :MapStruct | ListStruct */ = yield* this.getOperation(id)
        if (op != null) {
          t = yield* Y[op.type].typeDefinition.initType.call(this, this.store, op, args)
          this.store.initializedTypes[sid] = t
        }
      }
      return t
    }
    * createType (typedefinition, id) {
      var structname = typedefinition[0].struct
      id = id || this.store.getNextOpId(1)
      var op
      if (id[0] === '_') {
        op = yield* this.getOperation(id)
      } else {
        op = Y.Struct[structname].create(id)
        op.type = typedefinition[0].name
      }
      if (typedefinition[0].appendAdditionalInfo != null) {
        yield* typedefinition[0].appendAdditionalInfo.call(this, op, typedefinition[1])
      }
      if (op[0] === '_') {
        yield* this.setOperation(op)
      } else {
        yield* this.applyCreatedOperations([op])
      }
      return yield* this.getType(id, typedefinition[1])
    }
    /* createType (typedefinition, id) {
      var structname = typedefinition[0].struct
      id = id || this.store.getNextOpId(1)
      var op = Y.Struct[structname].create(id)
      op.type = typedefinition[0].name
      if (typedefinition[0].appendAdditionalInfo != null) {
        yield* typedefinition[0].appendAdditionalInfo.call(this, op, typedefinition[1])
      }
      // yield* this.applyCreatedOperations([op])
      yield* Y.Struct[op.struct].execute.call(this, op)
      yield* this.addOperation(op)
      yield* this.store.operationAdded(this, op)
      return yield* this.getType(id, typedefinition[1])
    }*/
    /*
      Apply operations that this user created (no remote ones!)
        * does not check for Struct.*.requiredOps()
        * also broadcasts it through the connector
    */
    * applyCreatedOperations (ops) {
      var send = []
      for (var i = 0; i < ops.length; i++) {
        var op = ops[i]
        yield* this.store.tryExecute.call(this, op)
        if (op.id == null || typeof op.id[1] !== 'string') {
          send.push(Y.Struct[op.struct].encode(op))
        }
      }
      if (!this.store.y.connector.isDisconnected() && send.length > 0) { // TODO: && !this.store.forwardAppliedOperations (but then i don't send delete ops)
        // is connected, and this is not going to be send in addOperation
        this.store.y.connector.broadcastOps(send)
      }
    }

    * deleteList (start) {
      while (start != null) {
        start = yield* this.getOperation(start)
        if (!start.gc) {
          start.gc = true
          start.deleted = true
          yield* this.setOperation(start)
          var delLength = start.content != null ? start.content.length : 1
          yield* this.markDeleted(start.id, delLength)
          if (start.opContent != null) {
            yield* this.deleteOperation(start.opContent)
          }
          this.store.queueGarbageCollector(start.id)
        }
        start = start.right
      }
    }

    /*
      Mark an operation as deleted, and add it to the GC, if possible.
    */
    * deleteOperation (targetId, length, preventCallType) /* :Generator<any, any, any> */ {
      if (length == null) {
        length = 1
      }
      yield* this.markDeleted(targetId, length)
      while (length > 0) {
        var callType = false
        var target = yield* this.os.findWithUpperBound([targetId[0], targetId[1] + length - 1])
        var targetLength = target != null && target.content != null ? target.content.length : 1
        if (target == null || target.id[0] !== targetId[0] || target.id[1] + targetLength <= targetId[1]) {
          // does not exist or is not in the range of the deletion
          target = null
          length = 0
        } else {
          // does exist, check if it is too long
          if (!target.deleted) {
            if (target.id[1] < targetId[1]) {
              // starts to the left of the deletion range
              target = yield* this.getInsertionCleanStart(targetId)
              targetLength = target.content.length // must have content property!
            }
            if (target.id[1] + targetLength > targetId[1] + length) {
              // ends to the right of the deletion range
              target = yield* this.getInsertionCleanEnd([targetId[0], targetId[1] + length - 1])
              targetLength = target.content.length
            }
          }
          length = target.id[1] - targetId[1]
        }

        if (target != null) {
          if (!target.deleted) {
            callType = true
            // set deleted & notify type
            target.deleted = true
            // delete containing lists
            if (target.start != null) {
              // TODO: don't do it like this .. -.-
              yield* this.deleteList(target.start)
              // yield* this.deleteList(target.id) -- do not gc itself because this may still get referenced
            }
            if (target.map != null) {
              for (var name in target.map) {
                yield* this.deleteList(target.map[name])
              }
              // TODO: here to..  (see above)
              // yield* this.deleteList(target.id) -- see above
            }
            if (target.opContent != null) {
              yield* this.deleteOperation(target.opContent)
              // target.opContent = null
            }
            if (target.requires != null) {
              for (var i = 0; i < target.requires.length; i++) {
                yield* this.deleteOperation(target.requires[i])
              }
            }
          }
          var left
          if (target.left != null) {
            left = yield* this.getInsertion(target.left)
          } else {
            left = null
          }

          // set here because it was deleted and/or gc'd
          yield* this.setOperation(target)

          /*
            Check if it is possible to add right to the gc.
            Because this delete can't be responsible for left being gc'd,
            we don't have to add left to the gc..
          */
          var right
          if (target.right != null) {
            right = yield* this.getOperation(target.right)
          } else {
            right = null
          }
          if (callType && !preventCallType) {
            yield* this.store.operationAdded(this, {
              struct: 'Delete',
              target: target.id,
              length: targetLength
            })
          }
          // need to gc in the end!
          yield* this.store.addToGarbageCollector.call(this, target, left)
          if (right != null) {
            yield* this.store.addToGarbageCollector.call(this, right, target)
          }
        }
      }
    }
    /*
      Mark an operation as deleted&gc'd
    */
    * markGarbageCollected (id, len) {
      // this.mem.push(["gc", id]);
      this.store.addToDebug('yield* this.markGarbageCollected(', id, ', ', len, ')')
      var n = yield* this.markDeleted(id, len)
      if (n.id[1] < id[1] && !n.gc) {
        // un-extend left
        var newlen = n.len - (id[1] - n.id[1])
        n.len -= newlen
        yield* this.ds.put(n)
        n = {id: id, len: newlen, gc: false}
        yield* this.ds.put(n)
      }
      // get prev&next before adding a new operation
      var prev = yield* this.ds.findPrev(id)
      var next = yield* this.ds.findNext(id)

      if (id[1] + len < n.id[1] + n.len && !n.gc) {
        // un-extend right
        yield* this.ds.put({id: [id[0], id[1] + len], len: n.len - len, gc: false})
        n.len = len
      }
      // set gc'd
      n.gc = true
      // can extend left?
      if (
        prev != null &&
        prev.gc &&
        Y.utils.compareIds([prev.id[0], prev.id[1] + prev.len], n.id)
      ) {
        prev.len += n.len
        yield* this.ds.delete(n.id)
        n = prev
        // ds.put n here?
      }
      // can extend right?
      if (
        next != null &&
        next.gc &&
        Y.utils.compareIds([n.id[0], n.id[1] + n.len], next.id)
      ) {
        n.len += next.len
        yield* this.ds.delete(next.id)
      }
      yield* this.ds.put(n)
      yield* this.updateState(n.id[0])
    }
    /*
      Mark an operation as deleted.

      returns the delete node
    */
    * markDeleted (id, length) {
      if (length == null) {
        length = 1
      }
      // this.mem.push(["del", id]);
      var n = yield* this.ds.findWithUpperBound(id)
      if (n != null && n.id[0] === id[0]) {
        if (n.id[1] <= id[1] && id[1] <= n.id[1] + n.len) {
          // id is in n's range
          var diff = id[1] + length - (n.id[1] + n.len) // overlapping right
          if (diff > 0) {
            // id+length overlaps n
            if (!n.gc) {
              n.len += diff
            } else {
              diff = n.id[1] + n.len - id[1] // overlapping left (id till n.end)
              if (diff < length) {
                // a partial deletion
                n = {id: [id[0], id[1] + diff], len: length - diff, gc: false}
                yield* this.ds.put(n)
              } else {
                // already gc'd
                throw new Error('Cannot happen! (it dit though.. :()')
                // return n
              }
            }
          } else {
            // no overlapping, already deleted
            return n
          }
        } else {
          // cannot extend left (there is no left!)
          n = {id: id, len: length, gc: false}
          yield* this.ds.put(n) // TODO: you double-put !!
        }
      } else {
        // cannot extend left
        n = {id: id, len: length, gc: false}
        yield* this.ds.put(n)
      }
      // can extend right?
      var next = yield* this.ds.findNext(n.id)
      if (
        next != null &&
        n.id[0] === next.id[0] &&
        n.id[1] + n.len >= next.id[1]
      ) {
        diff = n.id[1] + n.len - next.id[1] // from next.start to n.end
        while (diff >= 0) {
          // n overlaps with next
          if (next.gc) {
            // gc is stronger, so reduce length of n
            n.len -= diff
            if (diff >= next.len) {
              // delete the missing range after next
              diff = diff - next.len // missing range after next
              if (diff > 0) {
                yield* this.ds.put(n) // unneccessary? TODO!
                yield* this.markDeleted([next.id[0], next.id[1] + next.len], diff)
              }
            }
            break
          } else {
            // we can extend n with next
            if (diff > next.len) {
              // n is even longer than next
              // get next.next, and try to extend it
              var _next = yield* this.ds.findNext(next.id)
              yield* this.ds.delete(next.id)
              if (_next == null || n.id[0] !== _next.id[0]) {
                break
              } else {
                next = _next
                diff = n.id[1] + n.len - next.id[1] // from next.start to n.end
                // continue!
              }
            } else {
              // n just partially overlaps with next. extend n, delete next, and break this loop
              n.len += next.len - diff
              yield* this.ds.delete(next.id)
              break
            }
          }
        }
      }
      yield* this.ds.put(n)
      return n
    }
    /*
      Call this method when the client is connected&synced with the
      other clients (e.g. master). This will query the database for
      operations that can be gc'd and add them to the garbage collector.
    */
    * garbageCollectAfterSync () {
      if (this.store.gc1.length > 0 || this.store.gc2.length > 0) {
        console.warn('gc should be empty after sync')
      }
      yield* this.os.iterate(this, null, null, function * (op) {
        if (op.gc) {
          delete op.gc
          yield* this.setOperation(op)
        }
        if (op.parent != null) {
          var parentDeleted = yield* this.isDeleted(op.parent)
          if (parentDeleted) {
            op.gc = true
            if (!op.deleted) {
              yield* this.markDeleted(op.id, op.content != null ? op.content.length : 1)
              op.deleted = true
              if (op.opContent != null) {
                yield* this.deleteOperation(op.opContent)
              }
              if (op.requires != null) {
                for (var i = 0; i < op.requires.length; i++) {
                  yield* this.deleteOperation(op.requires[i])
                }
              }
            }
            yield* this.setOperation(op)
            this.store.gc1.push(op.id) // this is ok becaues its shortly before sync (otherwise use queueGarbageCollector!)
            return
          }
        }
        if (op.deleted) {
          var left = null
          if (op.left != null) {
            left = yield* this.getInsertion(op.left)
          }
          yield* this.store.addToGarbageCollector.call(this, op, left)
        }
      })
    }
    /*
      Really remove an op and all its effects.
      The complicated case here is the Insert operation:
      * reset left
      * reset right
      * reset parent.start
      * reset parent.end
      * reset origins of all right ops
    */
    * garbageCollectOperation (id) {
      this.store.addToDebug('yield* this.garbageCollectOperation(', id, ')')
      var o = yield* this.getOperation(id)
      yield* this.markGarbageCollected(id, (o != null && o.content != null) ? o.content.length : 1) // always mark gc'd
      // if op exists, then clean that mess up..
      if (o != null) {
        var deps = []
        if (o.opContent != null) {
          deps.push(o.opContent)
        }
        if (o.requires != null) {
          deps = deps.concat(o.requires)
        }
        for (var i = 0; i < deps.length; i++) {
          var dep = yield* this.getOperation(deps[i])
          if (dep != null) {
            if (!dep.deleted) {
              yield* this.deleteOperation(dep.id)
              dep = yield* this.getOperation(dep.id)
            }
            dep.gc = true
            yield* this.setOperation(dep)
            this.store.queueGarbageCollector(dep.id)
          } else {
            yield* this.markGarbageCollected(deps[i], 1)
          }
        }

        // remove gc'd op from the left op, if it exists
        if (o.left != null) {
          var left = yield* this.getInsertion(o.left)
          left.right = o.right
          yield* this.setOperation(left)
        }
        // remove gc'd op from the right op, if it exists
        // also reset origins of right ops
        if (o.right != null) {
          var right = yield* this.getOperation(o.right)
          right.left = o.left

          if (o.originOf != null && o.originOf.length > 0) {
            // find new origin of right ops
            // origin is the first left deleted operation
            var neworigin = o.left
            var neworigin_ = null
            while (neworigin != null) {
              neworigin_ = yield* this.getInsertion(neworigin)
              if (neworigin_.deleted) {
                break
              }
              neworigin = neworigin_.left
            }

            // reset origin of all right ops (except first right - duh!),

            /* ** The following code does not rely on the the originOf property **
                  I recently added originOf to all Insert Operations (see Struct.Insert.execute),
                  which saves which operations originate in a Insert operation.
                  Garbage collecting without originOf is more memory efficient, but is nearly impossible for large texts, or lists!
                  But I keep this code for now
            ```
            // reset origin of right
            right.origin = neworigin
            // search until you find origin pointer to the left of o
            if (right.right != null) {
              var i = yield* this.getOperation(right.right)
              var ids = [o.id, o.right]
              while (ids.some(function (id) {
                return Y.utils.compareIds(id, i.origin)
              })) {
                if (Y.utils.compareIds(i.origin, o.id)) {
                  // reset origin of i
                  i.origin = neworigin
                  yield* this.setOperation(i)
                }
                // get next i
                if (i.right == null) {
                  break
                } else {
                  ids.push(i.id)
                  i = yield* this.getOperation(i.right)
                }
              }
            }
            ```
            */
            // ** Now the new implementation starts **
            // reset neworigin of all originOf[*]
            for (var _i in o.originOf) {
              var originsIn = yield* this.getOperation(o.originOf[_i])
              if (originsIn != null) {
                originsIn.origin = neworigin
                yield* this.setOperation(originsIn)
              }
            }
            if (neworigin != null) {
              if (neworigin_.originOf == null) {
                neworigin_.originOf = o.originOf
              } else {
                neworigin_.originOf = o.originOf.concat(neworigin_.originOf)
              }
              yield* this.setOperation(neworigin_)
            }
            // we don't need to set right here, because
            // right should be in o.originOf => it is set it the previous for loop
          } else {
            // we didn't need to reset the origin of right
            // so we have to set right here
            yield* this.setOperation(right)
          }
        }
        // o may originate in another operation.
        // Since o is deleted, we have to reset o.origin's `originOf` property
        if (o.origin != null) {
          var origin = yield* this.getInsertion(o.origin)
          origin.originOf = origin.originOf.filter(function (_id) {
            return !Y.utils.compareIds(id, _id)
          })
          yield* this.setOperation(origin)
        }
        var parent
        if (o.parent != null) {
          parent = yield* this.getOperation(o.parent)
        }
        // remove gc'd op from parent, if it exists
        if (parent != null) {
          var setParent = false // whether to save parent to the os
          if (o.parentSub != null) {
            if (Y.utils.compareIds(parent.map[o.parentSub], o.id)) {
              setParent = true
              if (o.right != null) {
                parent.map[o.parentSub] = o.right
              } else {
                delete parent.map[o.parentSub]
              }
            }
          } else {
            if (Y.utils.compareIds(parent.start, o.id)) {
              // gc'd op is the start
              setParent = true
              parent.start = o.right
            }
            if (Y.utils.matchesId(o, parent.end)) {
              // gc'd op is the end
              setParent = true
              parent.end = o.left
            }
          }
          if (setParent) {
            yield* this.setOperation(parent)
          }
        }
        // finally remove it from the os
        yield* this.removeOperation(o.id)
      }
    }
    * checkDeleteStoreForState (state) {
      var n = yield* this.ds.findWithUpperBound([state.user, state.clock])
      if (n != null && n.id[0] === state.user && n.gc) {
        state.clock = Math.max(state.clock, n.id[1] + n.len)
      }
    }
    * updateState (user) {
      var state = yield* this.getState(user)
      yield* this.checkDeleteStoreForState(state)
      var o = yield* this.getInsertion([user, state.clock])
      var oLength = (o != null && o.content != null) ? o.content.length : 1
      while (o != null && user === o.id[0] && o.id[1] <= state.clock && o.id[1] + oLength > state.clock) {
        // either its a new operation (1. case), or it is an operation that was deleted, but is not yet in the OS
        state.clock += oLength
        yield* this.checkDeleteStoreForState(state)
        o = yield* this.os.findNext(o.id)
        oLength = (o != null && o.content != null) ? o.content.length : 1
      }
      yield* this.setState(state)
    }
    /*
      apply a delete set in order to get
      the state of the supplied ds
    */
    * applyDeleteSet (ds) {
      var deletions = []

      for (var user in ds) {
        var dv = ds[user]
        var pos = 0
        var d = dv[pos]
        yield* this.ds.iterate(this, [user, 0], [user, Number.MAX_VALUE], function * (n) {
          // cases:
          // 1. d deletes something to the right of n
          //  => go to next n (break)
          // 2. d deletes something to the left of n
          //  => create deletions
          //  => reset d accordingly
          //  *)=> if d doesn't delete anything anymore, go to next d (continue)
          // 3. not 2) and d deletes something that also n deletes
          //  => reset d so that it doesn't contain n's deletion
          //  *)=> if d does not delete anything anymore, go to next d (continue)
          while (d != null) {
            var diff = 0 // describe the diff of length in 1) and 2)
            if (n.id[1] + n.len <= d[0]) {
              // 1)
              break
            } else if (d[0] < n.id[1]) {
              // 2)
              // delete maximum the len of d
              // else delete as much as possible
              diff = Math.min(n.id[1] - d[0], d[1])
              deletions.push([user, d[0], diff, d[2]])
            } else {
              // 3)
              diff = n.id[1] + n.len - d[0] // never null (see 1)
              if (d[2] && !n.gc) {
                // d marks as gc'd but n does not
                // then delete either way
                deletions.push([user, d[0], Math.min(diff, d[1]), d[2]])
              }
            }
            if (d[1] <= diff) {
              // d doesn't delete anything anymore
              d = dv[++pos]
            } else {
              d[0] = d[0] + diff // reset pos
              d[1] = d[1] - diff // reset length
            }
          }
        })
        // for the rest.. just apply it
        for (; pos < dv.length; pos++) {
          d = dv[pos]
          deletions.push([user, d[0], d[1], d[2]])
        }
      }
      for (var i = 0; i < deletions.length; i++) {
        var del = deletions[i]
        // always try to delete..
        yield* this.deleteOperation([del[0], del[1]], del[2])
        if (del[3]) {
          // gc..
          yield* this.markGarbageCollected([del[0], del[1]], del[2]) // always mark gc'd
          // remove operation..
          var counter = del[1] + del[2]
          while (counter >= del[1]) {
            var o = yield* this.os.findWithUpperBound([del[0], counter - 1])
            if (o == null) {
              break
            }
            var oLen = o.content != null ? o.content.length : 1
            if (o.id[0] !== del[0] || o.id[1] + oLen <= del[1]) {
              // not in range
              break
            }
            if (o.id[1] + oLen > del[1] + del[2]) {
              // overlaps right
              o = yield* this.getInsertionCleanEnd([del[0], del[1] + del[2] - 1])
            }
            if (o.id[1] < del[1]) {
              // overlaps left
              o = yield* this.getInsertionCleanStart([del[0], del[1]])
            }
            counter = o.id[1]
            yield* this.garbageCollectOperation(o.id)
          }
        }
        if (this.store.forwardAppliedOperations) {
          var ops = []
          ops.push({struct: 'Delete', target: [d[0], d[1]], length: del[2]})
          this.store.y.connector.broadcastOps(ops)
        }
      }
    }
    * isGarbageCollected (id) {
      var n = yield* this.ds.findWithUpperBound(id)
      return n != null && n.id[0] === id[0] && id[1] < n.id[1] + n.len && n.gc
    }
    /*
      A DeleteSet (ds) describes all the deleted ops in the OS
    */
    * getDeleteSet () {
      var ds = {}
      yield* this.ds.iterate(this, null, null, function * (n) {
        var user = n.id[0]
        var counter = n.id[1]
        var len = n.len
        var gc = n.gc
        var dv = ds[user]
        if (dv === void 0) {
          dv = []
          ds[user] = dv
        }
        dv.push([counter, len, gc])
      })
      return ds
    }
    * isDeleted (id) {
      var n = yield* this.ds.findWithUpperBound(id)
      return n != null && n.id[0] === id[0] && id[1] < n.id[1] + n.len
    }
    * setOperation (op) {
      yield* this.os.put(op)
      return op
    }
    * addOperation (op) {
      yield* this.os.put(op)
      if (!this.store.y.connector.isDisconnected() && this.store.forwardAppliedOperations && typeof op.id[1] !== 'string') {
        // is connected, and this is not going to be send in addOperation
        this.store.y.connector.broadcastOps([op])
      }
    }
    // if insertion, try to combine with left insertion (if both have content property)
    * tryCombineWithLeft (op) {
      if (
        op != null &&
        op.left != null &&
        op.content != null &&
        op.left[0] === op.id[0] &&
        Y.utils.compareIds(op.left, op.origin)
      ) {
        var left = yield* this.getInsertion(op.left)
        if (left.content != null &&
            left.id[1] + left.content.length === op.id[1] &&
            left.originOf.length === 1 &&
            !left.gc && !left.deleted &&
            !op.gc && !op.deleted
        ) {
          // combine!
          if (op.originOf != null) {
            left.originOf = op.originOf
          } else {
            delete left.originOf
          }
          left.content = left.content.concat(op.content)
          left.right = op.right
          yield* this.os.delete(op.id)
          yield* this.setOperation(left)
        }
      }
    }
    * getInsertion (id) {
      var ins = yield* this.os.findWithUpperBound(id)
      if (ins == null) {
        return null
      } else {
        var len = ins.content != null ? ins.content.length : 1 // in case of opContent
        if (id[0] === ins.id[0] && id[1] < ins.id[1] + len) {
          return ins
        } else {
          return null
        }
      }
    }
    * getInsertionCleanStartEnd (id) {
      yield* this.getInsertionCleanStart(id)
      return yield* this.getInsertionCleanEnd(id)
    }
    // Return an insertion such that id is the first element of content
    // This function manipulates an operation, if necessary
    * getInsertionCleanStart (id) {
      var ins = yield* this.getInsertion(id)
      if (ins != null) {
        if (ins.id[1] === id[1]) {
          return ins
        } else {
          var left = Y.utils.copyObject(ins)
          ins.content = left.content.splice(id[1] - ins.id[1])
          ins.id = id
          var leftLid = Y.utils.getLastId(left)
          ins.origin = leftLid
          left.originOf = [ins.id]
          left.right = ins.id
          ins.left = leftLid
          // debugger // check
          yield* this.setOperation(left)
          yield* this.setOperation(ins)
          if (left.gc) {
            this.store.queueGarbageCollector(ins.id)
          }
          return ins
        }
      } else {
        return null
      }
    }
    // Return an insertion such that id is the last element of content
    // This function manipulates an operation, if necessary
    * getInsertionCleanEnd (id) {
      var ins = yield* this.getInsertion(id)
      if (ins != null) {
        if (ins.content == null || (ins.id[1] + ins.content.length - 1 === id[1])) {
          return ins
        } else {
          var right = Y.utils.copyObject(ins)
          right.content = ins.content.splice(id[1] - ins.id[1] + 1) // cut off remainder
          right.id = [id[0], id[1] + 1]
          var insLid = Y.utils.getLastId(ins)
          right.origin = insLid
          ins.originOf = [right.id]
          ins.right = right.id
          right.left = insLid
          // debugger // check
          yield* this.setOperation(right)
          yield* this.setOperation(ins)
          if (ins.gc) {
            this.store.queueGarbageCollector(right.id)
          }
          return ins
        }
      } else {
        return null
      }
    }
    * getOperation (id/* :any */)/* :Transaction<any> */ {
      var o = yield* this.os.find(id)
      if (id[0] !== '_' || o != null) {
        return o
      } else { // type is string
        // generate this operation?
        var comp = id[1].split('_')
        if (comp.length > 1) {
          var struct = comp[0]
          var op = Y.Struct[struct].create(id)
          op.type = comp[1]
          yield* this.setOperation(op)
          return op
        } else {
          // won't be called. but just in case..
          console.error('Unexpected case. How can this happen?')
          debugger // eslint-disable-line
          return null
        }
      }
    }
    * removeOperation (id) {
      yield* this.os.delete(id)
    }
    * setState (state) {
      var val = {
        id: [state.user],
        clock: state.clock
      }
      yield* this.ss.put(val)
    }
    * getState (user) {
      var n = yield* this.ss.find([user])
      var clock = n == null ? null : n.clock
      if (clock == null) {
        clock = 0
      }
      return {
        user: user,
        clock: clock
      }
    }
    * getStateVector () {
      var stateVector = []
      yield* this.ss.iterate(this, null, null, function * (n) {
        stateVector.push({
          user: n.id[0],
          clock: n.clock
        })
      })
      return stateVector
    }
    * getStateSet () {
      var ss = {}
      yield* this.ss.iterate(this, null, null, function * (n) {
        ss[n.id[0]] = n.clock
      })
      return ss
    }
    /*
      Here, we make all missing operations executable for the receiving user.

      Notes:
        startSS: denotes to the SV that the remote user sent
        currSS:  denotes to the state vector that the user should have if he
                 applies all already sent operations (increases is each step)

      We face several problems:
      * Execute op as is won't work because ops depend on each other
       -> find a way so that they do not anymore
      * When changing left, must not go more to the left than the origin
      * When changing right, you have to consider that other ops may have op
        as their origin, this means that you must not set one of these ops
        as the new right (interdependencies of ops)
      * can't just go to the right until you find the first known operation,
        With currSS
          -> interdependency of ops is a problem
        With startSS
          -> leads to inconsistencies when two users join at the same time.
             Then the position depends on the order of execution -> error!

        Solution:
        -> re-create originial situation
          -> set op.left = op.origin (which never changes)
          -> set op.right
               to the first operation that is known (according to startSS)
               or to the first operation that has an origin that is not to the
               right of op.
          -> Enforces unique execution order -> happy user

        Improvements: TODO
          * Could set left to origin, or the first known operation
            (startSS or currSS.. ?)
            -> Could be necessary when I turn GC again.
            -> Is a bad(ish) idea because it requires more computation

      What we do:
      * Iterate over all missing operations.
      * When there is an operation, where the right op is known, send this op all missing ops to the left to the user
      * I explained above what we have to do with each operation. Here is how we do it efficiently:
        1. Go to the left until you find either op.origin, or a known operation (let o denote current operation in the iteration)
        2. Found a known operation -> set op.left = o, and send it to the user. stop
        3. Found o = op.origin -> set op.left = op.origin, and send it to the user. start again from 1. (set op = o)
        4. Found some o -> set o.right = op, o.left = o.origin, send it to the user, continue
    */
    * getOperations (startSS) {
      // TODO: use bounds here!
      if (startSS == null) {
        startSS = {}
      }
      var send = []

      var endSV = yield* this.getStateVector()
      for (var endState of endSV) {
        var user = endState.user
        if (user === '_') {
          continue
        }
        var startPos = startSS[user] || 0
        if (startPos > 0) {
          // There is a change that [user, startPos] is in a composed Insertion (with a smaller counter)
          // find out if that is the case
          var firstMissing = yield* this.getInsertion([user, startPos])
          if (firstMissing != null) {
            // update startPos
            startPos = firstMissing.id[1]
          }
        }
        yield* this.os.iterate(this, [user, startPos], [user, Number.MAX_VALUE], function * (op) {
          op = Y.Struct[op.struct].encode(op)
          if (op.struct !== 'Insert') {
            send.push(op)
          } else if (op.right == null || op.right[1] < (startSS[op.right[0]] || 0)) {
            // case 1. op.right is known
            var o = op
            // Remember: ?
            // -> set op.right
            //    1. to the first operation that is known (according to startSS)
            //    2. or to the first operation that has an origin that is not to the
            //      right of op.
            // For this we maintain a list of ops which origins are not found yet.
            var missing_origins = [op]
            var newright = op.right
            while (true) {
              if (o.left == null) {
                op.left = null
                send.push(op)
                if (!Y.utils.compareIds(o.id, op.id)) {
                  o = Y.Struct[op.struct].encode(o)
                  o.right = missing_origins[missing_origins.length - 1].id
                  send.push(o)
                }
                break
              }
              o = yield* this.getInsertion(o.left)
              // we set another o, check if we can reduce $missing_origins
              while (missing_origins.length > 0 && Y.utils.matchesId(o, missing_origins[missing_origins.length - 1].origin)) {
                missing_origins.pop()
              }
              if (o.id[1] < (startSS[o.id[0]] || 0)) {
                // case 2. o is known
                op.left = Y.utils.getLastId(o)
                send.push(op)
                break
              } else if (Y.utils.matchesId(o, op.origin)) {
                // case 3. o is op.origin
                op.left = op.origin
                send.push(op)
                op = Y.Struct[op.struct].encode(o)
                op.right = newright
                if (missing_origins.length > 0) {
                  console.log('This should not happen .. :( please report this')
                }
                missing_origins = [op]
              } else {
                // case 4. send o, continue to find op.origin
                var s = Y.Struct[op.struct].encode(o)
                s.right = missing_origins[missing_origins.length - 1].id
                s.left = s.origin
                send.push(s)
                missing_origins.push(o)
              }
            }
          }
        })
      }
      return send.reverse()
    }
    /* this is what we used before.. use this as a reference..
    * makeOperationReady (startSS, op) {
      op = Y.Struct[op.struct].encode(op)
      op = Y.utils.copyObject(op) -- use copyoperation instead now!
      var o = op
      var ids = [op.id]
      // search for the new op.right
      // it is either the first known op (according to startSS)
      // or the o that has no origin to the right of op
      // (this is why we use the ids array)
      while (o.right != null) {
        var right = yield* this.getOperation(o.right)
        if (o.right[1] < (startSS[o.right[0]] || 0) || !ids.some(function (id) {
          return Y.utils.compareIds(id, right.origin)
        })) {
          break
        }
        ids.push(o.right)
        o = right
      }
      op.right = o.right
      op.left = op.origin
      return op
    }
    */
    * flush () {
      yield* this.os.flush()
      yield* this.ss.flush()
      yield* this.ds.flush()
    }
  }
  Y.Transaction = TransactionInterface
}

},{}],194:[function(require,module,exports){
/* @flow */
'use strict'

/*
  EventHandler is an helper class for constructing custom types.

  Why: When constructing custom types, you sometimes want your types to work
  synchronous: E.g.
  ``` Synchronous
    mytype.setSomething("yay")
    mytype.getSomething() === "yay"
  ```
  versus
  ``` Asynchronous
    mytype.setSomething("yay")
    mytype.getSomething() === undefined
    mytype.waitForSomething().then(function(){
      mytype.getSomething() === "yay"
    })
  ```

  The structures usually work asynchronously (you have to wait for the
  database request to finish). EventHandler helps you to make your type
  synchronous.
*/
module.exports = function (Y /* : any*/) {
  Y.utils = {}

  class EventListenerHandler {
    constructor () {
      this.eventListeners = []
    }
    destroy () {
      this.eventListeners = null
    }
     /*
      Basic event listener boilerplate...
    */
    addEventListener (f) {
      this.eventListeners.push(f)
    }
    removeEventListener (f) {
      this.eventListeners = this.eventListeners.filter(function (g) {
        return f !== g
      })
    }
    removeAllEventListeners () {
      this.eventListeners = []
    }
    callEventListeners (event) {
      for (var i = 0; i < this.eventListeners.length; i++) {
        try {
          this.eventListeners[i](event)
        } catch (e) {
          console.error('User events must not throw Errors!')
        }
      }
    }
  }
  Y.utils.EventListenerHandler = EventListenerHandler

  class EventHandler extends EventListenerHandler {
    /* ::
    waiting: Array<Insertion | Deletion>;
    awaiting: number;
    onevent: Function;
    eventListeners: Array<Function>;
    */
    /*
      onevent: is called when the structure changes.

      Note: "awaiting opertations" is used to denote operations that were
      prematurely called. Events for received operations can not be executed until
      all prematurely called operations were executed ("waiting operations")
    */
    constructor (onevent /* : Function */) {
      super()
      this.waiting = []
      this.awaiting = 0
      this.onevent = onevent
    }
    destroy () {
      super.destroy()
      this.waiting = null
      this.awaiting = null
      this.onevent = null
    }
    /*
      Call this when a new operation arrives. It will be executed right away if
      there are no waiting operations, that you prematurely executed
    */
    receivedOp (op) {
      if (this.awaiting <= 0) {
        this.onevent(op)
      } else {
        this.waiting.push(op)
      }
    }
    /*
      You created some operations, and you want the `onevent` function to be
      called right away. Received operations will not be executed untill all
      prematurely called operations are executed
    */
    awaitAndPrematurelyCall (ops) {
      this.awaiting++
      ops.map(Y.utils.copyOperation).forEach(this.onevent)
    }
    * awaitOps (transaction, f, args) {
      function notSoSmartSort (array) {
        // this function sorts insertions in a executable order
        var result = []
        while (array.length > 0) {
          for (var i = 0; i < array.length; i++) {
            var independent = true
            for (var j = 0; j < array.length; j++) {
              if (Y.utils.matchesId(array[j], array[i].left)) {
                // array[i] depends on array[j]
                independent = false
                break
              }
            }
            if (independent) {
              result.push(array.splice(i, 1)[0])
              i--
            }
          }
        }
        return result
      }
      var before = this.waiting.length
      // somehow create new operations
      yield* f.apply(transaction, args)
      // remove all appended ops / awaited ops
      this.waiting.splice(before)
      if (this.awaiting > 0) this.awaiting--
      // if there are no awaited ops anymore, we can update all waiting ops, and send execute them (if there are still no awaited ops)
      if (this.awaiting === 0 && this.waiting.length > 0) {
        // update all waiting ops
        for (let i = 0; i < this.waiting.length; i++) {
          var o = this.waiting[i]
          if (o.struct === 'Insert') {
            var _o = yield* transaction.getInsertion(o.id)
            if (!Y.utils.compareIds(_o.id, o.id)) {
              // o got extended
              o.left = [o.id[0], o.id[1] - 1]
            } else if (_o.left == null) {
              o.left = null
            } else {
              // find next undeleted op
              var left = yield* transaction.getInsertion(_o.left)
              while (left.deleted != null) {
                if (left.left != null) {
                  left = yield* transaction.getInsertion(left.left)
                } else {
                  left = null
                  break
                }
              }
              o.left = left != null ? Y.utils.getLastId(left) : null
            }
          }
        }
        // the previous stuff was async, so we have to check again!
        // We also pull changes from the bindings, if there exists such a method, this could increase awaiting too
        if (this._pullChanges != null) {
          this._pullChanges()
        }
        if (this.awaiting === 0) {
          // sort by type, execute inserts first
          var ins = []
          var dels = []
          this.waiting.forEach(function (o) {
            if (o.struct === 'Delete') {
              dels.push(o)
            } else {
              ins.push(o)
            }
          })
          // put in executable order
          ins = notSoSmartSort(ins)
          ins.forEach(this.onevent)
          dels.forEach(this.onevent)
          this.waiting = []
        }
      }
    }
    // TODO: Remove awaitedInserts and awaitedDeletes in favor of awaitedOps, as they are deprecated and do not always work
    // Do this in one of the coming releases that are breaking anyway
    /*
      Call this when you successfully awaited the execution of n Insert operations
    */
    awaitedInserts (n) {
      var ops = this.waiting.splice(this.waiting.length - n)
      for (var oid = 0; oid < ops.length; oid++) {
        var op = ops[oid]
        if (op.struct === 'Insert') {
          for (var i = this.waiting.length - 1; i >= 0; i--) {
            let w = this.waiting[i]
            // TODO: do I handle split operations correctly here? Super unlikely, but yeah..
            // Also: can this case happen? Can op be inserted in the middle of a larger op that is in $waiting?
            if (w.struct === 'Insert') {
              if (Y.utils.matchesId(w, op.left)) {
                // include the effect of op in w
                w.right = op.id
                // exclude the effect of w in op
                op.left = w.left
              } else if (Y.utils.compareIds(w.id, op.right)) {
                // similar..
                w.left = Y.utils.getLastId(op)
                op.right = w.right
              }
            }
          }
        } else {
          throw new Error('Expected Insert Operation!')
        }
      }
      this._tryCallEvents(n)
    }
    /*
      Call this when you successfully awaited the execution of n Delete operations
    */
    awaitedDeletes (n, newLeft) {
      var ops = this.waiting.splice(this.waiting.length - n)
      for (var j = 0; j < ops.length; j++) {
        var del = ops[j]
        if (del.struct === 'Delete') {
          if (newLeft != null) {
            for (var i = 0; i < this.waiting.length; i++) {
              let w = this.waiting[i]
              // We will just care about w.left
              if (w.struct === 'Insert' && Y.utils.compareIds(del.target, w.left)) {
                w.left = newLeft
              }
            }
          }
        } else {
          throw new Error('Expected Delete Operation!')
        }
      }
      this._tryCallEvents(n)
    }
    /* (private)
      Try to execute the events for the waiting operations
    */
    _tryCallEvents () {
      function notSoSmartSort (array) {
        var result = []
        while (array.length > 0) {
          for (var i = 0; i < array.length; i++) {
            var independent = true
            for (var j = 0; j < array.length; j++) {
              if (Y.utils.matchesId(array[j], array[i].left)) {
                // array[i] depends on array[j]
                independent = false
                break
              }
            }
            if (independent) {
              result.push(array.splice(i, 1)[0])
              i--
            }
          }
        }
        return result
      }
      if (this.awaiting > 0) this.awaiting--
      if (this.awaiting === 0 && this.waiting.length > 0) {
        var ins = []
        var dels = []
        this.waiting.forEach(function (o) {
          if (o.struct === 'Delete') {
            dels.push(o)
          } else {
            ins.push(o)
          }
        })
        ins = notSoSmartSort(ins)
        ins.forEach(this.onevent)
        dels.forEach(this.onevent)
        this.waiting = []
      }
    }
  }
  Y.utils.EventHandler = EventHandler

  /*
    A wrapper for the definition of a custom type.
    Every custom type must have three properties:

    * struct
      - Structname of this type
    * initType
      - Given a model, creates a custom type
    * class
      - the constructor of the custom type (e.g. in order to inherit from a type)
  */
  class CustomType { // eslint-disable-line
    /* ::
    struct: any;
    initType: any;
    class: Function;
    name: String;
    */
    constructor (def) {
      if (def.struct == null ||
        def.initType == null ||
        def.class == null ||
        def.name == null
      ) {
        throw new Error('Custom type was not initialized correctly!')
      }
      this.struct = def.struct
      this.initType = def.initType
      this.class = def.class
      this.name = def.name
      if (def.appendAdditionalInfo != null) {
        this.appendAdditionalInfo = def.appendAdditionalInfo
      }
      this.parseArguments = (def.parseArguments || function () {
        return [this]
      }).bind(this)
      this.parseArguments.typeDefinition = this
    }
  }
  Y.utils.CustomType = CustomType

  Y.utils.isTypeDefinition = function isTypeDefinition (v) {
    if (v != null) {
      if (v instanceof Y.utils.CustomType) return [v]
      else if (v.constructor === Array && v[0] instanceof Y.utils.CustomType) return v
      else if (v instanceof Function && v.typeDefinition instanceof Y.utils.CustomType) return [v.typeDefinition]
    }
    return false
  }

  /*
    Make a flat copy of an object
    (just copy properties)
  */
  function copyObject (o) {
    var c = {}
    for (var key in o) {
      c[key] = o[key]
    }
    return c
  }
  Y.utils.copyObject = copyObject

  /*
    Copy an operation, so that it can be manipulated.
    Note: You must not change subproperties (except o.content)!
  */
  function copyOperation (o) {
    o = copyObject(o)
    if (o.content != null) {
      o.content = o.content.map(function (c) { return c })
    }
    return o
  }

  Y.utils.copyOperation = copyOperation

  /*
    Defines a smaller relation on Id's
  */
  function smaller (a, b) {
    return a[0] < b[0] || (a[0] === b[0] && (a[1] < b[1] || typeof a[1] < typeof b[1]))
  }
  Y.utils.smaller = smaller

  function inDeletionRange (del, ins) {
    return del.target[0] === ins[0] && del.target[1] <= ins[1] && ins[1] < del.target[1] + (del.length || 1)
  }
  Y.utils.inDeletionRange = inDeletionRange

  function compareIds (id1, id2) {
    if (id1 == null || id2 == null) {
      return id1 === id2
    } else {
      return id1[0] === id2[0] && id1[1] === id2[1]
    }
  }
  Y.utils.compareIds = compareIds

  function matchesId (op, id) {
    if (id == null || op == null) {
      return id === op
    } else {
      if (id[0] === op.id[0]) {
        if (op.content == null) {
          return id[1] === op.id[1]
        } else {
          return id[1] >= op.id[1] && id[1] < op.id[1] + op.content.length
        }
      }
    }
  }
  Y.utils.matchesId = matchesId

  function getLastId (op) {
    if (op.content == null || op.content.length === 1) {
      return op.id
    } else {
      return [op.id[0], op.id[1] + op.content.length - 1]
    }
  }
  Y.utils.getLastId = getLastId

  function createEmptyOpsArray (n) {
    var a = new Array(n)
    for (var i = 0; i < a.length; i++) {
      a[i] = {
        id: [null, null]
      }
    }
    return a
  }

  function createSmallLookupBuffer (Store) {
    /*
      This buffer implements a very small buffer that temporarily stores operations
      after they are read / before they are written.
      The buffer basically implements FIFO. Often requested lookups will be re-queued every time they are looked up / written.

      It can speed up lookups on Operation Stores and State Stores. But it does not require notable use of memory or processing power.

      Good for os and ss, bot not for ds (because it often uses methods that require a flush)

      I tried to optimize this for performance, therefore no highlevel operations.
    */
    class SmallLookupBuffer extends Store {
      constructor (arg1, arg2) {
        // super(...arguments) -- do this when this is supported by stable nodejs
        super(arg1, arg2)
        this.writeBuffer = createEmptyOpsArray(5)
        this.readBuffer = createEmptyOpsArray(10)
      }
      * find (id, noSuperCall) {
        var i, r
        for (i = this.readBuffer.length - 1; i >= 0; i--) {
          r = this.readBuffer[i]
          // we don't have to use compareids, because id is always defined!
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            // found r
            // move r to the end of readBuffer
            for (; i < this.readBuffer.length - 1; i++) {
              this.readBuffer[i] = this.readBuffer[i + 1]
            }
            this.readBuffer[this.readBuffer.length - 1] = r
            return r
          }
        }
        var o
        for (i = this.writeBuffer.length - 1; i >= 0; i--) {
          r = this.writeBuffer[i]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            o = r
            break
          }
        }
        if (i < 0 && noSuperCall === undefined) {
          // did not reach break in last loop
          // read id and put it to the end of readBuffer
          o = yield* super.find(id)
        }
        if (o != null) {
          for (i = 0; i < this.readBuffer.length - 1; i++) {
            this.readBuffer[i] = this.readBuffer[i + 1]
          }
          this.readBuffer[this.readBuffer.length - 1] = o
        }
        return o
      }
      * put (o) {
        var id = o.id
        var i, r // helper variables
        for (i = this.writeBuffer.length - 1; i >= 0; i--) {
          r = this.writeBuffer[i]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            // is already in buffer
            // forget r, and move o to the end of writeBuffer
            for (; i < this.writeBuffer.length - 1; i++) {
              this.writeBuffer[i] = this.writeBuffer[i + 1]
            }
            this.writeBuffer[this.writeBuffer.length - 1] = o
            break
          }
        }
        if (i < 0) {
          // did not reach break in last loop
          // write writeBuffer[0]
          var write = this.writeBuffer[0]
          if (write.id[0] !== null) {
            yield* super.put(write)
          }
          // put o to the end of writeBuffer
          for (i = 0; i < this.writeBuffer.length - 1; i++) {
            this.writeBuffer[i] = this.writeBuffer[i + 1]
          }
          this.writeBuffer[this.writeBuffer.length - 1] = o
        }
        // check readBuffer for every occurence of o.id, overwrite if found
        // whether found or not, we'll append o to the readbuffer
        for (i = 0; i < this.readBuffer.length - 1; i++) {
          r = this.readBuffer[i + 1]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            this.readBuffer[i] = o
          } else {
            this.readBuffer[i] = r
          }
        }
        this.readBuffer[this.readBuffer.length - 1] = o
      }
      * delete (id) {
        var i, r
        for (i = 0; i < this.readBuffer.length; i++) {
          r = this.readBuffer[i]
          if (r.id[1] === id[1] && r.id[0] === id[0]) {
            this.readBuffer[i] = {
              id: [null, null]
            }
          }
        }
        yield* this.flush()
        yield* super.delete(id)
      }
      * findWithLowerBound (id) {
        var o = yield* this.find(id, true)
        if (o != null) {
          return o
        } else {
          yield* this.flush()
          return yield* super.findWithLowerBound.apply(this, arguments)
        }
      }
      * findWithUpperBound (id) {
        var o = yield* this.find(id, true)
        if (o != null) {
          return o
        } else {
          yield* this.flush()
          return yield* super.findWithUpperBound.apply(this, arguments)
        }
      }
      * findNext () {
        yield* this.flush()
        return yield* super.findNext.apply(this, arguments)
      }
      * findPrev () {
        yield* this.flush()
        return yield* super.findPrev.apply(this, arguments)
      }
      * iterate () {
        yield* this.flush()
        yield* super.iterate.apply(this, arguments)
      }
      * flush () {
        for (var i = 0; i < this.writeBuffer.length; i++) {
          var write = this.writeBuffer[i]
          if (write.id[0] !== null) {
            yield* super.put(write)
            this.writeBuffer[i] = {
              id: [null, null]
            }
          }
        }
      }
    }
    return SmallLookupBuffer
  }
  Y.utils.createSmallLookupBuffer = createSmallLookupBuffer
}

},{}],195:[function(require,module,exports){
/* @flow */
'use strict'

require('./Connector.js')(Y)
require('./Database.js')(Y)
require('./Transaction.js')(Y)
require('./Struct.js')(Y)
require('./Utils.js')(Y)
require('./Connectors/Test.js')(Y)

var requiringModules = {}

module.exports = Y
Y.requiringModules = requiringModules

Y.extend = function (name, value) {
  if (value instanceof Y.utils.CustomType) {
    Y[name] = value.parseArguments
  } else {
    Y[name] = value
  }
  if (requiringModules[name] != null) {
    requiringModules[name].resolve()
    delete requiringModules[name]
  }
}

Y.requestModules = requestModules
function requestModules (modules) {
  // determine if this module was compiled for es5 or es6 (y.js vs. y.es6)
  // if Insert.execute is a Function, then it isnt a generator..
  // then load the es5(.js) files..
  var extention = typeof regeneratorRuntime !== 'undefined' ? '.js' : '.es6'
  var promises = []
  for (var i = 0; i < modules.length; i++) {
    var module = modules[i].split('(')[0]
    var modulename = 'y-' + module.toLowerCase()
    if (Y[module] == null) {
      if (requiringModules[module] == null) {
        // module does not exist
        if (typeof window !== 'undefined' && window.Y !== 'undefined') {
          var imported = document.createElement('script')
          imported.src = Y.sourceDir + '/' + modulename + '/' + modulename + extention
          document.head.appendChild(imported)

          let requireModule = {}
          requiringModules[module] = requireModule
          requireModule.promise = new Promise(function (resolve) {
            requireModule.resolve = resolve
          })
          promises.push(requireModule.promise)
        } else {
          console.info('YJS: Please do not depend on automatic requiring of modules anymore! Extend modules as follows `require(\'y-modulename\')(Y)`')
          require(modulename)(Y)
        }
      } else {
        promises.push(requiringModules[modules[i]].promise)
      }
    }
  }
  return Promise.all(promises)
}

/* ::
type MemoryOptions = {
  name: 'memory'
}
type IndexedDBOptions = {
  name: 'indexeddb',
  namespace: string
}
type DbOptions = MemoryOptions | IndexedDBOptions

type WebRTCOptions = {
  name: 'webrtc',
  room: string
}
type WebsocketsClientOptions = {
  name: 'websockets-client',
  room: string
}
type ConnectionOptions = WebRTCOptions | WebsocketsClientOptions

type YOptions = {
  connector: ConnectionOptions,
  db: DbOptions,
  types: Array<TypeName>,
  sourceDir: string,
  share: {[key: string]: TypeName}
}
*/

function Y (opts/* :YOptions */) /* :Promise<YConfig> */ {
  opts.types = opts.types != null ? opts.types : []
  var modules = [opts.db.name, opts.connector.name].concat(opts.types)
  for (var name in opts.share) {
    modules.push(opts.share[name])
  }
  Y.sourceDir = opts.sourceDir
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      Y.requestModules(modules).then(function () {
        if (opts == null) reject('An options object is expected! ')
        else if (opts.connector == null) reject('You must specify a connector! (missing connector property)')
        else if (opts.connector.name == null) reject('You must specify connector name! (missing connector.name property)')
        else if (opts.db == null) reject('You must specify a database! (missing db property)')
        else if (opts.connector.name == null) reject('You must specify db name! (missing db.name property)')
        else if (opts.share == null) reject('You must specify a set of shared types!')
        else {
          var yconfig = new YConfig(opts)
          yconfig.db.whenUserIdSet(function () {
            yconfig.init(function () {
              resolve(yconfig)
            })
          })
        }
      }).catch(reject)
    }, 0)
  })
}

class YConfig {
  /* ::
  db: Y.AbstractDatabase;
  connector: Y.AbstractConnector;
  share: {[key: string]: any};
  options: Object;
  */
  constructor (opts, callback) {
    this.options = opts
    this.db = new Y[opts.db.name](this, opts.db)
    this.connector = new Y[opts.connector.name](this, opts.connector)
  }
  init (callback) {
    var opts = this.options
    var share = {}
    this.share = share
    this.db.requestTransaction(function * requestTransaction () {
      // create shared object
      for (var propertyname in opts.share) {
        var typeConstructor = opts.share[propertyname].split('(')
        var typeName = typeConstructor.splice(0, 1)
        var args = []
        if (typeConstructor.length === 1) {
          try {
            args = JSON.parse('[' + typeConstructor[0].split(')')[0] + ']')
          } catch (e) {
            throw new Error('Was not able to parse type definition! (share.' + propertyname + ')')
          }
        }
        var type = Y[typeName]
        var typedef = type.typeDefinition
        var id = ['_', typedef.struct + '_' + typeName + '_' + propertyname + '_' + typeConstructor]
        share[propertyname] = yield* this.createType(type.apply(typedef, args), id)
      }
      this.store.whenTransactionsFinished()
        .then(callback)
    })
  }
  isConnected () {
    return this.connector.isSynced
  }
  disconnect () {
    return this.connector.disconnect()
  }
  reconnect () {
    return this.connector.reconnect()
  }
  destroy () {
    if (this.connector.destroy != null) {
      this.connector.destroy()
    } else {
      this.connector.disconnect()
    }
    var self = this
    this.db.requestTransaction(function * () {
      yield* self.db.destroy()
      self.connector = null
      self.db = null
    })
  }
}

if (typeof window !== 'undefined') {
  window.Y = Y
}

},{"./Connector.js":189,"./Connectors/Test.js":190,"./Database.js":191,"./Struct.js":192,"./Transaction.js":193,"./Utils.js":194}],196:[function(require,module,exports){
/**
 * Given a number, return a zero-filled string.
 * From http://stackoverflow.com/questions/1267283/
 * @param  {number} width
 * @param  {number} number
 * @return {string}
 */
module.exports = function zeroFill (width, number, pad) {
  if (number === undefined) {
    return function (number, pad) {
      return zeroFill(width, number, pad)
    }
  }
  if (pad === undefined) pad = '0'
  width -= number.toString().length
  if (width > 0) return new Array(width + (/\./.test(number) ? 2 : 1)).join(pad) + number
  return number + ''
}

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJPYWtTdHJlYW1pbmcvaW5kZXguanMiLCJleGFtcGxlX2FwcGxpY2F0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2FkZHItdG8taXAtcG9ydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdGZpZWxkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtcHJvdG9jb2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYml0dG9ycmVudC10cmFja2VyL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9iaXR0b3JyZW50LXRyYWNrZXIvbGliL2NsaWVudC90cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY2xpZW50L3dlYnNvY2tldC10cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2JpdHRvcnJlbnQtdHJhY2tlci9saWIvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2Jsb2ItdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmxvY2stc3RyZWFtMi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2J1aWx0aW4tc3RhdHVzLWNvZGVzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2h1bmstc3RvcmUtc3RyZWFtL3dyaXRlLmpzIiwibm9kZV9tb2R1bGVzL2Nsb3Nlc3QtdG8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcGFjdDJzdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWluaGVyaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS10b3JyZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZS10b3JyZW50L25vZGVfbW9kdWxlcy9iZW5jb2RlL2JlbmNvZGUuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlLXRvcnJlbnQvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtdG9ycmVudC9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZGljdC5qcyIsIm5vZGVfbW9kdWxlcy9jcmVhdGUtdG9ycmVudC9ub2RlX21vZHVsZXMvYmVuY29kZS9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvZGVmaW5lZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmQtb2Ytc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZmlsZXN0cmVhbS9yZWFkLmpzIiwibm9kZV9tb2R1bGVzL2ZsYXR0ZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0LWJyb3dzZXItcnRjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLWNvcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGF0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbW1lZGlhdGUtY2h1bmstc3RvcmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lwYWRkci5qcy9saWIvaXBhZGRyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFzY2lpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1maWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXR5cGVkYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qdW5rL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hZ25ldC11cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VyY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVtb3J5LWNodW5rLXN0b3JlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21wNC1ib3gtZW5jb2RpbmcvYm94ZXMuanMiLCJub2RlX21vZHVsZXMvbXA0LWJveC1lbmNvZGluZy9kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL21wNC1ib3gtZW5jb2RpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXA0LXN0cmVhbS9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvbXA0LXN0cmVhbS9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvbXA0LXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aXN0cmVhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uZXh0LWV2ZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS10b3JyZW50LWZpbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2UtdG9ycmVudC1maWxlL25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcGFyc2UtdG9ycmVudC1maWxlL25vZGVfbW9kdWxlcy9iZW5jb2RlL2xpYi9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcGFyc2UtdG9ycmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZWpzb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGllY2UtbGVuZ3RoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW1wL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tLWl0ZXJhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZ2Utc2xpY2Utc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVuZGVyLW1lZGlhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlbmRlci1tZWRpYS9saWIvbWltZS5qc29uIiwibm9kZV9tb2R1bGVzL3J1bi1wYXJhbGxlbC1saW1pdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ydW4tcGFyYWxsZWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcnVzaGEvcnVzaGEuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtY29uY2F0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1nZXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXNoYTEvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtd2Vic29ja2V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2pzb24zL2xpYi9qc29uMy5qcyIsIm5vZGVfbW9kdWxlcy9zcGVlZG9tZXRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvcmVzcG9uc2UuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLXRvLWJsb2ItdXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS10by1ibG9iL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS13aXRoLWtub3duLWxlbmd0aC10by1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nMmNvbXBhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhpcnR5LXR3by9saWIvdGhpcnR5LXR3by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aGlydHktdHdvL2xpYi90aGlydHktdHdvL3RoaXJ0eS10d28uanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXlidWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycmVudC1kaXNjb3ZlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9ycmVudC1waWVjZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90eXBlZGFycmF5LXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91aW50NjRiZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJub2RlX21vZHVsZXMvdW5vcmRlcmVkLWFycmF5LXJlbW92ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3V0X21ldGFkYXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0X3BleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dF9wZXgvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy91dF9wZXgvbm9kZV9tb2R1bGVzL2JlbmNvZGUvbGliL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy91dGY4L3V0ZjguanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92aWRlb3N0cmVhbS9tcDQtcmVtdXhlci5qcyIsIm5vZGVfbW9kdWxlcy92aWRlb3N0cmVhbS92aWRlb3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvbGliL2ZpbGUtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvbGliL2ZpbGUuanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvcGVlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L2xpYi9yYXJpdHktbWFwLmpzIiwibm9kZV9tb2R1bGVzL3dlYnRvcnJlbnQvbGliL3RvcnJlbnQuanMiLCJub2RlX21vZHVsZXMvd2VidG9ycmVudC9saWIvd2ViY29ubi5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ0b3JyZW50L3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9tdXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3ktYXJyYXkvc3JjL0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL3ktbWFwL3NyYy9NYXAuanMiLCJub2RlX21vZHVsZXMveS1tZW1vcnkvc3JjL01lbW9yeS5qcyIsIm5vZGVfbW9kdWxlcy95LW1lbW9yeS9zcmMvUmVkQmxhY2tUcmVlLmpzIiwibm9kZV9tb2R1bGVzL3ktd2Vic29ja2V0cy1jbGllbnQvc3JjL1dlYnNvY2tldHMtY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3lqcy9zcmMvQ29ubmVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL3lqcy9zcmMvQ29ubmVjdG9ycy9UZXN0LmpzIiwibm9kZV9tb2R1bGVzL3lqcy9zcmMvRGF0YWJhc2UuanMiLCJub2RlX21vZHVsZXMveWpzL3NyYy9TdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMveWpzL3NyYy9UcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy95anMvc3JjL1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3lqcy9zcmMveS5qcyIsIm5vZGVfbW9kdWxlcy96ZXJvLWZpbGwvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0aUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3J1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkRBOzs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL3FEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3h0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbElBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNTNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNVpBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0NEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzViQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3prQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbnZhciBNdWx0aVN0cmVhbSA9IHJlcXVpcmUoJ211bHRpc3RyZWFtJyk7XHJcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG52YXIgcmVhZGFibGVTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcclxudmFyIFZpZGVvc3RyZWFtID0gcmVxdWlyZSgndmlkZW9zdHJlYW0nKTtcclxudmFyIHV0X3BleCA9IHJlcXVpcmUoJ3V0X3BleCcpO1xyXG52YXIgV2ViVG9ycmVudCA9IHJlcXVpcmUoJ3dlYnRvcnJlbnQnKTtcclxudmFyIFNpbXBsZVBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpO1xyXG4vL3ZhciBwYXJzZVRvcnJlbnQgPSByZXF1aXJlKCdwYXJzZS10b3JyZW50Jyk7IC8vIHVubsO2dGlnXHJcbi8vdmFyIGNyZWF0ZVRvcnJlbnQgPSByZXF1aXJlKCdjcmVhdGUtdG9ycmVudCcpOyAvLyB1bm7DtnRpZ1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIEZWU0xcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gRlZTTDtcclxuXHJcblxyXG4gLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgRlZTTCBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIG1ldGhvZHMgc3RyZWFtVmlkZW8sIGxvYWRWaWRlbywgY3JlYXRlU2lnbmFsaW5nRGF0YSwgY3JlYXRlU2lnbmFsaW5nRGF0YVJlc3BvbnNlLCBwcm9jZXNzU2lnbmFsaW5nUmVzcG9uc2UgYW5kIHNldmVyYWwgc2ltcGxlIGdldCBtZXRob2RzICBcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqLyBcclxuZnVuY3Rpb24gRlZTTChPYWtOYW1lKXtcclxuICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAoZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIHBlZXJJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDEwLDMwMCkgKyAxKTsgICBcclxuICAgICAgY29uc29sZS5sb2coXCJWZXJzaW9uOiBTaGFtcyAgICAgICAgSW4gT2FrU3RyZWFtaW5nIGNvbnN0cnVjdG9yLiB0aGlzLm5hbWU6IFwiICsgT2FrTmFtZSk7XHJcbiAgICAgIHZhciBPYWtOYW1lID0gT2FrTmFtZSB8fCBcIk5vTmFtZSBGVlNMIGluc3RhbmNlXCI7XHJcbiAgICAgIFxyXG4gICAgICAvLyBPbmx5IG1ldGhvZHMgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIEFQSSwgaS5lLiBvbmx5IG1ldGhvZHMgc2hvdWxkIGJlIHB1YmxpY2FsbHkgYWNjZXNzaWJsZS5cclxuICAgICAgLy8gRXZlcnkgbWV0aG9kIHNob3VsZCBoYXZlIGFjY2VzcyB0byB0aGVzZSB2YXJpYWJsZXMuIFRoZXJlZm9yZSB0aGV5IGFyZSBkZWZpbmllZCBhdCB0aGlzIGhpZ2ggc2NvcGUuXHJcbiAgICAgIHZhciBzaW1wbGVQZWVyQ3JlYXRpb25Db3VudGVyID0gMDtcclxuICAgICAgdmFyIGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGEgPSBbXTtcclxuICAgICAgdmFyIHRoZVRvcnJlbnQgPSBudWxsO1xyXG4gICAgICB2YXIgcGVlcnNUb0FkZCA9IFtdO1xyXG4gICAgICB2YXIgYnl0ZXNSZWNlaXZlZEZyb21TZXJ2ZXIgPSAwO1xyXG4gICAgICB2YXIgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA9IDA7XHJcbiAgICAgIHZhciBTSVpFX09GX1ZJREVPX0ZJTEUgPSAwO1xyXG4gICAgICBcclxuICAgICAgc2VsZi5zdHJlYW1WaWRlbyA9IHN0cmVhbVZpZGVvO1xyXG4gICAgICBzZWxmLmxvYWRWaWRlbyA9IGxvYWRWaWRlbztcclxuICAgICAgc2VsZi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgIHNlbGYuZ2V0X251bWJlcl9vZl9ieXRlc19kb3dubG9hZGVkX2Zyb21fc2VydmVyID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgcmV0dXJuIGJ5dGVzUmVjZWl2ZWRGcm9tU2VydmVyO1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5nZXRfbnVtYmVyX29mX2J5c3Rlc19kb3dubG9hZGVkX1AyUCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhlVG9ycmVudC5kb3dubG9hZGVkO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5nZXRfbnVtYmVyX29mX2J5dGVzX3VwbG9hZGVkX1AyUCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhlVG9ycmVudC51cGxvYWRlZDtcclxuICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHNlbGYuZ2V0X3BlcmNlbnRhZ2VfZG93bmxvYWRlZF9vZl90b3JyZW50ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgaWYodGhlVG9ycmVudCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGVUb3JyZW50LnByb2dyZXNzO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgc2VsZi5nZXRfZmlsZV9zaXplID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgcmV0dXJuIFNJWkVfT0ZfVklERU9fRklMRTtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGNyZWF0ZXMgKFdlYlJUQy0pc2lnbmFsaW5nIGRhdGEgdGhhdCBjYW4gYmUgcHV0IGludG8gY3JlYXRlU2lnbmFsaW5nRGF0YVJlc3BvbnNlIG1ldGhvZCBvZiBhbm90aGVyIEZWU0wgaW5zdGFuY2UgdG8gbWFudWFsbHkgY29ubmVjdGVkIEZWU0wgaW5zdGFuY2VzIFxyXG4gICAgICBzZWxmLmNyZWF0ZVNpZ25hbGluZ0RhdGEgPSBmdW5jdGlvbiAoY2FsbGJhY2spe1xyXG4gICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZENhbGxiYWNrID0gZmFsc2U7XHJcbiAgICAgICAgIHZhciBvYWtOdW1iZXIgPSBzaW1wbGVQZWVyQ3JlYXRpb25Db3VudGVyO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGEgZm9yIG9ha051bWJlcjogXCIgKyBvYWtOdW1iZXIpO1xyXG4gICAgICAgICBjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0gPSBuZXcgU2ltcGxlUGVlcih7aW5pdGlhdG9yOiB0cnVlLCB0aWNrbGU6IGZhbHNlfSk7XHJcbiAgICAgICAgIHNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXIrKztcclxuICAgICAgICAgXHJcbiAgICAgICAgIGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbb2FrTnVtYmVyXS5vbignc2lnbmFsJywgZnVuY3Rpb24gKHNpZ25hbGluZ0RhdGEpe1xyXG4gICAgICAgICAgICBpZighYWxyZWFkeUNhbGxlZENhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgYWxyZWFkeUNhbGxlZENhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgc2lnbmFsaW5nRGF0YS5vYWtOdW1iZXIgPSBvYWtOdW1iZXI7XHJcbiAgICAgICAgICAgICAgIGNhbGxiYWNrKHNpZ25hbGluZ0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gXHJcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGNyZWF0ZXMgKFdlYlJUQy0pc2lnbmFsaW5nIGRhdGEgYXMgYSByZXNwb25zZSB0byBzaW5nYWxpbmcgZGF0YSBmcm9tIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSBtZXRob2Qgb2YgYW5vdGhlciBGVlNMIGluc3RhbmNlLlxyXG4gICAgICAvLyBUaGlzIG1laHRvZCByZXR1cm5zIG5ldyAoV2ViUlRDLSlzaWduYWxpbmcgZGF0YSB3aGljaCBoYXMgdG8gcHV0IGludG8gcHJvY2Vzc1NpZ25hbGluZ1Jlc3BvbnNlIG1ldGhvZCBvZiB0aGUgRlZTTCBpbnN0YW5jZSB3aGljaCBjcmVhdGVkIHRoZSBvcmlnaW5hbCBzaW5nYWxpbmcgZGF0YS5cclxuICAgICAgc2VsZi5jcmVhdGVTaWduYWxpbmdEYXRhUmVzcG9uc2UgPSBmdW5jdGlvbiAoc2lnbmFsaW5nRGF0YSwgY2FsbGJhY2spe1xyXG4gICAgICAgICB2YXIgb2FrTnVtYmVyID0gc2lnbmFsaW5nRGF0YS5vYWtOdW1iZXI7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gY3JlYXRlU2lnbmFsaW5nRGF0YVJlc3BvbnNlLiBJbiB0aGUgYmVnaW5uaW5nIG9ha051bWJlcjogXCIgKyBvYWtOdW1iZXIpO1xyXG4gICAgICAgICBkZWxldGUgc2lnbmFsaW5nRGF0YS5vYWtOdW1iZXI7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgbXlQZWVyID0gbmV3IFNpbXBsZVBlZXIoe2luaXRpYXRvcjogZmFsc2UsIHRpY2tsZTogZmFsc2V9KTtcclxuICAgICAgICAgdmFyIGluZGV4ID0gc2ltcGxlUGVlckNyZWF0aW9uQ291bnRlcjtcclxuICAgICAgICAgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YVtpbmRleF0gPSBteVBlZXI7XHJcbiAgICAgICAgIHNpbXBsZVBlZXJDcmVhdGlvbkNvdW50ZXIrKztcclxuICAgICAgICAgXHJcbiAgICAgICAgIG15UGVlci5vbignc2lnbmFsJywgZnVuY3Rpb24gKGFuc3dlclNpZ25hbGluZ0RhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSwgYWZ0ZXIgb25TaWduYWwgb2FrTnVtYmVyOiBcIiArIG9ha051bWJlcik7XHJcbiAgICAgICAgICAgIGFuc3dlclNpZ25hbGluZ0RhdGEub2FrTnVtYmVyID0gb2FrTnVtYmVyO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGNyZWF0ZVNpZ25hbGluZ0RhdGFSZXNwb25zZSwgIG9iamVjdCB0aGF0IGlzIHJldHVybmVkIHdpdGggY2FsbGJhY2s6IFwiICsgSlNPTi5zdHJpbmdpZnkoYW5zd2VyU2lnbmFsaW5nRGF0YSkpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhhbnN3ZXJTaWduYWxpbmdEYXRhKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgIG15UGVlci5zaWduYWwoc2lnbmFsaW5nRGF0YSk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIG15UGVlci5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHNlbGYuYWRkU2ltcGxlUGVlckluc3RhbmNlKGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbaW5kZXhdLCB7fSwgZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcImFkZFNpbXBsZVBlZXJJbnN0YW5jZSBlbmRlZFwiKTt9KTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG5cclxuICAgICAgLy8gVGhpcyBtZXRob2QgZmluYWxseSBlc3RhYmxpc2hlcyBhIFdlYi1SVEMgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZSB0d28gRlZTTCBpbnN0YW5jZXMuIEZyb20gbm93IG9uIGJvdGggRlZTTCBpbnN0YW5jZXMgZXhjaGFuZ2UgdmlkZW8gZnJhZ21lbnRzLlxyXG4gICAgICBzZWxmLnByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSA9IGZ1bmN0aW9uIChzaWduYWxpbmdEYXRhLCBjYWxsYmFjayl7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gcHJvY2Vzc1NpZ25hbGluZ1Jlc3BvbnNlLCAgc2lnbmFsaW5nRGF0YSBwYXJhbXRlcjogXCIgKyBKU09OLnN0cmluZ2lmeShzaWduYWxpbmdEYXRhKSk7XHJcbiAgICAgICAgIHZhciBvYWtOdW1iZXIgPSBzaWduYWxpbmdEYXRhLm9ha051bWJlcjtcclxuICAgICAgICAgZGVsZXRlIHNpZ25hbGluZ0RhdGEub2FrTnVtYmVyO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSwgIG9ha051bWJlcjogXCIgKyBvYWtOdW1iZXIpO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcImNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGE6IFwiICsgY29ubmVjdGlvbnNXYWl0aW5nRm9yU2lnbmFsaW5nRGF0YSk7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgKGNvbm5lY3Rpb25zV2FpdGluZ0ZvclNpZ25hbGluZ0RhdGFbb2FrTnVtYmVyXSkub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0VzdGFibGlzaGVkIGEgc2ltcGxlLXBlZXIgY29ubmVjdGlvbicpO1xyXG4gICAgICAgICAgICBzZWxmLmFkZFNpbXBsZVBlZXJJbnN0YW5jZShjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0pO1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkluIHByb2Nlc3NTaWduYWxpbmdSZXNwb25zZSwgIG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byAuc2lnbmFsKCk6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2lnbmFsaW5nRGF0YSkpO1xyXG4gICAgICAgICBjb25uZWN0aW9uc1dhaXRpbmdGb3JTaWduYWxpbmdEYXRhW29ha051bWJlcl0uc2lnbmFsKHNpZ25hbGluZ0RhdGEpO1xyXG4gICAgICB9O1xyXG4gICAgICAgXHJcbiAgICAgICAvKipcclxuICAgICAgICogQHR5cGVkZWYgU3RyZWFtX0luZm9ybWF0aW9uX09iamVjdFxyXG4gICAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdmlkZW9fZmlsZV9zaXplIC0gVGhlIHNpemUgaW4gYnl0ZSBvZiB0aGUgdmlkZW8gZmlsZSB0aGF0IHdhcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXHJcbiAgICAgICAqL1xyXG4gICAgICAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAY2FsbGJhY2sgT2FrU3RyZWFtaW5nfnN0cmVhbVZpZGVvRmluaXNoZWRcclxuICAgICAgICogQHBhcmFtIHtTdHJlYW1fSW5mb3JtYXRpb25fT2JqZWN0fSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0IC0gQW4gb2JqZWN0IHRoYXQgb3RoZXIgY2xpZW50cy9wZWVycyBjYW4gcGFzcyBhcyBhbiBhcmd1bWVudCB0byB0aGVpciBsb2FkVmlkZW8gbWV0aG9kIHRvIGRvd25sb2FkIHRoZSB2aWRlbyBmcm9tIG90aGVyIGNsaWVudHMvcGVlcnMgYW5kL29yIGEgV2ViIFNlcnZlci5cclxuICAgICAgICovIFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFN0cmVhbXMgYSB2aWRlbyBmaWxlIHRvIGFsbCBvdGhlciBjbGllbnRzL3BlZXJzLlxyXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gdmlkZW9fZmlsZSAtIFRoZSB2aWRlbyBmaWxlIHRoYXQgc2hvdWxkIGJlIHN0cmVhbWVkIHRvIHRoZSBvdGhlciBjbGllbnRzL3BlZXJzLiBUaGlzIHBhcmFtdGVyIGNhbiBlaXRoZXIgYmUgYSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUgfFczQyBGaWxlIG9iamVjdH0sIGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlTGlzdCB8VzNDIEZpbGVMaXN0fSwgYSB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCB8Tm9kZSBCdWZmZXIgb2JqZWN0fSBvciBhIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9jbGFzc19zdHJlYW1fcmVhZGFibGUgfFJlYWRhYmxlIHN0cmVhbSBvYmplY3R9LlxyXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIGNyZWF0aW9uIG9mIHRoZSBTdHJlYW1fSW5mb3JtYXRpb25fT2JqZWN0LCB0aGF0IGFmdGVyIGl0cyBjcmVhdGlvbiBnZXRzIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnBhdGhfdG9fZmlsZV9vbl9YSFJfc2VydmVyIC0gVGhlIHBhdGggdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBYTUwgSFRUUCBSZXF1ZXN0IChYSFIpLiBBIHZhbGlkIHBhdGggd291bGQgYmUsIGZvciBleGFtcGxlLCBcIi92aWRlb3MvYVZpZGVvRmlsZS5tcDRcIi4gSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBzZXQgYm90aCB0aGUgcGF0aFRvRmlsZU9uWEhSU2VydmVyIGFuZCB0aGUgaGFzaFZhbHVlIHBhcmFtdGVyIGZvciBzdWNjZXNzZnVsbCBYSFIgcmVxdWVzdHMuIElmIHRoaXMgcHJvcGVydHkgYW5kIHRoZSBoYXNoVmFsdWUgcHJvcGVydHkgaXMgdW5kZWZpbmVkLCBubyB2aWRlbyBkYXRhIHdpbGwgYmUgcmVxdWVzdGVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaGFzaF92YWx1ZSAtIEhhc2ggdmFsdWUgb2YgdGhlIHZpZGVvIGZpbGUgdGhhdCBzaG91bGQgYnkgcmVxdWVzdGVkIGZyb20gdGhlIFNWU0wgV2ViU2VydmVyLiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHNldCBib3RoIHRoZSBwYXRoVG9GaWxlT25YSFJTZXJ2ZXIgYW5kIHRoZSBoYXNoVmFsdWUgcGFyYW10ZXIgZm9yIHN1Y2Nlc3NmdWxsIFhIUiByZXF1ZXN0cy4gSWYgdGhpcyBwcm9wZXJ0eSBhbmQgdGhlIGhhc2hWYWx1ZSBwcm9wZXJ0eSBpcyB1bmRlZmluZWQsIG5vIHZpZGVvIGRhdGEgd2lsbCBiZSByZXF1ZXN0ZWQgZnJvbSB0aGUgc2VydmVyLiBcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuWEhSX3NlcnZlcl9VUkwgLSBVUkwgb2YgYSBYSFIgc2VydmVyIHRoYXQgY2FuIHNlcnZlIHRoZSB2aWRlbyBmaWxlLiBJZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQsIFhIUiB3aWxsIGJlIHNlbmQgdG8gdGhlIFdlYiBzZXJ2ZXIgdGhhdCBzZXJ2ZWQgdGhlIFdlYiBwYWdlLlxyXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5YSFJfcG9ydCAtIFBvcnQgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBjb21tdW5pY2F0aW5nIHdpdGggdGhlIFhIUiBzZXJ2ZXIgdGhhdCB3YXMgc3BlY2lmaWVkIGluIHRoZSBYSFJTZXJ2ZXJVUkwgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgc2hvdWxkIG9ubHkgYmUgc2V0IHdoZW4gdGhlIFhIUlNlcnZlclVSTCBwcm9wZXJ0eSBpcyBzZXQgdG9vLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA4MC5cclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZG93bmxvYWRfZnJvbV9wMnBfdGltZV9yYW5nZSAtIEhvdyBtYW55IHNlY29uZHMgb2YgdmlkZW8gcGxheWJhY2sgbXVzdCBiZSBidWZmZXJlZCBpbiBhZHZhbmNlIHN1Y2ggdGhhdCBubyBtb3JlIGRhdGEgc3RyZWFtcyBhcmUgcmVxdWVzdGVkIGZyb20gdGhlIFdlYlRvcnJlbnQgbmV0d29yay4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMjAgKHNlY29uZHMpLlxyXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jcmVhdGVfcmVhZFN0cmVhbV9yZXF1ZXN0X3NpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYnl0ZSByYW5nZSByZXF1ZXN0cyB0byB0aGUgV2ViVG9ycmVudCBuZXR3b3JrLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA1MDAwMDAwIChieXRlcykuXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmRvd25sb2FkX2Zyb21fc2VydmVyX3RpbWVfcmFuZ2UgLSBIb3cgbWFueSBzZWNvbmRzIG9mIHZpZGVvIHBsYXliYWNrIG11c3QgYmUgYnVmZmVyZWQgaW4gYWR2YW5jZSBzdWNoIHRoYXQgbm8gbW9yZSBkYXRhIGlzIHJlcXVlc3RlZCBmcm9tIHRoZSBYSFIgc2VydmVyLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA1IChzZWNvbmRzKS5cclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucGVlcl91cGxvYWRfbGltaXRfbXVsdGlwbGllciAtIFRoZSBGVlNMIGNsaWVudCB3aWxsIHNldmVybHkgdGhyb3R0bGUgdGhlIHZpZGVvIGRhdGEgdXBsb2FkIHRvIG90aGVyIHBlZXJzIHdoZW4gKGJ5dGVzX3VwbG9hZGVkX3RvX290aGVyX3BlZXJzICogcGVlcl91cGxvYWRfbGltaXRfbXVsdGlwbGllciArIHBlZXJfdXBsb2FkX2xpbWl0X2FkZGl0aW9uID49ICBieXRlc19kb3dubG9hZGVkX2Zyb21fb3RoZXJfcGVlcnMpIGFuZCBzdG9wIHRoZSB0aHJvdHRpbmcgYXMgc29vbiBhcyB0aGlzIGluZXF1YWxpdHkgaXMgbm8gbG9uZ2VyIHRydWUuIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBwZWVyX3VwbG9hZF9saW1pdF9tdWx0aXBsaWVyIGlzIDIuXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnBlZXJfdXBsb2FkX2xpbWl0X2FkZGl0aW9uIC0gVGhlIEZWU0wgY2xpZW50IHdpbGwgc2V2ZXJseSB0aHJvdHRsZSB0aGUgdmlkZW8gZGF0YSB1cGxvYWQgdG8gb3RoZXIgcGVlcnMgd2hlbiAoYnl0ZXNfdXBsb2FkZWRfdG9fb3RoZXJfcGVlcnMgKiBwZWVyX3VwbG9hZF9saW1pdF9tdWx0aXBsaWVyICsgcGVlcl91cGxvYWRfbGltaXRfYWRkaXRpb24gPj0gIGJ5dGVzX2Rvd25sb2FkZWRfZnJvbV9vdGhlcl9wZWVycykgYW5kIHN0b3AgdGhlIHRocm90dGluZyBhcyBzb29uIGFzIHRoaXMgaW5lcXVhbGl0eSBpcyBubyBsb25nZXIgdHJ1ZS4gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHBlZXJfdXBsb2FkX2xpbWl0X2FkZGl0aW9uIGlzIDUwMDAwMCAoYnl0ZSkuXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nW11bXX0gb3B0aW9ucy53ZWJUb3JyZW50X3RyYWNrZXJzIC0gQXJyYXkgb2YgYXJyYXlzIG9mIFdlYlRvcnJlbnQgdHJhY2tpbmcgc2VydmVyIFVSTHMgKHN0cmluZ3MpLiBUaGVzZSBXZWJUb3JyZW50IHRyYWNrZXJzIHdpbGwgYmUgdXNlZCB0byBjb25uZWN0IHRvIG90aGVyIEZWU0wgaW5zdGFuY2VzLlxyXG4gICAgICAgKiBAcGFyYW0ge09ha1N0cmVhbWluZ35zdHJlYW1WaWRlb0ZpbmlzaGVkfSBjYWxsYmFjayAtIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2l0aCB0aGUgZ2VuZXJhdGVkIFN0cmVhbV9JbmZvcm1hdGlvbl9PYmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgZXhlY3V0aW9uIG9mIHN0cmVhbVZpZGVvLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gc3RyZWFtVmlkZW8odmlkZW9fZmlsZSwgb3B0aW9ucywgY2FsbGJhY2ssIHJldHVyblRvcnJlbnQsIGRlc3Ryb3lUb3JyZW50KXsgXHJcbiAgICAgICAgIHZhciB3ZWJUb3JyZW50Q2xpZW50ID0gbmV3IFdlYlRvcnJlbnQoKTtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0cmVhbVZpZGVvIGlzIGV4ZWN1dGVkXCIpO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlkZW9GaWxlOiBcIiArIHZpZGVvRmlsZSk7XHJcbiAgICAgICAgIC8vY29uc29sZS5sb2coXCJvcHRpb25zOiBcIiArIG9wdGlvbnMpO1xyXG4gICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spOyAgICAgICAgIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgIHZhciBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0ID0gb3B0aW9ucztcclxuICAgICAgICAgICAgIFxyXG4gICAgICAgICBpZih2aWRlb19maWxlKXtcclxuICAgICAgICAgICAgdmFyIHNlZWRpbmdPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICBuYW1lOiBcIk9ha1N0cmVhbWluZ19Ub3JyZW50XCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYob3B0aW9ucy53ZWJUb3JyZW50X3RyYWNrZXJzKXtcclxuICAgICAgICAgICAgICAgc2VlZGluZ09wdGlvbnMuYW5ub3VuY2VMaXN0ID0gb3B0aW9ucy53ZWJUb3JyZW50X3RyYWNrZXJzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IFxyXG4gICAgICAgICAgICB3ZWJUb3JyZW50Q2xpZW50LnNlZWQodmlkZW9fZmlsZSwgc2VlZGluZ09wdGlvbnMsIGZ1bmN0aW9uKHRvcnJlbnQpe1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRvcnJlbnQgZmlsZSBpcyBzZWVkZWRcIik7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvKiBLNDIgTWF5YmUgSSB3aWxsIG5lZWQgdGhpcyBsYXRlclxyXG4gICAgICAgICAgICAgICB2YXIgdG9ycmVudEZpbGVBc0Jsb2JVUkwgPSB0b3JyZW50LnRvcnJlbnRGaWxlQmxvYlVSTDtcclxuICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICB2YXIgWEhST3JNZXRob2RFbmRIYXBwZW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB0b3JyZW50RmlsZUFzQmxvYlVSTCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XHJcbiAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC50b3JyZW50QXNCbG9iID0gdGhpcy5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgIGlmKFhIUk9yTWV0aG9kRW5kSGFwcGVuZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBYSFJPck1ldGhvZEVuZEhhcHBlbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgU0laRV9PRl9WSURFT19GSUxFID0gMDtcclxuICAgICAgICAgICAgICAgc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5zaXplX29mX3ZpZGVvX2ZpbGUgPSAwO1xyXG4gICAgICAgICAgICAgICBmb3IodmFyIGk9MCwgbGVuZ3RoPXRvcnJlbnQuZmlsZXMubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgU0laRV9PRl9WSURFT19GSUxFICs9IHRvcnJlbnQuZmlsZXNbaV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LnNpemVfb2ZfdmlkZW9fZmlsZSArPSB0b3JyZW50LmZpbGVzW2ldLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5tYWduZXRVUkkgPSB0b3JyZW50Lm1hZ25ldFVSSTtcclxuICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0b3JyZW50Lm1hZ25ldFVSSTogXCIgKyB0b3JyZW50Lm1hZ25ldFVSSSk7XHJcbiAgICAgICAgICAgICAgIHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QuaW5mb0hhc2ggPSB0b3JyZW50LmluZm9IYXNoO1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC50b3JyZW50RmlsZSA9IHRvcnJlbnQudG9ycmVudEZpbGUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWFkZWQgc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdDpcXG5cIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QpKTtcclxuXHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvLyB2YXIgYnVmZmVyVG9ycmVudCA9IHBhcnNlVG9ycmVudChzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LnBhcnNlZFRvcnJlbnQpOyBLNDJcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gc3RyZWFtVmlkZW8gICAgXCIgKyBzZWxmLk9ha05hbWUgKyBcIi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgZ2V0cyBjcmVhdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoaXMgRlZTTCBpbnN0YW5jZSBhbHJlYWR5IGNvbm5lY3RlZCB0byBhbm90aGVyIHBlZXJcclxuICAgICAgICAgICAgICAgLy8gb3IgYXMgc29vbiBhcyBpdCBjb25uZWN0cyB0byBhbm90aGVyIHBlZXIuXHJcbiAgICAgICAgICAgICAgIHNlbGYuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIHN0cmVhbVZpZGVvICAgIFwiICsgc2VsZi5PYWtOYW1lICsgXCIuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyIGdldHMgZXhlY3V0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgIGlmKG5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMgPD0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMtLTtcclxuICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrQ2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICB0b3JyZW50Lm9uKCd3aXJlJywgZnVuY3Rpb24od2lyZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjYWxsYmFja0NhbGxlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcy0tOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBzdWNoIHRoYXQgdGhlIGZvclRlc3RpbmdfY29ubmVjdGVkVG9OZXdXZWJUb3JyZW50UGVlciBmdW5jdGlvbiBrbm93cyBob3cgbWFueSBwZWVycyBhbHJlYWR5IGNvbm5lY3RlZCB0byB0aGlzIEZWU0wgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgIHRvcnJlbnQub24oJ3dpcmUnLCBmdW5jdGlvbiAod2lyZSl7XHJcbiAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnNCZWNhdXNlTmV3V2lyZXMrKzsgIFxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgLy8gRm9yIHNvbWUgSmFzbWluZSB0ZXN0cyBpdCBpcyBhcHByb3ByaWF0ZSB0aGF0IHRoZSB0b3JyZW50IGdldHMgZGVzdHJveWVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0IGhhcyBiZWVuIGNyZWF0ZWQuIFRoZSBkZXN0cnVjdGlvbiBvZiB0aGUgdG9ycmVudCBzdG9wcyB0aGUgc2VlZGluZy5cclxuICAgICAgICAgICAgICAgaWYocmV0dXJuVG9ycmVudCA9PT0gXCJJdCdzIGEgdGVzdFwiKXtcclxuICAgICAgICAgICAgICAgICAgaWYoZGVzdHJveVRvcnJlbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgdG9ycmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3ZWJUb3JyZW50Q2xpZW50O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QsIHRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3Q7XHJcbiAgICAgICAgICAgICAgIH0gICAgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0KTtcclxuICAgICAgICAgICAgLyogSzQyXHJcbiAgICAgICAgICAgIGlmKFhIUk9yTWV0aG9kRW5kSGFwcGVuZCl7XHJcbiAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgWEhST3JNZXRob2RFbmRIYXBwZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICB9ICBcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAY2FsbGJhY2sgT2FrU3RyZWFtaW5nfmxvYWRlZFZpZGVvRmluaXNoZWRcclxuICAgICAgICovIFxyXG4gICAgICAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTdHJlYW1zIGEgdmlkZW8gZmlsZSB0byBhbGwgb3RoZXIgY2xpZW50cy9wZWVycy5cclxuICAgICAgICogQHBhcmFtIHtTdHJlYW1fSW5mb3JtYXRpb25fT2JqZWN0fSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0IC0gVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEgdGhhdCBpcyBuZWVkZWQgdG8gaW5pdGlhdGUgbG9hZGluZyB0aGUgdmlkZW8gZnJvbSBvdGhlciBwZWVycyBhbmQvb3IgYSBXZWIgc2VydmVyLiBTdHJlYW1fSW5mb3JtYXRpb25fT2JqZWN0J3MgY2FuIGJlIGNyZWF0ZWQgYnkgdGhlIHtAbGluayBzdHJlYW1WaWRlb3xzdHJlYW1WaWRlb30gbWV0aG9kLlxyXG4gICAgICAgKiBAcGFyYW0ge09ha1N0cmVhbWluZ35sb2FkZWRWaWRlb0ZpbmlzaGVkfSBjYWxsYmFjayAtIFRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGJlZW4gbG9hZGVkIGVudGlyZWx5IGludG8gdGhlIGJ1ZmZlciBvZiB0aGUgdmlkZW8gcGxheWVyLlxyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuZF9zdHJlYW1pbmdfd2hlbl92aWRlb19sb2FkZWQgLSBJZiB0aGlzIGFyZ3VtZW50IGlzIHRydWUsIGFsbCB1cGxvYWRpbmcgdG8gb3RoZXIgcGVlcnMgaXMgcGVybWFuZW50bHkgY2FuY2VsbGVkIGFuZCBhbGwgcHJvY2Vzc2luZyBvZiB0aGUgbG9hZFZpZGVvIG1ldGhvZCBwZXJtYW5lbnRseSBzdG9wcGVkIGFzIHNvb24gYXMgdGhlIHZpZGVvIGhhcyBiZWVuIGxvYWRlZCBjb21wbGV0ZWx5IGludG8gdGhlIGJ1ZmZlciBvZiB0aGUgdmlkZW8gcGxheWVyLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gbG9hZFZpZGVvKHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QsIGNhbGxiYWNrLCBlbmRfc3RyZWFtaW5nX3doZW5fdmlkZW9fbG9hZGVkKXsgICAgICAgXHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwibG9hZFZpZGVvIGlzIGNhbGxlZFwiKTtcclxuICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm9wdGlvbiBwYXJhbXRlcjpcXG5cIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QpKTtcclxuICAgICAgICAgXHJcbiAgICAgICAgIC8vIEFsbCB0aGVzZSBkZWNsYXJlZCB2YXJpYmFsZXMgdW50aWwgJ3ZhciBzZWxmID0gdGhpcycgYXJlIGludGVuZGVkIHRvIGJlIGNvbnN0YW50c1xyXG4gICAgICAgICB2YXIgZGVsaXZlcnlCeVNlcnZlciA9IChzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LnBhdGhfdG9fZmlsZV9vbl9YSFJfc2VydmVyIHx8IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QuaGFzaF92YWx1ZSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgIHZhciBkZWxpdmVyeUJ5V2VidG9ycmVudCA9IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QudG9ycmVudEZpbGUgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgIHZhciBYSFJTZXJ2ZXJVUkwgPSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LlhIUl9zZXJ2ZXJfVVJMIHx8IGZhbHNlO1xyXG4gICAgICAgICB2YXIgWEhSX1BPUlQgPSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LlhIUl9wb3J0IHx8IDgwO1xyXG4gICAgICAgICB2YXIgcGF0aFRvRmlsZU9uWEhSU2VydmVyID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5wYXRoX3RvX2ZpbGVfb25fWEhSX3NlcnZlcjsgICAgICBcclxuICAgICAgICAgdmFyIGhhc2hWYWx1ZSA9IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QuaGFzaF92YWx1ZTtcclxuICAgICAgICAgLy92YXIgd2ViVG9ycmVudFRyYWNrZXJzID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC53ZWJUb3JyZW50X3RyYWNrZXJzO1xyXG4gICAgICAgICB2YXIgTUFHTkVUX1VSSSA9IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QubWFnbmV0VVJJO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIk1BR05FVF9VUkk6IFwiICArIE1BR05FVF9VUkkpO1xyXG4gICAgICAgICB2YXIgVEhFX1JFQ0VJVkVEX1RPUlJFTlRfRklMRSA9IEJ1ZmZlci5mcm9tKHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QudG9ycmVudEZpbGUsICdiYXNlNjQnKTtcclxuICAgICAgICAgU0laRV9PRl9WSURFT19GSUxFID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5zaXplX29mX3ZpZGVvX2ZpbGU7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwic3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5zaXplX29mX3ZpZGVvX2ZpbGU6IFwiICArIHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3Quc2l6ZV9vZl92aWRlb19maWxlKTtcclxuXHJcbiAgICAgICAgIHZhciBET1dOTE9BRF9GUk9NX1AyUF9USU1FX1JBTkdFID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5kb3dubG9hZF9mcm9tX3AycF90aW1lX3JhbmdlIHx8IDIwO1xyXG4gICAgICAgICB2YXIgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5jcmVhdGVfcmVhZFN0cmVhbV9yZXF1ZXN0X3NpemUgfHwgMTAwMDAwMDA7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgRE9XTkxPQURfRlJPTV9TRVJWRVJfVElNRV9SQU5HRSA9IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QuZG93bmxvYWRfZnJvbV9zZXJ2ZXJfdGltZV9yYW5nZSB8fCAzO1xyXG4gICAgICAgICB2YXIgVVBMT0FEX0xJTUlUID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5wZWVyX3VwbG9hZF9saW1pdF9tdWx0aXBsaWVyIHx8IDI7XHJcbiAgICAgICAgIHZhciBBRERJVElPTl9UT19VUExPQURfTElNSVQgPSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LnBlZXJfdXBsb2FkX2xpbWl0X2FkZGl0aW9uIHx8IDUwMDAwMDtcclxuICAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICB2YXIgWEhSX1JFUVVFU1RfU0laRSA9IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QueGhyUmVxdWVzdFNpemUgfHwgNTAwMDAwOyAvLyBpbiBieXRlXHJcbiAgICAgICAgIHZhciBUSFJFU0hPTERfRk9SX1JFVFVSTklOR19PRl9BTlNXRVJfU1RSRUFNID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC50aHJlc2hvbGRGb3JSZXR1cm5pbmdBbnN3ZXJTdHJlYW0gfHwgNTAwMDAwOyAvLyBpbiBieXRlXHJcbiAgICAgICAgIHZhciBXQVRFUk1BUktfSEVJR0hUX09GX0FOU1dFUlNUUkVBTSA9IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3Qud2F0ZXJtYXJrSGVpZ2h0T2ZBbnN3ZXJTdHJlYW0gfHwgNTAwMDAwMDsgLy8gaW4gYnl0ZVxyXG4gICAgICAgICBcclxuICAgICAgICAgXHJcbiAgICAgICAgIHZhciBDSEVDS19JRl9CVUZGRVJfRlVMTF9FTk9VR0hfSU5URVJWQUwgPSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LmNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoSW50ZXJ2YWwgfHwgMjAwOyAvLyBpbiBtaWxpc2Vjb25kc1xyXG4gICAgICAgICB2YXIgQ0hFQ0tfSUZfQU5TV0VSU1RSRUFNX1JFQURZX0lOVEVSVkFMID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5jaGVja0lmQW5zd2Vyc3RyZWFtUmVhZHlJbnRlcnZhbCB8fCA1MDA7IC8vIGluIG1pbGlzZWNvbmRzXHJcbiAgICAgICAgIHZhciBVUERBVEVfQ0hBUlRfSU5URVJWQUwgPSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LnVwZGF0ZUNoYXJ0SW50ZXJ2YWwgfHwgMTAwMDsgLy8gaW4gbWlsaXNlY29uZHNcclxuICAgICAgICAgdmFyIENIT0tFX0lGX05FQ0VTU0FSWV9JTlRFUlZBTCA9IHN0cmVhbV9pbmZvcm1hdGlvbl9vYmplY3QuY2hva2VJZk5lY2Vzc2FyeUludGVydmFsIHx8IDUwMDsgLy8gaW4gbWlsaXNlY29uZHNcclxuICAgICAgICAgdmFyIENIRUNLX0lGX05FV19DUkVBVEVfUkVBRFNUUkVBTV9ORUNFU1NBUllfSU5URVJWQUwgPSBzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LmNoZWNrSWZOZXdDcmVhdGVSZWFkc3RyZWFtSW50ZXJ2YWwgfHwgMjAwMCA7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgLy8gRnJvbSBoZXJlIG9uIG1vc3QgbmV3bHkgZGVjbGFyZWQgdmFyaWFibGVzIGFyZSBub3QgaW5kZXRlZCB0byBmdW5jdGlvbiBhcyBjb25zdGFudHNcclxuICAgICAgICAgLy8gVGhlc2UgdmFyaWFibGVzIGFyZSBkZWNsYXJlZCBpbiB0aGlzIGhpZ2ggc2NvcGUgaW4gb3JkZXIgdG8gYWxsb3cgZXZlcnkgZnVuY3Rpb24gdGhhdCBpcyBkZWNsYXJlZCBpbiBsb2FkVmlkZW8gdG8gYWNjZXNzIGFuZCBtYW5pcHVsYXRlIHRoZXNlIHZhcmlhYmxlc1xyXG4gICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgIHZhciBlbmRTdHJlYW1pbmcgPSBmYWxzZTtcclxuICAgICAgICAgdmFyIHdlYlRvcnJlbnRDbGllbnQgPSBudWxsO1xyXG4gICAgICAgICB2YXIgd2lyZXMgPSBbXTsgLy8gYSB3aXJlIGlzIGEgY29ubmVjdGlvbiB0byBhbm90aGVyIHBlZXIgb3V0IG9mIHRoZSBXZWJUb3JyZW50IG5ldHdvcmtcclxuICAgICAgICAgdmFyIGdsb2JhbHZpZGVvc3RyZWFtUmVxdWVzdE51bWJlciA9IDA7XHJcbiAgICAgICAgIGJ5dGVzUmVjZWl2ZWRGcm9tU2VydmVyID0gMDsgLy8gVGhpcyB2YXJpYWJsZSBnZXRzIG9ubHkgaW5pdGlhbGl6ZWQgbm90IGRlY2xhcmVkXHJcbiAgICAgICAgIHZhciB3ZWJUb3JyZW50RmlsZTtcclxuICAgICAgICAgdmFyIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzID0gW107XHJcbiAgICAgICAgIHZhciBpbkNyaXRpY2FsID0gdHJ1ZTsgLy8gaW5jcml0aWNhbCBtZWFucyB0aGF0IFhIUiByZXF1ZXN0cyB3aWxsIGJlIGNvbmR1Y3RlZCBiZWNhdXNlIHRoZXJlIGlzIGxlc3MgdGhhbiBET1dOTE9BRF9GUk9NX1NFUlZFUl9USU1FX1JBTkdFIHNlY29uZHMgb2YgdmlkZW8gcGxheWJhY2sgYnVmZmVyZWQuXHJcbiAgICAgICAgIHZhciB2aWRlb0NvbXBsZXRlbHlMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgdmFyIGJ5dGVzVGFrZW5Gcm9tV2ViVG9ycmVudCA9IDA7XHJcbiAgICAgICAgIHZhciBieXRlc1Rha2VuRnJvbVNlcnZlciA9IDA7XHJcbiAgICAgICAgIHZhciBjb25zb2xlQ291bnRlciA9IDA7IC8vIFRoaXMgdmFyaWFibGUgaXMgb25seSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXHJcbiAgICAgICAgIFxyXG4gICAgICBcclxuICAgICAgICAgdmFyIG15VmlkZW8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xyXG4gICAgICAgICBteVZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGVycil7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXlWaWRlby5lcnJvcik7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgICBcclxuICAgICAgICAgLy8gTm9kZS5qcyByZWFkYWJsZSBzdHJlYW1zIGFyZSB1c2VkIHRvIGJ1ZmZlciB2aWRlbyBkYXRhIGJlZm9yZSBpdCBnZXRzIHB1dCBpbnRvIHRoZSBzb3VyY2UgYnVmZmVyXHJcbiAgICAgICAgIGZ1bmN0aW9uIE15UmVhZGFibGVTdHJlYW0ob3B0aW9ucyl7XHJcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdXRpbC5pbmhlcml0cyhNeVJlYWRhYmxlU3RyZWFtLCByZWFkYWJsZVN0cmVhbS5SZWFkYWJsZSk7XHJcbiAgICAgICAgIE15UmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oc2l6ZSl7fTtcclxuICAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgIGlmKGRlbGl2ZXJ5QnlXZWJ0b3JyZW50KXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJlbnRlcmVkIGlmKGRlbGl2ZXJ5QnlXZWJ0b3JyZW50KVwiKTtcclxuICAgICAgICAgICAgd2ViVG9ycmVudENsaWVudCA9IG5ldyBXZWJUb3JyZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB3ZWJUb3JyZW50T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLyogV2Vpw58gbmljaHQgbWVociB3YXJ1bSBkYXMgaGllciBzdGVodFxyXG4gICAgICAgICAgICBpZihzdHJlYW1faW5mb3JtYXRpb25fb2JqZWN0LnBhdGhUb0ZpbGVUb1NlZWQpe1xyXG4gICAgICAgICAgICAgICB3ZWJUb3JyZW50T3B0aW9ucy5wYXRoID0gc3RyZWFtX2luZm9ybWF0aW9uX29iamVjdC5wYXRoVG9GaWxlVG9TZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQSBtYWduZXRVUkkgY29udGFpbnMgVVJMcyB0byB0cmFja2luZyBzZXJ2ZXJzIGFuZCB0aGUgaW5mbyBoYXNoIG9mIHRoZSB0b3JyZW50LlxyXG4gICAgICAgICAgICAvL1RoZSBjbGllbnQgcmVjZWl2ZXMgdGhlIGNvbXBsZXRlIHRvcnJlbnQgZmlsZSBmcm9tIGEgdHJhY2tpbmcgc2VydmVyLlxyXG4gICAgICAgICAgICB3ZWJUb3JyZW50Q2xpZW50LmFkZChUSEVfUkVDRUlWRURfVE9SUkVOVF9GSUxFLCB3ZWJUb3JyZW50T3B0aW9ucywgZnVuY3Rpb24gKHRvcnJlbnQpe1xyXG4gICAgICAgICAgICAgICAvLyBGcm9tIHRoaXMgcG9pbnQgb24gdGhlIFdlYlRvcnJlbnQgaW5zdGFuY2Ugd2lsbCBkb3dubG9hZCB2aWRlbyBkYXRhIGZyb20gdGhlIFdlYlRvcnJlbnQgbmV0d29yayBpbiB0aGUgYmFja2dyb3VuZCBpbiBhIHJhcmVzdC1wZWFjZS1maXJzdCBtYW5uZXIgYXMgZmFzdCBhcyBwb3NzaWJsZS5cclxuICAgICAgICAgICAgICAgLy8gU2VxdWVudGlhbCBzdHJlYW0gcmVxdWVzdCBsaWtlIGNyZWF0ZXJlYWRzdHJpbWUgYXJlIHByaW9yaXRpemVkIG92ZXIgdGhpcyByYXJlc3QtcGVhY2UtZmlyc3QgYmFja2dyb3VuZCBkb3dubG9hZGluZy5cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwid2ViVG9ycmVudENsaWVudC5hZGQgICB0b3JyZW50IG1ldGEgZGF0YSByZWFkeVwiKTsgICAgICAgICBcclxuICAgICAgICAgICAgICAgdGhlVG9ycmVudCA9IHRvcnJlbnQ7XHJcbiAgICAgICAgICAgICAgIHdlYlRvcnJlbnRGaWxlID0gdG9ycmVudC5maWxlc1swXTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIC8vIFBlZXJzIHdoaWNoIHVzZWQgdGhlIG9mZmVyZWQgbWV0aG9kcyB0byBtYW51YWxseSBjb25uZWN0IHRvIHRoaXMgRlZTTCBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAvLyBiZWZvcmUgYSB0b3JyZW50IGZpbGUgd2FzIGxvYWRlZCBhcmUgYWRkZWQgbm93IHRvIHRoZSBzZXQgb2YgcGVlcnMgdGhhdCBhcmUgdXNlZCBmb3IgdmlkZW8gZGF0YSBleGNoYW5nZS5cclxuICAgICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8IHBlZXJzVG9BZGQubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICAgICAgICB0aGVUb3JyZW50LmFkZFBlZXIocGVlcnNUb0FkZFtqXVswXSk7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHBlZXJzVG9BZGRbal1bMV0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAocGVlcnNUb0FkZFtqXVsxXSkoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9IFxyXG5cclxuICAgICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgcHVycG9zZSBcclxuICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbiBsb2FkVmlkZW8gICAgXCIgKyBzZWxmLk9ha05hbWUgKyBcIi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgZ2V0cyBjcmVhdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoaXMgRlZTTCBpbnN0YW5jZSBhbHJlYWR5IGNvbm5lY3RlZCB0byBhbm90aGVyIHBlZXJcclxuICAgICAgICAgICAgICAgLy8gb3IgYXMgc29vbiBhcyBpdCBjb25uZWN0cyB0byBhbm90aGVyIHBlZXIuXHJcbiAgICAgICAgICAgICAgIHNlbGYuZm9yVGVzdGluZ19jb25uZWN0ZWRUb05ld1dlYlRvcnJlbnRQZWVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGxvYWRWaWRlbyAgICAgXCIgKyBzZWxmLk9ha05hbWUgKyBcIi5mb3JUZXN0aW5nX2Nvbm5lY3RlZFRvTmV3V2ViVG9ycmVudFBlZXIgICBnZXRzIGNhbGxlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgaWYobm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcyA8PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uc0JlY2F1c2VOZXdXaXJlcy0tO1xyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tDYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIHRvcnJlbnQub24oJ3dpcmUnLCBmdW5jdGlvbih3aXJlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWNhbGxiYWNrQ2FsbGVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzLS07ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHRvcnJlbnQub24oJ3dpcmUnLCBmdW5jdGlvbiAod2lyZSl7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidG9ycmVudC5vbignd2lyZScsIC4uKSBpcyBmaXJlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgd2lyZXMucHVzaCh3aXJlKTtcclxuICAgICAgICAgICAgICAgICAgaWYoIXdpbmRvdy5maXJzdFdpcmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZmlyc3RXaXJlID0gd2lyZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25zQmVjYXVzZU5ld1dpcmVzKys7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGFjdGl2YXRlcyB0aGUgdXRfcGV4IGV4dGVuc2lvbiBmb3IgdGhpcyBwZWVyXHJcbiAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBleGNoYW5nZSBwZWVycyBiZXR3ZWVuIFdlYlRvcnJlbnQgaW5zdGFuY2VzXHJcbiAgICAgICAgICAgICAgICAgIHdpcmUudXNlKHV0X3BleCgpKTtcclxuICAgICAgICAgICAgICAgICAgLy93aXJlLnV0X3BleC5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgd2lyZS51dF9wZXgub24oJ3BlZXInLCBmdW5jdGlvbiAocGVlcil7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoZVRvcnJlbnQuYWRkUGVlcihwZWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgLy8gZ290IGEgcGVlclxyXG4gICAgICAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSBhZGQgaXQgdG8gcGVlciBjb25uZWN0aW9ucyBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBUaGUgVmlkZW9zdHJlYW0gb2JqZWN0IGNvbmR1Y3RzLCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24sIGNyZWFSZWFkc3RyZWFtIHJlcXVlc3RzIGZvciB2aWRlbyBkYXRhIHRoYXQgdGhlIGxvYWRWaWRlbyBtZXRob2QgaGFzIHRvIGFuc3dlciBpbiBvcmRlciB0byBwbGF5IGJhY2sgdGhlIHZpZGVvIHN1Y2Nlc3NmdWxseVxyXG4gICAgICAgICAgICAgICAvLyBUaGUgVmlkZW9zdHJlYW0gb2JqZWN0IHByb2JhYmx5IGhhcyBiZWVuIGNyZWF0ZWQgZHVyaW5nIHRoZSB0aW1lIHdlYlRvcnJlbnRDbGllbnQuYWRkIHdhcyBjYWxsZWQgdW50aWwgaXRzIGNhbGxlZCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgIC8vIEluIHRoaXMgdGltZSB0aGUgVmlkZW9TdHJlYW0gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIHZpZGVvc3RyZWFtIGxpYnJhcnkgcHJvYmFibHkgaGFzIGNvbmR1Y3RlZCBzb21lIGNyZWF0ZVJlYWRzdHJlYW0gcmVxdWVzdHMgd2hvc2UgaGFuZGxlcnMgYXJlIHNhdmVkIGluIHRoZSB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVycyBhcnJheS5cclxuICAgICAgICAgICAgICAgLy8gRm9yIHRoZXNlIHJlcXVlc3RzIHdlIG5vdyBpbnRpYWxpemUgV2ViVG9ycmVudCBzdHJlYW1zLlxyXG4gICAgICAgICAgICAgICBmb3IodmFyIGk9MCwgbGVuZ3RoPXZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLmxlbmd0aDsgaTxsZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB0aGlzUmVxdWVzdCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLy8gVG8gYW5zd2VyIGEgY3JlYXRlUmVhZFN0cmVhbSByZXF1ZXN0IGEgTXVsdGlzdHJlYW0gKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL211bHRpc3RyZWFtKSBpcyByZXR1cm5lZCB3aGljaCByZXF1ZXN0cyBhIE5vZGUgcmVhZGFibGVTdHJlYW0gYXMgc29vbiBhcyBpdHMgYnVmZmVyIGhhcyB3ZW50IGRyeS5cclxuICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2FsbGJhY2sgd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBjcmVhdGVkIHJlYWRhYmxlU3RyZWFtIGlzIHNhdmVkIGluIGN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gb25Ub3JyZW50IG5hY2h0csOkZ2xpY2ggd2VidG9ycmVudCBzdHJlYW0gZXJ6ZXVnZW4gIHRoaXNSZXF1ZXN0LnN0YXJ0OiBcIiArIHRoaXNSZXF1ZXN0LnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkluIG9uVG9ycmVudCAgd2ViVG9ycmVudEZpbGUubGVuZ3RoOiBcIiArIHdlYlRvcnJlbnRGaWxlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQ3JlYXRlUmVhZFN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkUgPiB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMTtcclxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFO1xyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbignZW5kJywgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzUmVxdWVzdC5zdGFydCA+IHRoaXNSZXF1ZXN0Lmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtICYmIHRoaXNSZXF1ZXN0LnN0YXJ0IDwgdGhpc1JlcXVlc3QudmlkZW9GaWxlU2l6ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRDcmVhdGVSZWFkU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRSA+PSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnVucGlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgLy8gRXZlcnkgdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlciBoYXMgdG8gc2F2ZSB0aGUgYnl0ZSBpbmRleCB0aGF0IGl0IGV4cGVjdHMgbmV4dFxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgPSB0aGlzUmVxdWVzdC5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIERhdGEgdGhhdCBpcyByZWNlaXZlZCBmcm9tIHRoZSBXZWJUb3JyZW50IHJlYWRhYmxlIGdldHMgaW1tbWVkaWF0ZWx5IHB1bXBlZCBpbnRvIGEgd3JpdGVhYmxlIHN0cmVhbSBjYWxsZWQgIGNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQgd2hpY2ggcHJvY2Vzc2VzIHRoZSBuZXcgZGF0YS5cclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgXHJcbiAgICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgdmFyIGZpbGVMaWtlT2JqZWN0ID0gZnVuY3Rpb24gKHBhdGhUb0ZpbGVPblhIUlNlcnZlcil7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aFRvRmlsZU9uWEhSU2VydmVyID0gcGF0aFRvRmlsZU9uWEhSU2VydmVyO1xyXG4gICAgICAgICB9O1xyXG4gICAgICAgICAvLyBUaGUgVmlkZW9TdHJlYW0gb2JqZWN0IHdpbGwgY2FsbCBjcmVhdGVSZWFkU3RyZWFtIHNldmVyYWwgdGltZXMgd2l0aCBkaWZmZXJlbnQgdmFsdWVzIGZvciB0aGUgc3RhcnQgcHJvcGVydHkgb2Ygb3BzLlxyXG4gICAgICAgICBmaWxlTGlrZU9iamVjdC5wcm90b3R5cGUuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRzKXtcclxuICAgICAgICAgICAgaWYob3B0cy5zdGFydCA+PSBTSVpFX09GX1ZJREVPX0ZJTEUpe1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9wdHMuc3RhcnQgPiBTSVpFX09GX1ZJREVPX0ZJTEUgdGhlcmVmb3JlIGNiKG51bGwsbnVsbCkgZXZlcnkgdGltZVwiKTtcclxuICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgTXVsdGlTdHJlYW0oZnVuY3Rpb24gKGNiKXtjYihudWxsLCBudWxsKTt9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5Dcml0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiBjYWxsZWQgY3JlYXRlcmVhZFN0cmVhbSBcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiBvcHRzLnN0YXJ0OiBcIiArIG9wdHMuc3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgb3B0cy5lbmQ6IFwiICsgb3B0cy5lbmQpO1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgdGhpc1JlcXVlc3QgPSBuZXcgVmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlcigrK2dsb2JhbHZpZGVvc3RyZWFtUmVxdWVzdE51bWJlciwgb3B0cywgdGhpcyk7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEV2ZXJ5dGltZSBJIHByaW50ZWQgb3V0IHRoZSB2YWx1ZSBvZiBvcHRzLmVuZCBpcyB3YXMgTmFOLlxyXG4gICAgICAgICAgICAvLyBJIHN1cHBvc2UgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgXCJ0aWxsIHRoZSBlbmQgb2YgdGhlIGZpbGVcIlxyXG4gICAgICAgICAgICAvLyBPZiBjb3Vyc2UsIG91ciByZXR1cm5lZCBzdHJlYW0gc2hvdWxkLCBuZXZlcnRoZWxlc3MsIG5vdCBidWZmZXIgYSBnaWFudCBhbW91bnQgb2YgdmlkZW8gZGF0YSBpbiBhZHZhbmNlIGJ1dCBpbnN0ZWFkIHJldHJpZXZlIGFuZCBwdXQgb3V0IGNodW5rcyBvZiB2aWRlbyBkYXRhIG9uLWRlbWFuZFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYob3B0cy5lbmQgJiYgIWlzTmFOKG9wdHMuZW5kKSl7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmVuZCA9IG9wdHMuZW5kICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgaWYoU0laRV9PRl9WSURFT19GSUxFICE9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuZW5kID0gU0laRV9PRl9WSURFT19GSUxFO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBUaGlzIHdyaXRlYWJsZSBOb2RlLmpzIHN0cmVhbSB3aWxsIHByb2Nlc3MgZXZlcnkgZGF0YSB0aGF0IGlzIHJlY2VpdmVkIGZyb20gc2VxdWVudGlhbCBXZWJUb3JyZW50IHN0cmVhbXNcclxuICAgICAgICAgICAgdmFyIE15V3JpdGVhYmxlU3RyZWFtID0gZnVuY3Rpb24oaGlnaFdhdGVyTWFyayl7XHJcbiAgICAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcywgaGlnaFdhdGVyTWFyayk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHV0aWwuaW5oZXJpdHMoTXlXcml0ZWFibGVTdHJlYW0sIHJlYWRhYmxlU3RyZWFtLldyaXRhYmxlKTtcclxuICAgICAgICAgICAgTXlXcml0ZWFibGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgZG9uZSl7XHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQSBieXRlIHJhbmdlIHJlcXVlc3QgdG8gdGhlIFdlYlRvcnJlbnQgbmV0d29yayByZWNlaXZlZCBhIGNodW5rXCIpO1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTXlXcml0ZWFibGVTdHJlYW0gX3dyaXRlIGlzIGNhbGxlZFwiKTsgICAgICAgXHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA8IGNodW5rLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJNeVdyaXRlYWJsZVN0cmVhbSBfd3JpdGU6IHB1c2hpbmcgcmVjZWl2ZWQgZGF0YSBpbiBhbnN3ZXJTdHJlYW1cIilcclxuICAgICAgICAgICAgICAgICAgYnl0ZXNUYWtlbkZyb21XZWJUb3JyZW50ICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydC10aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgc3RyZWFtSGFzTWVtb3J5TGVmdCA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKGNodW5rLnNsaWNlKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCwgY2h1bmsubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gKz0gY2h1bmsubGVuZ3RoIC0gKHRoaXNSZXF1ZXN0LnN0YXJ0LXRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBpZihzdHJlYW1IYXNNZW1vcnlMZWZ0KXsgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzUmVxdWVzdC5zdGFydCA+PSB0aGlzUmVxdWVzdC5lbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiBXQVRFUk1BUktfSEVJR0hUX09GX0FOU1dFUlNUUkVBTX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qubm9Nb3JlRGF0YSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IFdBVEVSTUFSS19IRUlHSFRfT0ZfQU5TV0VSU1RSRUFNfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuY3JlYXRlUmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LnN0YXJ0ICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydC10aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8vY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkodGhpc1JlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQgPSBuZXcgTXlXcml0ZWFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IDE2fSk7XHJcbiAgICAgICAgICAgIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLnB1c2godGhpc1JlcXVlc3QpO1xyXG5cclxuICAgICAgICAgICAgaWYod2ViVG9ycmVudEZpbGUpeyAvLyBVbSBFaW5oYWx0dW5nIGRlcyBVcGxvYWQgbGltaXRzIGvDvG1tZXJ0IHNpY2ggZG9jaCBjaG9rZUlmTmVjZXNzYXJ5ICAgJiYgdGhlVG9ycmVudC51cGxvYWRlZCA8PSBVUExPQURfTElNSVQgKiB0aGVUb3JyZW50LmRvd25sb2FkZWQgKyBBRERJVElPTl9UT19VUExPQURfTElNSVQpe1xyXG4gICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiYWZ0ZXIgbmV3IHZpZGVvc3RyZWFtUmVxdWVzdCBjcmVhdGluZyBhIGNvcnJlc3BvbmRpbmcgd2VidG9ycmVudCBzdHJlYW1cIik7XHJcbiAgICAgICAgICAgICAgIC8vLy9jb25zb2xlLmxvZyhcIm9wdHMuc3RhcnQ6IFwiICsgb3B0cy5zdGFydCk7XHJcbiAgICAgICAgICAgICAgIC8vLy9jb25zb2xlLmxvZyhcIndlYlRvcnJlbnRGaWxlLmxlbmd0aDogXCIgKyB3ZWJUb3JyZW50RmlsZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhciBlbmRDcmVhdGVSZWFkU3RyZWFtO1xyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRSA+PSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5jcmVhdGVSZWFkU3RyZWFtKHtcInN0YXJ0XCIgOiB0aGlzUmVxdWVzdC5zdGFydCwgXCJlbmRcIiA6IGVuZENyZWF0ZVJlYWRTdHJlYW19KTtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QubGFzdEVuZENyZWF0ZVJlYWRTdHJlYW0gPSBlbmRDcmVhdGVSZWFkU3RyZWFtO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFdlYlRvcnJlbnQgPSB0aGlzUmVxdWVzdC5zdGFydDtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0udW5waXBlKCk7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGlwZSh0aGlzUmVxdWVzdC5jb2xsZWN0b3JTdHJlYW1Gb3JXZWJ0b3JyZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZmFjdG9yeUZ1bmN0aW9uRm9yU3RyZWFtQ3JlYXRpb24oY2Ipe1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlYWRhYmxlU3RyZWFtIHJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuY3JlYXRlUmVhZFN0cmVhbU51bWJlciArIFwiICAgIGRvZXMgYSBjYiByZXF1ZXN0XCIpOyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5lbmQgPj0gMCAmJiB0aGlzUmVxdWVzdC5zdGFydCA+PSB0aGlzUmVxdWVzdC5lbmQpe1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhbGxlZCBjYihudWxsLG51bGwpIGZyb20gXCIgKyB0aGlzUmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtTnVtYmVyKTsgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIC8vICEhISEhISEhISEhISEhISEhISEgVGVzdGVzaGFsYmVyIHJhdXNnZW5vbW1lbiAgICAgdGhpc1JlcXVlc3QucmVxID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0LnJlcSkge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2IobnVsbCwgbnVsbCkgaXMgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuQ2FsbGJhY2tOdW1iZXIrKztcclxuICAgICAgICAgICAgICAgaWYoY29uc29sZUNvdW50ZXI8MjApe1xyXG4gICAgICAgICAgICAgICAgICAvLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgICAgXCIgKyB0aGlzUmVxdWVzdC5DYWxsYmFja051bWJlciArIFwiLiBjYWxsIG9mIGZ1bmN0aW9uKGNiKSBmcm9tIFwiICsgdmlkZW9zdHJlYW1SZXF1ZXN0TnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhjb25zb2xlQ291bnRlcisrICsgXCIgICAgc3RhcnQ6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sgPSBjYjtcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qubm9Nb3JlRGF0YSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgaWYoIWNlY2tJZkFuc3dlclN0cmVhbVJlYWR5KHRoaXNSZXF1ZXN0KSl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYod2ViVG9ycmVudEZpbGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiTmV3IGNiIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYW5kIEkgc3Vic2VxdWVudGx5IGNyZWF0ZSBhIG5ldyB0b3JyZW50U3RyZWFtIGZvciBpdCBiZWNhdXNlIG5vbiBleGlzdGVkIGJlZm9yZSBmb3IgdGhpcyB2aWRlb3N0cmVhbVJlcXVlc3RcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vLy9jb25zb2xlLmxvZyhcIkFmdGVyIG5ldyBNdWx0aXN0cmVhbS4gdGhpc1JlcXVlc3Quc3RhcnQ6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAvLy8vY29uc29sZS5sb2coXCJ3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgd2ViVG9ycmVudEZpbGUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFID49IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmxlbmd0aC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDcmVhdGVSZWFkU3RyZWFtID0gdGhpc1JlcXVlc3Quc3RhcnQgKyBDUkVBVEVfUkVBRFNUUkVBTV9SRVFVRVNUX1NJWkU7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSA9IHdlYlRvcnJlbnRGaWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1wic3RhcnRcIiA6IHRoaXNSZXF1ZXN0LnN0YXJ0LCBcImVuZFwiIDogZW5kQ3JlYXRlUmVhZFN0cmVhbX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5sYXN0RW5kQ3JlYXRlUmVhZFN0cmVhbSA9IGVuZENyZWF0ZVJlYWRTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS51bnBpcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5waXBlKHRoaXNSZXF1ZXN0LmNvbGxlY3RvclN0cmVhbUZvcldlYnRvcnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZihkZWxpdmVyeUJ5U2VydmVyICYmIGluQ3JpdGljYWwgJiYgIXRoaXNSZXF1ZXN0LlhIUkNvbmR1Y3RlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKCF0aGVUb3JyZW50IHx8IHRoZVRvcnJlbnQucHJvZ3Jlc3MgPDEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kdWN0WEhSKHRoaXNSZXF1ZXN0KTsgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEEgbmV3IE11bHRpc3RyZWFtIGdldHMgY3JlYXRlZCB3aGljaCB3aWxsIGJlIHRoZSBhbnN3ZXIgdGhlIHRoZSByZXF1ZXN0IGZyb20gdGhlIFZpZGVvU3RyZWFtIHJlcXVlc3RcclxuICAgICAgICAgICAgdmFyIG11bHRpID0gbmV3IE11bHRpU3RyZWFtKGZhY3RvcnlGdW5jdGlvbkZvclN0cmVhbUNyZWF0aW9uKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBkZWNvbnN0cnVjdG9yQWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiB0ZXJtaW5hdGUgY3JlYXRlUmVhZFN0cmVhbVwiKTtcclxuICAgICAgICAgICAgdmFyIGRlc3Ryb3kgPSBtdWx0aS5kZXN0cm95O1xyXG4gICAgICAgICAgICBtdWx0aS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgaWYoZGVjb25zdHJ1Y3RvckFscmVhZHlDYWxsZWQpe1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRlY29uc3RydWN0b3Igb2YgXCIgKyB0aGlzUmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtTnVtYmVyICsgXCIgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRlY29uc3RydWN0b3Igb2YgXCIgKyB0aGlzUmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtTnVtYmVyICsgXCIgaXMgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGRlY29uc3RydWN0b3IgY2FsbCB0aGlzUmVxdWVzdC5zdGFydCBoYXMgdmFsdWU6IFwiICsgdGhpc1JlcXVlc3Quc3RhcnQpO1xyXG4gICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluIGRlY29uc3RydWN0b3IgY2FsbCB0aGlzUmVxdWVzdC5lbmQgaGFzIHZhbHVlOiBcIiArIHRoaXNSZXF1ZXN0LmVuZCk7XHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW4gZGVjb25zdHJ1Y3RvciBjYWxsIHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sgPT09IG51bGw6IFwiICsgKHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sgPT09IG51bGwpKTtcclxuICAgICAgICAgICAgICAgZGVjb25zdHJ1Y3RvckFscmVhZHlDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QucmVxKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LnJlcS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrID0gdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm5vTW9yZURhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0udW5waXBlKCk7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVycy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2ldID09PSB0aGlzUmVxdWVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgIGlmKHRoZUNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2sobnVsbCxudWxsKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAvLyB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLmRlc3Ryb3koKTsgICAgICAgICAgICAgICAgICBHbGF1YmUgaWNoIHVubsO2dGlnISEhIVxyXG4gICAgICAgICAgICAgICAvL3RoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5kZXN0cm95KCk7ICAgICAgICAgR2xhdWJlIGljaCBhdWNoIHVubsO2dGlnICEgV2lyZCBqYSBlaCDDvGJlcmdlYmVuLiBTb2xsdGUgc2ljaCBhbHNvIEZlcm9zcyBkcnVtIGvDvG1tZXJuLiBcclxuICAgICAgICAgICAgICAgLy8gdGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudC5kZXN0cm95KCk7IFZlcmJyYXVjaHQgamEgZWggbnVyIGVpbiBwYWFyIGJ5dGVcclxuICAgICAgICAgICAgICAgZGVzdHJveS5jYWxsKG11bHRpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG11bHRpO1xyXG4gICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBmcmVxdWVudGx5IGNoZWNrcyBpZiBsZXNzIHRoYW4gRE9XTkxPQURfRlJPTV9QMlBfVElNRV9SQU5HRSBzZWNvbmRzIG9mIHZpZGVvIGRhdGEgaXMgYnVmZmVyZWQgaW4gYWR2YW5jZS5cclxuICAgICAgICAgLy8gSWYgaXQgaXMgdGhlIGNhc2UgdGhpcyBmdW5jdGlvbiBjb25kdWN0cyBhIG5ldyBzZXF1ZW50aWFsIGJ5dGUgcmFuZ2UgcmVxdWVzdCB0byB0aGUgV2ViVG9ycmVudCBuZXR3b3JrXHJcbiAgICAgICAgIGZ1bmN0aW9uIGZyZXF1ZW50bHlDaGVja0lmTmV3Q3JlYXRlUmVhZFN0cmVhbU5lY2Vzc2FyeSgpe1xyXG4gICAgICAgICAgICBpZih2aWRlb0NvbXBsZXRlbHlMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgICBpZihteVZpZGVvLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgdmFyIHRpbWVSYW5nZXMgPSBteVZpZGVvLmJ1ZmZlcmVkOyAgICAgICAgICBcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRpbWVSYW5nZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICBpZiAobXlWaWRlby5jdXJyZW50VGltZSA+PSB0aW1lUmFuZ2VzLnN0YXJ0KGkpICYmIG15VmlkZW8uY3VycmVudFRpbWUgPD0gdGltZVJhbmdlcy5lbmQoaSkrMykge1xyXG4gICAgICAgICAgICAgICAgICAgICBpZiAodGltZVJhbmdlcy5lbmQoaSkgLSBteVZpZGVvLmN1cnJlbnRUaW1lIDw9IERPV05MT0FEX0ZST01fUDJQX1RJTUVfUkFOR0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzUmVxdWVzdCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzUmVxdWVzdC5zdGFydCA+IHRoaXNSZXF1ZXN0Lmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtICYmIHRoaXNSZXF1ZXN0LnN0YXJ0IDwgU0laRV9PRl9WSURFT19GSUxFKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZENyZWF0ZVJlYWRTdHJlYW07dmlkZW9GaWxlU2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydCArIENSRUFURV9SRUFEU1RSRUFNX1JFUVVFU1RfU0laRSA+PSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENyZWF0ZVJlYWRTdHJlYW0gPSB3ZWJUb3JyZW50RmlsZS5sZW5ndGgtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ3JlYXRlUmVhZFN0cmVhbSA9IHRoaXNSZXF1ZXN0LnN0YXJ0ICsgQ1JFQVRFX1JFQURTVFJFQU1fUkVRVUVTVF9TSVpFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtID0gd2ViVG9ycmVudEZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7XCJzdGFydFwiIDogdGhpc1JlcXVlc3Quc3RhcnQsIFwiZW5kXCIgOiBlbmRDcmVhdGVSZWFkU3RyZWFtfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0V2ViVG9ycmVudCA9IHRoaXNSZXF1ZXN0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnVucGlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBpcGUodGhpc1JlcXVlc3QuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZyZXF1ZW50bHlDaGVja0lmTmV3Q3JlYXRlUmVhZFN0cmVhbU5lY2Vzc2FyeSwgQ0hFQ0tfSUZfTkVXX0NSRUFURV9SRUFEU1RSRUFNX05FQ0VTU0FSWV9JTlRFUlZBTCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfSAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgLy8gVGhlIGZpbmFsIHZlcnNpb24gb2YgdGhlIGxpYnJhcnkgc2hvdWxkIG5vdCBpbmNsdWRlIHRoaXMgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyB0aGUgc3RhdGlzdGljcyB0aGF0IGFyZSBzaG93biBhYm92ZSB0aGUgdmlkZW8uIFRoaXMgdmVyc2lvbiBzaG93cyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBpbnRlbmRlZCBmb3IgZW5kIHVzZXIgdXNlLlxyXG4gICAgICAgICBmdW5jdGlvbiB1cGRhdGVDaGFydCgpe1xyXG4gICAgICAgICAgICBpZihlbmRTdHJlYW1pbmcpe1xyXG4gICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodGhlVG9ycmVudCAmJiB3ZWJUb3JyZW50RmlsZSl7XHJcbiAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiV2ViVG9ycmVudC1yZWNlaXZlZFwiKS5pbm5lckhUTUwgPSBcIndlYlRvcnJlbnRGaWxlLmxlbmd0aDogXCIgKyB3ZWJUb3JyZW50RmlsZS5sZW5ndGggKyBcIlxcbiB0b3JyZW50LmRvd25sb2FkZWQ6IFwiICsgdGhlVG9ycmVudC5kb3dubG9hZGVkICsgXCJcXG4gdG9ycmVudC51cGxvYWRlZDogXCIgKyB0aGVUb3JyZW50LnVwbG9hZGVkICsgXCJcXG4gdG9ycmVudC5wcm9ncmVzczogXCIgKyB0aGVUb3JyZW50LnByb2dyZXNzICsgXCJcXG4gQnl0ZXMgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiICsgYnl0ZXNSZWNlaXZlZEZyb21TZXJ2ZXIgKyBcIlxcbiBCeXRlcyB0YWtlbiBmcm9tIHNlcnZlciBkZWxpdmVyeTogXCIgKyBieXRlc1Rha2VuRnJvbVNlcnZlciArIFwiXFxuIEJ5dGVzIHRha2VuIGZyb20gV2ViVG9ycmVudCBkZWxpdmVyeTogXCIgKyBieXRlc1Rha2VuRnJvbVdlYlRvcnJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0VGltZW91dCh1cGRhdGVDaGFydCwgVVBEQVRFX0NIQVJUX0lOVEVSVkFMKTtcclxuICAgICAgICAgfSAgICAgICAgIFxyXG4gICAgICAgICBcclxuICAgICAgICAgXHJcbiAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGZvciBhIGdpdmVuIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXIgaWYgd2UgaGF2ZSBjYWxsZWQgZW5vdWdoIHZpZGVvIGRhdGEgdG8gY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgICAgIC8vIElmIGl0IGlzIHRoZSBjYXNlLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgdG9nZWh0ZXIgd2l0aCB0aGUgYnVmZmVyZWQgZGF0YS5cclxuICAgICAgICAgZnVuY3Rpb24gY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkodGhpc1JlcXVlc3Qpe1xyXG4gICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiQXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtOiBcIiArIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0pO1xyXG4gICAgICAgICAgICAvLy8vLy8vL2NvbnNvbGUubG9nKFwiSW4gY2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkgb2YgdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIgKyAgXCIuIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW06IFwiICsgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSArIFwiICAgICB0aGlzUmVxdWVzdC5jdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrOiBcIiArIHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayAmJiAoKHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPj0gVEhSRVNIT0xEX0ZPUl9SRVRVUk5JTkdfT0ZfQU5TV0VSX1NUUkVBTSkgfHwgKHRoaXNSZXF1ZXN0LnN0YXJ0ID49IFNJWkVfT0ZfVklERU9fRklMRSkpKXtcclxuICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcImFuc3dlclN0cmVhbSBmcm9tIHZpZGVvc3RyZWFtIFJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuY3JlYXRlUmVhZFN0cmVhbU51bWJlciArIFwiIGFuZCBDQiBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5DYWxsYmFja051bWJlciArIFwiIGdldHMgcmV0dXJuZWRcIik7XHJcbiAgICAgICAgICAgICAgIC8vIC8vLy8vL2NvbnNvbGUubG9nKFwiUmV0dXJpbmcgYW5zd2VyU3RyZWFtIG91dCBvZiBjZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSgpXCIpO1xyXG4gICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0pe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiBXQVRFUk1BUktfSEVJR0hUX09GX0FOU1dFUlNUUkVBTX0pO1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBmcmVxdWVudGx5IGNoZWNrcyBpZiB2aWRlbyBkYXRhIHVwbG9hZCBzaG91bGQgYmUgdGhyb3R0bGVkIGJlY2F1c2UgdGhlIHBlZXJfdXBsb2FkX2xpbWl0IGlzIHJlYWNoZWRcclxuICAgICAgICAgLy8gSWYgaXQgc2hvdWxkIGJlIHRocm90dGxlZCwgdGhlbiBldmVyeSBwZWVyIGdldHMgY2hva2VkIHdoaWNoIG1lYW5zIHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhIHNlbmQgdG8gb3RoZXIgcGVlcnMgZm9yIGFwcHJveGltYXRlbHkgODAwIG1pbGxpc2Vjb25kcy5cclxuICAgICAgICAgZnVuY3Rpb24gY2hva2VJZk5lY2Vzc2FyeSgpe1xyXG4gICAgICAgICAgICBpZiAodGhlVG9ycmVudCAmJiB0aGVUb3JyZW50LnVwbG9hZGVkID49IHRoZVRvcnJlbnQuZG93bmxvYWRlZCAqIFVQTE9BRF9MSU1JVCArIEFERElUSU9OX1RPX1VQTE9BRF9MSU1JVCkge1xyXG4gICAgICAgICAgICAgICAvKiBtYWNoZSBpY2ggc2Nob24gaW4gZWluZXIgYW5kZXJlbiBmcmVxdWVudCBtZXRob2RlXHJcbiAgICAgICAgICAgICAgIGlmKHZpZGVvQ29tcGxldGVseUxvYWRlZCl7XHJcbiAgICAgICAgICAgICAgICAgIHRoZVRvcnJlbnQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICBkZWxldGUgd2ViVG9ycmVudENsaWVudDtcclxuICAgICAgICAgICAgICAgICAgZW5kU3RyZWFtaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB3aXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJJIGNob2tlZCBhIHBlZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgIHdpcmVzW2ldLmNob2tlKCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNob2tlSWZOZWNlc3NhcnksIENIT0tFX0lGX05FQ0VTU0FSWV9JTlRFUlZBTCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgXHJcbiAgICAgICAgIGZ1bmN0aW9uIFZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXIoY3JlYXRlUmVhZFN0cmVhbU51bWJlciwgb3B0cywgc2VsZikge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIgPSBjcmVhdGVSZWFkU3RyZWFtTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gb3B0cy5zdGFydCB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLm9sZFN0YXJ0V2ViVG9ycmVudCA9IC00MjtcclxuICAgICAgICAgICAgdGhpcy5vbGRTdGFydFNlcnZlciA9IC00MjtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5DYWxsYmFja051bWJlciA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMud2ViVG9ycmVudFN0cmVhbSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IFdBVEVSTUFSS19IRUlHSFRfT0ZfQU5TV0VSU1RSRUFNfSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdG9yU3RyZWFtRm9yV2VidG9ycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuWEhSQ29uZHVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gLTQyO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGYgPSBzZWxmO1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVzVGFrZW5Gcm9tV2ViVG9ycmVudCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNUYWtlbkZyb21TZXJ2ZXIgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm5vTW9yZURhdGEgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZXEgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RFbmRDcmVhdGVSZWFkU3RyZWFtID0gLTQyO1xyXG4gICAgICAgICAgICB0aGlzLlhIUl9maWxlc2l6ZSA9IC00MjtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBmcmVxdWVudGx5IGNoZWNrcyBmb3IgZXZlcnkgdmlkZW9zdHJlYW1SZXF1ZXN0SGFuZGxlciBpZiB0aGVyZSBpcyBlbm91Z2ggZGF0YSBidWZmZXIgdG8gY2FsbCB0aGUgY29ycmVzcG9uZGluZyBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIHRoZSBidWZmZXJlZCBkYXRhXHJcbiAgICAgICAgIGZ1bmN0aW9uIGZyZXF1ZW50bHlDZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSgpe1xyXG4gICAgICAgICAgICBpZih2aWRlb0NvbXBsZXRlbHlMb2FkZWQpe1xyXG4gICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIGNlY2tJZkFuc3dlclN0cmVhbVJlYWR5KHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZyZXF1ZW50bHlDZWNrSWZBbnN3ZXJTdHJlYW1SZWFkeSwgQ0hFQ0tfSUZfQU5TV0VSU1RSRUFNX1JFQURZX0lOVEVSVkFMKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gVGhlIGpvYiBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGZyZXF1ZW50bHkgY2hlY2sgdG8gdGhpbmdzLlxyXG4gICAgICAgICAvLyBGaXJzdCwgaWYgdGhlIHZpZGVvIGlzIGNvbXBsZXRlbHkgbG9hZGVkLlxyXG4gICAgICAgICAvLyBTZWNvbmQsIGlmIGxlc3MgdGhhbiBET1dOTE9BRF9GUk9NX1NFUlZFUl9USU1FX1JBTkdFIHNlY29uZHMgb2YgdmlkZW8gcGxheWJhY2sgYXJlIGJ1ZmZlcmVkIGluIGFkdmFuY2UuXHJcbiAgICAgICAgIGZ1bmN0aW9uIGNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoKCl7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjaGVja0lmQnVmZmVyRnVsbEVub3VnaCBpcyBjYWxsZWRcIik7XHJcbiAgICAgICAgICAgIGlmKHZpZGVvQ29tcGxldGVseUxvYWRlZCl7XHJcbiAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlkZW8uZHVyYXRpb246IFwiICsgbXlWaWRlby5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgIGlmKG15VmlkZW8uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICB2YXIgdGltZVJhbmdlcyA9IG15VmlkZW8uYnVmZmVyZWQ7XHJcbiAgICAgICAgICAgICAgIGlmKHRpbWVSYW5nZXMubGVuZ3RoID49IDEpe1xyXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidGltZVJhbmdlcy5zdGFydCgwKTogXCIgKyB0aW1lUmFuZ2VzLnN0YXJ0KDApKTtcclxuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInRpbWVSYW5nZXMuZW5kKDApOiBcIiArIHRpbWVSYW5nZXMuZW5kKDApKTtcclxuICAgICAgICAgICAgICAgICAgaWYodGhlVG9ycmVudC5wcm9ncmVzcyA9PT0gMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHZpZGVvQ29tcGxldGVseUxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRpbWVSYW5nZXMuc3RhcnQoMCkgPT0gMCAmJiB0aW1lUmFuZ2VzLmVuZCgwKSA9PSBteVZpZGVvLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkluIGNoZWNrSWZCdWZmZXJGdWxsRW5vdWdoOiBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbXBsZXRlbHlMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVuZF9zdHJlYW1pbmdfd2hlbl92aWRlb19sb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGVUb3JyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVuZF9zdHJlYW1pbmdfd2hlbl92aWRlb19sb2FkZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGVUb3JyZW50KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlVG9ycmVudC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3ZWJUb3JyZW50Q2xpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFN0cmVhbWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgLy8gRnJvbSBoZXJlIG9uIGl0IGlzIGNoZWNrZWQgd2V0aGVyIHRoZXJlIGFyZSBsZXNzIHNlY29uZHMgYnVmZmVyZWQgdGhhbiBET1dOTE9BRF9GUk9NX1NFUlZFUl9USU1FX1JBTkdFXHJcbiAgICAgICAgICAgICAgIGluQ3JpdGljYWwgPSB0cnVlOyAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aW1lUmFuZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vY29uc29sZS5sb2coXCJUaW1lIHJhbmdlIG51bWJlciBcIiArIGkgKyBcIjogc3RhcnQoXCIgKyB0aW1lUmFuZ2VzLnN0YXJ0KGkpICsgXCIpIGVuZChcIiArIHRpbWVSYW5nZXMuZW5kKGkpICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAobXlWaWRlby5jdXJyZW50VGltZSA+PSB0aW1lUmFuZ2VzLnN0YXJ0KGkpICYmIG15VmlkZW8uY3VycmVudFRpbWUgPD0gdGltZVJhbmdlcy5lbmQoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVSYW5nZXMuZW5kKGkpIC0gbXlWaWRlby5jdXJyZW50VGltZSA+PSBET1dOTE9BRF9GUk9NX1NFUlZFUl9USU1FX1JBTkdFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ3JpdGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy9jb25zb2xlLmxvZyhcIkkgc2V0IGluQ3JpdGljYWwgdG8gZmFsc2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGlmIChkZWxpdmVyeUJ5U2VydmVyICYmIGluQ3JpdGljYWwpIHtcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbmd0aCA9IHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzLmxlbmd0aDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmICh2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tqXS5jdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrICE9PSBudWxsICYmIHZpZGVvc3RyZWFtUmVxdWVzdEhhbmRsZXJzW2pdLlhIUkNvbmR1Y3RlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZHVjdFhIUih2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0VGltZW91dChjaGVja0lmQnVmZmVyRnVsbEVub3VnaCwgQ0hFQ0tfSUZfQlVGRkVSX0ZVTExfRU5PVUdIX0lOVEVSVkFMKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgXHJcbiAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY29uZHVjdGVzIGEgWEhSIHJldXFlc3QgZm9yIHRoZSB2aWRlb3N0cmVhbVJlcXVlc3RIYW5kbGVyIHdoaWNoIGlzIGhhbmRlZCBvdmVyIHRvIHRoZSBmdW5jdGlvbiBhcyBpdHMgZmlyc3QgYW5kIG9ubHkgcGFyYW10ZXIuXHJcbiAgICAgICAgIGZ1bmN0aW9uIGNvbmR1Y3RYSFIodGhpc1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgaWYodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5YSFJDb25kdWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgcmVxU3RhcnQgPSB0aGlzUmVxdWVzdC5zdGFydDtcclxuICAgICAgICAgICAgdmFyIHJlcUVuZCA9IHJlcVN0YXJ0ICsgWEhSX1JFUVVFU1RfU0laRTtcclxuICAgXHJcbiAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LlhIUl9maWxlc2l6ZSA+IDAgJiYgcmVxRW5kID4gdGhpc1JlcXVlc3QuWEhSX2ZpbGVzaXplKXtcclxuICAgICAgICAgICAgICAgcmVxRW5kID0gdGhpc1JlcXVlc3QuWEhSX2ZpbGVzaXplO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNSZXF1ZXN0LmVuZCA+PSAwICYmIHJlcUVuZCA+IHRoaXNSZXF1ZXN0LmVuZCkge1xyXG4gICAgICAgICAgICAgICByZXFFbmQgPSB0aGlzUmVxdWVzdC5lbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChyZXFTdGFydCA+PSByZXFFbmQpe1xyXG4gICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIGNiKG51bGwsbnVsbClcIik7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvLyAhISEhISEhISEgZGllc2VyIGlmIGJsb2NrIG5ldSBmaXggdmVyc3VjaFxyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5yZXEpe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LlhIUkNvbmR1Y3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayhudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qIGdsYXViZSBpY2ggdW5uw7Z0aWdlciB1bmQvb2RlciBnZWbDpGhybGljaGVyIG3DvGxsXHJcbiAgICAgICAgICAgIGlmIChyZXFTdGFydCA+PSByZXFFbmQpIHtcclxuICAgICAgICAgICAgcmVxID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGNvbnNvbGVDb3VudGVyIDwgMTAwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgLy8vLy8vLy8vL2NvbnNvbGUubG9nKGNvbnNvbGVDb3VudGVyKysgKyBcIiAgdmlkZW9TdHJlYW0gXCIgKyB0aGlzUmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtTnVtYmVyICsgXCIgIENCIG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LkNhbGxiYWNrTnVtYmVyICsgXCIgICAgcmVxU3RhcnQ6IFwiICsgcmVxU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAvLy8vLy8vLy8vY29uc29sZS5sb2coY29uc29sZUNvdW50ZXIrKyArIFwiICBNdWx0aXN0cmVhbSBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIgKyBcIiAgIENCIG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LkNhbGxiYWNrTnVtYmVyICsgXCIgICAgcmVxRW5kOiBcIiArIHJlcUVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBYSFJEYXRhSGFuZGxlciA9IGZ1bmN0aW9uIChjaHVuayl7XHJcbiAgICAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWRGcm9tU2VydmVyICs9IGNodW5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJlYWRhYmxlU3RyZWFtIHJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuY3JlYXRlUmVhZFN0cmVhbU51bWJlciArIFwiIHJlY2VpdmVkIGEgY2h1bmsgb2YgbGVuZ3RoIFwiICsgY2h1bmsubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Qubm9Nb3JlRGF0YSl7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0U2VydmVyICs9IGNodW5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdC5zdGFydCAtIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0U2VydmVyIDwgY2h1bmsubGVuZ3RoKXsgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgYnl0ZXNUYWtlbkZyb21TZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoIC0gKHRoaXNSZXF1ZXN0LnN0YXJ0IC0gdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtICs9IGNodW5rLmxlbmd0aCAtICh0aGlzUmVxdWVzdC5zdGFydCAtIHRoaXNSZXF1ZXN0Lm9sZFN0YXJ0U2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgdmFyIG15QnVmZmVyID0gY2h1bmsuc2xpY2UodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlciwgY2h1bmsubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkluIFhIUkRhdGFIYW5kbGVyICAgbXlCdWZmZXIubGVuZ3RoOiBcIiArIG15QnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBTdHJlYW1IYXNNZW1vcnlMZWZ0ID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobXlCdWZmZXIpOyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICBpZighU3RyZWFtSGFzTWVtb3J5TGVmdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2tGdW5jdGlvbiA9IHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYnl0ZXNJbkFuc3dlclN0cmVhbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbSA9IG5ldyBNeVJlYWRhYmxlU3RyZWFtKHtoaWdoV2F0ZXJNYXJrOiBXQVRFUk1BUktfSEVJR0hUX09GX0FOU1dFUlNUUkVBTX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7IFxyXG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ub01vcmVEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LndlYlRvcnJlbnRTdHJlYW0ucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdC5zdGFydCA+PSB0aGlzUmVxdWVzdC5lbmQgJiYgdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFja0Z1bmN0aW9uID0gdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXNSZXF1ZXN0LmFuc3dlclN0cmVhbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtID0gbmV3IE15UmVhZGFibGVTdHJlYW0oe2hpZ2hXYXRlck1hcms6IFdBVEVSTUFSS19IRUlHSFRfT0ZfQU5TV0VSU1RSRUFNfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYWxsZWQgQ0Igd2l0aCBkYXRhIG91dCBvZiBhbnN3ZXJTdHJlYW0gZnJvbSB2aWRlb3N0cmVhbVJlcXVlc3QgbnVtYmVyIFwiICsgdGhpc1JlcXVlc3QuY3JlYXRlUmVhZFN0cmVhbU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdC53ZWJUb3JyZW50U3RyZWFtKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qud2ViVG9ycmVudFN0cmVhbS5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrRnVuY3Rpb24obnVsbCwgcmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5zdGFydCArPSBjaHVuay5sZW5ndGggLSAodGhpc1JlcXVlc3Quc3RhcnQgLSB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlcik7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhpc1JlcXVlc3Qub2xkU3RhcnRTZXJ2ZXIgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgWEhSRW5kID0gZnVuY3Rpb24gKCl7XHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVhZGFibGVTdHJlYW0gcmVxdWVzdCBudW1iZXIgXCIgKyB0aGlzUmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtTnVtYmVyICsgXCIgWEhSRW5kXCIpO1xyXG4gICAgICAgICAgICAgICBpZiAoY29uc29sZUNvdW50ZXIgPCAxMDAwMDAwMDAwMDAwKXtcclxuICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL2NvbnNvbGUubG9nKFwiWEhSRW5kIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8qIFdhbnQgdG8gc29sdmUgZXhhbXBsZV9hcHBsaWNhdGlvbi5qczoxNDAxMyBVbmNhdWdodCBFcnJvcjogRGF0YSB0b28gc2hvcnQgICBEYWhlciBkYXMgaGllciBhdXNrb21tZW50aWVydFxyXG4gICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5ieXRlc0luQW5zd2VyU3RyZWFtID4gMCAmJiB0aGlzUmVxdWVzdC5jdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LmJ5dGVzSW5BbnN3ZXJTdHJlYW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpc1JlcXVlc3QuYW5zd2VyU3RyZWFtO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5hbnN3ZXJTdHJlYW0gPSBuZXcgTXlSZWFkYWJsZVN0cmVhbSh7aGlnaFdhdGVyTWFyazogV0FURVJNQVJLX0hFSUdIVF9PRl9BTlNXRVJTVFJFQU19KTtcclxuICAgICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrRnVuY3Rpb24gPSB0aGlzUmVxdWVzdC5jdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5jdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlhIUkVuZDogY2FsbGVkIENCIHdpdGggZGF0YSBvdXQgb2YgYW5zd2VyU3RyZWFtIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICB0aGVDYWxsYmFja0Z1bmN0aW9uKG51bGwsIHJlcyk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmN1cnJlbnRseUV4cGVjdGVkQ2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICBpZih0aGlzUmVxdWVzdC5zdGFydCA8IFNJWkVfT0ZfVklERU9fRklMRSAmJiB0aGlzUmVxdWVzdC5zdGFydCA8IHRoaXNSZXF1ZXN0LlhIUl9maWxlc2l6ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXNSZXF1ZXN0LmVuZCA+IDAgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpc1JlcXVlc3Quc3RhcnQgPCB0aGlzUmVxdWVzdC5lbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25kdWN0WEhSKHRoaXNSZXF1ZXN0KTsgLy8gdHJ5IHRvIHNvbHZlIGV4YW1wbGVfYXBwbGljYXRpb24uanM6MTQwMTMgVW5jYXVnaHQgRXJyb3I6IERhdGEgdG9vIHNob3J0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZHVjdFhIUih0aGlzUmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiWEhSRW5kIGZyb20gdmlkZW9zdHJlYW1SZXF1ZXN0IG51bWJlciBcIiArIHRoaXNSZXF1ZXN0LmNyZWF0ZVJlYWRTdHJlYW1OdW1iZXIgKyBcIiB0aGlzUmVxdWVzdC5jdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrID09PSBudWxsIDogXCIgKyAodGhpc1JlcXVlc3QuY3VycmVudGx5RXhwZWN0ZWRDYWxsYmFjayA9PT0gbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzUmVxdWVzdC5YSFJDb25kdWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgLy99ICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5vbGRTdGFydFNlcnZlciA9IHJlcVN0YXJ0O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkF0IGh0dG8uZ2V0ICAgcmVxU3RhcnQ6IFwiICsgcmVxU3RhcnQgKyBcIiAgICAgcmVxRW5kOiBcIiArIHJlcUVuZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIFhIUk9wdGlvbk9iamVjdCA9IHtcclxuICAgICAgICAgICAgICAgcGF0aDogdGhpc1JlcXVlc3Quc2VsZi5wYXRoVG9GaWxlT25YSFJTZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgcmFuZ2U6ICdieXRlcz0nICsgcmVxU3RhcnQgKyAnLScgKyAocmVxRW5kLTEpXHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYoWEhSU2VydmVyVVJMKXtcclxuICAgICAgICAgICAgICAgWEhST3B0aW9uT2JqZWN0Lmhvc3RuYW1lID0gWEhSU2VydmVyVVJMO1xyXG4gICAgICAgICAgICAgICBYSFJPcHRpb25PYmplY3QucG9ydCA9IFhIUl9QT1JUO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzUmVxdWVzdC5yZXEgPSBodHRwLmdldChYSFJPcHRpb25PYmplY3QsIGZ1bmN0aW9uIChyZXMpe1xyXG4gICAgICAgICAgICAgICAgICB2YXIgY29udGVudFJhbmdlID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtcmFuZ2UnXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicGFyc2VJbnQoY29udGVudFJhbmdlLnNwbGl0KCcvJylbMV0sIDEwKSBYSFI6IFwiICsgcGFyc2VJbnQoY29udGVudFJhbmdlLnNwbGl0KCcvJylbMV0sIDEwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIEhhdCB6dSBidWdzIGdlZsO8aHJ0LiBIYXQgZ2VyaW5nZSBwcmlvcml0w6R0IGVpbnp1YmF1ZW4gZGFzIGZpbGVfc2l6ZSBhdWNoIHZvbSBYSFIgc2VydmVyIGVyZnJhZ3Qgd2lyZC5cclxuICAgICAgICAgICAgICAgICAgICAgLy9TSVpFX09GX1ZJREVPX0ZJTEUgPSBwYXJzZUludChjb250ZW50UmFuZ2Uuc3BsaXQoJy8nKVsxXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAvL2lmKHRoaXNSZXF1ZXN0LmVuZCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXNSZXF1ZXN0LlhIUl9maWxlc2l6ZSA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZS5zcGxpdCgnLycpWzFdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vY29uc29sZS5sb2coXCJJIHJldHVybiBjdXJyZW50bHlFeHBlY3RlZENhbGxiYWNrIHdpdGggaHR0cCByZXNwb25zZSBzdHJlYW1cIik7XHJcbiAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vL2NvbnNvbGUubG9nKFwiZnVuY3Rpb24ocmVzKSBpcyBleGVjdXRlZCBmcm9tIHJlYWRzdHJlYW0gbnVtYmVyIFwiICsgY3JlYXRlUmVhZFN0cmVhbUNvdW50ZXIgKyBcIiBhbmQgQ0IgbnVtYmVyIFwiICsgdGhpc0NhbGxiYWNrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCBYSFJFbmQpO1xyXG4gICAgICAgICAgICAgICAgICByZXMub24oJ2RhdGEnLCBYSFJEYXRhSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBmcmVxdWVudGx5Q2hlY2tJZk5ld0NyZWF0ZVJlYWRTdHJlYW1OZWNlc3NhcnkoKTtcclxuICAgICAgICAgY2hva2VJZk5lY2Vzc2FyeSgpO1xyXG4gICAgICAgICB1cGRhdGVDaGFydCgpO1xyXG4gICAgICAgICBmcmVxdWVudGx5Q2Vja0lmQW5zd2VyU3RyZWFtUmVhZHkoKTtcclxuICAgICAgICAgY2hlY2tJZkJ1ZmZlckZ1bGxFbm91Z2goKTtcclxuXHJcbiAgICAgICAgIC8vLy8vL2NvbnNvbGUubG9nKFwiSSBjYWxsIFZpZGVvc3RyZWFtIGNvbnN0cnVjdG9yXCIpO1xyXG4gICAgICAgICBpZihoYXNoVmFsdWUpe1xyXG4gICAgICAgICAgICBWaWRlb3N0cmVhbShuZXcgZmlsZUxpa2VPYmplY3QoaGFzaFZhbHVlKSwgbXlWaWRlbyk7XHJcbiAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFZpZGVvc3RyZWFtKG5ldyBmaWxlTGlrZU9iamVjdChwYXRoVG9GaWxlT25YSFJTZXJ2ZXIpLCBteVZpZGVvKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBzaW1wbGUtcGVlciBjb25uZWN0aW9uIHRvIHRoZSBXZWJUb3JyZW50IHN3YXJtIG9mIHRoZSBGVlNMIGluc3RhbmNlLlxyXG4gICAgICAvLyBBIHNpbXBsZS1wZWVyIGlzIGEgd3JhcHBlciBmb3IgYSBXZWItUlRDIGNvbm5lY3Rpb24uXHJcbiAgICAgIGZ1bmN0aW9uIGFkZFNpbXBsZVBlZXJJbnN0YW5jZShzaW1wbGVQZWVySW5zdGFuY2UsIG9wdGlvbnMsIGNhbGxiYWNrKXtcclxuICAgICAgICAgLy8gVGhlIG1ldGhvZCBhZGQgYSBzaW1wbGVQZWVyIHRvIHRoZSBXZWJUb3JyZW50IHN3YXJtIGluc3RhbmNlXHJcbiAgICAgICAgIGlmKHRoZVRvcnJlbnQpe1xyXG4gICAgICAgICAgICBpZih0aGVUb3JyZW50LmluZm9IYXNoKXtcclxuICAgICAgICAgICAgICAgdGhlVG9ycmVudC5hZGRQZWVyKHNpbXBsZVBlZXJJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGVUb3JyZW50Lm9uKCdpbmZvSGFzaCcsIGZ1bmN0aW9uKCkge3RoZVRvcnJlbnQuYWRkUGVlcihzaW1wbGVQZWVySW5zdGFuY2UpOyBpZihjYWxsYmFjayl7Y2FsbGJhY2soKX19KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcGFpciA9IFtdO1xyXG4gICAgICAgICAgICBwYWlyLnB1c2goc2ltcGxlUGVlckluc3RhbmNlKTtcclxuICAgICAgICAgICAgcGFpci5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgcGVlcnNUb0FkZC5wdXNoKHBhaXIpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfSkoKTtcclxufSIsInZhciBZID0gcmVxdWlyZShcInlqc1wiKTtcclxucmVxdWlyZShcInktYXJyYXlcIikoWSk7XHJcbnJlcXVpcmUoXCJ5LW1lbW9yeVwiKShZKTtcclxucmVxdWlyZShcInktd2Vic29ja2V0cy1jbGllbnRcIikoWSk7XHJcbnJlcXVpcmUoXCJ5LW1hcFwiKShZKTtcclxudmFyIE9ha1N0cmVhbWluZyA9IHJlcXVpcmUoJy4vT2FrU3RyZWFtaW5nJyk7XHJcbnZhciBteVN0cmVhbWluZyA9IG5ldyBPYWtTdHJlYW1pbmcoKTtcclxuXHJcbnZhciB0aGVTaGFyZWRNYXAgPSBudWxsO1xyXG52YXIgdGhlU2hhcmVkQXJyYXkgPSBudWxsO1xyXG52YXIgc3RyZWFtU291cmNlID0gZmFsc2U7XHJcblxyXG4vKlxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdmb3JtJykuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgbXlTdHJlYW1pbmcubG9hZFZpZGVvKEpTT04ucGFyc2UoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2luY29taW5nJykudmFsdWUpLCBmdW5jdGlvbigpe2NvbnNvbGUubG9nKFwiQWxsIHZpZGVvIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWRcIik7fSk7XHJcbn0pO1xyXG4qL1xyXG5cclxuWSh7XHJcbiAgZGI6IHtcclxuICAgIG5hbWU6ICdtZW1vcnknXHJcbiAgfSxcclxuICBjb25uZWN0b3I6IHtcclxuICAgICAvL3VybCA6IFwiaHR0cHM6Ly95anMuZGJpcy5yd3RoLWFhY2hlbi5kZTo1MDc4XCIsXHJcbiAgICBuYW1lOiAnd2Vic29ja2V0cy1jbGllbnQnLFxyXG4gICAgcm9vbTogJ1dlYlRvcnJlbnQtU3RyZWFtaW5nLXllYWgnXHJcbiAgfSxcclxuICBzaGFyZToge1xyXG4gICAgIC8vbXlNYXAgOiAnTWFwJyxcclxuICAgICBteUFycmF5IDogJ0FycmF5J1xyXG4gIH1cclxufSkudGhlbihmdW5jdGlvbiAoeSl7XHJcbiAgLy90aGVTaGFyZWRNYXAgPSB5LnNoYXJlLm15TWFwO1xyXG4gIHRoZVNoYXJlZEFycmF5ID0geS5zaGFyZS5teUFycmF5O1xyXG4gIC8qXHJcbiAgeS5zaGFyZS5teU1hcC5vYnNlcnZlKGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgY29uc29sZS5sb2coXCJUaGUgZm9sbG93aW5nIGV2ZW50LXR5cGUgd2FzIHRocm93bjogXCIrIGV2ZW50LnR5cGUpXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVGhlIGV2ZW50IHdhcyBleGVjdXRlZCBvbjogXCIrIGV2ZW50Lm5hbWUpXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVGhlIGV2ZW50IG9iamVjdCBoYXMgbW9yZSBpbmZvcm1hdGlvbjpcIilcclxuICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xyXG4gICAgICBpZighc3RyZWFtU291cmNlKXtcclxuICAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyBnZXRzIGxvYWRlZFwiKTtcclxuICAgICAgICAgbXlTdHJlYW1pbmcubG9hZFZpZGVvKHRoZVNoYXJlZE1hcC5nZXRQcmltaXRpdmUoXCJzdHJlYW1JbmZvcm1hdGlvbk9iamVjdFwiKSwgZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIkFsbCB2aWRlbyBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkXCIpO30pO1xyXG4gICAgICAgICBjb25zb2xlLmxvZyhcIkFmdGVyIG15U3RyZWFtaW5nLmxvYWRWaWRlbyguLikgaW4gbXlNYXAub2JzZXJ2ZSguLilcIik7ICAgIFxyXG4gICAgICB9XHJcbiAgfSk7XHJcbiAgKi9cclxuICAgdGhlU2hhcmVkQXJyYXkub2JzZXJ2ZShmdW5jdGlvbihldmVudCl7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVGhlIGZvbGxvd2luZyBldmVudC10eXBlIHdhcyB0aHJvd246IFwiKyBldmVudC50eXBlKVxyXG4gICAgICBjb25zb2xlLmxvZyhcIlRoZSBldmVudCB3YXMgZXhlY3V0ZWQgb246IFwiKyBldmVudC5uYW1lKVxyXG4gICAgICBjb25zb2xlLmxvZyhcIlRoZSBldmVudCBvYmplY3QgaGFzIG1vcmUgaW5mb3JtYXRpb246XCIpXHJcbiAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcclxuICAgICAgaWYoIXN0cmVhbVNvdXJjZSl7XHJcbiAgICAgICAgIGNvbnNvbGUubG9nKFwiVmlkZW8gZ2V0cyBsb2FkZWRcIik7XHJcbiAgICAgICAgIG15U3RyZWFtaW5nLmxvYWRWaWRlbyh0aGVTaGFyZWRBcnJheS5nZXQoMCksIGZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJBbGwgdmlkZW8gZGF0YSBoYXMgYmVlbiByZWNlaXZlZFwiKTt9KTtcclxuICAgICAgICAgY29uc29sZS5sb2coXCJBZnRlciBteVN0cmVhbWluZy5sb2FkVmlkZW8oLi4pIGluIG15TWFwLm9ic2VydmUoLi4pXCIpOyAgICBcclxuICAgICAgfVxyXG4gICB9KTtcclxufSk7XHJcblxyXG53aW5kb3cuaGFuZGxlRmlsZXMgPSBmdW5jdGlvbihmaWxlcyl7ICAgICAvLyAsW1wid3NzOi8vdHJhY2tlci53ZWJ0b3JyZW50LmlvXCJdICAgXCJ3czovL2xvY2FsaG9zdDo4MDgxXCIgICAgXCJodHRwOi8vZ2F1ZGkuaW5mb3JtYXRpay5yd3RoLWFhY2hlbi5kZS9XZWJUb3JyZW50VmlkZW8vOjk5MTdcIiAgWEhSX3NlcnZlcl9VUkwgOiBcImxvY2FsaG9zdFwiICAgICBoYXNoX3ZhbHVlIDogXCIvXCIgKyBcImViZTUxMzg5NTM4YjdlNThjYjVjOWQyYTkxNDhhNTdkNDVmMzIzOGM2MTI0ODUxMzk3OWE3MGVjOGE2YTA4NGVcIiwgd2ViVG9ycmVudF90cmFja2VyczogW1tcIndzczovL3RyYWNrZXIud2VidG9ycmVudC5pb1wiXV19LCBcclxuICAgc3RyZWFtU291cmNlID0gdHJ1ZTtcclxuICAgbXlTdHJlYW1pbmcuc3RyZWFtVmlkZW8oZmlsZXNbMF0sIHtYSFJfc2VydmVyX1VSTCA6IFwibG9jYWxob3N0XCIsIFhIUl9wb3J0OiA4MDgwLCBwYXRoX3RvX2ZpbGVfb25fWEhSX3NlcnZlcjogXCIvdmlkZW9zL1wiICsgZmlsZXNbMF0ubmFtZX0sIGZ1bmN0aW9uKHN0cmVhbUluZm9ybWF0aW9uT2JqZWN0KXtcclxuICAgICAgLy9jb25zb2xlLmxvZyhcInN0cmVhbUluZm9ybWF0aW9uT2JqZWN0OlxcblwiICsgSlNPTi5zdHJpbmdpZnkoc3RyZWFtSW5mb3JtYXRpb25PYmplY3QpKTtcclxuICAgICAgY29uc29sZS5sb2coXCJJbiBleGFtcGxlLmpzIHZpZGVvIGZpbGUgZ290IHNlZWRlZC5cIik7XHJcbiAgICAgIHRoZVNoYXJlZEFycmF5Lmluc2VydCgwLCBbc3RyZWFtSW5mb3JtYXRpb25PYmplY3RdKTtcclxuICAgfSk7XHJcbn1cclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyB0aGUgc3RhdGlzdGljcyB0aGF0IGlzIHNob3duIGFib3ZlIHRoZSB2aWRlb1xyXG4vLyB1cGRhdGVDaGFydCBpbiBsb2FkVmlkZW8gc2hvd3MgbW9yZSBpbmZvcyBidXQgaXMgbm90IGluZGVudCBmb3IgZW5kdXNlciB1c2UuIFRoaXMgaXMgaW50ZW5kZWQgYXMgZW5kdXNlciBleGFtcGxlLlxyXG4vKlxyXG5mdW5jdGlvbiB1cGRhdGVDaGFydCgpe1xyXG4gICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIldlYlRvcnJlbnQtcmVjZWl2ZWRcIikuaW5uZXJIVE1MID0gXCJ3ZWJUb3JyZW50RmlsZS5sZW5ndGg6IFwiICsgbXlTdHJlYW1pbmcuZ2V0X2ZpbGVfc2l6ZSgpICsgXCJcXG4gdG9ycmVudC5kb3dubG9hZGVkOiBcIiArIG15U3RyZWFtaW5nLmdldF9udW1iZXJfb2ZfYnlzdGVzX2Rvd25sb2FkZWRfUDJQKCkgKyBcIlxcbiB0b3JyZW50LnVwbG9hZGVkOiBcIiArIG15U3RyZWFtaW5nLmdldF9udW1iZXJfb2ZfYnl0ZXNfdXBsb2FkZWRfUDJQKCkgKyBcIlxcbiB0b3JyZW50LnByb2dyZXNzOiBcIiArIG15U3RyZWFtaW5nLmdldF9wZXJjZW50YWdlX2Rvd25sb2FkZWRfb2ZfdG9ycmVudCgpICsgXCJcXG4gQnl0ZXMgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6IFwiICsgbXlTdHJlYW1pbmcuZ2V0X251bWJlcl9vZl9ieXRlc19kb3dubG9hZGVkX2Zyb21fc2VydmVyKCk7XHJcbiAgIHNldFRpbWVvdXQodXBkYXRlQ2hhcnQsIDUwMCk7XHJcbn1cclxudXBkYXRlQ2hhcnQoKTtcclxuKi8gICAiLCJ2YXIgQUREUl9SRSA9IC9eXFxbPyhbXlxcXV0rKVxcXT86KFxcZCspJC8gLy8gaXB2NC9pcHY2L2hvc3RuYW1lICsgcG9ydFxuXG52YXIgY2FjaGUgPSB7fVxuXG4vLyByZXNldCBjYWNoZSB3aGVuIGl0IGdldHMgdG8gMTAwLDAwMCBlbGVtZW50cyAofiA2MDBLQiBvZiBpcHY0IGFkZHJlc3Nlcylcbi8vIHNvIGl0IHdpbGwgbm90IGdyb3cgdG8gY29uc3VtZSBhbGwgbWVtb3J5IGluIGxvbmctcnVubmluZyBwcm9jZXNzZXNcbnZhciBzaXplID0gMFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZHJUb0lQUG9ydCAoYWRkcikge1xuICBpZiAoc2l6ZSA9PT0gMTAwMDAwKSBtb2R1bGUuZXhwb3J0cy5yZXNldCgpXG4gIGlmICghY2FjaGVbYWRkcl0pIHtcbiAgICB2YXIgbSA9IEFERFJfUkUuZXhlYyhhZGRyKVxuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHI6ICcgKyBhZGRyKVxuICAgIGNhY2hlW2FkZHJdID0gWyBtWzFdLCBOdW1iZXIobVsyXSkgXVxuICAgIHNpemUgKz0gMVxuICB9XG4gIHJldHVybiBjYWNoZVthZGRyXVxufVxuXG5tb2R1bGUuZXhwb3J0cy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0ICgpIHtcbiAgY2FjaGUgPSB7fVxuICBzaXplID0gMFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oY2hhcnMpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpXSk7XG4gICAgICBlbmNvZGVkMiA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMV0pO1xuICAgICAgZW5jb2RlZDMgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzJdKTtcbiAgICAgIGVuY29kZWQ0ID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSszXSk7XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpO1xuIiwiLyoqXG4gKiBEZWNvZGVzIGJlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IChvcHRpb25hbClcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kIChvcHRpb25hbClcbiAqIEBwYXJhbSAge1N0cmluZ30gZW5jb2RpbmcgKG9wdGlvbmFsKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGRhdGEsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwpIHtcbiAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgc3RhcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsKSB7XG4gICAgZW5jb2RpbmcgPSBlbmRcbiAgICBlbmQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gIShCdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgPyBuZXcgQnVmZmVyKGRhdGEpXG4gICAgOiBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZGVjb2RlLmJ5dGVzID0gZGVjb2RlLmRhdGEubGVuZ3RoXG5cbiAgcmV0dXJuIGRlY29kZS5uZXh0KClcbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgPSBudWxsXG5kZWNvZGUuZW5jb2RpbmcgPSBudWxsXG5cbmRlY29kZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBzd2l0Y2ggKGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0pIHtcbiAgICBjYXNlIDB4NjQ6XG4gICAgICByZXR1cm4gZGVjb2RlLmRpY3Rpb25hcnkoKVxuICAgIGNhc2UgMHg2QzpcbiAgICAgIHJldHVybiBkZWNvZGUubGlzdCgpXG4gICAgY2FzZSAweDY5OlxuICAgICAgcmV0dXJuIGRlY29kZS5pbnRlZ2VyKClcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRlY29kZS5idWZmZXIoKVxuICB9XG59XG5cbmRlY29kZS5maW5kID0gZnVuY3Rpb24gKGNocikge1xuICB2YXIgaSA9IGRlY29kZS5wb3NpdGlvblxuICB2YXIgYyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICB2YXIgZCA9IGRlY29kZS5kYXRhXG5cbiAgd2hpbGUgKGkgPCBjKSB7XG4gICAgaWYgKGRbaV0gPT09IGNocikgcmV0dXJuIGlcbiAgICBpKytcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBkYXRhOiBNaXNzaW5nIGRlbGltaXRlciBcIicgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoMTYpICsgJ10nXG4gIClcbn1cblxuZGVjb2RlLmRpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7XG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGRpY3QgPSB7fVxuXG4gIHdoaWxlIChkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1KSB7XG4gICAgZGljdFtkZWNvZGUuYnVmZmVyKCldID0gZGVjb2RlLm5leHQoKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gZGljdFxufVxuXG5kZWNvZGUubGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgbHN0ID0gW11cblxuICB3aGlsZSAoZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSkge1xuICAgIGxzdC5wdXNoKGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBsc3Rcbn1cblxuZGVjb2RlLmludGVnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbmQgPSBkZWNvZGUuZmluZCgweDY1KVxuICB2YXIgbnVtYmVyID0gZGVjb2RlLmRhdGEudG9TdHJpbmcoJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uICsgMSwgZW5kKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgMTApXG59XG5cbmRlY29kZS5idWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZXAgPSBkZWNvZGUuZmluZCgweDNBKVxuICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoZGVjb2RlLmRhdGEudG9TdHJpbmcoJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXApLCAxMClcbiAgdmFyIGVuZCA9ICsrc2VwICsgbGVuZ3RoXG5cbiAgZGVjb2RlLnBvc2l0aW9uID0gZW5kXG5cbiAgcmV0dXJuIGRlY29kZS5lbmNvZGluZ1xuICAgID8gZGVjb2RlLmRhdGEudG9TdHJpbmcoZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZClcbiAgICA6IGRlY29kZS5kYXRhLnNsaWNlKHNlcCwgZW5kKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZVxuIiwiLyoqXG4gKiBFbmNvZGVzIGRhdGEgaW4gYmVuY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE9iamVjdHxOdW1iZXJ8Qm9vbGVhbn0gZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBlbmNvZGUgKGRhdGEsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIHZhciBidWZmZXJzID0gW11cbiAgdmFyIHJlc3VsdCA9IG51bGxcblxuICBlbmNvZGUuX2VuY29kZShidWZmZXJzLCBkYXRhKVxuICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpXG4gIGVuY29kZS5ieXRlcyA9IHJlc3VsdC5sZW5ndGhcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICByZXN1bHQuY29weShidWZmZXIsIG9mZnNldClcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmVuY29kZS5ieXRlcyA9IC0xXG5lbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gZmFsc2VcblxuZW5jb2RlLl9lbmNvZGUgPSBmdW5jdGlvbiAoYnVmZmVycywgZGF0YSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVyblxuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgZGF0YSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBlbmNvZGUuYnVmZmVyKGJ1ZmZlcnMsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBlbmNvZGUubnVtYmVyKGJ1ZmZlcnMsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KGJ1ZmZlcnMsIGRhdGEpXG4gICAgICAgIDogZW5jb2RlLmRpY3QoYnVmZmVycywgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBlbmNvZGUubnVtYmVyKGJ1ZmZlcnMsIGRhdGEgPyAxIDogMClcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxudmFyIGJ1ZmZFID0gbmV3IEJ1ZmZlcignZScpXG52YXIgYnVmZkQgPSBuZXcgQnVmZmVyKCdkJylcbnZhciBidWZmTCA9IG5ldyBCdWZmZXIoJ2wnKVxuXG5lbmNvZGUuYnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgKyAnOicgKyBkYXRhKSlcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uIChidWZmZXJzLCBkYXRhKSB7XG4gIHZhciBtYXhMbyA9IDB4ODAwMDAwMDBcbiAgdmFyIGhpID0gKGRhdGEgLyBtYXhMbykgPDwgMFxuICB2YXIgbG8gPSAoZGF0YSAlIG1heExvKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2gobmV3IEJ1ZmZlcignaScgKyB2YWwgKyAnZScpKVxuXG4gIGlmICh2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQpIHtcbiAgICBlbmNvZGUuX2Zsb2F0Q29udmVyc2lvbkRldGVjdGVkID0gdHJ1ZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXQVJOSU5HOiBQb3NzaWJsZSBkYXRhIGNvcnJ1cHRpb24gZGV0ZWN0ZWQgd2l0aCB2YWx1ZSBcIicgKyBkYXRhICsgJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicgKyB2YWwgKyAnXCInXG4gICAgKVxuICAgIGNvbnNvbGUudHJhY2UoKVxuICB9XG59XG5cbmVuY29kZS5kaWN0ID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgYnVmZmVycy5wdXNoKGJ1ZmZEKVxuXG4gIHZhciBqID0gMFxuICB2YXIga1xuICAvLyBmaXggZm9yIGlzc3VlICMxMyAtIHNvcnRlZCBkaWN0c1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciAoOyBqIDwga2w7IGorKykge1xuICAgIGsgPSBrZXlzW2pdXG4gICAgZW5jb2RlLmJ1ZmZlcihidWZmZXJzLCBrKVxuICAgIGVuY29kZS5fZW5jb2RlKGJ1ZmZlcnMsIGRhdGFba10pXG4gIH1cblxuICBidWZmZXJzLnB1c2goYnVmZkUpXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24gKGJ1ZmZlcnMsIGRhdGEpIHtcbiAgdmFyIGkgPSAwXG4gIHZhciBjID0gZGF0YS5sZW5ndGhcbiAgYnVmZmVycy5wdXNoKGJ1ZmZMKVxuXG4gIGZvciAoOyBpIDwgYzsgaSsrKSB7XG4gICAgZW5jb2RlLl9lbmNvZGUoYnVmZmVycywgZGF0YVtpXSlcbiAgfVxuXG4gIGJ1ZmZlcnMucHVzaChidWZmRSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcbiIsInZhciBiZW5jb2RlID0gbW9kdWxlLmV4cG9ydHNcblxuYmVuY29kZS5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpXG5iZW5jb2RlLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJylcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBhbW91bnQgb2YgYnl0ZXNcbiAqIG5lZWRlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHZhbHVlXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl8QnVmZmVyfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn0gYnl0ZUNvdW50XG4gKi9cbmJlbmNvZGUuYnl0ZUxlbmd0aCA9IGJlbmNvZGUuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKHZhbHVlKS5sZW5ndGhcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSwgY29tcGFyYXRvciwgbG93LCBoaWdoKSB7XG4gIHZhciBtaWQsIGNtcDtcblxuICBpZihsb3cgPT09IHVuZGVmaW5lZClcbiAgICBsb3cgPSAwO1xuXG4gIGVsc2Uge1xuICAgIGxvdyA9IGxvd3wwO1xuICAgIGlmKGxvdyA8IDAgfHwgbG93ID49IGhheXN0YWNrLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBsb3dlciBib3VuZFwiKTtcbiAgfVxuXG4gIGlmKGhpZ2ggPT09IHVuZGVmaW5lZClcbiAgICBoaWdoID0gaGF5c3RhY2subGVuZ3RoIC0gMTtcblxuICBlbHNlIHtcbiAgICBoaWdoID0gaGlnaHwwO1xuICAgIGlmKGhpZ2ggPCBsb3cgfHwgaGlnaCA+PSBoYXlzdGFjay5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgdXBwZXIgYm91bmRcIik7XG4gIH1cblxuICB3aGlsZShsb3cgPD0gaGlnaCkge1xuICAgIC8qIE5vdGUgdGhhdCBcIihsb3cgKyBoaWdoKSA+Pj4gMVwiIG1heSBvdmVyZmxvdywgYW5kIHJlc3VsdHMgaW4gYSB0eXBlY2FzdFxuICAgICAqIHRvIGRvdWJsZSAod2hpY2ggZ2l2ZXMgdGhlIHdyb25nIHJlc3VsdHMpLiAqL1xuICAgIG1pZCA9IGxvdyArIChoaWdoIC0gbG93ID4+IDEpO1xuICAgIGNtcCA9ICtjb21wYXJhdG9yKGhheXN0YWNrW21pZF0sIG5lZWRsZSwgbWlkLCBoYXlzdGFjayk7XG5cbiAgICAvKiBUb28gbG93LiAqL1xuICAgIGlmKGNtcCA8IDAuMClcbiAgICAgIGxvdyAgPSBtaWQgKyAxO1xuXG4gICAgLyogVG9vIGhpZ2guICovXG4gICAgZWxzZSBpZihjbXAgPiAwLjApXG4gICAgICBoaWdoID0gbWlkIC0gMTtcblxuICAgIC8qIEtleSBmb3VuZC4gKi9cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWlkO1xuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIH5sb3c7XG59XG4iLCJ2YXIgQ29udGFpbmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiA/IEJ1ZmZlciAvL2luIG5vZGUsIHVzZSBidWZmZXJzXHJcblx0XHQ6IHR5cGVvZiBJbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBJbnQ4QXJyYXkgLy9pbiBuZXdlciBicm93c2VycywgdXNlIHdlYmdsIGludDhhcnJheXNcclxuXHRcdDogZnVuY3Rpb24obCl7IHZhciBhID0gbmV3IEFycmF5KGwpOyBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBhW2ldPTA7IH07IC8vZWxzZSwgZG8gc29tZXRoaW5nIHNpbWlsYXJcclxuXHJcbmZ1bmN0aW9uIEJpdEZpZWxkKGRhdGEsIG9wdHMpe1xyXG5cdGlmKCEodGhpcyBpbnN0YW5jZW9mIEJpdEZpZWxkKSkge1xyXG5cdFx0cmV0dXJuIG5ldyBCaXRGaWVsZChkYXRhLCBvcHRzKTtcclxuXHR9XHJcblxyXG5cdGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDApe1xyXG5cdFx0ZGF0YSA9IDA7XHJcblx0fVxyXG5cclxuXHR0aGlzLmdyb3cgPSBvcHRzICYmIChpc0Zpbml0ZShvcHRzLmdyb3cpICYmIGdldEJ5dGVTaXplKG9wdHMuZ3JvdykgfHwgb3B0cy5ncm93KSB8fCAwO1xyXG5cclxuXHRpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIiB8fCBkYXRhID09PSB1bmRlZmluZWQpe1xyXG5cdFx0ZGF0YSA9IG5ldyBDb250YWluZXIoZ2V0Qnl0ZVNpemUoZGF0YSkpO1xyXG5cdFx0aWYoZGF0YS5maWxsICYmICFkYXRhLl9pc0J1ZmZlcikgZGF0YS5maWxsKDApOyAvLyBjbGVhciBub2RlIGJ1ZmZlcnMgb2YgZ2FyYmFnZVxyXG5cdH1cclxuXHR0aGlzLmJ1ZmZlciA9IGRhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJ5dGVTaXplKG51bSl7XHJcblx0dmFyIG91dCA9IG51bSA+PiAzO1xyXG5cdGlmKG51bSAlIDggIT09IDApIG91dCsrO1xyXG5cdHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbkJpdEZpZWxkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpKXtcclxuXHR2YXIgaiA9IGkgPj4gMztcclxuXHRyZXR1cm4gKGogPCB0aGlzLmJ1ZmZlci5sZW5ndGgpICYmXHJcblx0XHQhISh0aGlzLmJ1ZmZlcltqXSAmICgxMjggPj4gKGkgJSA4KSkpO1xyXG59O1xyXG5cclxuQml0RmllbGQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGIpe1xyXG5cdHZhciBqID0gaSA+PiAzO1xyXG5cdGlmIChiIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEpe1xyXG5cdFx0aWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IGogKyAxKSB0aGlzLl9ncm93KE1hdGgubWF4KGogKyAxLCBNYXRoLm1pbigyICogdGhpcy5idWZmZXIubGVuZ3RoLCB0aGlzLmdyb3cpKSk7XHJcblx0XHQvLyBTZXRcclxuXHRcdHRoaXMuYnVmZmVyW2pdIHw9IDEyOCA+PiAoaSAlIDgpO1xyXG5cdH0gZWxzZSBpZiAoaiA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xyXG5cdFx0Ly8vIENsZWFyXHJcblx0XHR0aGlzLmJ1ZmZlcltqXSAmPSB+KDEyOCA+PiAoaSAlIDgpKTtcclxuXHR9XHJcbn07XHJcblxyXG5CaXRGaWVsZC5wcm90b3R5cGUuX2dyb3cgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgbGVuZ3RoICYmIGxlbmd0aCA8PSB0aGlzLmdyb3cpIHtcclxuXHRcdHZhciBuZXdCdWZmZXIgPSBuZXcgQ29udGFpbmVyKGxlbmd0aCk7XHJcblx0XHRpZiAobmV3QnVmZmVyLmZpbGwpIG5ld0J1ZmZlci5maWxsKDApO1xyXG5cdFx0aWYgKHRoaXMuYnVmZmVyLmNvcHkpIHRoaXMuYnVmZmVyLmNvcHkobmV3QnVmZmVyLCAwKTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRuZXdCdWZmZXJbaV0gPSB0aGlzLmJ1ZmZlcltpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcblx0fVxyXG59O1xyXG5cclxuaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlLmV4cG9ydHMgPSBCaXRGaWVsZDtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBXaXJlXG5cbnZhciBiZW5jb2RlID0gcmVxdWlyZSgnYmVuY29kZScpXG52YXIgQml0RmllbGQgPSByZXF1aXJlKCdiaXRmaWVsZCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2JpdHRvcnJlbnQtcHJvdG9jb2wnKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNwZWVkb21ldGVyID0gcmVxdWlyZSgnc3BlZWRvbWV0ZXInKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciBCSVRGSUVMRF9HUk9XID0gNDAwMDAwXG52YXIgS0VFUF9BTElWRV9USU1FT1VUID0gNTUwMDBcblxudmFyIE1FU1NBR0VfUFJPVE9DT0wgPSBCdWZmZXIuZnJvbSgnXFx1MDAxM0JpdFRvcnJlbnQgcHJvdG9jb2wnKVxudmFyIE1FU1NBR0VfS0VFUF9BTElWRSA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAwXSlcbnZhciBNRVNTQUdFX0NIT0tFID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDBdKVxudmFyIE1FU1NBR0VfVU5DSE9LRSA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAxXSlcbnZhciBNRVNTQUdFX0lOVEVSRVNURUQgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMl0pXG52YXIgTUVTU0FHRV9VTklOVEVSRVNURUQgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwM10pXG5cbnZhciBNRVNTQUdFX1JFU0VSVkVEID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdXG52YXIgTUVTU0FHRV9QT1JUID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIDB4MDksIDB4MDAsIDB4MDBdXG5cbmZ1bmN0aW9uIFJlcXVlc3QgKHBpZWNlLCBvZmZzZXQsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgdGhpcy5waWVjZSA9IHBpZWNlXG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xufVxuXG5pbmhlcml0cyhXaXJlLCBzdHJlYW0uRHVwbGV4KVxuXG5mdW5jdGlvbiBXaXJlICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdpcmUpKSByZXR1cm4gbmV3IFdpcmUoKVxuICBzdHJlYW0uRHVwbGV4LmNhbGwodGhpcylcblxuICB0aGlzLl9kZWJ1Z0lkID0gaGF0KDMyKVxuICB0aGlzLl9kZWJ1ZygnbmV3IHdpcmUnKVxuXG4gIHRoaXMucGVlcklkID0gbnVsbCAvLyByZW1vdGUgcGVlciBpZCAoaGV4IHN0cmluZylcbiAgdGhpcy5wZWVySWRCdWZmZXIgPSBudWxsIC8vIHJlbW90ZSBwZWVyIGlkIChidWZmZXIpXG4gIHRoaXMudHlwZSA9IG51bGwgLy8gY29ubmVjdGlvbiB0eXBlICgnd2VicnRjJywgJ3RjcEluY29taW5nJywgJ3RjcE91dGdvaW5nJywgJ3dlYlNlZWQnKVxuXG4gIHRoaXMuYW1DaG9raW5nID0gdHJ1ZSAvLyBhcmUgd2UgY2hva2luZyB0aGUgcGVlcj9cbiAgdGhpcy5hbUludGVyZXN0ZWQgPSBmYWxzZSAvLyBhcmUgd2UgaW50ZXJlc3RlZCBpbiB0aGUgcGVlcj9cblxuICB0aGlzLnBlZXJDaG9raW5nID0gdHJ1ZSAvLyBpcyB0aGUgcGVlciBjaG9raW5nIHVzP1xuICB0aGlzLnBlZXJJbnRlcmVzdGVkID0gZmFsc2UgLy8gaXMgdGhlIHBlZXIgaW50ZXJlc3RlZCBpbiB1cz9cblxuICAvLyBUaGUgbGFyZ2VzdCB0b3JyZW50IHRoYXQgSSBrbm93IG9mICh0aGUgR2VvY2l0aWVzIGFyY2hpdmUpIGlzIH42NDEgR0IgYW5kIGhhc1xuICAvLyB+NDEsMDAwIHBpZWNlcy4gVGhlcmVmb3JlLCBjYXAgYml0ZmllbGQgdG8gMTB4IGxhcmdlciAoNDAwLDAwMCBiaXRzKSB0byBzdXBwb3J0IGFsbFxuICAvLyBwb3NzaWJsZSB0b3JyZW50cyBidXQgcHJldmVudCBtYWxpY2lvdXMgcGVlcnMgZnJvbSBncm93aW5nIGJpdGZpZWxkIHRvIGZpbGwgbWVtb3J5LlxuICB0aGlzLnBlZXJQaWVjZXMgPSBuZXcgQml0RmllbGQoMCwgeyBncm93OiBCSVRGSUVMRF9HUk9XIH0pXG5cbiAgdGhpcy5wZWVyRXh0ZW5zaW9ucyA9IHt9XG5cbiAgdGhpcy5yZXF1ZXN0cyA9IFtdIC8vIG91dGdvaW5nXG4gIHRoaXMucGVlclJlcXVlc3RzID0gW10gLy8gaW5jb21pbmdcblxuICB0aGlzLmV4dGVuZGVkTWFwcGluZyA9IHt9IC8vIG51bWJlciAtPiBzdHJpbmcsIGV4OiAxIC0+ICd1dF9tZXRhZGF0YSdcbiAgdGhpcy5wZWVyRXh0ZW5kZWRNYXBwaW5nID0ge30gLy8gc3RyaW5nIC0+IG51bWJlciwgZXg6IDkgLT4gJ3V0X21ldGFkYXRhJ1xuXG4gIC8vIFRoZSBleHRlbmRlZCBoYW5kc2hha2UgdG8gc2VuZCwgbWludXMgdGhlIFwibVwiIGZpZWxkLCB3aGljaCBnZXRzIGF1dG9tYXRpY2FsbHlcbiAgLy8gZmlsbGVkIGZyb20gYHRoaXMuZXh0ZW5kZWRNYXBwaW5nYFxuICB0aGlzLmV4dGVuZGVkSGFuZHNoYWtlID0ge31cblxuICB0aGlzLnBlZXJFeHRlbmRlZEhhbmRzaGFrZSA9IHt9IC8vIHJlbW90ZSBwZWVyJ3MgZXh0ZW5kZWQgaGFuZHNoYWtlXG5cbiAgdGhpcy5fZXh0ID0ge30gIC8vIHN0cmluZyAtPiBmdW5jdGlvbiwgZXggJ3V0X21ldGFkYXRhJyAtPiB1dF9tZXRhZGF0YSgpXG4gIHRoaXMuX25leHRFeHQgPSAxXG5cbiAgdGhpcy51cGxvYWRlZCA9IDBcbiAgdGhpcy5kb3dubG9hZGVkID0gMFxuICB0aGlzLnVwbG9hZFNwZWVkID0gc3BlZWRvbWV0ZXIoKVxuICB0aGlzLmRvd25sb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG5cbiAgdGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwgPSBudWxsXG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gIHRoaXMuX3RpbWVvdXRNcyA9IDBcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlIC8vIHdhcyB0aGUgd2lyZSBlbmRlZCBieSBjYWxsaW5nIGBkZXN0cm95YD9cbiAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZVxuXG4gIHRoaXMuX3BhcnNlclNpemUgPSAwIC8vIG51bWJlciBvZiBuZWVkZWQgYnl0ZXMgdG8gcGFyc2UgbmV4dCBtZXNzYWdlIGZyb20gcmVtb3RlIHBlZXJcbiAgdGhpcy5fcGFyc2VyID0gbnVsbCAvLyBmdW5jdGlvbiB0byBjYWxsIG9uY2UgYHRoaXMuX3BhcnNlclNpemVgIGJ5dGVzIGFyZSBhdmFpbGFibGVcblxuICB0aGlzLl9idWZmZXIgPSBbXSAvLyBpbmNvbXBsZXRlIG1lc3NhZ2UgZGF0YVxuICB0aGlzLl9idWZmZXJTaXplID0gMCAvLyBjYWNoZWQgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gYHRoaXMuX2J1ZmZlcmBcblxuICB0aGlzLm9uKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaClcblxuICB0aGlzLl9wYXJzZUhhbmRzaGFrZSgpXG59XG5cbi8qKlxuICogU2V0IHdoZXRoZXIgdG8gc2VuZCBhIFwia2VlcC1hbGl2ZVwiIHBpbmcgKHNlbnQgZXZlcnkgNTVzKVxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVcbiAqL1xuV2lyZS5wcm90b3R5cGUuc2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKGVuYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVidWcoJ3NldEtlZXBBbGl2ZSAlcycsIGVuYWJsZSlcbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9rZWVwQWxpdmVJbnRlcnZhbClcbiAgaWYgKGVuYWJsZSA9PT0gZmFsc2UpIHJldHVyblxuICBzZWxmLl9rZWVwQWxpdmVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmtlZXBBbGl2ZSgpXG4gIH0sIEtFRVBfQUxJVkVfVElNRU9VVClcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGNvbnNpZGVyaW5nIGEgcmVxdWVzdCB0byBiZSBcInRpbWVkIG91dFwiXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVucmVmIChzaG91bGQgdGhlIHRpbWVyIGJlIHVucmVmJ2Q/IGRlZmF1bHQ6IGZhbHNlKVxuICovXG5XaXJlLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKG1zLCB1bnJlZikge1xuICB0aGlzLl9kZWJ1Zygnc2V0VGltZW91dCBtcz0lZCB1bnJlZj0lcycsIG1zLCB1bnJlZilcbiAgdGhpcy5fY2xlYXJUaW1lb3V0KClcbiAgdGhpcy5fdGltZW91dE1zID0gbXNcbiAgdGhpcy5fdGltZW91dFVucmVmID0gISF1bnJlZlxuICB0aGlzLl91cGRhdGVUaW1lb3V0KClcbn1cblxuV2lyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX2RlYnVnKCdkZXN0cm95JylcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG4gIHRoaXMuZW5kKClcbn1cblxuV2lyZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kZWJ1ZygnZW5kJylcbiAgdGhpcy5fb25VbmludGVyZXN0ZWQoKVxuICB0aGlzLl9vbkNob2tlKClcbiAgc3RyZWFtLkR1cGxleC5wcm90b3R5cGUuZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuLyoqXG4gKiBVc2UgdGhlIHNwZWNpZmllZCBwcm90b2NvbCBleHRlbnNpb24uXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gRXh0ZW5zaW9uXG4gKi9cbldpcmUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChFeHRlbnNpb24pIHtcbiAgdmFyIG5hbWUgPSBFeHRlbnNpb24ucHJvdG90eXBlLm5hbWVcbiAgaWYgKCFuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gY2xhc3MgcmVxdWlyZXMgYSBcIm5hbWVcIiBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlJylcbiAgfVxuICB0aGlzLl9kZWJ1ZygndXNlIGV4dGVuc2lvbi5uYW1lPSVzJywgbmFtZSlcblxuICB2YXIgZXh0ID0gdGhpcy5fbmV4dEV4dFxuICB2YXIgaGFuZGxlciA9IG5ldyBFeHRlbnNpb24odGhpcylcblxuICBmdW5jdGlvbiBub29wICgpIHt9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uSGFuZHNoYWtlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlci5vbkhhbmRzaGFrZSA9IG5vb3BcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIub25FeHRlbmRlZEhhbmRzaGFrZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGhhbmRsZXIub25FeHRlbmRlZEhhbmRzaGFrZSA9IG5vb3BcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIub25NZXNzYWdlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaGFuZGxlci5vbk1lc3NhZ2UgPSBub29wXG4gIH1cblxuICB0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdID0gbmFtZVxuICB0aGlzLl9leHRbbmFtZV0gPSBoYW5kbGVyXG4gIHRoaXNbbmFtZV0gPSBoYW5kbGVyXG5cbiAgdGhpcy5fbmV4dEV4dCArPSAxXG59XG5cbi8vXG4vLyBPVVRHT0lORyBNRVNTQUdFU1xuLy9cblxuLyoqXG4gKiBNZXNzYWdlIFwia2VlcC1hbGl2ZVwiOiA8bGVuPTAwMDA+XG4gKi9cbldpcmUucHJvdG90eXBlLmtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ2tlZXAtYWxpdmUnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfS0VFUF9BTElWRSlcbn1cblxuLyoqXG4gKiBNZXNzYWdlOiBcImhhbmRzaGFrZVwiIDxwc3RybGVuPjxwc3RyPjxyZXNlcnZlZD48aW5mb19oYXNoPjxwZWVyX2lkPlxuICogQHBhcmFtICB7QnVmZmVyfHN0cmluZ30gaW5mb0hhc2ggKGFzIEJ1ZmZlciBvciAqaGV4KiBzdHJpbmcpXG4gKiBAcGFyYW0gIHtCdWZmZXJ8c3RyaW5nfSBwZWVySWRcbiAqIEBwYXJhbSAge09iamVjdH0gZXh0ZW5zaW9uc1xuICovXG5XaXJlLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucykge1xuICB2YXIgaW5mb0hhc2hCdWZmZXIsIHBlZXJJZEJ1ZmZlclxuICBpZiAodHlwZW9mIGluZm9IYXNoID09PSAnc3RyaW5nJykge1xuICAgIGluZm9IYXNoQnVmZmVyID0gQnVmZmVyLmZyb20oaW5mb0hhc2gsICdoZXgnKVxuICB9IGVsc2Uge1xuICAgIGluZm9IYXNoQnVmZmVyID0gaW5mb0hhc2hcbiAgICBpbmZvSGFzaCA9IGluZm9IYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICB9XG4gIGlmICh0eXBlb2YgcGVlcklkID09PSAnc3RyaW5nJykge1xuICAgIHBlZXJJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBlZXJJZCwgJ2hleCcpXG4gIH0gZWxzZSB7XG4gICAgcGVlcklkQnVmZmVyID0gcGVlcklkXG4gICAgcGVlcklkID0gcGVlcklkQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICB9XG5cbiAgaWYgKGluZm9IYXNoQnVmZmVyLmxlbmd0aCAhPT0gMjAgfHwgcGVlcklkQnVmZmVyLmxlbmd0aCAhPT0gMjApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZm9IYXNoIGFuZCBwZWVySWQgTVVTVCBoYXZlIGxlbmd0aCAyMCcpXG4gIH1cblxuICB0aGlzLl9kZWJ1ZygnaGFuZHNoYWtlIGk9JXMgcD0lcyBleHRzPSVvJywgaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucylcblxuICB2YXIgcmVzZXJ2ZWQgPSBCdWZmZXIuZnJvbShNRVNTQUdFX1JFU0VSVkVEKVxuXG4gIC8vIGVuYWJsZSBleHRlbmRlZCBtZXNzYWdlXG4gIHJlc2VydmVkWzVdIHw9IDB4MTBcblxuICBpZiAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmRodCkgcmVzZXJ2ZWRbN10gfD0gMVxuXG4gIHRoaXMuX3B1c2goQnVmZmVyLmNvbmNhdChbTUVTU0FHRV9QUk9UT0NPTCwgcmVzZXJ2ZWQsIGluZm9IYXNoQnVmZmVyLCBwZWVySWRCdWZmZXJdKSlcbiAgdGhpcy5faGFuZHNoYWtlU2VudCA9IHRydWVcblxuICBpZiAodGhpcy5wZWVyRXh0ZW5zaW9ucy5leHRlbmRlZCAmJiAhdGhpcy5fZXh0ZW5kZWRIYW5kc2hha2VTZW50KSB7XG4gICAgLy8gUGVlcidzIGhhbmRzaGFrZSBpbmRpY2F0ZWQgc3VwcG9ydCBhbHJlYWR5XG4gICAgLy8gKGluY29taW5nIGNvbm5lY3Rpb24pXG4gICAgdGhpcy5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlKClcbiAgfVxufVxuXG4vKiBQZWVyIHN1cHBvcnRzIEJFUC0wMDEwLCBzZW5kIGV4dGVuZGVkIGhhbmRzaGFrZS5cbiAqXG4gKiBUaGlzIGNvbWVzIGFmdGVyIHRoZSAnaGFuZHNoYWtlJyBldmVudCB0byBnaXZlIHRoZSB1c2VyIGEgY2hhbmNlIHRvIHBvcHVsYXRlXG4gKiBgdGhpcy5leHRlbmRlZEhhbmRzaGFrZWAgYW5kIGB0aGlzLmV4dGVuZGVkTWFwcGluZ2AgYmVmb3JlIHRoZSBleHRlbmRlZCBoYW5kc2hha2VcbiAqIGlzIHNlbnQgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICovXG5XaXJlLnByb3RvdHlwZS5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlID0gZnVuY3Rpb24gKCkge1xuICAvLyBDcmVhdGUgZXh0ZW5kZWQgbWVzc2FnZSBvYmplY3QgZnJvbSByZWdpc3RlcmVkIGV4dGVuc2lvbnNcbiAgdmFyIG1zZyA9IGV4dGVuZCh0aGlzLmV4dGVuZGVkSGFuZHNoYWtlKVxuICBtc2cubSA9IHt9XG4gIGZvciAodmFyIGV4dCBpbiB0aGlzLmV4dGVuZGVkTWFwcGluZykge1xuICAgIHZhciBuYW1lID0gdGhpcy5leHRlbmRlZE1hcHBpbmdbZXh0XVxuICAgIG1zZy5tW25hbWVdID0gTnVtYmVyKGV4dClcbiAgfVxuXG4gIC8vIFNlbmQgZXh0ZW5kZWQgaGFuZHNoYWtlXG4gIHRoaXMuZXh0ZW5kZWQoMCwgYmVuY29kZS5lbmNvZGUobXNnKSlcbiAgdGhpcy5fZXh0ZW5kZWRIYW5kc2hha2VTZW50ID0gdHJ1ZVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJjaG9rZVwiOiA8bGVuPTAwMDE+PGlkPTA+XG4gKi9cbldpcmUucHJvdG90eXBlLmNob2tlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbUNob2tpbmcpIHJldHVyblxuICB0aGlzLmFtQ2hva2luZyA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2Nob2tlJylcbiAgdGhpcy5wZWVyUmVxdWVzdHMuc3BsaWNlKDAsIHRoaXMucGVlclJlcXVlc3RzLmxlbmd0aClcbiAgdGhpcy5fcHVzaChNRVNTQUdFX0NIT0tFKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJ1bmNob2tlXCI6IDxsZW49MDAwMT48aWQ9MT5cbiAqL1xuV2lyZS5wcm90b3R5cGUudW5jaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmFtQ2hva2luZykgcmV0dXJuXG4gIHRoaXMuYW1DaG9raW5nID0gZmFsc2VcbiAgdGhpcy5fZGVidWcoJ3VuY2hva2UnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfVU5DSE9LRSlcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwiaW50ZXJlc3RlZFwiOiA8bGVuPTAwMDE+PGlkPTI+XG4gKi9cbldpcmUucHJvdG90eXBlLmludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFtSW50ZXJlc3RlZCkgcmV0dXJuXG4gIHRoaXMuYW1JbnRlcmVzdGVkID0gdHJ1ZVxuICB0aGlzLl9kZWJ1ZygnaW50ZXJlc3RlZCcpXG4gIHRoaXMuX3B1c2goTUVTU0FHRV9JTlRFUkVTVEVEKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJ1bmludGVyZXN0ZWRcIjogPGxlbj0wMDAxPjxpZD0zPlxuICovXG5XaXJlLnByb3RvdHlwZS51bmludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5hbUludGVyZXN0ZWQpIHJldHVyblxuICB0aGlzLmFtSW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCd1bmludGVyZXN0ZWQnKVxuICB0aGlzLl9wdXNoKE1FU1NBR0VfVU5JTlRFUkVTVEVEKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJoYXZlXCI6IDxsZW49MDAwNT48aWQ9ND48cGllY2UgaW5kZXg+XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKi9cbldpcmUucHJvdG90eXBlLmhhdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdGhpcy5fZGVidWcoJ2hhdmUgJWQnLCBpbmRleClcbiAgdGhpcy5fbWVzc2FnZSg0LCBbaW5kZXhdLCBudWxsKVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgXCJiaXRmaWVsZFwiOiA8bGVuPTAwMDErWD48aWQ9NT48Yml0ZmllbGQ+XG4gKiBAcGFyYW0gIHtCaXRGaWVsZHxCdWZmZXJ9IGJpdGZpZWxkXG4gKi9cbldpcmUucHJvdG90eXBlLmJpdGZpZWxkID0gZnVuY3Rpb24gKGJpdGZpZWxkKSB7XG4gIHRoaXMuX2RlYnVnKCdiaXRmaWVsZCcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJpdGZpZWxkKSkgYml0ZmllbGQgPSBiaXRmaWVsZC5idWZmZXJcbiAgdGhpcy5fbWVzc2FnZSg1LCBbXSwgYml0ZmllbGQpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcInJlcXVlc3RcIjogPGxlbj0wMDEzPjxpZD02PjxpbmRleD48YmVnaW4+PGxlbmd0aD5cbiAqIEBwYXJhbSAge251bWJlcn0gICBpbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSAgIG9mZnNldFxuICogQHBhcmFtICB7bnVtYmVyfSAgIGxlbmd0aFxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNiXG4gKi9cbldpcmUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IGZ1bmN0aW9uICgpIHt9XG4gIGlmICh0aGlzLl9maW5pc2hlZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignd2lyZSBpcyBjbG9zZWQnKSlcbiAgaWYgKHRoaXMucGVlckNob2tpbmcpIHJldHVybiBjYihuZXcgRXJyb3IoJ3BlZXIgaXMgY2hva2luZycpKVxuXG4gIHRoaXMuX2RlYnVnKCdyZXF1ZXN0IGluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQnLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgdGhpcy5yZXF1ZXN0cy5wdXNoKG5ldyBSZXF1ZXN0KGluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2IpKVxuICB0aGlzLl91cGRhdGVUaW1lb3V0KClcbiAgdGhpcy5fbWVzc2FnZSg2LCBbaW5kZXgsIG9mZnNldCwgbGVuZ3RoXSwgbnVsbClcbn1cblxuLyoqXG4gKiBNZXNzYWdlIFwicGllY2VcIjogPGxlbj0wMDA5K1g+PGlkPTc+PGluZGV4PjxiZWdpbj48YmxvY2s+XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtICB7QnVmZmVyfSBidWZmZXJcbiAqL1xuV2lyZS5wcm90b3R5cGUucGllY2UgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgYnVmZmVyKSB7XG4gIHRoaXMuX2RlYnVnKCdwaWVjZSBpbmRleD0lZCBvZmZzZXQ9JWQnLCBpbmRleCwgb2Zmc2V0KVxuICB0aGlzLnVwbG9hZGVkICs9IGJ1ZmZlci5sZW5ndGhcbiAgdGhpcy51cGxvYWRTcGVlZChidWZmZXIubGVuZ3RoKVxuICB0aGlzLmVtaXQoJ3VwbG9hZCcsIGJ1ZmZlci5sZW5ndGgpXG4gIHRoaXMuX21lc3NhZ2UoNywgW2luZGV4LCBvZmZzZXRdLCBidWZmZXIpXG59XG5cbi8qKlxuICogTWVzc2FnZSBcImNhbmNlbFwiOiA8bGVuPTAwMTM+PGlkPTg+PGluZGV4PjxiZWdpbj48bGVuZ3RoPlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSAge251bWJlcn0gbGVuZ3RoXG4gKi9cbldpcmUucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdGhpcy5fZGVidWcoJ2NhbmNlbCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICB0aGlzLl9jYWxsYmFjayhcbiAgICBwdWxsKHRoaXMucmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGxlbmd0aCksXG4gICAgbmV3IEVycm9yKCdyZXF1ZXN0IHdhcyBjYW5jZWxsZWQnKSxcbiAgICBudWxsXG4gIClcbiAgdGhpcy5fbWVzc2FnZSg4LCBbaW5kZXgsIG9mZnNldCwgbGVuZ3RoXSwgbnVsbClcbn1cblxuLyoqXG4gKiBNZXNzYWdlOiBcInBvcnRcIiA8bGVuPTAwMDM+PGlkPTk+PGxpc3Rlbi1wb3J0PlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcnRcbiAqL1xuV2lyZS5wcm90b3R5cGUucG9ydCA9IGZ1bmN0aW9uIChwb3J0KSB7XG4gIHRoaXMuX2RlYnVnKCdwb3J0ICVkJywgcG9ydClcbiAgdmFyIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShNRVNTQUdFX1BPUlQpXG4gIG1lc3NhZ2Uud3JpdGVVSW50MTZCRShwb3J0LCA1KVxuICB0aGlzLl9wdXNoKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogTWVzc2FnZTogXCJleHRlbmRlZFwiIDxsZW49MDAwNStYPjxpZD0yMD48ZXh0LW51bWJlcj48cGF5bG9hZD5cbiAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IGV4dFxuICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAqL1xuV2lyZS5wcm90b3R5cGUuZXh0ZW5kZWQgPSBmdW5jdGlvbiAoZXh0LCBvYmopIHtcbiAgdGhpcy5fZGVidWcoJ2V4dGVuZGVkIGV4dD0lcycsIGV4dClcbiAgaWYgKHR5cGVvZiBleHQgPT09ICdzdHJpbmcnICYmIHRoaXMucGVlckV4dGVuZGVkTWFwcGluZ1tleHRdKSB7XG4gICAgZXh0ID0gdGhpcy5wZWVyRXh0ZW5kZWRNYXBwaW5nW2V4dF1cbiAgfVxuICBpZiAodHlwZW9mIGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZXh0SWQgPSBCdWZmZXIuZnJvbShbZXh0XSlcbiAgICB2YXIgYnVmID0gQnVmZmVyLmlzQnVmZmVyKG9iaikgPyBvYmogOiBiZW5jb2RlLmVuY29kZShvYmopXG5cbiAgICB0aGlzLl9tZXNzYWdlKDIwLCBbXSwgQnVmZmVyLmNvbmNhdChbZXh0SWQsIGJ1Zl0pKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGV4dGVuc2lvbjogJyArIGV4dClcbiAgfVxufVxuXG4vKipcbiAqIER1cGxleCBzdHJlYW0gbWV0aG9kLiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHJlbW90ZSBwZWVyIHN0cmVhbSB3YW50cyBkYXRhLiBOby1vcFxuICogc2luY2Ugd2UnbGwganVzdCBwdXNoIGRhdGEgd2hlbmV2ZXIgd2UgZ2V0IGl0LlxuICovXG5XaXJlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICovXG5XaXJlLnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uIChpZCwgbnVtYmVycywgZGF0YSkge1xuICB2YXIgZGF0YUxlbmd0aCA9IGRhdGEgPyBkYXRhLmxlbmd0aCA6IDBcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg1ICsgNCAqIG51bWJlcnMubGVuZ3RoKVxuXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGJ1ZmZlci5sZW5ndGggKyBkYXRhTGVuZ3RoIC0gNCwgMClcbiAgYnVmZmVyWzRdID0gaWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUobnVtYmVyc1tpXSwgNSArIDQgKiBpKVxuICB9XG5cbiAgdGhpcy5fcHVzaChidWZmZXIpXG4gIGlmIChkYXRhKSB0aGlzLl9wdXNoKGRhdGEpXG59XG5cbldpcmUucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgaWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm5cbiAgcmV0dXJuIHRoaXMucHVzaChkYXRhKVxufVxuXG4vL1xuLy8gSU5DT01JTkcgTUVTU0FHRVNcbi8vXG5cbldpcmUucHJvdG90eXBlLl9vbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBrZWVwLWFsaXZlJylcbiAgdGhpcy5lbWl0KCdrZWVwLWFsaXZlJylcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGluZm9IYXNoQnVmZmVyLCBwZWVySWRCdWZmZXIsIGV4dGVuc2lvbnMpIHtcbiAgdmFyIGluZm9IYXNoID0gaW5mb0hhc2hCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG4gIHZhciBwZWVySWQgPSBwZWVySWRCdWZmZXIudG9TdHJpbmcoJ2hleCcpXG5cbiAgdGhpcy5fZGVidWcoJ2dvdCBoYW5kc2hha2UgaT0lcyBwPSVzIGV4dHM9JW8nLCBpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuXG4gIHRoaXMucGVlcklkID0gcGVlcklkXG4gIHRoaXMucGVlcklkQnVmZmVyID0gcGVlcklkQnVmZmVyXG4gIHRoaXMucGVlckV4dGVuc2lvbnMgPSBleHRlbnNpb25zXG5cbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBpbmZvSGFzaCwgcGVlcklkLCBleHRlbnNpb25zKVxuXG4gIHZhciBuYW1lXG4gIGZvciAobmFtZSBpbiB0aGlzLl9leHQpIHtcbiAgICB0aGlzLl9leHRbbmFtZV0ub25IYW5kc2hha2UoaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucylcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLmV4dGVuZGVkICYmIHRoaXMuX2hhbmRzaGFrZVNlbnQgJiZcbiAgICAgICF0aGlzLl9leHRlbmRlZEhhbmRzaGFrZVNlbnQpIHtcbiAgICAvLyBvdXRnb2luZyBjb25uZWN0aW9uXG4gICAgdGhpcy5fc2VuZEV4dGVuZGVkSGFuZHNoYWtlKClcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25DaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVyQ2hva2luZyA9IHRydWVcbiAgdGhpcy5fZGVidWcoJ2dvdCBjaG9rZScpXG4gIHRoaXMuZW1pdCgnY2hva2UnKVxuICB3aGlsZSAodGhpcy5yZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFjayh0aGlzLnJlcXVlc3RzLnNoaWZ0KCksIG5ldyBFcnJvcigncGVlciBpcyBjaG9raW5nJyksIG51bGwpXG4gIH1cbn1cblxuV2lyZS5wcm90b3R5cGUuX29uVW5jaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVyQ2hva2luZyA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCdnb3QgdW5jaG9rZScpXG4gIHRoaXMuZW1pdCgndW5jaG9rZScpXG59XG5cbldpcmUucHJvdG90eXBlLl9vbkludGVyZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGVlckludGVyZXN0ZWQgPSB0cnVlXG4gIHRoaXMuX2RlYnVnKCdnb3QgaW50ZXJlc3RlZCcpXG4gIHRoaXMuZW1pdCgnaW50ZXJlc3RlZCcpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblVuaW50ZXJlc3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wZWVySW50ZXJlc3RlZCA9IGZhbHNlXG4gIHRoaXMuX2RlYnVnKCdnb3QgdW5pbnRlcmVzdGVkJylcbiAgdGhpcy5lbWl0KCd1bmludGVyZXN0ZWQnKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25IYXZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIGlmICh0aGlzLnBlZXJQaWVjZXMuZ2V0KGluZGV4KSkgcmV0dXJuXG4gIHRoaXMuX2RlYnVnKCdnb3QgaGF2ZSAlZCcsIGluZGV4KVxuXG4gIHRoaXMucGVlclBpZWNlcy5zZXQoaW5kZXgsIHRydWUpXG4gIHRoaXMuZW1pdCgnaGF2ZScsIGluZGV4KVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25CaXRGaWVsZCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5wZWVyUGllY2VzID0gbmV3IEJpdEZpZWxkKGJ1ZmZlcilcbiAgdGhpcy5fZGVidWcoJ2dvdCBiaXRmaWVsZCcpXG4gIHRoaXMuZW1pdCgnYml0ZmllbGQnLCB0aGlzLnBlZXJQaWVjZXMpXG59XG5cbldpcmUucHJvdG90eXBlLl9vblJlcXVlc3QgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5hbUNob2tpbmcpIHJldHVyblxuICBzZWxmLl9kZWJ1ZygnZ290IHJlcXVlc3QgaW5kZXg9JWQgb2Zmc2V0PSVkIGxlbmd0aD0lZCcsIGluZGV4LCBvZmZzZXQsIGxlbmd0aClcblxuICB2YXIgcmVzcG9uZCA9IGZ1bmN0aW9uIChlcnIsIGJ1ZmZlcikge1xuICAgIGlmIChyZXF1ZXN0ICE9PSBwdWxsKHNlbGYucGVlclJlcXVlc3RzLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpKSByZXR1cm5cbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVidWcoJ2Vycm9yIHNhdGlzZnlpbmcgcmVxdWVzdCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkICglcyknLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGVyci5tZXNzYWdlKVxuICAgIHNlbGYucGllY2UoaW5kZXgsIG9mZnNldCwgYnVmZmVyKVxuICB9XG5cbiAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbmRleCwgb2Zmc2V0LCBsZW5ndGgsIHJlc3BvbmQpXG4gIHNlbGYucGVlclJlcXVlc3RzLnB1c2gocmVxdWVzdClcbiAgc2VsZi5lbWl0KCdyZXF1ZXN0JywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoLCByZXNwb25kKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25QaWVjZSA9IGZ1bmN0aW9uIChpbmRleCwgb2Zmc2V0LCBidWZmZXIpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBwaWVjZSBpbmRleD0lZCBvZmZzZXQ9JWQnLCBpbmRleCwgb2Zmc2V0KVxuICB0aGlzLl9jYWxsYmFjayhwdWxsKHRoaXMucmVxdWVzdHMsIGluZGV4LCBvZmZzZXQsIGJ1ZmZlci5sZW5ndGgpLCBudWxsLCBidWZmZXIpXG4gIHRoaXMuZG93bmxvYWRlZCArPSBidWZmZXIubGVuZ3RoXG4gIHRoaXMuZG93bmxvYWRTcGVlZChidWZmZXIubGVuZ3RoKVxuICB0aGlzLmVtaXQoJ2Rvd25sb2FkJywgYnVmZmVyLmxlbmd0aClcbiAgdGhpcy5lbWl0KCdwaWVjZScsIGluZGV4LCBvZmZzZXQsIGJ1ZmZlcilcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQsIGxlbmd0aCkge1xuICB0aGlzLl9kZWJ1ZygnZ290IGNhbmNlbCBpbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxuICBwdWxsKHRoaXMucGVlclJlcXVlc3RzLCBpbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG4gIHRoaXMuZW1pdCgnY2FuY2VsJywgaW5kZXgsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25Qb3J0ID0gZnVuY3Rpb24gKHBvcnQpIHtcbiAgdGhpcy5fZGVidWcoJ2dvdCBwb3J0ICVkJywgcG9ydClcbiAgdGhpcy5lbWl0KCdwb3J0JywgcG9ydClcbn1cblxuV2lyZS5wcm90b3R5cGUuX29uRXh0ZW5kZWQgPSBmdW5jdGlvbiAoZXh0LCBidWYpIHtcbiAgaWYgKGV4dCA9PT0gMCkge1xuICAgIHZhciBpbmZvXG4gICAgdHJ5IHtcbiAgICAgIGluZm8gPSBiZW5jb2RlLmRlY29kZShidWYpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnaWdub3JpbmcgaW52YWxpZCBleHRlbmRlZCBoYW5kc2hha2U6ICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICAgIH1cblxuICAgIGlmICghaW5mbykgcmV0dXJuXG4gICAgdGhpcy5wZWVyRXh0ZW5kZWRIYW5kc2hha2UgPSBpbmZvXG5cbiAgICB2YXIgbmFtZVxuICAgIGlmICh0eXBlb2YgaW5mby5tID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChuYW1lIGluIGluZm8ubSkge1xuICAgICAgICB0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmdbbmFtZV0gPSBOdW1iZXIoaW5mby5tW25hbWVdLnRvU3RyaW5nKCkpXG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiB0aGlzLl9leHQpIHtcbiAgICAgIGlmICh0aGlzLnBlZXJFeHRlbmRlZE1hcHBpbmdbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5fZXh0W25hbWVdLm9uRXh0ZW5kZWRIYW5kc2hha2UodGhpcy5wZWVyRXh0ZW5kZWRIYW5kc2hha2UpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RlYnVnKCdnb3QgZXh0ZW5kZWQgaGFuZHNoYWtlJylcbiAgICB0aGlzLmVtaXQoJ2V4dGVuZGVkJywgJ2hhbmRzaGFrZScsIHRoaXMucGVlckV4dGVuZGVkSGFuZHNoYWtlKVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdKSB7XG4gICAgICBleHQgPSB0aGlzLmV4dGVuZGVkTWFwcGluZ1tleHRdIC8vIGZyaWVuZGx5IG5hbWUgZm9yIGV4dGVuc2lvblxuICAgICAgaWYgKHRoaXMuX2V4dFtleHRdKSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIGFuIHJlZ2lzdGVyZWQgZXh0ZW5zaW9uIGhhbmRsZXIsIHNvIGNhbGwgaXRcbiAgICAgICAgdGhpcy5fZXh0W2V4dF0ub25NZXNzYWdlKGJ1ZilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGVidWcoJ2dvdCBleHRlbmRlZCBtZXNzYWdlIGV4dD0lcycsIGV4dClcbiAgICB0aGlzLmVtaXQoJ2V4dGVuZGVkJywgZXh0LCBidWYpXG4gIH1cbn1cblxuV2lyZS5wcm90b3R5cGUuX29uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZGVidWcoJ3JlcXVlc3QgdGltZWQgb3V0JylcbiAgdGhpcy5fY2FsbGJhY2sodGhpcy5yZXF1ZXN0cy5zaGlmdCgpLCBuZXcgRXJyb3IoJ3JlcXVlc3QgaGFzIHRpbWVkIG91dCcpLCBudWxsKVxuICB0aGlzLmVtaXQoJ3RpbWVvdXQnKVxufVxuXG4vKipcbiAqIER1cGxleCBzdHJlYW0gbWV0aG9kLiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHJlbW90ZSBwZWVyIGhhcyBkYXRhIGZvciB1cy4gRGF0YSB0aGF0IHRoZVxuICogcmVtb3RlIHBlZXIgc2VuZHMgZ2V0cyBidWZmZXJlZCAoaS5lLiBub3QgYWN0dWFsbHkgcHJvY2Vzc2VkKSB1bnRpbCB0aGUgcmlnaHQgbnVtYmVyXG4gKiBvZiBieXRlcyBoYXZlIGFycml2ZWQsIGRldGVybWluZWQgYnkgdGhlIGxhc3QgY2FsbCB0byBgdGhpcy5fcGFyc2UobnVtYmVyLCBjYWxsYmFjaylgLlxuICogT25jZSBlbm91Z2ggYnl0ZXMgaGF2ZSBhcnJpdmVkIHRvIHByb2Nlc3MgdGhlIG1lc3NhZ2UsIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICogKGkuZS4gYHRoaXMuX3BhcnNlcmApIGdldHMgY2FsbGVkIHdpdGggdGhlIGZ1bGwgYnVmZmVyIG9mIGRhdGEuXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gZW5jb2RpbmdcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5XaXJlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuX2J1ZmZlclNpemUgKz0gZGF0YS5sZW5ndGhcbiAgdGhpcy5fYnVmZmVyLnB1c2goZGF0YSlcblxuICB3aGlsZSAodGhpcy5fYnVmZmVyU2l6ZSA+PSB0aGlzLl9wYXJzZXJTaXplKSB7XG4gICAgdmFyIGJ1ZmZlciA9ICh0aGlzLl9idWZmZXIubGVuZ3RoID09PSAxKVxuICAgICAgPyB0aGlzLl9idWZmZXJbMF1cbiAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXIpXG4gICAgdGhpcy5fYnVmZmVyU2l6ZSAtPSB0aGlzLl9wYXJzZXJTaXplXG4gICAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyU2l6ZVxuICAgICAgPyBbYnVmZmVyLnNsaWNlKHRoaXMuX3BhcnNlclNpemUpXVxuICAgICAgOiBbXVxuICAgIHRoaXMuX3BhcnNlcihidWZmZXIuc2xpY2UoMCwgdGhpcy5fcGFyc2VyU2l6ZSkpXG4gIH1cblxuICBjYihudWxsKSAvLyBTaWduYWwgdGhhdCB3ZSdyZSByZWFkeSBmb3IgbW9yZSBkYXRhXG59XG5cbldpcmUucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBlcnIsIGJ1ZmZlcikge1xuICBpZiAoIXJlcXVlc3QpIHJldHVyblxuXG4gIHRoaXMuX2NsZWFyVGltZW91dCgpXG5cbiAgaWYgKCF0aGlzLnBlZXJDaG9raW5nICYmICF0aGlzLl9maW5pc2hlZCkgdGhpcy5fdXBkYXRlVGltZW91dCgpXG4gIHJlcXVlc3QuY2FsbGJhY2soZXJyLCBidWZmZXIpXG59XG5cbldpcmUucHJvdG90eXBlLl9jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fdGltZW91dCkgcmV0dXJuXG5cbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsXG59XG5cbldpcmUucHJvdG90eXBlLl91cGRhdGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl90aW1lb3V0TXMgfHwgIXNlbGYucmVxdWVzdHMubGVuZ3RoIHx8IHNlbGYuX3RpbWVvdXQpIHJldHVyblxuXG4gIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblRpbWVvdXQoKVxuICB9LCBzZWxmLl90aW1lb3V0TXMpXG4gIGlmIChzZWxmLl90aW1lb3V0VW5yZWYgJiYgc2VsZi5fdGltZW91dC51bnJlZikgc2VsZi5fdGltZW91dC51bnJlZigpXG59XG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgbG9jYWwgcGVlciBpcyB3YWl0aW5nIHRvIHJlY2VpdmUgZnJvbSB0aGUgcmVtb3RlIHBlZXJcbiAqIGluIG9yZGVyIHRvIHBhcnNlIGEgY29tcGxldGUgbWVzc2FnZSwgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgZW5vdWdoXG4gKiBieXRlcyBoYXZlIGFycml2ZWQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNpemVcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBwYXJzZXJcbiAqL1xuV2lyZS5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gKHNpemUsIHBhcnNlcikge1xuICB0aGlzLl9wYXJzZXJTaXplID0gc2l6ZVxuICB0aGlzLl9wYXJzZXIgPSBwYXJzZXJcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgYSBtZXNzYWdlLCB0byBkZXRlcm1pbmUgdGhlIGxlbmd0aCBvZiBieXRlcyB0aGF0IG11c3QgYmVcbiAqIHdhaXRlZCBmb3IgaW4gb3JkZXIgdG8gaGF2ZSB0aGUgd2hvbGUgbWVzc2FnZS5cbiAqIEBwYXJhbSAge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbldpcmUucHJvdG90eXBlLl9vbk1lc3NhZ2VMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBidWZmZXIucmVhZFVJbnQzMkJFKDApXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fcGFyc2UobGVuZ3RoLCB0aGlzLl9vbk1lc3NhZ2UpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb25LZWVwQWxpdmUoKVxuICAgIHRoaXMuX3BhcnNlKDQsIHRoaXMuX29uTWVzc2FnZUxlbmd0aClcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBhIG1lc3NhZ2UgZnJvbSB0aGUgcmVtb3RlIHBlZXIuXG4gKiBAcGFyYW0gIHtCdWZmZXJ9IGJ1ZmZlclxuICovXG5XaXJlLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB0aGlzLl9wYXJzZSg0LCB0aGlzLl9vbk1lc3NhZ2VMZW5ndGgpXG4gIHN3aXRjaCAoYnVmZmVyWzBdKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRoaXMuX29uQ2hva2UoKVxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB0aGlzLl9vblVuY2hva2UoKVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB0aGlzLl9vbkludGVyZXN0ZWQoKVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB0aGlzLl9vblVuaW50ZXJlc3RlZCgpXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHRoaXMuX29uSGF2ZShidWZmZXIucmVhZFVJbnQzMkJFKDEpKVxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiB0aGlzLl9vbkJpdEZpZWxkKGJ1ZmZlci5zbGljZSgxKSlcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gdGhpcy5fb25SZXF1ZXN0KGJ1ZmZlci5yZWFkVUludDMyQkUoMSksXG4gICAgICAgICAgYnVmZmVyLnJlYWRVSW50MzJCRSg1KSwgYnVmZmVyLnJlYWRVSW50MzJCRSg5KSlcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaWVjZShidWZmZXIucmVhZFVJbnQzMkJFKDEpLFxuICAgICAgICAgIGJ1ZmZlci5yZWFkVUludDMyQkUoNSksIGJ1ZmZlci5zbGljZSg5KSlcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gdGhpcy5fb25DYW5jZWwoYnVmZmVyLnJlYWRVSW50MzJCRSgxKSxcbiAgICAgICAgICBidWZmZXIucmVhZFVJbnQzMkJFKDUpLCBidWZmZXIucmVhZFVJbnQzMkJFKDkpKVxuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiB0aGlzLl9vblBvcnQoYnVmZmVyLnJlYWRVSW50MTZCRSgxKSlcbiAgICBjYXNlIDIwOlxuICAgICAgcmV0dXJuIHRoaXMuX29uRXh0ZW5kZWQoYnVmZmVyLnJlYWRVSW50OCgxKSwgYnVmZmVyLnNsaWNlKDIpKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHVua25vd24gbWVzc2FnZScpXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCd1bmtub3dubWVzc2FnZScsIGJ1ZmZlcilcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fcGFyc2VIYW5kc2hha2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9wYXJzZSgxLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgdmFyIHBzdHJsZW4gPSBidWZmZXIucmVhZFVJbnQ4KDApXG4gICAgc2VsZi5fcGFyc2UocHN0cmxlbiArIDQ4LCBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBoYW5kc2hha2Uuc2xpY2UoMCwgcHN0cmxlbilcbiAgICAgIGlmIChwcm90b2NvbC50b1N0cmluZygpICE9PSAnQml0VG9ycmVudCBwcm90b2NvbCcpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ0Vycm9yOiB3aXJlIG5vdCBzcGVha2luZyBCaXRUb3JyZW50IHByb3RvY29sICglcyknLCBwcm90b2NvbC50b1N0cmluZygpKVxuICAgICAgICBzZWxmLmVuZCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaGFuZHNoYWtlID0gaGFuZHNoYWtlLnNsaWNlKHBzdHJsZW4pXG4gICAgICBzZWxmLl9vbkhhbmRzaGFrZShoYW5kc2hha2Uuc2xpY2UoOCwgMjgpLCBoYW5kc2hha2Uuc2xpY2UoMjgsIDQ4KSwge1xuICAgICAgICBkaHQ6ICEhKGhhbmRzaGFrZVs3XSAmIDB4MDEpLCAvLyBzZWUgYmVwXzAwMDVcbiAgICAgICAgZXh0ZW5kZWQ6ICEhKGhhbmRzaGFrZVs1XSAmIDB4MTApIC8vIHNlZSBiZXBfMDAxMFxuICAgICAgfSlcbiAgICAgIHNlbGYuX3BhcnNlKDQsIHNlbGYuX29uTWVzc2FnZUxlbmd0aClcbiAgICB9KVxuICB9KVxufVxuXG5XaXJlLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZVxuXG4gIHRoaXMucHVzaChudWxsKSAvLyBzdHJlYW0gY2Fubm90IGJlIGhhbGYgb3Blbiwgc28gc2lnbmFsIHRoZSBlbmQgb2YgaXRcbiAgd2hpbGUgKHRoaXMucmVhZCgpKSB7fSAvLyBjb25zdW1lIGFuZCBkaXNjYXJkIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0gZGF0YVxuXG4gIGNsZWFySW50ZXJ2YWwodGhpcy5fa2VlcEFsaXZlSW50ZXJ2YWwpXG4gIHRoaXMuX3BhcnNlKE51bWJlci5NQVhfVkFMVUUsIGZ1bmN0aW9uICgpIHt9KVxuICB0aGlzLnBlZXJSZXF1ZXN0cyA9IFtdXG4gIHdoaWxlICh0aGlzLnJlcXVlc3RzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMucmVxdWVzdHMuc2hpZnQoKSwgbmV3IEVycm9yKCd3aXJlIHdhcyBjbG9zZWQnKSwgbnVsbClcbiAgfVxufVxuXG5XaXJlLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIGFyZ3NbMF0gPSAnWycgKyB0aGlzLl9kZWJ1Z0lkICsgJ10gJyArIGFyZ3NbMF1cbiAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbn1cblxuZnVuY3Rpb24gcHVsbCAocmVxdWVzdHMsIHBpZWNlLCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlcSA9IHJlcXVlc3RzW2ldXG4gICAgaWYgKHJlcS5waWVjZSAhPT0gcGllY2UgfHwgcmVxLm9mZnNldCAhPT0gb2Zmc2V0IHx8IHJlcS5sZW5ndGggIT09IGxlbmd0aCkgY29udGludWVcblxuICAgIGlmIChpID09PSAwKSByZXF1ZXN0cy5zaGlmdCgpXG4gICAgZWxzZSByZXF1ZXN0cy5zcGxpY2UoaSwgMSlcblxuICAgIHJldHVybiByZXFcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXR0b3JyZW50LXRyYWNrZXInKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgcGFyYWxsZWwgPSByZXF1aXJlKCdydW4tcGFyYWxsZWwnKVxudmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG52YXIgdW5pcSA9IHJlcXVpcmUoJ3VuaXEnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2xpYi9jb21tb24nKVxudmFyIEhUVFBUcmFja2VyID0gcmVxdWlyZSgnLi9saWIvY2xpZW50L2h0dHAtdHJhY2tlcicpIC8vIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG52YXIgVURQVHJhY2tlciA9IHJlcXVpcmUoJy4vbGliL2NsaWVudC91ZHAtdHJhY2tlcicpIC8vIGVtcHR5IG9iamVjdCBpbiBicm93c2VyXG52YXIgV2ViU29ja2V0VHJhY2tlciA9IHJlcXVpcmUoJy4vbGliL2NsaWVudC93ZWJzb2NrZXQtdHJhY2tlcicpXG5cbmluaGVyaXRzKENsaWVudCwgRXZlbnRFbWl0dGVyKVxuXG4vKipcbiAqIEJpdFRvcnJlbnQgdHJhY2tlciBjbGllbnQuXG4gKlxuICogRmluZCB0b3JyZW50IHBlZXJzLCB0byBoZWxwIGEgdG9ycmVudCBjbGllbnQgcGFydGljaXBhdGUgaW4gYSB0b3JyZW50IHN3YXJtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBvcHRzLmluZm9IYXNoICAgICAgICAgIHRvcnJlbnQgaW5mbyBoYXNoXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IG9wdHMucGVlcklkICAgICAgICAgICAgcGVlciBpZFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IG9wdHMuYW5ub3VuY2UgIGFubm91bmNlXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5wb3J0ICAgICAgICAgICAgICAgICAgICAgdG9ycmVudCBjbGllbnQgbGlzdGVuaW5nIHBvcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdHMuZ2V0QW5ub3VuY2VPcHRzICAgICAgICBjYWxsYmFjayB0byBwcm92aWRlIGRhdGEgdG8gdHJhY2tlclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucnRjQ29uZmlnICAgICAgICAgICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy53cnRjICAgICAgICAgICAgICAgICAgICAgY3VzdG9tIHdlYnJ0YyBpbXBsICh1c2VmdWwgaW4gbm9kZS5qcylcbiAqL1xuZnVuY3Rpb24gQ2xpZW50IChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgQ2xpZW50KSkgcmV0dXJuIG5ldyBDbGllbnQob3B0cylcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBpZiAoIW9wdHMucGVlcklkKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgcGVlcklkYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGluZm9IYXNoYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5hbm5vdW5jZSkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGFubm91bmNlYCBpcyByZXF1aXJlZCcpXG4gIGlmICghcHJvY2Vzcy5icm93c2VyICYmICFvcHRzLnBvcnQpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBwb3J0YCBpcyByZXF1aXJlZCcpXG5cbiAgLy8gcmVxdWlyZWRcbiAgc2VsZi5wZWVySWQgPSB0eXBlb2Ygb3B0cy5wZWVySWQgPT09ICdzdHJpbmcnXG4gICAgPyBvcHRzLnBlZXJJZFxuICAgIDogb3B0cy5wZWVySWQudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuX3BlZXJJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlbGYucGVlcklkLCAnaGV4JylcbiAgc2VsZi5fcGVlcklkQmluYXJ5ID0gc2VsZi5fcGVlcklkQnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKVxuXG4gIHNlbGYuaW5mb0hhc2ggPSB0eXBlb2Ygb3B0cy5pbmZvSGFzaCA9PT0gJ3N0cmluZydcbiAgICA/IG9wdHMuaW5mb0hhc2hcbiAgICA6IG9wdHMuaW5mb0hhc2gudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuX2luZm9IYXNoQnVmZmVyID0gQnVmZmVyLmZyb20oc2VsZi5pbmZvSGFzaCwgJ2hleCcpXG4gIHNlbGYuX2luZm9IYXNoQmluYXJ5ID0gc2VsZi5faW5mb0hhc2hCdWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpXG5cbiAgc2VsZi5fcG9ydCA9IG9wdHMucG9ydFxuXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2VcblxuICBzZWxmLl9ydGNDb25maWcgPSBvcHRzLnJ0Y0NvbmZpZ1xuICBzZWxmLl93cnRjID0gb3B0cy53cnRjXG4gIHNlbGYuX2dldEFubm91bmNlT3B0cyA9IG9wdHMuZ2V0QW5ub3VuY2VPcHRzXG5cbiAgZGVidWcoJ25ldyBjbGllbnQgJXMnLCBzZWxmLmluZm9IYXNoKVxuXG4gIHZhciB3ZWJydGNTdXBwb3J0ID0gc2VsZi5fd3J0YyAhPT0gZmFsc2UgJiYgKCEhc2VsZi5fd3J0YyB8fCBQZWVyLldFQlJUQ19TVVBQT1JUKVxuXG4gIHZhciBhbm5vdW5jZSA9ICh0eXBlb2Ygb3B0cy5hbm5vdW5jZSA9PT0gJ3N0cmluZycpXG4gICAgPyBbIG9wdHMuYW5ub3VuY2UgXVxuICAgIDogb3B0cy5hbm5vdW5jZSA9PSBudWxsXG4gICAgICA/IFtdXG4gICAgICA6IG9wdHMuYW5ub3VuY2VcblxuICBhbm5vdW5jZSA9IGFubm91bmNlLm1hcChmdW5jdGlvbiAoYW5ub3VuY2VVcmwpIHtcbiAgICBhbm5vdW5jZVVybCA9IGFubm91bmNlVXJsLnRvU3RyaW5nKClcbiAgICBpZiAoYW5ub3VuY2VVcmxbYW5ub3VuY2VVcmwubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGZyb20gdHJhY2tlcnMgdG8gY2F0Y2ggZHVwbGljYXRlc1xuICAgICAgYW5ub3VuY2VVcmwgPSBhbm5vdW5jZVVybC5zdWJzdHJpbmcoMCwgYW5ub3VuY2VVcmwubGVuZ3RoIC0gMSlcbiAgICB9XG4gICAgcmV0dXJuIGFubm91bmNlVXJsXG4gIH0pXG5cbiAgYW5ub3VuY2UgPSB1bmlxKGFubm91bmNlKVxuXG4gIHNlbGYuX3RyYWNrZXJzID0gYW5ub3VuY2VcbiAgICAubWFwKGZ1bmN0aW9uIChhbm5vdW5jZVVybCkge1xuICAgICAgdmFyIHByb3RvY29sID0gdXJsLnBhcnNlKGFubm91bmNlVXJsKS5wcm90b2NvbFxuICAgICAgaWYgKChwcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOicpICYmXG4gICAgICAgICAgdHlwZW9mIEhUVFBUcmFja2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSFRUUFRyYWNrZXIoc2VsZiwgYW5ub3VuY2VVcmwpXG4gICAgICB9IGVsc2UgaWYgKHByb3RvY29sID09PSAndWRwOicgJiYgdHlwZW9mIFVEUFRyYWNrZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVRFBUcmFja2VyKHNlbGYsIGFubm91bmNlVXJsKVxuICAgICAgfSBlbHNlIGlmICgocHJvdG9jb2wgPT09ICd3czonIHx8IHByb3RvY29sID09PSAnd3NzOicpICYmIHdlYnJ0Y1N1cHBvcnQpIHtcbiAgICAgICAgLy8gU2tpcCB3czovLyB0cmFja2VycyBvbiBodHRwczovLyBzaXRlcyBiZWNhdXNlIHRoZXkgdGhyb3cgU2VjdXJpdHlFcnJvclxuICAgICAgICBpZiAocHJvdG9jb2wgPT09ICd3czonICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgbmV4dFRpY2tXYXJuKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHJhY2tlciBwcm90b2NvbDogJyArIGFubm91bmNlVXJsKSlcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0VHJhY2tlcihzZWxmLCBhbm5vdW5jZVVybClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRUaWNrV2FybihuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRyYWNrZXIgcHJvdG9jb2w6ICcgKyBhbm5vdW5jZVVybCkpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tXYXJuIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnd2FybmluZycsIGVycilcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNjcmFwZSBhIHRyYWNrZXIgZm9yIGFuIGluZm8gaGFzaCB3aXRob3V0IG5lZWRpbmcgdG9cbiAqIGNyZWF0ZSBhIENsaWVudCwgcGFzcyBpdCBhIHBhcnNlZCB0b3JyZW50LCBldGMuIFN1cHBvcnQgc2NyYXBpbmcgYSB0cmFja2VyIGZvciBtdWx0aXBsZVxuICogdG9ycmVudHMgYXQgdGhlIHNhbWUgdGltZS5cbiAqIEBwYXJhbXMge09iamVjdH0gb3B0c1xuICogQHBhcmFtICB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBvcHRzLmluZm9IYXNoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG9wdHMuYW5ub3VuY2VcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5DbGllbnQuc2NyYXBlID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGNiID0gb25jZShjYilcblxuICBpZiAoIW9wdHMuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBpbmZvSGFzaGAgaXMgcmVxdWlyZWQnKVxuICBpZiAoIW9wdHMuYW5ub3VuY2UpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBhbm5vdW5jZWAgaXMgcmVxdWlyZWQnKVxuXG4gIHZhciBjbGllbnRPcHRzID0gZXh0ZW5kKG9wdHMsIHtcbiAgICBpbmZvSGFzaDogQXJyYXkuaXNBcnJheShvcHRzLmluZm9IYXNoKSA/IG9wdHMuaW5mb0hhc2hbMF0gOiBvcHRzLmluZm9IYXNoLFxuICAgIHBlZXJJZDogQnVmZmVyLmZyb20oJzAxMjM0NTY3ODkwMTIzNDU2Nzg5JyksIC8vIGR1bW15IHZhbHVlXG4gICAgcG9ydDogNjg4MSAvLyBkdW1teSB2YWx1ZVxuICB9KVxuXG4gIHZhciBjbGllbnQgPSBuZXcgQ2xpZW50KGNsaWVudE9wdHMpXG4gIGNsaWVudC5vbmNlKCdlcnJvcicsIGNiKVxuXG4gIHZhciBsZW4gPSBBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpID8gb3B0cy5pbmZvSGFzaC5sZW5ndGggOiAxXG4gIHZhciByZXN1bHRzID0ge31cbiAgY2xpZW50Lm9uKCdzY3JhcGUnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGxlbiAtPSAxXG4gICAgcmVzdWx0c1tkYXRhLmluZm9IYXNoXSA9IGRhdGFcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBjbGllbnQuZGVzdHJveSgpXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlc3VsdHMpXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2IobnVsbCwgcmVzdWx0c1trZXlzWzBdXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwsIHJlc3VsdHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIG9wdHMuaW5mb0hhc2ggPSBBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpXG4gICAgPyBvcHRzLmluZm9IYXNoLm1hcChmdW5jdGlvbiAoaW5mb0hhc2gpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbmZvSGFzaCwgJ2hleCcpXG4gICAgfSlcbiAgICA6IEJ1ZmZlci5mcm9tKG9wdHMuaW5mb0hhc2gsICdoZXgnKVxuICBjbGllbnQuc2NyYXBlKHsgaW5mb0hhc2g6IG9wdHMuaW5mb0hhc2ggfSlcbiAgcmV0dXJuIGNsaWVudFxufVxuXG4vKipcbiAqIFNlbmQgYSBgc3RhcnRgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdzZW5kIGBzdGFydGAnKVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBvcHRzLmV2ZW50ID0gJ3N0YXJ0ZWQnXG4gIHNlbGYuX2Fubm91bmNlKG9wdHMpXG5cbiAgLy8gc3RhcnQgYW5ub3VuY2luZyBvbiBpbnRlcnZhbHNcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHRyYWNrZXIuc2V0SW50ZXJ2YWwoKVxuICB9KVxufVxuXG4vKipcbiAqIFNlbmQgYSBgc3RvcGAgYW5ub3VuY2UgdG8gdGhlIHRyYWNrZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy51cGxvYWRlZFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmRvd25sb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5udW13YW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubGVmdCAoaWYgbm90IHNldCwgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5KVxuICovXG5DbGllbnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NlbmQgYHN0b3BgJylcbiAgb3B0cyA9IHNlbGYuX2RlZmF1bHRBbm5vdW5jZU9wdHMob3B0cylcbiAgb3B0cy5ldmVudCA9ICdzdG9wcGVkJ1xuICBzZWxmLl9hbm5vdW5jZShvcHRzKVxufVxuXG4vKipcbiAqIFNlbmQgYSBgY29tcGxldGVgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubnVtd2FudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmxlZnQgKGlmIG5vdCBzZXQsIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSlcbiAqL1xuQ2xpZW50LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgY29tcGxldGVgJylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cyA9IHNlbGYuX2RlZmF1bHRBbm5vdW5jZU9wdHMob3B0cylcbiAgb3B0cy5ldmVudCA9ICdjb21wbGV0ZWQnXG4gIHNlbGYuX2Fubm91bmNlKG9wdHMpXG59XG5cbi8qKlxuICogU2VuZCBhIGB1cGRhdGVgIGFubm91bmNlIHRvIHRoZSB0cmFja2Vycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMudXBsb2FkZWRcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0cy5kb3dubG9hZGVkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdHMubnVtd2FudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRzLmxlZnQgKGlmIG5vdCBzZXQsIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSlcbiAqL1xuQ2xpZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NlbmQgYHVwZGF0ZWAnKVxuICBvcHRzID0gc2VsZi5fZGVmYXVsdEFubm91bmNlT3B0cyhvcHRzKVxuICBpZiAob3B0cy5ldmVudCkgZGVsZXRlIG9wdHMuZXZlbnRcbiAgc2VsZi5fYW5ub3VuY2Uob3B0cylcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5fYW5ub3VuY2UgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIC8vIHRyYWNrZXIgc2hvdWxkIG5vdCBtb2RpZnkgYG9wdHNgIG9iamVjdCwgaXQncyBwYXNzZWQgdG8gYWxsIHRyYWNrZXJzXG4gICAgdHJhY2tlci5hbm5vdW5jZShvcHRzKVxuICB9KVxufVxuXG4vKipcbiAqIFNlbmQgYSBzY3JhcGUgcmVxdWVzdCB0byB0aGUgdHJhY2tlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5DbGllbnQucHJvdG90eXBlLnNjcmFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnc2VuZCBgc2NyYXBlYCcpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHNlbGYuX3RyYWNrZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrZXIpIHtcbiAgICAvLyB0cmFja2VyIHNob3VsZCBub3QgbW9kaWZ5IGBvcHRzYCBvYmplY3QsIGl0J3MgcGFzc2VkIHRvIGFsbCB0cmFja2Vyc1xuICAgIHRyYWNrZXIuc2NyYXBlKG9wdHMpXG4gIH0pXG59XG5cbkNsaWVudC5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWxNcykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGVidWcoJ3NldEludGVydmFsICVkJywgaW50ZXJ2YWxNcylcbiAgc2VsZi5fdHJhY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHRyYWNrZXIuc2V0SW50ZXJ2YWwoaW50ZXJ2YWxNcylcbiAgfSlcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgZGVidWcoJ2Rlc3Ryb3knKVxuXG4gIHZhciB0YXNrcyA9IHNlbGYuX3RyYWNrZXJzLm1hcChmdW5jdGlvbiAodHJhY2tlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHRyYWNrZXIuZGVzdHJveShjYilcbiAgICB9XG4gIH0pXG5cbiAgcGFyYWxsZWwodGFza3MsIGNiKVxuXG4gIHNlbGYuX3RyYWNrZXJzID0gW11cbiAgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzID0gbnVsbFxufVxuXG5DbGllbnQucHJvdG90eXBlLl9kZWZhdWx0QW5ub3VuY2VPcHRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgaWYgKG9wdHMubnVtd2FudCA9PSBudWxsKSBvcHRzLm51bXdhbnQgPSBjb21tb24uREVGQVVMVF9BTk5PVU5DRV9QRUVSU1xuXG4gIGlmIChvcHRzLnVwbG9hZGVkID09IG51bGwpIG9wdHMudXBsb2FkZWQgPSAwXG4gIGlmIChvcHRzLmRvd25sb2FkZWQgPT0gbnVsbCkgb3B0cy5kb3dubG9hZGVkID0gMFxuXG4gIGlmIChzZWxmLl9nZXRBbm5vdW5jZU9wdHMpIG9wdHMgPSBleHRlbmQob3B0cywgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzKCkpXG4gIHJldHVybiBvcHRzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFRyYWNrZXJcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5pbmhlcml0cyhUcmFja2VyLCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIFRyYWNrZXIgKGNsaWVudCwgYW5ub3VuY2VVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG4gIHNlbGYuY2xpZW50ID0gY2xpZW50XG4gIHNlbGYuYW5ub3VuY2VVcmwgPSBhbm5vdW5jZVVybFxuXG4gIHNlbGYuaW50ZXJ2YWwgPSBudWxsXG4gIHNlbGYuZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuVHJhY2tlci5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWxNcykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKGludGVydmFsTXMgPT0gbnVsbCkgaW50ZXJ2YWxNcyA9IHNlbGYuREVGQVVMVF9BTk5PVU5DRV9JTlRFUlZBTFxuXG4gIGNsZWFySW50ZXJ2YWwoc2VsZi5pbnRlcnZhbClcblxuICBpZiAoaW50ZXJ2YWxNcykge1xuICAgIHNlbGYuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmFubm91bmNlKHNlbGYuY2xpZW50Ll9kZWZhdWx0QW5ub3VuY2VPcHRzKCkpXG4gICAgfSwgaW50ZXJ2YWxNcylcbiAgICBpZiAoc2VsZi5pbnRlcnZhbC51bnJlZikgc2VsZi5pbnRlcnZhbC51bnJlZigpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhY2tlclxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXR0b3JyZW50LXRyYWNrZXI6d2Vic29ja2V0LXRyYWNrZXInKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBoYXQgPSByZXF1aXJlKCdoYXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG52YXIgU29ja2V0ID0gcmVxdWlyZSgnc2ltcGxlLXdlYnNvY2tldCcpXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKVxudmFyIFRyYWNrZXIgPSByZXF1aXJlKCcuL3RyYWNrZXInKVxuXG4vLyBVc2UgYSBzb2NrZXQgcG9vbCwgc28gdHJhY2tlciBjbGllbnRzIHNoYXJlIFdlYlNvY2tldCBvYmplY3RzIGZvciB0aGUgc2FtZSBzZXJ2ZXIuXG4vLyBJbiBwcmFjdGljZSwgV2ViU29ja2V0cyBhcmUgcHJldHR5IHNsb3cgdG8gZXN0YWJsaXNoLCBzbyB0aGlzIGdpdmVzIGEgbmljZSBwZXJmb3JtYW5jZVxuLy8gYm9vc3QsIGFuZCBzYXZlcyBicm93c2VyIHJlc291cmNlcy5cbnZhciBzb2NrZXRQb29sID0ge31cblxudmFyIFJFQ09OTkVDVF9NSU5JTVVNID0gMTUgKiAxMDAwXG52YXIgUkVDT05ORUNUX01BWElNVU0gPSAzMCAqIDYwICogMTAwMFxudmFyIFJFQ09OTkVDVF9WQVJJQU5DRSA9IDMwICogMTAwMFxudmFyIE9GRkVSX1RJTUVPVVQgPSA1MCAqIDEwMDBcblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhY2tlciwgVHJhY2tlcilcblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhY2tlciAoY2xpZW50LCBhbm5vdW5jZVVybCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgVHJhY2tlci5jYWxsKHNlbGYsIGNsaWVudCwgYW5ub3VuY2VVcmwpXG4gIGRlYnVnKCduZXcgd2Vic29ja2V0IHRyYWNrZXIgJXMnLCBhbm5vdW5jZVVybClcblxuICBzZWxmLnBlZXJzID0ge30gLy8gcGVlcnMgKG9mZmVyIGlkIC0+IHBlZXIpXG4gIHNlbGYuc29ja2V0ID0gbnVsbFxuXG4gIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2VcbiAgc2VsZi5yZXRyaWVzID0gMFxuICBzZWxmLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuXG4gIHNlbGYuX29wZW5Tb2NrZXQoKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5ERUZBVUxUX0FOTk9VTkNFX0lOVEVSVkFMID0gMzAgKiAxMDAwIC8vIDMwIHNlY29uZHNcblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuYW5ub3VuY2UgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkIHx8IHNlbGYucmVjb25uZWN0aW5nKSByZXR1cm5cbiAgaWYgKCFzZWxmLnNvY2tldC5jb25uZWN0ZWQpIHtcbiAgICBzZWxmLnNvY2tldC5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5hbm5vdW5jZShvcHRzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcGFyYW1zID0gZXh0ZW5kKG9wdHMsIHtcbiAgICBhY3Rpb246ICdhbm5vdW5jZScsXG4gICAgaW5mb19oYXNoOiBzZWxmLmNsaWVudC5faW5mb0hhc2hCaW5hcnksXG4gICAgcGVlcl9pZDogc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeVxuICB9KVxuICBpZiAoc2VsZi5fdHJhY2tlcklkKSBwYXJhbXMudHJhY2tlcmlkID0gc2VsZi5fdHJhY2tlcklkXG5cbiAgaWYgKG9wdHMuZXZlbnQgPT09ICdzdG9wcGVkJykge1xuICAgIC8vIERvbid0IGluY2x1ZGUgb2ZmZXJzIHdpdGggJ3N0b3BwZWQnIGV2ZW50XG4gICAgc2VsZi5fc2VuZChwYXJhbXMpXG4gIH0gZWxzZSB7XG4gICAgLy8gTGltaXQgdGhlIG51bWJlciBvZiBvZmZlcnMgdGhhdCBhcmUgZ2VuZXJhdGVkLCBzaW5jZSBpdCBjYW4gYmUgc2xvd1xuICAgIHZhciBudW13YW50ID0gTWF0aC5taW4ob3B0cy5udW13YW50LCA1KVxuXG4gICAgc2VsZi5fZ2VuZXJhdGVPZmZlcnMobnVtd2FudCwgZnVuY3Rpb24gKG9mZmVycykge1xuICAgICAgcGFyYW1zLm51bXdhbnQgPSBudW13YW50XG4gICAgICBwYXJhbXMub2ZmZXJzID0gb2ZmZXJzXG4gICAgICBzZWxmLl9zZW5kKHBhcmFtcylcbiAgICB9KVxuICB9XG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLnNjcmFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQgfHwgc2VsZi5yZWNvbm5lY3RpbmcpIHJldHVyblxuICBpZiAoIXNlbGYuc29ja2V0LmNvbm5lY3RlZCkge1xuICAgIHNlbGYuc29ja2V0Lm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNjcmFwZShvcHRzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgaW5mb0hhc2hlcyA9IChBcnJheS5pc0FycmF5KG9wdHMuaW5mb0hhc2gpICYmIG9wdHMuaW5mb0hhc2gubGVuZ3RoID4gMClcbiAgICA/IG9wdHMuaW5mb0hhc2gubWFwKGZ1bmN0aW9uIChpbmZvSGFzaCkge1xuICAgICAgcmV0dXJuIGluZm9IYXNoLnRvU3RyaW5nKCdiaW5hcnknKVxuICAgIH0pXG4gICAgOiAob3B0cy5pbmZvSGFzaCAmJiBvcHRzLmluZm9IYXNoLnRvU3RyaW5nKCdiaW5hcnknKSkgfHwgc2VsZi5jbGllbnQuX2luZm9IYXNoQmluYXJ5XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgYWN0aW9uOiAnc2NyYXBlJyxcbiAgICBpbmZvX2hhc2g6IGluZm9IYXNoZXNcbiAgfVxuXG4gIHNlbGYuX3NlbmQocGFyYW1zKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gY2IobnVsbClcblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuICBjbGVhckludGVydmFsKHNlbGYuaW50ZXJ2YWwpXG4gIGNsZWFyVGltZW91dChzZWxmLnJlY29ubmVjdFRpbWVyKVxuXG4gIGlmIChzZWxmLnNvY2tldCkge1xuICAgIHNlbGYuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0Jywgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQpXG4gICAgc2VsZi5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzZWxmLl9vblNvY2tldERhdGFCb3VuZClcbiAgICBzZWxmLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzZWxmLl9vblNvY2tldENsb3NlQm91bmQpXG4gICAgc2VsZi5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25Tb2NrZXRFcnJvckJvdW5kKVxuICB9XG5cbiAgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQgPSBudWxsXG4gIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZCA9IG51bGxcbiAgc2VsZi5fb25Tb2NrZXREYXRhQm91bmQgPSBudWxsXG4gIHNlbGYuX29uU29ja2V0Q2xvc2VCb3VuZCA9IG51bGxcblxuICAvLyBEZXN0cm95IHBlZXJzXG4gIGZvciAodmFyIHBlZXJJZCBpbiBzZWxmLnBlZXJzKSB7XG4gICAgdmFyIHBlZXIgPSBzZWxmLnBlZXJzW3BlZXJJZF1cbiAgICBjbGVhclRpbWVvdXQocGVlci50cmFja2VyVGltZW91dClcbiAgICBwZWVyLmRlc3Ryb3koKVxuICB9XG4gIHNlbGYucGVlcnMgPSBudWxsXG5cbiAgaWYgKHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0pIHtcbiAgICBzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdLmNvbnN1bWVycyAtPSAxXG4gIH1cblxuICBpZiAoc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXS5jb25zdW1lcnMgPT09IDApIHtcbiAgICBkZWxldGUgc29ja2V0UG9vbFtzZWxmLmFubm91bmNlVXJsXVxuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuc29ja2V0Lm9uKCdlcnJvcicsIG5vb3ApIC8vIGlnbm9yZSBhbGwgZnV0dXJlIGVycm9yc1xuICAgICAgc2VsZi5zb2NrZXQuZGVzdHJveShjYilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBzZWxmLnNvY2tldCA9IG51bGxcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29wZW5Tb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgaWYgKCFzZWxmLnBlZXJzKSBzZWxmLnBlZXJzID0ge31cblxuICBzZWxmLl9vblNvY2tldENvbm5lY3RCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblNvY2tldENvbm5lY3QoKVxuICB9XG4gIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLl9vblNvY2tldEVycm9yKGVycilcbiAgfVxuICBzZWxmLl9vblNvY2tldERhdGFCb3VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5fb25Tb2NrZXREYXRhKGRhdGEpXG4gIH1cbiAgc2VsZi5fb25Tb2NrZXRDbG9zZUJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uU29ja2V0Q2xvc2UoKVxuICB9XG5cbiAgc2VsZi5zb2NrZXQgPSBzb2NrZXRQb29sW3NlbGYuYW5ub3VuY2VVcmxdXG4gIGlmIChzZWxmLnNvY2tldCkge1xuICAgIHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0uY29uc3VtZXJzICs9IDFcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNvY2tldCA9IHNvY2tldFBvb2xbc2VsZi5hbm5vdW5jZVVybF0gPSBuZXcgU29ja2V0KHNlbGYuYW5ub3VuY2VVcmwpXG4gICAgc2VsZi5zb2NrZXQuY29uc3VtZXJzID0gMVxuICAgIHNlbGYuc29ja2V0Lm9uKCdjb25uZWN0Jywgc2VsZi5fb25Tb2NrZXRDb25uZWN0Qm91bmQpXG4gIH1cblxuICBzZWxmLnNvY2tldC5vbignZGF0YScsIHNlbGYuX29uU29ja2V0RGF0YUJvdW5kKVxuICBzZWxmLnNvY2tldC5vbignY2xvc2UnLCBzZWxmLl9vblNvY2tldENsb3NlQm91bmQpXG4gIHNlbGYuc29ja2V0Lm9uKCdlcnJvcicsIHNlbGYuX29uU29ja2V0RXJyb3JCb3VuZClcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0Q29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgaWYgKHNlbGYucmVjb25uZWN0aW5nKSB7XG4gICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHNlbGYucmV0cmllcyA9IDBcbiAgICBzZWxmLmFubm91bmNlKHNlbGYuY2xpZW50Ll9kZWZhdWx0QW5ub3VuY2VPcHRzKCkpXG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHRyeSB7XG4gICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignSW52YWxpZCB0cmFja2VyIHJlc3BvbnNlJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZGF0YS5hY3Rpb24gPT09ICdhbm5vdW5jZScpIHtcbiAgICBzZWxmLl9vbkFubm91bmNlUmVzcG9uc2UoZGF0YSlcbiAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiA9PT0gJ3NjcmFwZScpIHtcbiAgICBzZWxmLl9vblNjcmFwZVJlc3BvbnNlKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fb25Tb2NrZXRFcnJvcihuZXcgRXJyb3IoJ2ludmFsaWQgYWN0aW9uIGluIFdTIHJlc3BvbnNlOiAnICsgZGF0YS5hY3Rpb24pKVxuICB9XG59XG5cbldlYlNvY2tldFRyYWNrZXIucHJvdG90eXBlLl9vbkFubm91bmNlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoZGF0YS5pbmZvX2hhc2ggIT09IHNlbGYuY2xpZW50Ll9pbmZvSGFzaEJpbmFyeSkge1xuICAgIGRlYnVnKFxuICAgICAgJ2lnbm9yaW5nIHdlYnNvY2tldCBkYXRhIGZyb20gJXMgZm9yICVzIChsb29raW5nIGZvciAlczogcmV1c2VkIHNvY2tldCknLFxuICAgICAgc2VsZi5hbm5vdW5jZVVybCwgY29tbW9uLmJpbmFyeVRvSGV4KGRhdGEuaW5mb19oYXNoKSwgc2VsZi5jbGllbnQuaW5mb0hhc2hcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZGF0YS5wZWVyX2lkICYmIGRhdGEucGVlcl9pZCA9PT0gc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeSkge1xuICAgIC8vIGlnbm9yZSBvZmZlcnMvYW5zd2VycyBmcm9tIHRoaXMgY2xpZW50XG4gICAgcmV0dXJuXG4gIH1cblxuICBkZWJ1ZyhcbiAgICAncmVjZWl2ZWQgJXMgZnJvbSAlcyBmb3IgJXMnLFxuICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpLCBzZWxmLmFubm91bmNlVXJsLCBzZWxmLmNsaWVudC5pbmZvSGFzaFxuICApXG5cbiAgdmFyIGZhaWx1cmUgPSBkYXRhWydmYWlsdXJlIHJlYXNvbiddXG4gIGlmIChmYWlsdXJlKSByZXR1cm4gc2VsZi5jbGllbnQuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcihmYWlsdXJlKSlcblxuICB2YXIgd2FybmluZyA9IGRhdGFbJ3dhcm5pbmcgbWVzc2FnZSddXG4gIGlmICh3YXJuaW5nKSBzZWxmLmNsaWVudC5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKHdhcm5pbmcpKVxuXG4gIHZhciBpbnRlcnZhbCA9IGRhdGEuaW50ZXJ2YWwgfHwgZGF0YVsnbWluIGludGVydmFsJ11cbiAgaWYgKGludGVydmFsKSBzZWxmLnNldEludGVydmFsKGludGVydmFsICogMTAwMClcblxuICB2YXIgdHJhY2tlcklkID0gZGF0YVsndHJhY2tlciBpZCddXG4gIGlmICh0cmFja2VySWQpIHtcbiAgICAvLyBJZiBhYnNlbnQsIGRvIG5vdCBkaXNjYXJkIHByZXZpb3VzIHRyYWNrZXJJZCB2YWx1ZVxuICAgIHNlbGYuX3RyYWNrZXJJZCA9IHRyYWNrZXJJZFxuICB9XG5cbiAgaWYgKGRhdGEuY29tcGxldGUgIT0gbnVsbCkge1xuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgIGFubm91bmNlOiBzZWxmLmFubm91bmNlVXJsLFxuICAgICAgY29tcGxldGU6IGRhdGEuY29tcGxldGUsXG4gICAgICBpbmNvbXBsZXRlOiBkYXRhLmluY29tcGxldGVcbiAgICB9KVxuICB9XG5cbiAgdmFyIHBlZXJcbiAgaWYgKGRhdGEub2ZmZXIgJiYgZGF0YS5wZWVyX2lkKSB7XG4gICAgZGVidWcoJ2NyZWF0aW5nIHBlZXIgKGZyb20gcmVtb3RlIG9mZmVyKScpXG4gICAgcGVlciA9IG5ldyBQZWVyKHtcbiAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgY29uZmlnOiBzZWxmLmNsaWVudC5fcnRjQ29uZmlnLFxuICAgICAgd3J0Yzogc2VsZi5jbGllbnQuX3dydGNcbiAgICB9KVxuICAgIHBlZXIuaWQgPSBjb21tb24uYmluYXJ5VG9IZXgoZGF0YS5wZWVyX2lkKVxuICAgIHBlZXIub25jZSgnc2lnbmFsJywgZnVuY3Rpb24gKGFuc3dlcikge1xuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgYWN0aW9uOiAnYW5ub3VuY2UnLFxuICAgICAgICBpbmZvX2hhc2g6IHNlbGYuY2xpZW50Ll9pbmZvSGFzaEJpbmFyeSxcbiAgICAgICAgcGVlcl9pZDogc2VsZi5jbGllbnQuX3BlZXJJZEJpbmFyeSxcbiAgICAgICAgdG9fcGVlcl9pZDogZGF0YS5wZWVyX2lkLFxuICAgICAgICBhbnN3ZXI6IGFuc3dlcixcbiAgICAgICAgb2ZmZXJfaWQ6IGRhdGEub2ZmZXJfaWRcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLl90cmFja2VySWQpIHBhcmFtcy50cmFja2VyaWQgPSBzZWxmLl90cmFja2VySWRcbiAgICAgIHNlbGYuX3NlbmQocGFyYW1zKVxuICAgIH0pXG4gICAgcGVlci5zaWduYWwoZGF0YS5vZmZlcilcbiAgICBzZWxmLmNsaWVudC5lbWl0KCdwZWVyJywgcGVlcilcbiAgfVxuXG4gIGlmIChkYXRhLmFuc3dlciAmJiBkYXRhLnBlZXJfaWQpIHtcbiAgICB2YXIgb2ZmZXJJZCA9IGNvbW1vbi5iaW5hcnlUb0hleChkYXRhLm9mZmVyX2lkKVxuICAgIHBlZXIgPSBzZWxmLnBlZXJzW29mZmVySWRdXG4gICAgaWYgKHBlZXIpIHtcbiAgICAgIHBlZXIuaWQgPSBjb21tb24uYmluYXJ5VG9IZXgoZGF0YS5wZWVyX2lkKVxuICAgICAgcGVlci5zaWduYWwoZGF0YS5hbnN3ZXIpXG4gICAgICBzZWxmLmNsaWVudC5lbWl0KCdwZWVyJywgcGVlcilcblxuICAgICAgY2xlYXJUaW1lb3V0KHBlZXIudHJhY2tlclRpbWVvdXQpXG4gICAgICBwZWVyLnRyYWNrZXJUaW1lb3V0ID0gbnVsbFxuICAgICAgZGVsZXRlIHNlbGYucGVlcnNbb2ZmZXJJZF1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2dvdCB1bmV4cGVjdGVkIGFuc3dlcjogJyArIEpTT04uc3RyaW5naWZ5KGRhdGEuYW5zd2VyKSlcbiAgICB9XG4gIH1cbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU2NyYXBlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgZGF0YSA9IGRhdGEuZmlsZXMgfHwge31cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHNlbGYuY2xpZW50LmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ2ludmFsaWQgc2NyYXBlIHJlc3BvbnNlJykpXG4gICAgcmV0dXJuXG4gIH1cblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGluZm9IYXNoKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gZGF0YVtpbmZvSGFzaF1cbiAgICAvLyBUT0RPOiBvcHRpb25hbGx5IGhhbmRsZSBkYXRhLmZsYWdzLm1pbl9yZXF1ZXN0X2ludGVydmFsXG4gICAgLy8gKHNlcGFyYXRlIGZyb20gYW5ub3VuY2UgaW50ZXJ2YWwpXG4gICAgc2VsZi5jbGllbnQuZW1pdCgnc2NyYXBlJywge1xuICAgICAgYW5ub3VuY2U6IHNlbGYuYW5ub3VuY2VVcmwsXG4gICAgICBpbmZvSGFzaDogY29tbW9uLmJpbmFyeVRvSGV4KGluZm9IYXNoKSxcbiAgICAgIGNvbXBsZXRlOiByZXNwb25zZS5jb21wbGV0ZSxcbiAgICAgIGluY29tcGxldGU6IHJlc3BvbnNlLmluY29tcGxldGUsXG4gICAgICBkb3dubG9hZGVkOiByZXNwb25zZS5kb3dubG9hZGVkXG4gICAgfSlcbiAgfSlcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3koKVxuICBzZWxmLl9zdGFydFJlY29ubmVjdFRpbWVyKClcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX29uU29ja2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3koKVxuICAvLyBlcnJvcnMgd2lsbCBvZnRlbiBoYXBwZW4gaWYgYSB0cmFja2VyIGlzIG9mZmxpbmUsIHNvIGRvbid0IHRyZWF0IGl0IGFzIGZhdGFsXG4gIHNlbGYuY2xpZW50LmVtaXQoJ3dhcm5pbmcnLCBlcnIpXG4gIHNlbGYuX3N0YXJ0UmVjb25uZWN0VGltZXIoKVxufVxuXG5XZWJTb2NrZXRUcmFja2VyLnByb3RvdHlwZS5fc3RhcnRSZWNvbm5lY3RUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBtcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFJFQ09OTkVDVF9WQVJJQU5DRSkgKyBNYXRoLm1pbihNYXRoLnBvdygyLCBzZWxmLnJldHJpZXMpICogUkVDT05ORUNUX01JTklNVU0sIFJFQ09OTkVDVF9NQVhJTVVNKVxuXG4gIHNlbGYucmVjb25uZWN0aW5nID0gdHJ1ZVxuICBjbGVhclRpbWVvdXQoc2VsZi5yZWNvbm5lY3RUaW1lcilcbiAgc2VsZi5yZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmV0cmllcysrXG4gICAgc2VsZi5fb3BlblNvY2tldCgpXG4gIH0sIG1zKVxuICBpZiAoc2VsZi5yZWNvbm5lY3RUaW1lci51bnJlZikgc2VsZi5yZWNvbm5lY3RUaW1lci51bnJlZigpXG5cbiAgZGVidWcoJ3JlY29ubmVjdGluZyBzb2NrZXQgaW4gJXMgbXMnLCBtcylcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHZhciBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKVxuICBkZWJ1Zygnc2VuZCAlcycsIG1lc3NhZ2UpXG4gIHNlbGYuc29ja2V0LnNlbmQobWVzc2FnZSlcbn1cblxuV2ViU29ja2V0VHJhY2tlci5wcm90b3R5cGUuX2dlbmVyYXRlT2ZmZXJzID0gZnVuY3Rpb24gKG51bXdhbnQsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgb2ZmZXJzID0gW11cbiAgZGVidWcoJ2dlbmVyYXRpbmcgJXMgb2ZmZXJzJywgbnVtd2FudClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bXdhbnQ7ICsraSkge1xuICAgIGdlbmVyYXRlT2ZmZXIoKVxuICB9XG4gIGNoZWNrRG9uZSgpXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVPZmZlciAoKSB7XG4gICAgdmFyIG9mZmVySWQgPSBoYXQoMTYwKVxuICAgIGRlYnVnKCdjcmVhdGluZyBwZWVyIChmcm9tIF9nZW5lcmF0ZU9mZmVycyknKVxuICAgIHZhciBwZWVyID0gc2VsZi5wZWVyc1tvZmZlcklkXSA9IG5ldyBQZWVyKHtcbiAgICAgIGluaXRpYXRvcjogdHJ1ZSxcbiAgICAgIHRyaWNrbGU6IGZhbHNlLFxuICAgICAgY29uZmlnOiBzZWxmLmNsaWVudC5fcnRjQ29uZmlnLFxuICAgICAgd3J0Yzogc2VsZi5jbGllbnQuX3dydGNcbiAgICB9KVxuICAgIHBlZXIub25jZSgnc2lnbmFsJywgZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgICBvZmZlcnMucHVzaCh7XG4gICAgICAgIG9mZmVyOiBvZmZlcixcbiAgICAgICAgb2ZmZXJfaWQ6IGNvbW1vbi5oZXhUb0JpbmFyeShvZmZlcklkKVxuICAgICAgfSlcbiAgICAgIGNoZWNrRG9uZSgpXG4gICAgfSlcbiAgICBwZWVyLnRyYWNrZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZygndHJhY2tlciB0aW1lb3V0OiBkZXN0cm95aW5nIHBlZXInKVxuICAgICAgcGVlci50cmFja2VyVGltZW91dCA9IG51bGxcbiAgICAgIGRlbGV0ZSBzZWxmLnBlZXJzW29mZmVySWRdXG4gICAgICBwZWVyLmRlc3Ryb3koKVxuICAgIH0sIE9GRkVSX1RJTUVPVVQpXG4gICAgaWYgKHBlZXIudHJhY2tlclRpbWVvdXQudW5yZWYpIHBlZXIudHJhY2tlclRpbWVvdXQudW5yZWYoKVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEb25lICgpIHtcbiAgICBpZiAob2ZmZXJzLmxlbmd0aCA9PT0gbnVtd2FudCkge1xuICAgICAgZGVidWcoJ2dlbmVyYXRlZCAlcyBvZmZlcnMnLCBudW13YW50KVxuICAgICAgY2Iob2ZmZXJzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCIvKipcbiAqIEZ1bmN0aW9ucy9jb25zdGFudHMgbmVlZGVkIGJ5IGJvdGggdGhlIGNsaWVudCBhbmQgc2VydmVyLlxuICovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kL211dGFibGUnKVxuXG5leHBvcnRzLkRFRkFVTFRfQU5OT1VOQ0VfUEVFUlMgPSA1MFxuZXhwb3J0cy5NQVhfQU5OT1VOQ0VfUEVFUlMgPSA4MlxuXG5leHBvcnRzLmJpbmFyeVRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKVxuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICdiaW5hcnknKS50b1N0cmluZygnaGV4Jylcbn1cblxuZXhwb3J0cy5oZXhUb0JpbmFyeSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cilcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAnaGV4JykudG9TdHJpbmcoJ2JpbmFyeScpXG59XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbW1vbi1ub2RlJylcbmV4dGVuZChleHBvcnRzLCBjb25maWcpXG4iLCIvKiBnbG9iYWwgQmxvYiwgRmlsZVJlYWRlciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2JUb0J1ZmZlciAoYmxvYiwgY2IpIHtcbiAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCAhKGJsb2IgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIEJsb2InKVxuICB9XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICBmdW5jdGlvbiBvbkxvYWRFbmQgKGUpIHtcbiAgICByZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZEVuZCwgZmFsc2UpXG4gICAgaWYgKGUuZXJyb3IpIGNiKGUuZXJyb3IpXG4gICAgZWxzZSBjYihudWxsLCBuZXcgQnVmZmVyKHJlYWRlci5yZXN1bHQpKVxuICB9XG5cbiAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBvbkxvYWRFbmQsIGZhbHNlKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbn1cbiIsIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBzdXBwb3J0cyBBcnJheUJ1ZmZlclZpZXdzXG4gKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuICovXG5cbnZhciBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPSBibG9iU3VwcG9ydGVkICYmIChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcbiAgICByZXR1cm4gYi5zaXplID09PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBtYXBzIEFycmF5QnVmZmVyVmlld3MgdG8gQXJyYXlCdWZmZXJzXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcbiAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG4gICAgaWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcbiAgICAgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvcHkuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZiwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCkpO1xuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgYXJ5W2ldID0gYnVmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cblxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5mdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcbiAgcmV0dXJuIG5ldyBCbG9iKGFyeSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID8gZ2xvYmFsLkJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm07XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJ2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCbG9jaztcbmluaGVyaXRzKEJsb2NrLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBCbG9jayAoc2l6ZSwgb3B0cykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCbG9jaykpIHJldHVybiBuZXcgQmxvY2soc2l6ZSwgb3B0cyk7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcyk7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0gc2l6ZTtcbiAgICAgICAgc2l6ZSA9IG9wdHMuc2l6ZTtcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZSB8fCA1MTI7XG4gICAgXG4gICAgaWYgKG9wdHMubm9wYWQpIHRoaXMuX3plcm9QYWRkaW5nID0gZmFsc2U7XG4gICAgZWxzZSB0aGlzLl96ZXJvUGFkZGluZyA9IGRlZmluZWQob3B0cy56ZXJvUGFkZGluZywgdHJ1ZSk7XG4gICAgXG4gICAgdGhpcy5fYnVmZmVyZWQgPSBbXTtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbn1cblxuQmxvY2sucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYnVmLCBlbmMsIG5leHQpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVyZWQucHVzaChidWYpO1xuICAgIFxuICAgIHdoaWxlICh0aGlzLl9idWZmZXJlZEJ5dGVzID49IHRoaXMuc2l6ZSkge1xuICAgICAgICB2YXIgYiA9IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmZmVyZWQpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHRoaXMuc2l6ZTtcbiAgICAgICAgdGhpcy5wdXNoKGIuc2xpY2UoMCwgdGhpcy5zaXplKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkID0gWyBiLnNsaWNlKHRoaXMuc2l6ZSwgYi5sZW5ndGgpIF07XG4gICAgfVxuICAgIG5leHQoKTtcbn07XG5cbkJsb2NrLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgJiYgdGhpcy5femVyb1BhZGRpbmcpIHtcbiAgICAgICAgdmFyIHplcm9lcyA9IG5ldyBCdWZmZXIodGhpcy5zaXplIC0gdGhpcy5fYnVmZmVyZWRCeXRlcyk7XG4gICAgICAgIHplcm9lcy5maWxsKDApO1xuICAgICAgICB0aGlzLl9idWZmZXJlZC5wdXNoKHplcm9lcyk7XG4gICAgICAgIHRoaXMucHVzaChCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZmZlcmVkKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcykge1xuICAgICAgICB0aGlzLnB1c2goQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZmZXJlZCkpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucHVzaChudWxsKTtcbn07XG4iLCIiLCIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyO1xudmFyIFNsb3dCdWZmZXIgPSBidWZmZXIuU2xvd0J1ZmZlcjtcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcbmV4cG9ydHMuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHZhciBlbmMgPSBlbmNvZGluZztcbiAgdmFyIF9maWxsID0gZmlsbDtcbiAgaWYgKF9maWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gICAgX2ZpbGwgPSAwO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBmaWxsQnVmID0gbmV3IEJ1ZmZlcihfZmlsbCwgZW5jKTtcbiAgICB2YXIgZmxlbiA9IGZpbGxCdWYubGVuZ3RoO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgIGJ1ZltpXSA9IGZpbGxCdWZbaSAlIGZsZW5dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbChfZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG59XG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiAoIWdsb2JhbC5VaW50OEFycmF5IHx8IFVpbnQ4QXJyYXkuZnJvbSAhPT0gQnVmZmVyLmZyb20pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGxlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgdmFsdWUuY29weShvdXQsIDAsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsICcgKyAnQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID49IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc2l6ZSk7XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICBmb3IgKHZhciBpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG59XG5cbmluaXQoKVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSB0ZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjUwMFwiOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICBcIjUwMVwiOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICBcIjUwMlwiOiBcIkJhZCBHYXRld2F5XCIsXG4gIFwiNTAzXCI6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICBcIjUwNFwiOiBcIkdhdGV3YXkgVGltZW91dFwiLFxuICBcIjUwNVwiOiBcIkhUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gIFwiNTA2XCI6IFwiVmFyaWFudCBBbHNvIE5lZ290aWF0ZXNcIixcbiAgXCI1MDdcIjogXCJJbnN1ZmZpY2llbnQgU3RvcmFnZVwiLFxuICBcIjUwOFwiOiBcIkxvb3AgRGV0ZWN0ZWRcIixcbiAgXCI1MDlcIjogXCJCYW5kd2lkdGggTGltaXQgRXhjZWVkZWRcIixcbiAgXCI1MTBcIjogXCJOb3QgRXh0ZW5kZWRcIixcbiAgXCI1MTFcIjogXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCJcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQ2h1bmtTdG9yZVdyaXRlU3RyZWFtXG5cbnZhciBCbG9ja1N0cmVhbSA9IHJlcXVpcmUoJ2Jsb2NrLXN0cmVhbTInKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbmluaGVyaXRzKENodW5rU3RvcmVXcml0ZVN0cmVhbSwgc3RyZWFtLldyaXRhYmxlKVxuXG5mdW5jdGlvbiBDaHVua1N0b3JlV3JpdGVTdHJlYW0gKHN0b3JlLCBjaHVua0xlbmd0aCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIENodW5rU3RvcmVXcml0ZVN0cmVhbSkpIHtcbiAgICByZXR1cm4gbmV3IENodW5rU3RvcmVXcml0ZVN0cmVhbShzdG9yZSwgY2h1bmtMZW5ndGgsIG9wdHMpXG4gIH1cbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZiwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBpZiAoIXN0b3JlIHx8ICFzdG9yZS5wdXQgfHwgIXN0b3JlLmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhYnN0cmFjdC1jaHVuay1zdG9yZSBjb21wbGlhbnQgc3RvcmUnKVxuICB9XG4gIGNodW5rTGVuZ3RoID0gTnVtYmVyKGNodW5rTGVuZ3RoKVxuICBpZiAoIWNodW5rTGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ1NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgY2h1bmsgbGVuZ3RoJylcblxuICBzZWxmLl9ibG9ja3N0cmVhbSA9IG5ldyBCbG9ja1N0cmVhbShjaHVua0xlbmd0aCwgeyB6ZXJvUGFkZGluZzogZmFsc2UgfSlcblxuICBzZWxmLl9ibG9ja3N0cmVhbVxuICAgIC5vbignZGF0YScsIG9uRGF0YSlcbiAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyBzZWxmLmRlc3Ryb3koZXJyKSB9KVxuXG4gIHZhciBpbmRleCA9IDBcbiAgZnVuY3Rpb24gb25EYXRhIChjaHVuaykge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc3RvcmUucHV0KGluZGV4LCBjaHVuaylcbiAgICBpbmRleCArPSAxXG4gIH1cblxuICBzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7IHRoaXMuX2Jsb2Nrc3RyZWFtLmVuZCgpIH0pXG59XG5cbkNodW5rU3RvcmVXcml0ZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdGhpcy5fYmxvY2tzdHJlYW0ud3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaylcbn1cblxuQ2h1bmtTdG9yZVdyaXRlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBudW1iZXJzKSB7XG4gIHZhciBjbG9zZXN0ID0gSW5maW5pdHlcbiAgdmFyIGRpZmZlcmVuY2UgPSAwXG4gIHZhciB3aW5uZXIgPSBudWxsXG5cbiAgbnVtYmVycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGJcbiAgfSlcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IG51bWJlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7ICBcbiAgICBkaWZmZXJlbmNlID0gTWF0aC5hYnModGFyZ2V0IC0gbnVtYmVyc1tpXSlcbiAgICBpZiAoZGlmZmVyZW5jZSA+PSBjbG9zZXN0KSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjbG9zZXN0ID0gZGlmZmVyZW5jZVxuICAgIHdpbm5lciA9IG51bWJlcnNbaV1cbiAgfVxuXG4gIHJldHVybiB3aW5uZXJcbn1cbiIsInZhciBpcGFkZHIgPSByZXF1aXJlKCdpcGFkZHIuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYWN0MnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgc3dpdGNoKGJ1Zi5sZW5ndGgpIHtcbiAgY2FzZSA2OlxuICAgIHJldHVybiBidWZbMF0gKyBcIi5cIiArIGJ1ZlsxXSArIFwiLlwiICsgYnVmWzJdICsgXCIuXCIgKyBidWZbM10gKyBcIjpcIiArIGJ1Zi5yZWFkVUludDE2QkUoNCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTg6XG4gICAgdmFyIGhleEdyb3VwcyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGhleEdyb3Vwcy5wdXNoKGJ1Zi5yZWFkVUludDE2QkUoaSAqIDIpLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHZhciBob3N0ID0gaXBhZGRyLnBhcnNlKGhleEdyb3Vwcy5qb2luKFwiOlwiKSkudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gXCJbXCIgKyBob3N0ICsgXCJdOlwiICsgYnVmLnJlYWRVSW50MTZCRSgxNik7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBDb21wYWN0IElQL1BPUlQsIEl0IHNob3VsZCBjb250YWluIDYgb3IgMTggYnl0ZXNcIik7XG4gIH1cbn07XG5cbmNvbXBhY3Qyc3RyaW5nLm11bHRpID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZihidWYubGVuZ3RoICUgNiAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWYgbGVuZ3RoIGlzbid0IG11bHRpcGxlIG9mIGNvbXBhY3QgSVAvUE9SVHMgKDYgYnl0ZXMpXCIpO1xuXG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYnVmLmxlbmd0aCAtIDE7IGkgPSBpICsgNikge1xuICAgIG91dHB1dC5wdXNoKGNvbXBhY3Qyc3RyaW5nKGJ1Zi5zbGljZShpLCBpICsgNikpKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5jb21wYWN0MnN0cmluZy5tdWx0aTYgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmKGJ1Zi5sZW5ndGggJSAxOCAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWYgbGVuZ3RoIGlzbid0IG11bHRpcGxlIG9mIGNvbXBhY3QgSVA2L1BPUlRzICgxOCBieXRlcylcIik7XG5cbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBidWYubGVuZ3RoIC0gMTsgaSA9IGkgKyAxOCkge1xuICAgIG91dHB1dC5wdXNoKGNvbXBhY3Qyc3RyaW5nKGJ1Zi5zbGljZShpLCBpICsgMTgpKSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcbiIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRvcnJlbnRcbm1vZHVsZS5leHBvcnRzLnBhcnNlSW5wdXQgPSBwYXJzZUlucHV0XG5cbm1vZHVsZS5leHBvcnRzLmFubm91bmNlTGlzdCA9IFtcbiAgWyAndWRwOi8vdHJhY2tlci5vcGVuYml0dG9ycmVudC5jb206ODAnIF0sXG4gIFsgJ3VkcDovL3RyYWNrZXIuaW50ZXJuZXR3YXJyaW9ycy5uZXQ6MTMzNycgXSxcbiAgWyAndWRwOi8vdHJhY2tlci5sZWVjaGVycy1wYXJhZGlzZS5vcmc6Njk2OScgXSxcbiAgWyAndWRwOi8vdHJhY2tlci5jb3BwZXJzdXJmZXIudGs6Njk2OScgXSxcbiAgWyAndWRwOi8vZXhvZHVzLmRlc3luYy5jb206Njk2OScgXSxcbiAgWyAnd3NzOi8vdHJhY2tlci53ZWJ0b3JyZW50LmlvJyBdLFxuICBbICd3c3M6Ly90cmFja2VyLmJ0b3JyZW50Lnh5eicgXSxcbiAgWyAnd3NzOi8vdHJhY2tlci5vcGVud2VidG9ycmVudC5jb20nIF0sXG4gIFsgJ3dzczovL3RyYWNrZXIuZmFzdGNhc3QubnonIF1cbl1cblxudmFyIGJlbmNvZGUgPSByZXF1aXJlKCdiZW5jb2RlJylcbnZhciBCbG9ja1N0cmVhbSA9IHJlcXVpcmUoJ2Jsb2NrLXN0cmVhbTInKVxudmFyIGNhbGNQaWVjZUxlbmd0aCA9IHJlcXVpcmUoJ3BpZWNlLWxlbmd0aCcpXG52YXIgY29yZVBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgRmlsZVJlYWRTdHJlYW0gPSByZXF1aXJlKCdmaWxlc3RyZWFtL3JlYWQnKVxudmFyIGZsYXR0ZW4gPSByZXF1aXJlKCdmbGF0dGVuJylcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBpc0ZpbGUgPSByZXF1aXJlKCdpcy1maWxlJylcbnZhciBqdW5rID0gcmVxdWlyZSgnanVuaycpXG52YXIgTXVsdGlTdHJlYW0gPSByZXF1aXJlKCdtdWx0aXN0cmVhbScpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbi8qKlxuICogQ3JlYXRlIGEgdG9ycmVudC5cbiAqIEBwYXJhbSAge3N0cmluZ3xGaWxlfEZpbGVMaXN0fEJ1ZmZlcnxTdHJlYW18QXJyYXkuPHN0cmluZ3xGaWxlfEJ1ZmZlcnxTdHJlYW0+fSBpbnB1dFxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0gIHtzdHJpbmc9fSBvcHRzLm5hbWVcbiAqIEBwYXJhbSAge0RhdGU9fSBvcHRzLmNyZWF0aW9uRGF0ZVxuICogQHBhcmFtICB7c3RyaW5nPX0gb3B0cy5jb21tZW50XG4gKiBAcGFyYW0gIHtzdHJpbmc9fSBvcHRzLmNyZWF0ZWRCeVxuICogQHBhcmFtICB7Ym9vbGVhbnxudW1iZXI9fSBvcHRzLnByaXZhdGVcbiAqIEBwYXJhbSAge251bWJlcj19IG9wdHMucGllY2VMZW5ndGhcbiAqIEBwYXJhbSAge0FycmF5LjxBcnJheS48c3RyaW5nPj49fSBvcHRzLmFubm91bmNlTGlzdFxuICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz49fSBvcHRzLnVybExpc3RcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICogQHJldHVybiB7QnVmZmVyfSBidWZmZXIgb2YgLnRvcnJlbnQgZmlsZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvcnJlbnQgKGlucHV0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBjcmVhdGVUb3JyZW50KGlucHV0LCBudWxsLCBvcHRzKVxuICBvcHRzID0gb3B0cyA/IGV4dGVuZChvcHRzKSA6IHt9XG5cbiAgX3BhcnNlSW5wdXQoaW5wdXQsIG9wdHMsIGZ1bmN0aW9uIChlcnIsIGZpbGVzLCBzaW5nbGVGaWxlVG9ycmVudCkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgb3B0cy5zaW5nbGVGaWxlVG9ycmVudCA9IHNpbmdsZUZpbGVUb3JyZW50XG4gICAgb25GaWxlcyhmaWxlcywgb3B0cywgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5wdXQgKGlucHV0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBwYXJzZUlucHV0KGlucHV0LCBudWxsLCBvcHRzKVxuICBvcHRzID0gb3B0cyA/IGV4dGVuZChvcHRzKSA6IHt9XG4gIF9wYXJzZUlucHV0KGlucHV0LCBvcHRzLCBjYilcbn1cblxuLyoqXG4gKiBQYXJzZSBpbnB1dCBmaWxlIGFuZCByZXR1cm4gZmlsZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gX3BhcnNlSW5wdXQgKGlucHV0LCBvcHRzLCBjYikge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdHlwZScpXG5cbiAgaWYgKGlzRmlsZUxpc3QoaW5wdXQpKSBpbnB1dCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGlucHV0KVxuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSBpbnB1dCA9IFsgaW5wdXQgXVxuXG4gIC8vIEluIEVsZWN0cm9uLCB1c2UgdGhlIHRydWUgZmlsZSBwYXRoXG4gIGlucHV0ID0gaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGlzQmxvYihpdGVtKSAmJiB0eXBlb2YgaXRlbS5wYXRoID09PSAnc3RyaW5nJykgcmV0dXJuIGl0ZW0ucGF0aFxuICAgIHJldHVybiBpdGVtXG4gIH0pXG5cbiAgLy8gSWYgdGhlcmUncyBqdXN0IG9uZSBmaWxlLCBhbGxvdyB0aGUgbmFtZSB0byBiZSBzZXQgYnkgYG9wdHMubmFtZWBcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnICYmICFpbnB1dFswXS5uYW1lKSBpbnB1dFswXS5uYW1lID0gb3B0cy5uYW1lXG5cbiAgdmFyIGNvbW1vblByZWZpeCA9IG51bGxcbiAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBwYXRoID0gaXRlbS5mdWxsUGF0aCB8fCBpdGVtLm5hbWVcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHBhdGggPSAnVW5rbm93biBGaWxlICcgKyAoaSArIDEpXG4gICAgICBpdGVtLnVua25vd25OYW1lID0gdHJ1ZVxuICAgIH1cblxuICAgIGl0ZW0ucGF0aCA9IHBhdGguc3BsaXQoJy8nKVxuXG4gICAgLy8gUmVtb3ZlIGluaXRpYWwgc2xhc2hcbiAgICBpZiAoIWl0ZW0ucGF0aFswXSkge1xuICAgICAgaXRlbS5wYXRoLnNoaWZ0KClcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5wYXRoLmxlbmd0aCA8IDIpIHsgLy8gTm8gcmVhbCBwcmVmaXhcbiAgICAgIGNvbW1vblByZWZpeCA9IG51bGxcbiAgICB9IGVsc2UgaWYgKGkgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMSkgeyAvLyBUaGUgZmlyc3QgZmlsZSBoYXMgYSBwcmVmaXhcbiAgICAgIGNvbW1vblByZWZpeCA9IGl0ZW0ucGF0aFswXVxuICAgIH0gZWxzZSBpZiAoaXRlbS5wYXRoWzBdICE9PSBjb21tb25QcmVmaXgpIHsgLy8gVGhlIHByZWZpeCBkb2Vzbid0IG1hdGNoXG4gICAgICBjb21tb25QcmVmaXggPSBudWxsXG4gICAgfVxuICB9KVxuXG4gIC8vIHJlbW92ZSBqdW5rIGZpbGVzXG4gIGlucHV0ID0gaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgdmFyIGZpbGVuYW1lID0gaXRlbS5wYXRoW2l0ZW0ucGF0aC5sZW5ndGggLSAxXVxuICAgIHJldHVybiBub3RIaWRkZW4oZmlsZW5hbWUpICYmIGp1bmsubm90KGZpbGVuYW1lKVxuICB9KVxuXG4gIGlmIChjb21tb25QcmVmaXgpIHtcbiAgICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcGF0aGxlc3MgPSAoQnVmZmVyLmlzQnVmZmVyKGl0ZW0pIHx8IGlzUmVhZGFibGUoaXRlbSkpICYmICFpdGVtLnBhdGhcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgcGF0aGxlc3MpIHJldHVyblxuICAgICAgaXRlbS5wYXRoLnNoaWZ0KClcbiAgICB9KVxuICB9XG5cbiAgaWYgKCFvcHRzLm5hbWUgJiYgY29tbW9uUHJlZml4KSB7XG4gICAgb3B0cy5uYW1lID0gY29tbW9uUHJlZml4XG4gIH1cblxuICBpZiAoIW9wdHMubmFtZSkge1xuICAgIC8vIHVzZSBmaXJzdCB1c2VyLXNldCBmaWxlIG5hbWVcbiAgICBpbnB1dC5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdHMubmFtZSA9IGNvcmVQYXRoLmJhc2VuYW1lKGl0ZW0pXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKCFpdGVtLnVua25vd25OYW1lKSB7XG4gICAgICAgIG9wdHMubmFtZSA9IGl0ZW0ucGF0aFtpdGVtLnBhdGgubGVuZ3RoIC0gMV1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaWYgKCFvcHRzLm5hbWUpIHtcbiAgICBvcHRzLm5hbWUgPSAnVW5uYW1lZCBUb3JyZW50ICcgKyBEYXRlLm5vdygpXG4gIH1cblxuICB2YXIgbnVtUGF0aHMgPSBpbnB1dC5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgaXRlbSkge1xuICAgIHJldHVybiBzdW0gKyBOdW1iZXIodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKVxuICB9LCAwKVxuXG4gIHZhciBpc1NpbmdsZUZpbGVUb3JyZW50ID0gKGlucHV0Lmxlbmd0aCA9PT0gMSlcblxuICBpZiAoaW5wdXQubGVuZ3RoID09PSAxICYmIHR5cGVvZiBpbnB1dFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIGZzLnN0YXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZXN5c3RlbSBwYXRocyBkbyBub3Qgd29yayBpbiB0aGUgYnJvd3NlcicpXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3MgYSBzaW5nbGUgcGF0aCwgdmVyaWZ5IGl0J3MgYSBmaWxlIGJlZm9yZSBkZWNpZGluZyB0aGlzIGlzIGEgc2luZ2xlXG4gICAgLy8gZmlsZSB0b3JyZW50XG4gICAgaXNGaWxlKGlucHV0WzBdLCBmdW5jdGlvbiAoZXJyLCBwYXRoSXNGaWxlKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaXNTaW5nbGVGaWxlVG9ycmVudCA9IHBhdGhJc0ZpbGVcbiAgICAgIHByb2Nlc3NJbnB1dCgpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3NJbnB1dCgpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbnB1dCAoKSB7XG4gICAgcGFyYWxsZWwoaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBmaWxlID0ge31cblxuICAgICAgICBpZiAoaXNCbG9iKGl0ZW0pKSB7XG4gICAgICAgICAgZmlsZS5nZXRTdHJlYW0gPSBnZXRCbG9iU3RyZWFtKGl0ZW0pXG4gICAgICAgICAgZmlsZS5sZW5ndGggPSBpdGVtLnNpemVcbiAgICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoaXRlbSkpIHtcbiAgICAgICAgICBmaWxlLmdldFN0cmVhbSA9IGdldEJ1ZmZlclN0cmVhbShpdGVtKVxuICAgICAgICAgIGZpbGUubGVuZ3RoID0gaXRlbS5sZW5ndGhcbiAgICAgICAgfSBlbHNlIGlmIChpc1JlYWRhYmxlKGl0ZW0pKSB7XG4gICAgICAgICAgZmlsZS5nZXRTdHJlYW0gPSBnZXRTdHJlYW1TdHJlYW0oaXRlbSwgZmlsZSlcbiAgICAgICAgICBmaWxlLmxlbmd0aCA9IDBcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZzLnN0YXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZXN5c3RlbSBwYXRocyBkbyBub3Qgd29yayBpbiB0aGUgYnJvd3NlcicpXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZWVwUm9vdCA9IG51bVBhdGhzID4gMSB8fCBpc1NpbmdsZUZpbGVUb3JyZW50XG4gICAgICAgICAgZ2V0RmlsZXMoaXRlbSwga2VlcFJvb3QsIGNiKVxuICAgICAgICAgIHJldHVybiAvLyBlYXJseSByZXR1cm4hXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHR5cGUnKVxuICAgICAgICB9XG4gICAgICAgIGZpbGUucGF0aCA9IGl0ZW0ucGF0aFxuICAgICAgICBjYihudWxsLCBmaWxlKVxuICAgICAgfVxuICAgIH0pLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGZpbGVzID0gZmxhdHRlbihmaWxlcylcbiAgICAgIGNiKG51bGwsIGZpbGVzLCBpc1NpbmdsZUZpbGVUb3JyZW50KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RmlsZXMgKHBhdGgsIGtlZXBSb290LCBjYikge1xuICB0cmF2ZXJzZVBhdGgocGF0aCwgZ2V0RmlsZUluZm8sIGZ1bmN0aW9uIChlcnIsIGZpbGVzKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGVzKSkgZmlsZXMgPSBmbGF0dGVuKGZpbGVzKVxuICAgIGVsc2UgZmlsZXMgPSBbIGZpbGVzIF1cblxuICAgIHBhdGggPSBjb3JlUGF0aC5ub3JtYWxpemUocGF0aClcbiAgICBpZiAoa2VlcFJvb3QpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHBhdGgubGFzdEluZGV4T2YoY29yZVBhdGguc2VwKSArIDEpXG4gICAgfVxuICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09IGNvcmVQYXRoLnNlcCkgcGF0aCArPSBjb3JlUGF0aC5zZXBcblxuICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIGZpbGUuZ2V0U3RyZWFtID0gZ2V0RmlsZVBhdGhTdHJlYW0oZmlsZS5wYXRoKVxuICAgICAgZmlsZS5wYXRoID0gZmlsZS5wYXRoLnJlcGxhY2UocGF0aCwgJycpLnNwbGl0KGNvcmVQYXRoLnNlcClcbiAgICB9KVxuICAgIGNiKG51bGwsIGZpbGVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRGaWxlSW5mbyAocGF0aCwgY2IpIHtcbiAgY2IgPSBvbmNlKGNiKVxuICBmcy5zdGF0KHBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHZhciBpbmZvID0ge1xuICAgICAgbGVuZ3RoOiBzdGF0LnNpemUsXG4gICAgICBwYXRoOiBwYXRoXG4gICAgfVxuICAgIGNiKG51bGwsIGluZm8pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlUGF0aCAocGF0aCwgZm4sIGNiKSB7XG4gIGZzLnJlYWRkaXIocGF0aCwgZnVuY3Rpb24gKGVyciwgZW50cmllcykge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgLy8gdGhpcyBpcyBhIGZpbGVcbiAgICAgIGZuKHBhdGgsIGNiKVxuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAvLyByZWFsIGVycm9yXG4gICAgICBjYihlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBmb2xkZXJcbiAgICAgIHBhcmFsbGVsKGVudHJpZXMuZmlsdGVyKG5vdEhpZGRlbikuZmlsdGVyKGp1bmsubm90KS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICB0cmF2ZXJzZVBhdGgoY29yZVBhdGguam9pbihwYXRoLCBlbnRyeSksIGZuLCBjYilcbiAgICAgICAgfVxuICAgICAgfSksIGNiKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbm90SGlkZGVuIChmaWxlKSB7XG4gIHJldHVybiBmaWxlWzBdICE9PSAnLidcbn1cblxuZnVuY3Rpb24gZ2V0UGllY2VMaXN0IChmaWxlcywgcGllY2VMZW5ndGgsIGNiKSB7XG4gIGNiID0gb25jZShjYilcbiAgdmFyIHBpZWNlcyA9IFtdXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgdmFyIHN0cmVhbXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gZmlsZS5nZXRTdHJlYW1cbiAgfSlcblxuICB2YXIgcmVtYWluaW5nSGFzaGVzID0gMFxuICB2YXIgcGllY2VOdW0gPSAwXG4gIHZhciBlbmRlZCA9IGZhbHNlXG5cbiAgdmFyIG11bHRpc3RyZWFtID0gbmV3IE11bHRpU3RyZWFtKHN0cmVhbXMpXG4gIHZhciBibG9ja3N0cmVhbSA9IG5ldyBCbG9ja1N0cmVhbShwaWVjZUxlbmd0aCwgeyB6ZXJvUGFkZGluZzogZmFsc2UgfSlcblxuICBtdWx0aXN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKVxuXG4gIG11bHRpc3RyZWFtXG4gICAgLnBpcGUoYmxvY2tzdHJlYW0pXG4gICAgLm9uKCdkYXRhJywgb25EYXRhKVxuICAgIC5vbignZW5kJywgb25FbmQpXG4gICAgLm9uKCdlcnJvcicsIG9uRXJyb3IpXG5cbiAgZnVuY3Rpb24gb25EYXRhIChjaHVuaykge1xuICAgIGxlbmd0aCArPSBjaHVuay5sZW5ndGhcblxuICAgIHZhciBpID0gcGllY2VOdW1cbiAgICBzaGExKGNodW5rLCBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgcGllY2VzW2ldID0gaGFzaFxuICAgICAgcmVtYWluaW5nSGFzaGVzIC09IDFcbiAgICAgIG1heWJlRG9uZSgpXG4gICAgfSlcbiAgICByZW1haW5pbmdIYXNoZXMgKz0gMVxuICAgIHBpZWNlTnVtICs9IDFcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kICgpIHtcbiAgICBlbmRlZCA9IHRydWVcbiAgICBtYXliZURvbmUoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgY2xlYW51cCgpXG4gICAgY2IoZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgbXVsdGlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICBibG9ja3N0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSlcbiAgICBibG9ja3N0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpXG4gICAgYmxvY2tzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlRG9uZSAoKSB7XG4gICAgaWYgKGVuZGVkICYmIHJlbWFpbmluZ0hhc2hlcyA9PT0gMCkge1xuICAgICAgY2xlYW51cCgpXG4gICAgICBjYihudWxsLCBuZXcgQnVmZmVyKHBpZWNlcy5qb2luKCcnKSwgJ2hleCcpLCBsZW5ndGgpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uRmlsZXMgKGZpbGVzLCBvcHRzLCBjYikge1xuICB2YXIgYW5ub3VuY2VMaXN0ID0gb3B0cy5hbm5vdW5jZUxpc3RcblxuICBpZiAoIWFubm91bmNlTGlzdCkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy5hbm5vdW5jZSA9PT0gJ3N0cmluZycpIGFubm91bmNlTGlzdCA9IFsgWyBvcHRzLmFubm91bmNlIF0gXVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5hbm5vdW5jZSkpIHtcbiAgICAgIGFubm91bmNlTGlzdCA9IG9wdHMuYW5ub3VuY2UubWFwKGZ1bmN0aW9uICh1KSB7IHJldHVybiBbIHUgXSB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghYW5ub3VuY2VMaXN0KSBhbm5vdW5jZUxpc3QgPSBbXVxuXG4gIGlmIChnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbm5vdW5jZUxpc3QucHVzaChbIFsgZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UgXSBdKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShnbG9iYWwuV0VCVE9SUkVOVF9BTk5PVU5DRSkpIHtcbiAgICAgIGFubm91bmNlTGlzdCA9IGFubm91bmNlTGlzdC5jb25jYXQoZ2xvYmFsLldFQlRPUlJFTlRfQU5OT1VOQ0UubWFwKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIHJldHVybiBbIHUgXVxuICAgICAgfSkpXG4gICAgfVxuICB9XG5cbiAgLy8gV2hlbiBubyB0cmFja2VycyBzcGVjaWZpZWQsIHVzZSBzb21lIHJlYXNvbmFibGUgZGVmYXVsdHNcbiAgaWYgKG9wdHMuYW5ub3VuY2UgPT09IHVuZGVmaW5lZCAmJiBvcHRzLmFubm91bmNlTGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYW5ub3VuY2VMaXN0ID0gYW5ub3VuY2VMaXN0LmNvbmNhdChtb2R1bGUuZXhwb3J0cy5hbm5vdW5jZUxpc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMudXJsTGlzdCA9PT0gJ3N0cmluZycpIG9wdHMudXJsTGlzdCA9IFsgb3B0cy51cmxMaXN0IF1cblxuICB2YXIgdG9ycmVudCA9IHtcbiAgICBpbmZvOiB7XG4gICAgICBuYW1lOiBvcHRzLm5hbWVcbiAgICB9LFxuICAgICdjcmVhdGlvbiBkYXRlJzogTWF0aC5jZWlsKChOdW1iZXIob3B0cy5jcmVhdGlvbkRhdGUpIHx8IERhdGUubm93KCkpIC8gMTAwMCksXG4gICAgZW5jb2Rpbmc6ICdVVEYtOCdcbiAgfVxuXG4gIGlmIChhbm5vdW5jZUxpc3QubGVuZ3RoICE9PSAwKSB7XG4gICAgdG9ycmVudC5hbm5vdW5jZSA9IGFubm91bmNlTGlzdFswXVswXVxuICAgIHRvcnJlbnRbJ2Fubm91bmNlLWxpc3QnXSA9IGFubm91bmNlTGlzdFxuICB9XG5cbiAgaWYgKG9wdHMuY29tbWVudCAhPT0gdW5kZWZpbmVkKSB0b3JyZW50LmNvbW1lbnQgPSBvcHRzLmNvbW1lbnRcblxuICBpZiAob3B0cy5jcmVhdGVkQnkgIT09IHVuZGVmaW5lZCkgdG9ycmVudFsnY3JlYXRlZCBieSddID0gb3B0cy5jcmVhdGVkQnlcblxuICBpZiAob3B0cy5wcml2YXRlICE9PSB1bmRlZmluZWQpIHRvcnJlbnQuaW5mby5wcml2YXRlID0gTnVtYmVyKG9wdHMucHJpdmF0ZSlcblxuICAvLyBcInNzbC1jZXJ0XCIga2V5IGlzIGZvciBTU0wgdG9ycmVudHMsIHNlZTpcbiAgLy8gICAtIGh0dHA6Ly9ibG9nLmxpYnRvcnJlbnQub3JnLzIwMTIvMDEvYml0dG9ycmVudC1vdmVyLXNzbC9cbiAgLy8gICAtIGh0dHA6Ly93d3cubGlidG9ycmVudC5vcmcvbWFudWFsLXJlZi5odG1sI3NzbC10b3JyZW50c1xuICAvLyAgIC0gaHR0cDovL3d3dy5saWJ0b3JyZW50Lm9yZy9yZWZlcmVuY2UtQ3JlYXRlX1RvcnJlbnRzLmh0bWxcbiAgaWYgKG9wdHMuc3NsQ2VydCAhPT0gdW5kZWZpbmVkKSB0b3JyZW50LmluZm9bJ3NzbC1jZXJ0J10gPSBvcHRzLnNzbENlcnRcblxuICBpZiAob3B0cy51cmxMaXN0ICE9PSB1bmRlZmluZWQpIHRvcnJlbnRbJ3VybC1saXN0J10gPSBvcHRzLnVybExpc3RcblxuICB2YXIgcGllY2VMZW5ndGggPSBvcHRzLnBpZWNlTGVuZ3RoIHx8IGNhbGNQaWVjZUxlbmd0aChmaWxlcy5yZWR1Y2Uoc3VtTGVuZ3RoLCAwKSlcbiAgdG9ycmVudC5pbmZvWydwaWVjZSBsZW5ndGgnXSA9IHBpZWNlTGVuZ3RoXG5cbiAgZ2V0UGllY2VMaXN0KGZpbGVzLCBwaWVjZUxlbmd0aCwgZnVuY3Rpb24gKGVyciwgcGllY2VzLCB0b3JyZW50TGVuZ3RoKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB0b3JyZW50LmluZm8ucGllY2VzID0gcGllY2VzXG5cbiAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICBkZWxldGUgZmlsZS5nZXRTdHJlYW1cbiAgICB9KVxuXG4gICAgaWYgKG9wdHMuc2luZ2xlRmlsZVRvcnJlbnQpIHtcbiAgICAgIHRvcnJlbnQuaW5mby5sZW5ndGggPSB0b3JyZW50TGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcnJlbnQuaW5mby5maWxlcyA9IGZpbGVzXG4gICAgfVxuXG4gICAgY2IobnVsbCwgYmVuY29kZS5lbmNvZGUodG9ycmVudCkpXG4gIH0pXG59XG5cbi8qKlxuICogQWNjdW11bGF0b3IgdG8gc3VtIGZpbGUgbGVuZ3Roc1xuICogQHBhcmFtICB7bnVtYmVyfSBzdW1cbiAqIEBwYXJhbSAge09iamVjdH0gZmlsZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzdW1MZW5ndGggKHN1bSwgZmlsZSkge1xuICByZXR1cm4gc3VtICsgZmlsZS5sZW5ndGhcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqIEBwYXJhbSAgeyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNCbG9iIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBCbG9iXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBXM0MgYEZpbGVMaXN0YCBvYmplY3RcbiAqIEBwYXJhbSAgeyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGaWxlTGlzdCAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgRmlsZUxpc3QgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgRmlsZUxpc3Rcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIG5vZGUgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUmVhZGFibGUgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nXG59XG5cbi8qKlxuICogQ29udmVydCBhIGBGaWxlYCB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLlxuICogQHBhcmFtICB7RmlsZXxCbG9ifSBmaWxlXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmxvYlN0cmVhbSAoZmlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmlsZVJlYWRTdHJlYW0oZmlsZSlcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBgQnVmZmVyYCB0byBhIGxhenkgcmVhZGFibGUgc3RyZWFtLlxuICogQHBhcmFtICB7QnVmZmVyfSBidWZmZXJcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRCdWZmZXJTdHJlYW0gKGJ1ZmZlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpXG4gICAgcy5lbmQoYnVmZmVyKVxuICAgIHJldHVybiBzXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgZmlsZSBwYXRoIHRvIGEgbGF6eSByZWFkYWJsZSBzdHJlYW0uXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRGaWxlUGF0aFN0cmVhbSAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcmVhZGFibGUgc3RyZWFtIHRvIGEgbGF6eSByZWFkYWJsZSBzdHJlYW0uIEFkZHMgaW5zdHJ1bWVudGF0aW9uIHRvIHRyYWNrXG4gKiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBzdHJlYW0gYW5kIHNldCBgZmlsZS5sZW5ndGhgLlxuICpcbiAqIEBwYXJhbSAge1N0cmVhbX0gc3RyZWFtXG4gKiBAcGFyYW0gIHtPYmplY3R9IGZpbGVcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRTdHJlYW1TdHJlYW0gKHJlYWRhYmxlLCBmaWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBuZXcgc3RyZWFtLlRyYW5zZm9ybSgpXG4gICAgY291bnRlci5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGJ1ZiwgZW5jLCBkb25lKSB7XG4gICAgICBmaWxlLmxlbmd0aCArPSBidWYubGVuZ3RoXG4gICAgICB0aGlzLnB1c2goYnVmKVxuICAgICAgZG9uZSgpXG4gICAgfVxuICAgIHJlYWRhYmxlLnBpcGUoY291bnRlcilcbiAgICByZXR1cm4gY291bnRlclxuICB9XG59XG4iLCJ2YXIgYmVuY29kZSA9IG1vZHVsZS5leHBvcnRzXG5cbmJlbmNvZGUuZW5jb2RlID0gcmVxdWlyZSggJy4vbGliL2VuY29kZScgKVxuYmVuY29kZS5kZWNvZGUgPSByZXF1aXJlKCAnLi9saWIvZGVjb2RlJyApXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYW1vdW50IG9mIGJ5dGVzXG4gKiBuZWVkZWQgdG8gZW5jb2RlIHRoZSBnaXZlbiB2YWx1ZVxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfEJvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGJ5dGVDb3VudFxuICovXG5iZW5jb2RlLmJ5dGVMZW5ndGggPSBiZW5jb2RlLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24oIHZhbHVlICkge1xuICByZXR1cm4gYmVuY29kZS5lbmNvZGUoIHZhbHVlICkubGVuZ3RoXG59XG4iLCJ2YXIgRGljdCA9IHJlcXVpcmUoXCIuL2RpY3RcIilcblxuLyoqXG4gKiBEZWNvZGVzIGJlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtICB7QnVmZmVyfSBkYXRhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0IChvcHRpb25hbClcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kIChvcHRpb25hbClcbiAqIEBwYXJhbSAge1N0cmluZ30gZW5jb2RpbmcgKG9wdGlvbmFsKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fEJ1ZmZlcnxTdHJpbmd8TnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWNvZGUoIGRhdGEsIHN0YXJ0LCBlbmQsIGVuY29kaW5nICkge1xuICBcbiAgaWYoIHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicgJiYgZW5jb2RpbmcgPT0gbnVsbCApIHtcbiAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgc3RhcnQgPSB1bmRlZmluZWRcbiAgfVxuICBcbiAgaWYoIHR5cGVvZiBlbmQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBlbmRcbiAgICBlbmQgPSB1bmRlZmluZWRcbiAgfVxuICBcbiAgZGVjb2RlLnBvc2l0aW9uID0gMFxuICBkZWNvZGUuZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBudWxsXG5cbiAgZGVjb2RlLmRhdGEgPSAhKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKVxuICAgID8gbmV3IEJ1ZmZlciggZGF0YSApXG4gICAgOiBkYXRhLnNsaWNlKCBzdGFydCwgZW5kIClcbiAgXG4gIGRlY29kZS5ieXRlcyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICBcbiAgcmV0dXJuIGRlY29kZS5uZXh0KClcblxufVxuXG5kZWNvZGUuYnl0ZXMgPSAwXG5kZWNvZGUucG9zaXRpb24gPSAwXG5kZWNvZGUuZGF0YSAgICAgPSBudWxsXG5kZWNvZGUuZW5jb2RpbmcgPSBudWxsXG5cbmRlY29kZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgc3dpdGNoKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICkge1xuICAgIGNhc2UgMHg2NDogcmV0dXJuIGRlY29kZS5kaWN0aW9uYXJ5KCk7IGJyZWFrXG4gICAgY2FzZSAweDZDOiByZXR1cm4gZGVjb2RlLmxpc3QoKTsgYnJlYWtcbiAgICBjYXNlIDB4Njk6IHJldHVybiBkZWNvZGUuaW50ZWdlcigpOyBicmVha1xuICAgIGRlZmF1bHQ6ICAgcmV0dXJuIGRlY29kZS5idWZmZXIoKTsgYnJlYWtcbiAgfVxuXG59XG5cbmRlY29kZS5maW5kID0gZnVuY3Rpb24oIGNociApIHtcblxuICB2YXIgaSA9IGRlY29kZS5wb3NpdGlvblxuICB2YXIgYyA9IGRlY29kZS5kYXRhLmxlbmd0aFxuICB2YXIgZCA9IGRlY29kZS5kYXRhXG5cbiAgd2hpbGUoIGkgPCBjICkge1xuICAgIGlmKCBkW2ldID09PSBjaHIgKVxuICAgICAgcmV0dXJuIGlcbiAgICBpKytcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBkYXRhOiBNaXNzaW5nIGRlbGltaXRlciBcIicgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoIGNociApICsgJ1wiIFsweCcgK1xuICAgIGNoci50b1N0cmluZyggMTYgKSArICddJ1xuICApXG5cbn1cblxuZGVjb2RlLmRpY3Rpb25hcnkgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBkaWN0ID0gbmV3IERpY3QoKVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGRpY3QuYmluYXJ5U2V0KGRlY29kZS5idWZmZXIoKSwgZGVjb2RlLm5leHQoKSlcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGRpY3RcblxufVxuXG5kZWNvZGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgdmFyIGxzdCA9IFtdXG5cbiAgd2hpbGUoIGRlY29kZS5kYXRhW2RlY29kZS5wb3NpdGlvbl0gIT09IDB4NjUgKSB7XG4gICAgbHN0LnB1c2goIGRlY29kZS5uZXh0KCkgKVxuICB9XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICByZXR1cm4gbHN0XG5cbn1cblxuZGVjb2RlLmludGVnZXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgZW5kICAgID0gZGVjb2RlLmZpbmQoIDB4NjUgKVxuICB2YXIgbnVtYmVyID0gZGVjb2RlLmRhdGEudG9TdHJpbmcoICdhc2NpaScsIGRlY29kZS5wb3NpdGlvbiArIDEsIGVuZCApXG5cbiAgZGVjb2RlLnBvc2l0aW9uICs9IGVuZCArIDEgLSBkZWNvZGUucG9zaXRpb25cblxuICByZXR1cm4gcGFyc2VJbnQoIG51bWJlciwgMTAgKVxuXG59XG5cbmRlY29kZS5idWZmZXIgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgc2VwICAgID0gZGVjb2RlLmZpbmQoIDB4M0EgKVxuICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoIGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24sIHNlcCApLCAxMCApXG4gIHZhciBlbmQgICAgPSArK3NlcCArIGxlbmd0aFxuXG4gIGRlY29kZS5wb3NpdGlvbiA9IGVuZFxuXG4gIHJldHVybiBkZWNvZGUuZW5jb2RpbmdcbiAgICA/IGRlY29kZS5kYXRhLnRvU3RyaW5nKCBkZWNvZGUuZW5jb2RpbmcsIHNlcCwgZW5kIClcbiAgICA6IGRlY29kZS5kYXRhLnNsaWNlKCBzZXAsIGVuZCApXG5cbn1cblxuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGVcbiIsInZhciBEaWN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEaWN0KCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5c1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IFtdLFxuICB9KVxufVxuXG5EaWN0LnByb3RvdHlwZS5iaW5hcnlLZXlzID0gZnVuY3Rpb24gYmluYXJ5S2V5cygpIHtcbiAgcmV0dXJuIHRoaXMuX2tleXMuc2xpY2UoKVxufVxuXG5EaWN0LnByb3RvdHlwZS5iaW5hcnlTZXQgPSBmdW5jdGlvbiBiaW5hcnlTZXQoa2V5LCB2YWx1ZSkge1xuICB0aGlzLl9rZXlzLnB1c2goa2V5KVxuXG4gIHRoaXNba2V5XSA9IHZhbHVlXG59XG4iLCIvKipcbiAqIEVuY29kZXMgZGF0YSBpbiBiZW5jb2RlLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcnxBcnJheXxTdHJpbmd8T2JqZWN0fE51bWJlcnxCb29sZWFufSBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZSggZGF0YSwgYnVmZmVyLCBvZmZzZXQgKSB7XG4gIFxuICB2YXIgYnVmZmVycyA9IFtdXG4gIHZhciByZXN1bHQgPSBudWxsXG4gIFxuICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YSApXG4gIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoIGJ1ZmZlcnMgKVxuICBlbmNvZGUuYnl0ZXMgPSByZXN1bHQubGVuZ3RoXG4gIFxuICBpZiggQnVmZmVyLmlzQnVmZmVyKCBidWZmZXIgKSApIHtcbiAgICByZXN1bHQuY29weSggYnVmZmVyLCBvZmZzZXQgKVxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdFxuICBcbn1cblxuZW5jb2RlLmJ5dGVzID0gLTFcbmVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSBmYWxzZVxuXG5lbmNvZGUuX2VuY29kZSA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGlmKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCggdHlwZW9mIGRhdGEgKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGVuY29kZS5idWZmZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KCBidWZmZXJzLCBkYXRhIClcbiAgICAgICAgOiBlbmNvZGUuZGljdCggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSA/IDEgOiAwIClcbiAgICAgIGJyZWFrXG4gIH1cblxufVxuXG52YXIgYnVmZl9lID0gbmV3IEJ1ZmZlcignZScpXG4gICwgYnVmZl9kID0gbmV3IEJ1ZmZlcignZCcpXG4gICwgYnVmZl9sID0gbmV3IEJ1ZmZlcignbCcpXG5cbmVuY29kZS5idWZmZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoIGRhdGEgKSArICc6JyArIGRhdGEpIClcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuICB2YXIgbWF4TG8gPSAweDgwMDAwMDAwXG4gIHZhciBoaSA9ICggZGF0YSAvIG1heExvICkgPDwgMFxuICB2YXIgbG8gPSAoIGRhdGEgJSBtYXhMbyAgKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoICdpJyArIHZhbCArICdlJyApKVxuXG4gIGlmKCB2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgKSB7XG4gICAgZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCA9IHRydWVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV0FSTklORzogUG9zc2libGUgZGF0YSBjb3JydXB0aW9uIGRldGVjdGVkIHdpdGggdmFsdWUgXCInK2RhdGErJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicrdmFsKydcIidcbiAgICApXG4gICAgY29uc29sZS50cmFjZSgpXG4gIH1cblxufVxuXG5lbmNvZGUuZGljdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9kIClcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcbiAgLy8gZml4IGZvciBpc3N1ZSAjMTMgLSBzb3J0ZWQgZGljdHNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZGF0YSApLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciggOyBqIDwga2wgOyBqKyspIHtcbiAgICBrPWtleXNbal1cbiAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBrIClcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtrXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgdmFyIGkgPSAwLCBqID0gMVxuICB2YXIgYyA9IGRhdGEubGVuZ3RoXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9sIClcblxuICBmb3IoIDsgaSA8IGM7IGkrKyApIHtcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtpXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG5cbn1cblxuLy8gRXhwb3NlXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgfVxufTtcbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnN0ZGlvICYmIEFycmF5LmlzQXJyYXkoc3RyZWFtLnN0ZGlvKSAmJiBzdHJlYW0uc3RkaW8ubGVuZ3RoID09PSAzXG59O1xuXG52YXIgZW9zID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcblx0aWYgKCFvcHRzKSBvcHRzID0ge307XG5cblx0Y2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuXG5cdHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblx0dmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXHR2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IChvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGUpO1xuXHR2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpO1xuXG5cdHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuXHR9O1xuXG5cdHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHdyaXRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCFyZWFkYWJsZSkgY2FsbGJhY2soKTtcblx0fTtcblxuXHR2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcblx0XHRyZWFkYWJsZSA9IGZhbHNlO1xuXHRcdGlmICghd3JpdGFibGUpIGNhbGxiYWNrKCk7XG5cdH07XG5cblx0dmFyIG9uZXhpdCA9IGZ1bmN0aW9uKGV4aXRDb2RlKSB7XG5cdFx0Y2FsbGJhY2soZXhpdENvZGUgPyBuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGVycm9yIGNvZGU6ICcgKyBleGl0Q29kZSkgOiBudWxsKTtcblx0fTtcblxuXHR2YXIgb25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChyZWFkYWJsZSAmJiAhKHJzICYmIHJzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHRcdGlmICh3cml0YWJsZSAmJiAhKHdzICYmIHdzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHR9O1xuXG5cdHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdH07XG5cblx0aWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG5cdFx0c3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO1xuXHRcdGVsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0fSBlbHNlIGlmICh3cml0YWJsZSAmJiAhd3MpIHsgLy8gbGVnYWN5IHN0cmVhbXNcblx0XHRzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHR9XG5cblx0aWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7XG5cblx0c3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG5cdHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHRpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cdHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25leGl0KTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY2FsbGJhY2spO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIlxubW9kdWxlLmV4cG9ydHMgPSAgcmVxdWlyZSgnLi9saWIvJyk7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZWpzb24gPSByZXF1aXJlKCdwYXJzZWpzb24nKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe31cblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6XG4gICAgKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG4gICAgICAgbG9jYXRpb24ucG9ydCA6XG4gICAgICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG4gIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG4gIH1cblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogdGhpcy5wYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBmb3JjZUpTT05QOiB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IHRoaXMucG9saWN5UG9ydCxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgcGZ4OiB0aGlzLnBmeCxcbiAgICBrZXk6IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiB0aGlzLmNlcnQsXG4gICAgY2E6IHRoaXMuY2EsXG4gICAgY2lwaGVyczogdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVyc1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCl7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uKHBhY2tldCl7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSlcbiAgICAsIGZhaWxlZCA9IGZhbHNlXG4gICAgLCBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuKCl7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09IG1zZy50eXBlICYmICdwcm9iZScgPT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCl7XG4gICAgb25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlKCl7XG4gICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSh0byl7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy9SZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAoKXtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcblxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYuZW1pdCgncGluZycpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIGNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogQ2FsbGJhY2tzIGNvdW50LlxuICovXG5cbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcbiAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgIHNlbGYub25EYXRhKG1zZyk7XG4gIH0pO1xuXG4gIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJyxlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJysgc2VsZi5pZnJhbWVJZCArJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiIsIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5KCl7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUihvcHRzKXtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHxcbiAgICAgIHBvcnQgIT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24ob3B0cyl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGZuKXtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3Qob3B0cyl7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIGRvbmUgYWZ0ZXIgb3BlbiBiZWNhdXNlIEZpcmVmb3ggaXMgc3R1cGlkXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMjE2OTAzL2dldC1iaW5hcnktZGF0YS13aXRoLXhtbGh0dHByZXF1ZXN0LWluLWEtZmlyZWZveC1leHRlbnNpb25cbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIH1cblxuICAgIGlmICgnUE9TVCcgPT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09IHhoci5zdGF0dXMgfHwgMTIyMyA9PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlYnVnKCd4aHIgZGF0YSAlcycsIHRoaXMuZGF0YSk7XG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbihmcm9tRXJyb3Ipe1xuICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2goZSkge31cbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbigpe1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLnNwbGl0KCc7JylbMF07XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdmFyIHVpOEFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB2YXIgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gdWk4QXJyLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2godWk4QXJyW2lkeF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGFBcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcbiAgUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xudmFyIEJyb3dzZXJXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cblxuICB0aGlzLndzID0gQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2J1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldil7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5pZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9O1xufVxuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoIUJyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy90aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUoKXtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MylcbiAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaChlKSB7IH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBzdXBwb3J0c0JpbmFyeSkge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dGY4ZW5jb2RlKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJydcbiAgICAsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICBpICs9IG47XG4gICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoICE9ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgdmFyIG51bWJlclRvb0xvbmcgPSBmYWxzZTtcbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICBudW1iZXJUb29Mb25nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgaWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsInZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciByZUV4dGVuc2lvbiA9IC9eLipcXC4oXFx3KykkLztcbnZhciB0b0J1ZmZlciA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktdG8tYnVmZmVyJyk7XG5cbmZ1bmN0aW9uIEZpbGVSZWFkU3RyZWFtKGZpbGUsIG9wdHMpIHtcbiAgdmFyIHJlYWRTdHJlYW0gPSB0aGlzO1xuICBpZiAoISAodGhpcyBpbnN0YW5jZW9mIEZpbGVSZWFkU3RyZWFtKSkge1xuICAgIHJldHVybiBuZXcgRmlsZVJlYWRTdHJlYW0oZmlsZSwgb3B0cyk7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgLy8gaW5oZXJpdCByZWFkYWJsZVxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIC8vIHNhdmUgdGhlIHJlYWQgb2Zmc2V0XG4gIHRoaXMuX29mZnNldCA9IDA7XG4gIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gIHRoaXMuX2ZpbGUgPSBmaWxlO1xuICB0aGlzLl9zaXplID0gZmlsZS5zaXplO1xuICB0aGlzLl9jaHVua1NpemUgPSBvcHRzLmNodW5rU2l6ZSB8fCBNYXRoLm1heCh0aGlzLl9zaXplIC8gMTAwMCwgMjAwICogMTAyNCk7XG5cbiAgLy8gY3JlYXRlIHRoZSByZWFkZXJcbiAgdGhpcy5yZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gIC8vIGdlbmVyYXRlIHRoZSBoZWFkZXIgYmxvY2tzIHRoYXQgd2Ugd2lsbCBzZW5kIGFzIHBhcnQgb2YgdGhlIGluaXRpYWwgcGF5bG9hZFxuICB0aGlzLl9nZW5lcmF0ZUhlYWRlckJsb2NrcyhmaWxlLCBvcHRzLCBmdW5jdGlvbihlcnIsIGJsb2Nrcykge1xuICAgIC8vIGlmIHdlIGVuY291bnRlcmVkIGFuIGVycm9yLCBlbWl0IGl0XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cblxuICAgIC8vIHB1c2ggdGhlIGhlYWRlciBibG9ja3Mgb3V0IHRvIHRoZSBzdHJlYW1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9ja3MpKSB7XG4gICAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgcmVhZFN0cmVhbS5wdXNoKGJsb2NrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlYWRTdHJlYW0uX3JlYWR5ID0gdHJ1ZTtcbiAgICByZWFkU3RyZWFtLmVtaXQoJ19yZWFkeScpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoRmlsZVJlYWRTdHJlYW0sIFJlYWRhYmxlKTtcbm1vZHVsZS5leHBvcnRzID0gRmlsZVJlYWRTdHJlYW07XG5cbkZpbGVSZWFkU3RyZWFtLnByb3RvdHlwZS5fZ2VuZXJhdGVIZWFkZXJCbG9ja3MgPSBmdW5jdGlvbihmaWxlLCBvcHRzLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCBbXSk7XG59O1xuXG5GaWxlUmVhZFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgIHRoaXMub25jZSgnX3JlYWR5JywgdGhpcy5fcmVhZC5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlYWRTdHJlYW0gPSB0aGlzO1xuICB2YXIgcmVhZGVyID0gdGhpcy5yZWFkZXI7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICB2YXIgZW5kT2Zmc2V0ID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5fY2h1bmtTaXplO1xuICBpZiAoZW5kT2Zmc2V0ID4gdGhpcy5fc2l6ZSkgZW5kT2Zmc2V0ID0gdGhpcy5fc2l6ZTtcblxuICBpZiAoc3RhcnRPZmZzZXQgPT09IHRoaXMuX3NpemUpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgc3RyZWFtIG9mZnNldFxuICAgIHJlYWRTdHJlYW0uX29mZnNldCA9IGVuZE9mZnNldDtcblxuICAgIC8vIGdldCB0aGUgZGF0YSBjaHVua1xuICAgIHJlYWRTdHJlYW0ucHVzaCh0b0J1ZmZlcihyZWFkZXIucmVzdWx0KSk7XG4gIH1cbiAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgcmVhZGVyLmVycm9yKTtcbiAgfVxuXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih0aGlzLl9maWxlLnNsaWNlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpKTtcbn07XG5cbkZpbGVSZWFkU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZpbGUgPSBudWxsO1xuICBpZiAodGhpcy5yZWFkZXIpIHtcbiAgICB0aGlzLnJlYWRlci5vbmxvYWQgPSBudWxsO1xuICAgIHRoaXMucmVhZGVyLm9uZXJyb3IgPSBudWxsO1xuICAgIHRyeSB7IHRoaXMucmVhZGVyLmFib3J0KCk7IH0gY2F0Y2ggKGUpIHt9O1xuICB9XG4gIHRoaXMucmVhZGVyID0gbnVsbDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxhdHRlbihsaXN0LCBkZXB0aCkge1xuICBkZXB0aCA9ICh0eXBlb2YgZGVwdGggPT0gJ251bWJlcicpID8gZGVwdGggOiBJbmZpbml0eTtcblxuICBpZiAoIWRlcHRoKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gX2ZsYXR0ZW4obGlzdCwgMSk7XG5cbiAgZnVuY3Rpb24gX2ZsYXR0ZW4obGlzdCwgZCkge1xuICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSAmJiBkIDwgZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoX2ZsYXR0ZW4oaXRlbSwgZCArIDEpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChpdGVtKTtcbiAgICAgIH1cbiAgICB9LCBbXSk7XG4gIH1cbn07XG4iLCIvLyBvcmlnaW5hbGx5IHB1bGxlZCBvdXQgb2Ygc2ltcGxlLXBlZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCcm93c2VyUlRDICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbFxuICB2YXIgd3J0YyA9IHtcbiAgICBSVENQZWVyQ29ubmVjdGlvbjogd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLFxuICAgIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fFxuICAgICAgd2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICAgIFJUQ0ljZUNhbmRpZGF0ZTogd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cubW96UlRDSWNlQ2FuZGlkYXRlIHx8XG4gICAgICB3aW5kb3cud2Via2l0UlRDSWNlQ2FuZGlkYXRlXG4gIH1cbiAgaWYgKCF3cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSByZXR1cm4gbnVsbFxuICByZXR1cm4gd3J0Y1xufVxuIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICAgICAgaWYgKG9iai50b0pTT04gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygb2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCJ2YXIgaGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0cywgYmFzZSkge1xuICAgIGlmICghYmFzZSkgYmFzZSA9IDE2O1xuICAgIGlmIChiaXRzID09PSB1bmRlZmluZWQpIGJpdHMgPSAxMjg7XG4gICAgaWYgKGJpdHMgPD0gMCkgcmV0dXJuICcwJztcbiAgICBcbiAgICB2YXIgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cykpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGRpZ2l0cyA9PT0gSW5maW5pdHk7IGkgKj0gMikge1xuICAgICAgICBkaWdpdHMgPSBNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzIC8gaSkpIC8gTWF0aC5sb2coYmFzZSkgKiBpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcmVtID0gZGlnaXRzIC0gTWF0aC5mbG9vcihkaWdpdHMpO1xuICAgIFxuICAgIHZhciByZXMgPSAnJztcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguZmxvb3IoZGlnaXRzKTsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZW0pIHtcbiAgICAgICAgdmFyIGIgPSBNYXRoLnBvdyhiYXNlLCByZW0pO1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGIpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQocmVzLCBiYXNlKTtcbiAgICBpZiAocGFyc2VkICE9PSBJbmZpbml0eSAmJiBwYXJzZWQgPj0gTWF0aC5wb3coMiwgYml0cykpIHtcbiAgICAgICAgcmV0dXJuIGhhdChiaXRzLCBiYXNlKVxuICAgIH1cbiAgICBlbHNlIHJldHVybiByZXM7XG59O1xuXG5oYXQucmFjayA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlLCBleHBhbmRCeSkge1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBpdGVycyA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpdGVycyArKyA+IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEJ5KSBiaXRzICs9IGV4cGFuZEJ5O1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCd0b28gbWFueSBJRCBjb2xsaXNpb25zLCB1c2UgbW9yZSBiaXRzJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGlkID0gaGF0KGJpdHMsIGJhc2UpO1xuICAgICAgICB9IHdoaWxlIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChoYXRzLCBpZCkpO1xuICAgICAgICBcbiAgICAgICAgaGF0c1tpZF0gPSBkYXRhO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICB2YXIgaGF0cyA9IGZuLmhhdHMgPSB7fTtcbiAgICBcbiAgICBmbi5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZuLmhhdHNbaWRdO1xuICAgIH07XG4gICAgXG4gICAgZm4uc2V0ID0gZnVuY3Rpb24gKGlkLCB2YWx1ZSkge1xuICAgICAgICBmbi5oYXRzW2lkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBcbiAgICBmbi5iaXRzID0gYml0cyB8fCAxMjg7XG4gICAgZm4uYmFzZSA9IGJhc2UgfHwgMTY7XG4gICAgcmV0dXJuIGZuO1xufTtcbiIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG52YXIgaHR0cHMgPSBtb2R1bGUuZXhwb3J0cztcblxuZm9yICh2YXIga2V5IGluIGh0dHApIHtcbiAgICBpZiAoaHR0cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBodHRwc1trZXldID0gaHR0cFtrZXldO1xufTtcblxuaHR0cHMucmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIHBhcmFtcy5zY2hlbWUgPSAnaHR0cHMnO1xuICAgIHBhcmFtcy5wcm90b2NvbCA9ICdodHRwczonO1xuICAgIHJldHVybiBodHRwLnJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKTtcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBJbW1lZGlhdGVTdG9yZVxuXG5mdW5jdGlvbiBJbW1lZGlhdGVTdG9yZSAoc3RvcmUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEltbWVkaWF0ZVN0b3JlKSkgcmV0dXJuIG5ldyBJbW1lZGlhdGVTdG9yZShzdG9yZSlcblxuICB0aGlzLnN0b3JlID0gc3RvcmVcbiAgdGhpcy5jaHVua0xlbmd0aCA9IHN0b3JlLmNodW5rTGVuZ3RoXG5cbiAgaWYgKCF0aGlzLnN0b3JlIHx8ICF0aGlzLnN0b3JlLmdldCB8fCAhdGhpcy5zdG9yZS5wdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYWJzdHJhY3QtY2h1bmstc3RvcmUgY29tcGxpYW50JylcbiAgfVxuXG4gIHRoaXMubWVtID0gW11cbn1cblxuSW1tZWRpYXRlU3RvcmUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChpbmRleCwgYnVmLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5tZW1baW5kZXhdID0gYnVmXG4gIHNlbGYuc3RvcmUucHV0KGluZGV4LCBidWYsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm1lbVtpbmRleF0gPSBudWxsXG4gICAgaWYgKGNiKSBjYihlcnIpXG4gIH0pXG59XG5cbkltbWVkaWF0ZVN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZ2V0KGluZGV4LCBudWxsLCBvcHRzKVxuXG4gIHZhciBzdGFydCA9IChvcHRzICYmIG9wdHMub2Zmc2V0KSB8fCAwXG4gIHZhciBlbmQgPSBvcHRzICYmIG9wdHMubGVuZ3RoICYmIChzdGFydCArIG9wdHMubGVuZ3RoKVxuXG4gIHZhciBidWYgPSB0aGlzLm1lbVtpbmRleF1cbiAgaWYgKGJ1ZikgcmV0dXJuIG5leHRUaWNrKGNiLCBudWxsLCBvcHRzID8gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpIDogYnVmKVxuXG4gIHRoaXMuc3RvcmUuZ2V0KGluZGV4LCBvcHRzLCBjYilcbn1cblxuSW1tZWRpYXRlU3RvcmUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gIHRoaXMuc3RvcmUuY2xvc2UoY2IpXG59XG5cbkltbWVkaWF0ZVN0b3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHRoaXMuc3RvcmUuZGVzdHJveShjYilcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBlcnIsIHZhbCkge1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIGNiKGVyciwgdmFsKVxuICB9KVxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgZXhwYW5kSVB2NiwgaXBhZGRyLCBpcHY0UGFydCwgaXB2NFJlZ2V4ZXMsIGlwdjZQYXJ0LCBpcHY2UmVnZXhlcywgbWF0Y2hDSURSLCByb290O1xuXG4gIGlwYWRkciA9IHt9O1xuXG4gIHJvb3QgPSB0aGlzO1xuXG4gIGlmICgodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUgIT09IG51bGwpICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpcGFkZHI7XG4gIH0gZWxzZSB7XG4gICAgcm9vdFsnaXBhZGRyJ10gPSBpcGFkZHI7XG4gIH1cblxuICBtYXRjaENJRFIgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kLCBwYXJ0U2l6ZSwgY2lkckJpdHMpIHtcbiAgICB2YXIgcGFydCwgc2hpZnQ7XG4gICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBjYW5ub3QgbWF0Y2ggQ0lEUiBmb3Igb2JqZWN0cyB3aXRoIGRpZmZlcmVudCBsZW5ndGhzXCIpO1xuICAgIH1cbiAgICBwYXJ0ID0gMDtcbiAgICB3aGlsZSAoY2lkckJpdHMgPiAwKSB7XG4gICAgICBzaGlmdCA9IHBhcnRTaXplIC0gY2lkckJpdHM7XG4gICAgICBpZiAoc2hpZnQgPCAwKSB7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdFtwYXJ0XSA+PiBzaGlmdCAhPT0gc2Vjb25kW3BhcnRdID4+IHNoaWZ0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNpZHJCaXRzIC09IHBhcnRTaXplO1xuICAgICAgcGFydCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBpcGFkZHIuc3VibmV0TWF0Y2ggPSBmdW5jdGlvbihhZGRyZXNzLCByYW5nZUxpc3QsIGRlZmF1bHROYW1lKSB7XG4gICAgdmFyIHJhbmdlTmFtZSwgcmFuZ2VTdWJuZXRzLCBzdWJuZXQsIF9pLCBfbGVuO1xuICAgIGlmIChkZWZhdWx0TmFtZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0TmFtZSA9ICd1bmljYXN0JztcbiAgICB9XG4gICAgZm9yIChyYW5nZU5hbWUgaW4gcmFuZ2VMaXN0KSB7XG4gICAgICByYW5nZVN1Ym5ldHMgPSByYW5nZUxpc3RbcmFuZ2VOYW1lXTtcbiAgICAgIGlmIChyYW5nZVN1Ym5ldHNbMF0gJiYgIShyYW5nZVN1Ym5ldHNbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcmFuZ2VTdWJuZXRzID0gW3JhbmdlU3VibmV0c107XG4gICAgICB9XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHJhbmdlU3VibmV0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBzdWJuZXQgPSByYW5nZVN1Ym5ldHNbX2ldO1xuICAgICAgICBpZiAoYWRkcmVzcy5tYXRjaC5hcHBseShhZGRyZXNzLCBzdWJuZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdE5hbWU7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSVB2NChvY3RldHMpIHtcbiAgICAgIHZhciBvY3RldCwgX2ksIF9sZW47XG4gICAgICBpZiAob2N0ZXRzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGlwdjQgb2N0ZXQgY291bnQgc2hvdWxkIGJlIDRcIik7XG4gICAgICB9XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9jdGV0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvY3RldCA9IG9jdGV0c1tfaV07XG4gICAgICAgIGlmICghKCgwIDw9IG9jdGV0ICYmIG9jdGV0IDw9IDI1NSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBpcHY0IG9jdGV0IHNob3VsZCBmaXQgaW4gOCBiaXRzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9jdGV0cyA9IG9jdGV0cztcbiAgICB9XG5cbiAgICBJUHY0LnByb3RvdHlwZS5raW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ2lwdjQnO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2N0ZXRzLmpvaW4oXCIuXCIpO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2N0ZXRzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKG90aGVyLCBjaWRyUmFuZ2UpIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKGNpZHJSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9yZWYgPSBvdGhlciwgb3RoZXIgPSBfcmVmWzBdLCBjaWRyUmFuZ2UgPSBfcmVmWzFdO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyLmtpbmQoKSAhPT0gJ2lwdjQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogY2Fubm90IG1hdGNoIGlwdjQgYWRkcmVzcyB3aXRoIG5vbi1pcHY0IG9uZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaENJRFIodGhpcy5vY3RldHMsIG90aGVyLm9jdGV0cywgOCwgY2lkclJhbmdlKTtcbiAgICB9O1xuXG4gICAgSVB2NC5wcm90b3R5cGUuU3BlY2lhbFJhbmdlcyA9IHtcbiAgICAgIHVuc3BlY2lmaWVkOiBbW25ldyBJUHY0KFswLCAwLCAwLCAwXSksIDhdXSxcbiAgICAgIGJyb2FkY2FzdDogW1tuZXcgSVB2NChbMjU1LCAyNTUsIDI1NSwgMjU1XSksIDMyXV0sXG4gICAgICBtdWx0aWNhc3Q6IFtbbmV3IElQdjQoWzIyNCwgMCwgMCwgMF0pLCA0XV0sXG4gICAgICBsaW5rTG9jYWw6IFtbbmV3IElQdjQoWzE2OSwgMjU0LCAwLCAwXSksIDE2XV0sXG4gICAgICBsb29wYmFjazogW1tuZXcgSVB2NChbMTI3LCAwLCAwLCAwXSksIDhdXSxcbiAgICAgIFwicHJpdmF0ZVwiOiBbW25ldyBJUHY0KFsxMCwgMCwgMCwgMF0pLCA4XSwgW25ldyBJUHY0KFsxNzIsIDE2LCAwLCAwXSksIDEyXSwgW25ldyBJUHY0KFsxOTIsIDE2OCwgMCwgMF0pLCAxNl1dLFxuICAgICAgcmVzZXJ2ZWQ6IFtbbmV3IElQdjQoWzE5MiwgMCwgMCwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMTkyLCAwLCAyLCAwXSksIDI0XSwgW25ldyBJUHY0KFsxOTIsIDg4LCA5OSwgMF0pLCAyNF0sIFtuZXcgSVB2NChbMTk4LCA1MSwgMTAwLCAwXSksIDI0XSwgW25ldyBJUHY0KFsyMDMsIDAsIDExMywgMF0pLCAyNF0sIFtuZXcgSVB2NChbMjQwLCAwLCAwLCAwXSksIDRdXVxuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlwYWRkci5zdWJuZXRNYXRjaCh0aGlzLCB0aGlzLlNwZWNpYWxSYW5nZXMpO1xuICAgIH07XG5cbiAgICBJUHY0LnByb3RvdHlwZS50b0lQdjRNYXBwZWRBZGRyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLklQdjYucGFyc2UoXCI6OmZmZmY6XCIgKyAodGhpcy50b1N0cmluZygpKSk7XG4gICAgfTtcblxuICAgIElQdjQucHJvdG90eXBlLnByZWZpeExlbmd0aEZyb21TdWJuZXRNYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2lkciwgaSwgb2N0ZXQsIHN0b3AsIHplcm9zLCB6ZXJvdGFibGUsIF9pO1xuICAgICAgemVyb3RhYmxlID0ge1xuICAgICAgICAwOiA4LFxuICAgICAgICAxMjg6IDcsXG4gICAgICAgIDE5MjogNixcbiAgICAgICAgMjI0OiA1LFxuICAgICAgICAyNDA6IDQsXG4gICAgICAgIDI0ODogMyxcbiAgICAgICAgMjUyOiAyLFxuICAgICAgICAyNTQ6IDEsXG4gICAgICAgIDI1NTogMFxuICAgICAgfTtcbiAgICAgIGNpZHIgPSAwO1xuICAgICAgc3RvcCA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gX2kgPSAzOyBfaSA+PSAwOyBpID0gX2kgKz0gLTEpIHtcbiAgICAgICAgb2N0ZXQgPSB0aGlzLm9jdGV0c1tpXTtcbiAgICAgICAgaWYgKG9jdGV0IGluIHplcm90YWJsZSkge1xuICAgICAgICAgIHplcm9zID0gemVyb3RhYmxlW29jdGV0XTtcbiAgICAgICAgICBpZiAoc3RvcCAmJiB6ZXJvcyAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh6ZXJvcyAhPT0gOCkge1xuICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNpZHIgKz0gemVyb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAzMiAtIGNpZHI7XG4gICAgfTtcblxuICAgIHJldHVybiBJUHY0O1xuXG4gIH0pKCk7XG5cbiAgaXB2NFBhcnQgPSBcIigwP1xcXFxkK3wweFthLWYwLTldKylcIjtcblxuICBpcHY0UmVnZXhlcyA9IHtcbiAgICBmb3VyT2N0ZXQ6IG5ldyBSZWdFeHAoXCJeXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiJFwiLCAnaScpLFxuICAgIGxvbmdWYWx1ZTogbmV3IFJlZ0V4cChcIl5cIiArIGlwdjRQYXJ0ICsgXCIkXCIsICdpJylcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5wYXJzZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2gsIHBhcnNlSW50QXV0bywgcGFydCwgc2hpZnQsIHZhbHVlO1xuICAgIHBhcnNlSW50QXV0byA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZ1swXSA9PT0gXCIwXCIgJiYgc3RyaW5nWzFdICE9PSBcInhcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCA4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChzdHJpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLmZvdXJPY3RldCkpIHtcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBtYXRjaC5zbGljZSgxLCA2KTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VJbnRBdXRvKHBhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaXB2NFJlZ2V4ZXMubG9uZ1ZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBwYXJzZUludEF1dG8obWF0Y2hbMV0pO1xuICAgICAgaWYgKHZhbHVlID4gMHhmZmZmZmZmZiB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBhZGRyZXNzIG91dHNpZGUgZGVmaW5lZCByYW5nZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHNoaWZ0ID0gX2kgPSAwOyBfaSA8PSAyNDsgc2hpZnQgPSBfaSArPSA4KSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCgodmFsdWUgPj4gc2hpZnQpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSkucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgaXBhZGRyLklQdjYgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSVB2NihwYXJ0cykge1xuICAgICAgdmFyIGksIHBhcnQsIF9pLCBfaiwgX2xlbiwgX3JlZjtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDE2KSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gX2kgPSAwOyBfaSA8PSAxNDsgaSA9IF9pICs9IDIpIHtcbiAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goKHBhcnRzW2ldIDw8IDgpIHwgcGFydHNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBpcHY2IHBhcnQgY291bnQgc2hvdWxkIGJlIDggb3IgMTZcIik7XG4gICAgICB9XG4gICAgICBfcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjsgX2orKykge1xuICAgICAgICBwYXJ0ID0gX3JlZltfal07XG4gICAgICAgIGlmICghKCgwIDw9IHBhcnQgJiYgcGFydCA8PSAweGZmZmYpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogaXB2NiBwYXJ0IHNob3VsZCBmaXQgaW4gMTYgYml0c1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIElQdjYucHJvdG90eXBlLmtpbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnaXB2Nic7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcGFjdFN0cmluZ1BhcnRzLCBwYXJ0LCBwdXNoUGFydCwgc3RhdGUsIHN0cmluZ1BhcnRzLCBfaSwgX2xlbjtcbiAgICAgIHN0cmluZ1BhcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcGFydCA9IF9yZWZbX2ldO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFydC50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICBjb21wYWN0U3RyaW5nUGFydHMgPSBbXTtcbiAgICAgIHB1c2hQYXJ0ID0gZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gY29tcGFjdFN0cmluZ1BhcnRzLnB1c2gocGFydCk7XG4gICAgICB9O1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzdHJpbmdQYXJ0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gc3RyaW5nUGFydHNbX2ldO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcwJykge1xuICAgICAgICAgICAgICBwdXNoUGFydCgnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwdXNoUGFydChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHVzaFBhcnQocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgIHB1c2hQYXJ0KCcnKTtcbiAgICAgICAgICAgICAgcHVzaFBhcnQocGFydCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHB1c2hQYXJ0KHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IDIpIHtcbiAgICAgICAgcHVzaFBhcnQoJycpO1xuICAgICAgICBwdXNoUGFydCgnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGFjdFN0cmluZ1BhcnRzLmpvaW4oXCI6XCIpO1xuICAgIH07XG5cbiAgICBJUHY2LnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJ5dGVzLCBwYXJ0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGJ5dGVzID0gW107XG4gICAgICBfcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gX3JlZltfaV07XG4gICAgICAgIGJ5dGVzLnB1c2gocGFydCA+PiA4KTtcbiAgICAgICAgYnl0ZXMucHVzaChwYXJ0ICYgMHhmZik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnRvTm9ybWFsaXplZFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcnQ7XG4gICAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMucGFydHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcnQgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnQudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpKS5qb2luKFwiOlwiKTtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihvdGhlciwgY2lkclJhbmdlKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmIChjaWRyUmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgICBfcmVmID0gb3RoZXIsIG90aGVyID0gX3JlZlswXSwgY2lkclJhbmdlID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlci5raW5kKCkgIT09ICdpcHY2Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IGNhbm5vdCBtYXRjaCBpcHY2IGFkZHJlc3Mgd2l0aCBub24taXB2NiBvbmVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hDSURSKHRoaXMucGFydHMsIG90aGVyLnBhcnRzLCAxNiwgY2lkclJhbmdlKTtcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUuU3BlY2lhbFJhbmdlcyA9IHtcbiAgICAgIHVuc3BlY2lmaWVkOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTI4XSxcbiAgICAgIGxpbmtMb2NhbDogW25ldyBJUHY2KFsweGZlODAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTBdLFxuICAgICAgbXVsdGljYXN0OiBbbmV3IElQdjYoWzB4ZmYwMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCA4XSxcbiAgICAgIGxvb3BiYWNrOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDFdKSwgMTI4XSxcbiAgICAgIHVuaXF1ZUxvY2FsOiBbbmV3IElQdjYoWzB4ZmMwMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCA3XSxcbiAgICAgIGlwdjRNYXBwZWQ6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMCwgMHhmZmZmLCAwLCAwXSksIDk2XSxcbiAgICAgIHJmYzYxNDU6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMHhmZmZmLCAwLCAwLCAwXSksIDk2XSxcbiAgICAgIHJmYzYwNTI6IFtuZXcgSVB2NihbMHg2NCwgMHhmZjliLCAwLCAwLCAwLCAwLCAwLCAwXSksIDk2XSxcbiAgICAgICc2dG80JzogW25ldyBJUHY2KFsweDIwMDIsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTZdLFxuICAgICAgdGVyZWRvOiBbbmV3IElQdjYoWzB4MjAwMSwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAzMl0sXG4gICAgICByZXNlcnZlZDogW1tuZXcgSVB2NihbMHgyMDAxLCAweGRiOCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAzMl1dXG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXBhZGRyLnN1Ym5ldE1hdGNoKHRoaXMsIHRoaXMuU3BlY2lhbFJhbmdlcyk7XG4gICAgfTtcblxuICAgIElQdjYucHJvdG90eXBlLmlzSVB2NE1hcHBlZEFkZHJlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlKCkgPT09ICdpcHY0TWFwcGVkJztcbiAgICB9O1xuXG4gICAgSVB2Ni5wcm90b3R5cGUudG9JUHY0QWRkcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhpZ2gsIGxvdywgX3JlZjtcbiAgICAgIGlmICghdGhpcy5pc0lQdjRNYXBwZWRBZGRyZXNzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0cnlpbmcgdG8gY29udmVydCBhIGdlbmVyaWMgaXB2NiBhZGRyZXNzIHRvIGlwdjRcIik7XG4gICAgICB9XG4gICAgICBfcmVmID0gdGhpcy5wYXJ0cy5zbGljZSgtMiksIGhpZ2ggPSBfcmVmWzBdLCBsb3cgPSBfcmVmWzFdO1xuICAgICAgcmV0dXJuIG5ldyBpcGFkZHIuSVB2NChbaGlnaCA+PiA4LCBoaWdoICYgMHhmZiwgbG93ID4+IDgsIGxvdyAmIDB4ZmZdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIElQdjY7XG5cbiAgfSkoKTtcblxuICBpcHY2UGFydCA9IFwiKD86WzAtOWEtZl0rOjo/KStcIjtcblxuICBpcHY2UmVnZXhlcyA9IHtcbiAgICBcIm5hdGl2ZVwiOiBuZXcgUmVnRXhwKFwiXig6Oik/KFwiICsgaXB2NlBhcnQgKyBcIik/KFswLTlhLWZdKyk/KDo6KT8kXCIsICdpJyksXG4gICAgdHJhbnNpdGlvbmFsOiBuZXcgUmVnRXhwKChcIl4oKD86XCIgKyBpcHY2UGFydCArIFwiKXwoPzo6OikoPzpcIiArIGlwdjZQYXJ0ICsgXCIpPylcIikgKyAoXCJcIiArIGlwdjRQYXJ0ICsgXCJcXFxcLlwiICsgaXB2NFBhcnQgKyBcIlxcXFwuXCIgKyBpcHY0UGFydCArIFwiXFxcXC5cIiArIGlwdjRQYXJ0ICsgXCIkXCIpLCAnaScpXG4gIH07XG5cbiAgZXhwYW5kSVB2NiA9IGZ1bmN0aW9uKHN0cmluZywgcGFydHMpIHtcbiAgICB2YXIgY29sb25Db3VudCwgbGFzdENvbG9uLCBwYXJ0LCByZXBsYWNlbWVudCwgcmVwbGFjZW1lbnRDb3VudDtcbiAgICBpZiAoc3RyaW5nLmluZGV4T2YoJzo6JykgIT09IHN0cmluZy5sYXN0SW5kZXhPZignOjonKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbG9uQ291bnQgPSAwO1xuICAgIGxhc3RDb2xvbiA9IC0xO1xuICAgIHdoaWxlICgobGFzdENvbG9uID0gc3RyaW5nLmluZGV4T2YoJzonLCBsYXN0Q29sb24gKyAxKSkgPj0gMCkge1xuICAgICAgY29sb25Db3VudCsrO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLnN1YnN0cigwLCAyKSA9PT0gJzo6Jykge1xuICAgICAgY29sb25Db3VudC0tO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nLnN1YnN0cigtMiwgMikgPT09ICc6OicpIHtcbiAgICAgIGNvbG9uQ291bnQtLTtcbiAgICB9XG4gICAgaWYgKGNvbG9uQ291bnQgPiBwYXJ0cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlcGxhY2VtZW50Q291bnQgPSBwYXJ0cyAtIGNvbG9uQ291bnQ7XG4gICAgcmVwbGFjZW1lbnQgPSAnOic7XG4gICAgd2hpbGUgKHJlcGxhY2VtZW50Q291bnQtLSkge1xuICAgICAgcmVwbGFjZW1lbnQgKz0gJzA6JztcbiAgICB9XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoJzo6JywgcmVwbGFjZW1lbnQpO1xuICAgIGlmIChzdHJpbmdbMF0gPT09ICc6Jykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJzonKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSBzdHJpbmcuc3BsaXQoXCI6XCIpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gX3JlZltfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpO1xuICB9O1xuXG4gIGlwYWRkci5JUHY2LnBhcnNlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBtYXRjaCwgb2N0ZXQsIG9jdGV0cywgcGFydHMsIF9pLCBfbGVuO1xuICAgIGlmIChzdHJpbmcubWF0Y2goaXB2NlJlZ2V4ZXNbJ25hdGl2ZSddKSkge1xuICAgICAgcmV0dXJuIGV4cGFuZElQdjYoc3RyaW5nLCA4KTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzWyd0cmFuc2l0aW9uYWwnXSkpIHtcbiAgICAgIHBhcnRzID0gZXhwYW5kSVB2NihtYXRjaFsxXS5zbGljZSgwLCAtMSksIDYpO1xuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIG9jdGV0cyA9IFtwYXJzZUludChtYXRjaFsyXSksIHBhcnNlSW50KG1hdGNoWzNdKSwgcGFyc2VJbnQobWF0Y2hbNF0pLCBwYXJzZUludChtYXRjaFs1XSldO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9jdGV0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIG9jdGV0ID0gb2N0ZXRzW19pXTtcbiAgICAgICAgICBpZiAoISgoMCA8PSBvY3RldCAmJiBvY3RldCA8PSAyNTUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2gob2N0ZXRzWzBdIDw8IDggfCBvY3RldHNbMV0pO1xuICAgICAgICBwYXJ0cy5wdXNoKG9jdGV0c1syXSA8PCA4IHwgb2N0ZXRzWzNdKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc0lQdjQgPSBpcGFkZHIuSVB2Ni5pc0lQdjYgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZXIoc3RyaW5nKSAhPT0gbnVsbDtcbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGU7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyB0aGlzKHRoaXMucGFyc2VyKHN0cmluZykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlID0gX2Vycm9yO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2NC5pc1ZhbGlkRm91clBhcnREZWNpbWFsID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKGlwYWRkci5JUHY0LmlzVmFsaWQoc3RyaW5nKSAmJiBzdHJpbmcubWF0Y2goL15cXGQrKFxcLlxcZCspezN9JC8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuSVB2Ni5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIgJiYgc3RyaW5nLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbmV3IHRoaXModGhpcy5wYXJzZXIoc3RyaW5nKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGUgPSBfZXJyb3I7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGlwYWRkci5JUHY0LnBhcnNlID0gaXBhZGRyLklQdjYucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcGFydHM7XG4gICAgcGFydHMgPSB0aGlzLnBhcnNlcihzdHJpbmcpO1xuICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiBzdHJpbmcgaXMgbm90IGZvcm1hdHRlZCBsaWtlIGlwIGFkZHJlc3NcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhwYXJ0cyk7XG4gIH07XG5cbiAgaXBhZGRyLklQdjQucGFyc2VDSURSID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIG1hc2tMZW5ndGgsIG1hdGNoO1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiguKylcXC8oXFxkKykkLykpIHtcbiAgICAgIG1hc2tMZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICBpZiAobWFza0xlbmd0aCA+PSAwICYmIG1hc2tMZW5ndGggPD0gMzIpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnBhcnNlKG1hdGNoWzFdKSwgbWFza0xlbmd0aF07XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImlwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBhbiBJUHY0IENJRFIgcmFuZ2VcIik7XG4gIH07XG5cbiAgaXBhZGRyLklQdjYucGFyc2VDSURSID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIG1hc2tMZW5ndGgsIG1hdGNoO1xuICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiguKylcXC8oXFxkKykkLykpIHtcbiAgICAgIG1hc2tMZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICBpZiAobWFza0xlbmd0aCA+PSAwICYmIG1hc2tMZW5ndGggPD0gMTI4KSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5wYXJzZShtYXRjaFsxXSksIG1hc2tMZW5ndGhdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHN0cmluZyBpcyBub3QgZm9ybWF0dGVkIGxpa2UgYW4gSVB2NiBDSURSIHJhbmdlXCIpO1xuICB9O1xuXG4gIGlwYWRkci5pc1ZhbGlkID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGlwYWRkci5JUHY2LmlzVmFsaWQoc3RyaW5nKSB8fCBpcGFkZHIuSVB2NC5pc1ZhbGlkKHN0cmluZyk7XG4gIH07XG5cbiAgaXBhZGRyLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKGlwYWRkci5JUHY2LmlzVmFsaWQoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlKHN0cmluZyk7XG4gICAgfSBlbHNlIGlmIChpcGFkZHIuSVB2NC5pc1ZhbGlkKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBpcGFkZHIuSVB2NC5wYXJzZShzdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpcGFkZHI6IHRoZSBhZGRyZXNzIGhhcyBuZWl0aGVyIElQdjYgbm9yIElQdjQgZm9ybWF0XCIpO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIucGFyc2VDSURSID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIGUgPSBfZXJyb3I7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXBhZGRyLklQdjQucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0aGUgYWRkcmVzcyBoYXMgbmVpdGhlciBJUHY2IG5vciBJUHY0IENJRFIgZm9ybWF0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpcGFkZHIuZnJvbUJ5dGVBcnJheSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgdmFyIGxlbmd0aDtcbiAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIG5ldyBpcGFkZHIuSVB2NChieXRlcyk7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPT09IDE2KSB7XG4gICAgICByZXR1cm4gbmV3IGlwYWRkci5JUHY2KGJ5dGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXBhZGRyOiB0aGUgYmluYXJ5IGlucHV0IGlzIG5laXRoZXIgYW4gSVB2NiBub3IgSVB2NCBhZGRyZXNzXCIpO1xuICAgIH1cbiAgfTtcblxuICBpcGFkZHIucHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBhZGRyO1xuICAgIGFkZHIgPSB0aGlzLnBhcnNlKHN0cmluZyk7XG4gICAgaWYgKGFkZHIua2luZCgpID09PSAnaXB2NicgJiYgYWRkci5pc0lQdjRNYXBwZWRBZGRyZXNzKCkpIHtcbiAgICAgIHJldHVybiBhZGRyLnRvSVB2NEFkZHJlc3MoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZHI7XG4gICAgfVxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLyogKGMpIDIwMTYgQXJpIFBvcmFkIChAYXJpcG9yYWQpIDxodHRwOi8vYXJpcG9yYWQuY29tPi4gTGljZW5zZTogYXJpcG9yYWQubWl0LWxpY2Vuc2Uub3JnICovXG5cbi8vIFBhcnRpYWxseSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk0MDQ5LzE5Mjg0ODQsIGFuZCBmcm9tIGFub3RoZXIgU08gYW5zd2VyLCB3aGljaCB0b2xkIG1lIHRoYXQgdGhlIGhpZ2hlc3Rcbi8vIGNoYXIgY29kZSB0aGF0J3MgYXNjaWkgaXMgMTI3LCBidXQgSSBjYW4ndCBmaW5kIHRoZSBsaW5rIGZvci4gU29ycnkuXG5cbnZhciBNQVhfQVNDSUlfQ0hBUl9DT0RFID0gMTI3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXNjaWkoc3RyKSB7XG4gIGZvciAodmFyIGkgPSAwLCBzdHJMZW4gPSBzdHIubGVuZ3RoOyBpIDwgc3RyTGVuOyArK2kpIHtcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPiBNQVhfQVNDSUlfQ0hBUl9DT0RFKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIEJ1ZmZlclxuICpcbiAqIEF1dGhvcjogICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCBpcy1idWZmZXJgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJlxuICAgIChvYmouX2lzQnVmZmVyIHx8IC8vIEZvciBTYWZhcmkgNS03IChtaXNzaW5nIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAob2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSlcbiAgICApKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRmlsZShwYXRoLCBjYil7XG4gIGlmKCFjYilyZXR1cm4gaXNGaWxlU3luYyhwYXRoKTtcblxuICBmcy5zdGF0KHBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdHMpe1xuICAgIGlmKGVycilyZXR1cm4gY2IoZXJyKTtcbiAgICByZXR1cm4gY2IobnVsbCwgc3RhdHMuaXNGaWxlKCkpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBpc0ZpbGVTeW5jO1xuXG5mdW5jdGlvbiBpc0ZpbGVTeW5jKHBhdGgpe1xuICByZXR1cm4gZnMuZXhpc3RzU3luYyhwYXRoKSAmJiBmcy5zdGF0U3luYyhwYXRoKS5pc0ZpbGUoKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzICAgICAgPSBpc1R5cGVkQXJyYXlcbmlzVHlwZWRBcnJheS5zdHJpY3QgPSBpc1N0cmljdFR5cGVkQXJyYXlcbmlzVHlwZWRBcnJheS5sb29zZSAgPSBpc0xvb3NlVHlwZWRBcnJheVxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgbmFtZXMgPSB7XG4gICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBJbnQxNkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBJbnQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50OEFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDE2QXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShhcnIpIHtcbiAgcmV0dXJuIChcbiAgICAgICBpc1N0cmljdFR5cGVkQXJyYXkoYXJyKVxuICAgIHx8IGlzTG9vc2VUeXBlZEFycmF5KGFycilcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1N0cmljdFR5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgICAgYXJyIGluc3RhbmNlb2YgSW50OEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgSW50MTZBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEludDMyQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50MTZBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG4gIClcbn1cblxuZnVuY3Rpb24gaXNMb29zZVR5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiBuYW1lc1t0b1N0cmluZy5jYWxsKGFycildXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gLy8gQWxsXG4vLyAvXm5wbS1kZWJ1Z1xcLmxvZyQvLCAgIC8vIG5wbSBlcnJvciBsb2dcbi8vIC9eXFwuLipcXC5zd3AkLywgICAgICAgIC8vIHZpbSBzdGF0ZVxuLy8gLy8gbWFjT1Ncbi8vIC9eXFwuRFNfU3RvcmUkLywgICAgICAgLy8gc3RvcmVzIGN1c3RvbSBmb2xkZXIgYXR0cmlidXRlc1xuLy8gL15cXC5BcHBsZURvdWJsZSQvLCAgICAvLyBzdG9yZXMgYWRkaXRpb25hbCBmaWxlIHJlc291cmNlc1xuLy8gL15cXC5MU092ZXJyaWRlJC8sICAgICAvLyBjb250YWlucyB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgYXBwIHRvIGJlIHVzZWRcbi8vIC9eSWNvblxcciQvLCAgICAgICAgICAgLy8gY3VzdG9tIEZpbmRlciBpY29uOiBodHRwOi8vc3VwZXJ1c2VyLmNvbS9xdWVzdGlvbnMvMjk4Nzg1L2ljb24tZmlsZS1vbi1vcy14LWRlc2t0b3Bcbi8vIC9eXFwuXy4qLywgICAgICAgICAgICAgLy8gdGh1bWJuYWlsXG4vLyAvXlxcLlNwb3RsaWdodC1WMTAwJC8sICAvLyBmaWxlIHRoYXQgbWlnaHQgYXBwZWFyIG9uIGV4dGVybmFsIGRpc2tcbi8vIC9cXC5UcmFzaGVzLywgICAgICAgICAgLy8gZmlsZSB0aGF0IG1pZ2h0IGFwcGVhciBvbiBleHRlcm5hbCBkaXNrXG4vLyAvXl9fTUFDT1NYJC8sICAgICAgICAgLy8gcmVzb3VyY2UgZm9ya1xuLy8gLy8gTGludXhcbi8vIC9+JC8sICAgICAgICAgICAgICAgICAvLyBiYWNrdXAgZmlsZVxuLy8gLy8gV2luZG93c1xuLy8gL15UaHVtYnNcXC5kYiQvLCAgICAgICAvLyBpbWFnZSBmaWxlIGNhY2hlXG4vLyAvXmVodGh1bWJzXFwuZGIkLywgICAgIC8vIGZvbGRlciBjb25maWcgZmlsZVxuLy8gL15EZXNrdG9wXFwuaW5pJC8gICAgICAvLyBzdG9yZXMgY3VzdG9tIGZvbGRlciBhdHRyaWJ1dGVzXG5cbmV4cG9ydHMucmUgPSAvXm5wbS1kZWJ1Z1xcLmxvZyR8XlxcLi4qXFwuc3dwJHxeXFwuRFNfU3RvcmUkfF5cXC5BcHBsZURvdWJsZSR8XlxcLkxTT3ZlcnJpZGUkfF5JY29uXFxyJHxeXFwuXy4qfF5cXC5TcG90bGlnaHQtVjEwMCR8XFwuVHJhc2hlc3xeX19NQUNPU1gkfH4kfF5UaHVtYnNcXC5kYiR8XmVodGh1bWJzXFwuZGIkfF5EZXNrdG9wXFwuaW5pJC87XG5cbmV4cG9ydHMuaXMgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcblx0cmV0dXJuIGV4cG9ydHMucmUudGVzdChmaWxlbmFtZSk7XG59O1xuXG5leHBvcnRzLm5vdCA9IGV4cG9ydHMuaXNudCA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuXHRyZXR1cm4gIWV4cG9ydHMuaXMoZmlsZW5hbWUpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gbWFnbmV0VVJJRGVjb2RlXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBtYWduZXRVUklEZWNvZGVcbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IG1hZ25ldFVSSUVuY29kZVxuXG52YXIgYmFzZTMyID0gcmVxdWlyZSgndGhpcnR5LXR3bycpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcblxuLyoqXG4gKiBQYXJzZSBhIG1hZ25ldCBVUkkgYW5kIHJldHVybiBhbiBvYmplY3Qgb2Yga2V5cy92YWx1ZXNcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVyaVxuICogQHJldHVybiB7T2JqZWN0fSBwYXJzZWQgdXJpXG4gKi9cbmZ1bmN0aW9uIG1hZ25ldFVSSURlY29kZSAodXJpKSB7XG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIC8vIFN1cHBvcnQgJ21hZ25ldDonIGFuZCAnc3RyZWFtLW1hZ25ldDonIHVyaXNcbiAgdmFyIGRhdGEgPSB1cmkuc3BsaXQoJ21hZ25ldDo/JylbMV1cblxuICB2YXIgcGFyYW1zID0gKGRhdGEgJiYgZGF0YS5sZW5ndGggPj0gMClcbiAgICA/IGRhdGEuc3BsaXQoJyYnKVxuICAgIDogW11cblxuICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIga2V5dmFsID0gcGFyYW0uc3BsaXQoJz0nKVxuXG4gICAgLy8gVGhpcyBrZXl2YWwgaXMgaW52YWxpZCwgc2tpcCBpdFxuICAgIGlmIChrZXl2YWwubGVuZ3RoICE9PSAyKSByZXR1cm5cblxuICAgIHZhciBrZXkgPSBrZXl2YWxbMF1cbiAgICB2YXIgdmFsID0ga2V5dmFsWzFdXG5cbiAgICAvLyBDbGVhbiB1cCB0b3JyZW50IG5hbWVcbiAgICBpZiAoa2V5ID09PSAnZG4nKSB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQodmFsKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuXG4gICAgLy8gQWRkcmVzcyB0cmFja2VyICh0ciksIGV4YWN0IHNvdXJjZSAoeHMpLCBhbmQgYWNjZXB0YWJsZSBzb3VyY2UgKGFzKSBhcmUgZW5jb2RlZFxuICAgIC8vIFVSSXMsIHNvIGRlY29kZSB0aGVtXG4gICAgaWYgKGtleSA9PT0gJ3RyJyB8fCBrZXkgPT09ICd4cycgfHwga2V5ID09PSAnYXMnIHx8IGtleSA9PT0gJ3dzJykge1xuICAgICAgdmFsID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbClcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4ga2V5d29yZHMgYXMgYW4gYXJyYXlcbiAgICBpZiAoa2V5ID09PSAna3QnKSB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQodmFsKS5zcGxpdCgnKycpXG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgcmVwZWF0ZWQgcGFyYW1ldGVycywgcmV0dXJuIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgIGlmIChyZXN1bHRba2V5XSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9sZCA9IHJlc3VsdFtrZXldXG4gICAgICAgIHJlc3VsdFtrZXldID0gW29sZCwgdmFsXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbFxuICAgIH1cbiAgfSlcblxuICAvLyBDb252ZW5pZW5jZSBwcm9wZXJ0aWVzIGZvciBwYXJpdHkgd2l0aCBgcGFyc2UtdG9ycmVudC1maWxlYCBtb2R1bGVcbiAgdmFyIG1cbiAgaWYgKHJlc3VsdC54dCkge1xuICAgIHZhciB4dHMgPSBBcnJheS5pc0FycmF5KHJlc3VsdC54dCkgPyByZXN1bHQueHQgOiBbIHJlc3VsdC54dCBdXG4gICAgeHRzLmZvckVhY2goZnVuY3Rpb24gKHh0KSB7XG4gICAgICBpZiAoKG0gPSB4dC5tYXRjaCgvXnVybjpidGloOiguezQwfSkvKSkpIHtcbiAgICAgICAgcmVzdWx0LmluZm9IYXNoID0gbVsxXS50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2UgaWYgKChtID0geHQubWF0Y2goL151cm46YnRpaDooLnszMn0pLykpKSB7XG4gICAgICAgIHZhciBkZWNvZGVkU3RyID0gYmFzZTMyLmRlY29kZShtWzFdKVxuICAgICAgICByZXN1bHQuaW5mb0hhc2ggPSBuZXcgQnVmZmVyKGRlY29kZWRTdHIsICdiaW5hcnknKS50b1N0cmluZygnaGV4JylcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGlmIChyZXN1bHQuaW5mb0hhc2gpIHJlc3VsdC5pbmZvSGFzaEJ1ZmZlciA9IG5ldyBCdWZmZXIocmVzdWx0LmluZm9IYXNoLCAnaGV4JylcblxuICBpZiAocmVzdWx0LmRuKSByZXN1bHQubmFtZSA9IHJlc3VsdC5kblxuICBpZiAocmVzdWx0Lmt0KSByZXN1bHQua2V5d29yZHMgPSByZXN1bHQua3RcblxuICBpZiAodHlwZW9mIHJlc3VsdC50ciA9PT0gJ3N0cmluZycpIHJlc3VsdC5hbm5vdW5jZSA9IFsgcmVzdWx0LnRyIF1cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQudHIpKSByZXN1bHQuYW5ub3VuY2UgPSByZXN1bHQudHJcbiAgZWxzZSByZXN1bHQuYW5ub3VuY2UgPSBbXVxuXG4gIHJlc3VsdC51cmxMaXN0ID0gW11cbiAgaWYgKHR5cGVvZiByZXN1bHQuYXMgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkocmVzdWx0LmFzKSkge1xuICAgIHJlc3VsdC51cmxMaXN0ID0gcmVzdWx0LnVybExpc3QuY29uY2F0KHJlc3VsdC5hcylcbiAgfVxuICBpZiAodHlwZW9mIHJlc3VsdC53cyA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQud3MpKSB7XG4gICAgcmVzdWx0LnVybExpc3QgPSByZXN1bHQudXJsTGlzdC5jb25jYXQocmVzdWx0LndzKVxuICB9XG5cbiAgdW5pcShyZXN1bHQuYW5ub3VuY2UpXG4gIHVuaXEocmVzdWx0LnVybExpc3QpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBtYWduZXRVUklFbmNvZGUgKG9iaikge1xuICBvYmogPSBleHRlbmQob2JqKSAvLyBjbG9uZSBvYmosIHNvIHdlIGNhbiBtdXRhdGUgaXRcblxuICAvLyBzdXBwb3J0IHVzaW5nIGNvbnZlbmllbmNlIG5hbWVzLCBpbiBhZGRpdGlvbiB0byBzcGVjIG5hbWVzXG4gIC8vIChleGFtcGxlOiBgaW5mb0hhc2hgIGZvciBgeHRgLCBgbmFtZWAgZm9yIGBkbmApXG4gIGlmIChvYmouaW5mb0hhc2hCdWZmZXIpIG9iai54dCA9ICd1cm46YnRpaDonICsgb2JqLmluZm9IYXNoQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICBpZiAob2JqLmluZm9IYXNoKSBvYmoueHQgPSAndXJuOmJ0aWg6JyArIG9iai5pbmZvSGFzaFxuICBpZiAob2JqLm5hbWUpIG9iai5kbiA9IG9iai5uYW1lXG4gIGlmIChvYmoua2V5d29yZHMpIG9iai5rdCA9IG9iai5rZXl3b3Jkc1xuICBpZiAob2JqLmFubm91bmNlKSBvYmoudHIgPSBvYmouYW5ub3VuY2VcbiAgaWYgKG9iai51cmxMaXN0KSB7XG4gICAgb2JqLndzID0gb2JqLnVybExpc3RcbiAgICBkZWxldGUgb2JqLmFzXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJ21hZ25ldDo/J1xuICBPYmplY3Qua2V5cyhvYmopXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMlxuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgdmFyIHZhbHVlcyA9IEFycmF5LmlzQXJyYXkob2JqW2tleV0pID8gb2JqW2tleV0gOiBbIG9ialtrZXldIF1cbiAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGopIHtcbiAgICAgICAgaWYgKChpID4gMCB8fCBqID4gMCkgJiYgKGtleSAhPT0gJ2t0JyB8fCBqID09PSAwKSkgcmVzdWx0ICs9ICcmJ1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdkbicpIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLnJlcGxhY2UoLyUyMC9nLCAnKycpXG4gICAgICAgIGlmIChrZXkgPT09ICd0cicgfHwga2V5ID09PSAneHMnIHx8IGtleSA9PT0gJ2FzJyB8fCBrZXkgPT09ICd3cycpIHtcbiAgICAgICAgICB2YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsKVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdrdCcpIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpXG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2t0JyAmJiBqID4gMCkgcmVzdWx0ICs9ICcrJyArIHZhbFxuICAgICAgICBlbHNlIHJlc3VsdCArPSBrZXkgKyAnPScgKyB2YWxcbiAgICAgIH0pXG4gICAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE1lZGlhRWxlbWVudFdyYXBwZXJcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgdG9BcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ3RvLWFycmF5YnVmZmVyJylcblxudmFyIE1lZGlhU291cmNlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1lZGlhU291cmNlXG5cbnZhciBERUZBVUxUX0JVRkZFUl9EVVJBVElPTiA9IDYwIC8vIHNlY29uZHNcblxuZnVuY3Rpb24gTWVkaWFFbGVtZW50V3JhcHBlciAoZWxlbSwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIE1lZGlhRWxlbWVudFdyYXBwZXIpKSByZXR1cm4gbmV3IE1lZGlhRWxlbWVudFdyYXBwZXIoZWxlbSwgb3B0cylcblxuICBpZiAoIU1lZGlhU291cmNlKSB0aHJvdyBuZXcgRXJyb3IoJ3dlYiBicm93c2VyIGxhY2tzIE1lZGlhU291cmNlIHN1cHBvcnQnKVxuXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHNlbGYuX2J1ZmZlckR1cmF0aW9uID0gb3B0cy5idWZmZXJEdXJhdGlvbiB8fCBERUZBVUxUX0JVRkZFUl9EVVJBVElPTlxuICBzZWxmLl9lbGVtID0gZWxlbVxuICBzZWxmLl9tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpXG4gIHNlbGYuX3N0cmVhbXMgPSBbXVxuICBzZWxmLmRldGFpbGVkRXJyb3IgPSBudWxsXG5cbiAgc2VsZi5fZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckhhbmRsZXIpXG4gICAgdmFyIHN0cmVhbXMgPSBzZWxmLl9zdHJlYW1zLnNsaWNlKClcbiAgICBzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgc3RyZWFtLmRlc3Ryb3koc2VsZi5fZWxlbS5lcnJvcilcbiAgICB9KVxuICB9XG4gIHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckhhbmRsZXIpXG5cbiAgc2VsZi5fZWxlbS5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzZWxmLl9tZWRpYVNvdXJjZSlcbn1cblxuLypcbiAqIGBvYmpgIGNhbiBiZSBhIHByZXZpb3VzIHZhbHVlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb25cbiAqIG9yIGEgc3RyaW5nXG4gKi9cbk1lZGlhRWxlbWVudFdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICByZXR1cm4gbmV3IE1lZGlhU291cmNlU3RyZWFtKHNlbGYsIG9iailcbn1cblxuLypcbiAqIFVzZSB0byB0cmlnZ2VyIGFuIGVycm9yIG9uIHRoZSB1bmRlcmx5aW5nIG1lZGlhIGVsZW1lbnRcbiAqL1xuTWVkaWFFbGVtZW50V3JhcHBlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIGJlIGNhcmVmdWwgbm90IHRvIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgZGV0YWlsZWRFcnJvciB2YWx1ZXNcbiAgaWYgKCFzZWxmLmRldGFpbGVkRXJyb3IpIHtcbiAgICBzZWxmLmRldGFpbGVkRXJyb3IgPSBlcnJcbiAgfVxuICB0cnkge1xuICAgIHNlbGYuX21lZGlhU291cmNlLmVuZE9mU3RyZWFtKCdkZWNvZGUnKVxuICB9IGNhdGNoIChlcnIpIHt9XG59XG5cbmluaGVyaXRzKE1lZGlhU291cmNlU3RyZWFtLCBzdHJlYW0uV3JpdGFibGUpXG5cbmZ1bmN0aW9uIE1lZGlhU291cmNlU3RyZWFtICh3cmFwcGVyLCBvYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cbiAgc2VsZi5fd3JhcHBlciA9IHdyYXBwZXJcbiAgc2VsZi5fZWxlbSA9IHdyYXBwZXIuX2VsZW1cbiAgc2VsZi5fbWVkaWFTb3VyY2UgPSB3cmFwcGVyLl9tZWRpYVNvdXJjZVxuICBzZWxmLl9hbGxTdHJlYW1zID0gd3JhcHBlci5fc3RyZWFtc1xuICBzZWxmLl9hbGxTdHJlYW1zLnB1c2goc2VsZilcbiAgc2VsZi5fYnVmZmVyRHVyYXRpb24gPSB3cmFwcGVyLl9idWZmZXJEdXJhdGlvblxuICBzZWxmLl9zb3VyY2VCdWZmZXIgPSBudWxsXG5cbiAgc2VsZi5fb3BlbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25Tb3VyY2VPcGVuKClcbiAgfVxuICBzZWxmLl9mbG93SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9mbG93KClcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHNlbGYuX3R5cGUgPSBvYmpcbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBzb3VyY2VCdWZmZXJcbiAgICBpZiAoc2VsZi5fbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICBzZWxmLl9jcmVhdGVTb3VyY2VCdWZmZXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2VsZi5fb3BlbkhhbmRsZXIpXG4gICAgfVxuICB9IGVsc2UgaWYgKG9iai5fc291cmNlQnVmZmVyID09PSBudWxsKSB7XG4gICAgb2JqLmRlc3Ryb3koKVxuICAgIHNlbGYuX3R5cGUgPSBvYmouX3R5cGUgLy8gVGhlIG9sZCBzdHJlYW0gd2FzIGNyZWF0ZWQgYnV0IGhhc24ndCBmaW5pc2hlZCBpbml0aWFsaXppbmdcbiAgICBzZWxmLl9tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2VsZi5fb3BlbkhhbmRsZXIpXG4gIH0gZWxzZSBpZiAob2JqLl9zb3VyY2VCdWZmZXIpIHtcbiAgICBvYmouZGVzdHJveSgpXG4gICAgc2VsZi5fdHlwZSA9IG9iai5fdHlwZVxuICAgIHNlbGYuX3NvdXJjZUJ1ZmZlciA9IG9iai5fc291cmNlQnVmZmVyIC8vIENvcHkgb3ZlciB0aGUgb2xkIHNvdXJjZUJ1ZmZlclxuICAgIHNlbGYuX3NvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCBzZWxmLl9mbG93SGFuZGxlcilcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhcmd1bWVudCB0byBNZWRpYUVsZW1lbnRXcmFwcGVyLmNyZWF0ZVdyaXRlU3RyZWFtIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBwcmV2aW91cyBzdHJlYW0gcmV0dXJuZWQgZnJvbSB0aGF0IGZ1bmN0aW9uJylcbiAgfVxuXG4gIHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHNlbGYuX2Zsb3dIYW5kbGVyKVxuXG4gIHNlbGYub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX3dyYXBwZXIuZXJyb3IoZXJyKVxuICB9KVxuXG4gIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNlbGYuX2ZpbmlzaGVkID0gdHJ1ZVxuICAgIGlmIChzZWxmLl9hbGxTdHJlYW1zLmV2ZXJ5KGZ1bmN0aW9uIChvdGhlcikgeyByZXR1cm4gb3RoZXIuX2ZpbmlzaGVkIH0pKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLl9tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgfVxuICB9KVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX29uU291cmNlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHNlbGYuX29wZW5IYW5kbGVyKVxuICBzZWxmLl9jcmVhdGVTb3VyY2VCdWZmZXIoKVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIC8vIFJlbW92ZSBmcm9tIGFsbFN0cmVhbXNcbiAgc2VsZi5fYWxsU3RyZWFtcy5zcGxpY2Uoc2VsZi5fYWxsU3RyZWFtcy5pbmRleE9mKHNlbGYpLCAxKVxuXG4gIHNlbGYuX21lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBzZWxmLl9vcGVuSGFuZGxlcilcbiAgc2VsZi5fZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gIGlmIChzZWxmLl9zb3VyY2VCdWZmZXIpIHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gICAgaWYgKHNlbGYuX21lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgc2VsZi5fc291cmNlQnVmZmVyLmFib3J0KClcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICBzZWxmLmVtaXQoJ2Nsb3NlJylcbn1cblxuTWVkaWFTb3VyY2VTdHJlYW0ucHJvdG90eXBlLl9jcmVhdGVTb3VyY2VCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmIChNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoc2VsZi5fdHlwZSkpIHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIgPSBzZWxmLl9tZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIoc2VsZi5fdHlwZSlcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgc2VsZi5fZmxvd0hhbmRsZXIpXG4gICAgaWYgKHNlbGYuX2NiKSB7XG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgfVxufVxuXG5NZWRpYVNvdXJjZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmICghc2VsZi5fc291cmNlQnVmZmVyKSB7XG4gICAgc2VsZi5fY2IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgc2VsZi5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYilcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi5fc291cmNlQnVmZmVyLnVwZGF0aW5nKSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ2Fubm90IGFwcGVuZCBidWZmZXIgd2hpbGUgc291cmNlIGJ1ZmZlciB1cGRhdGluZycpKVxuICB9XG5cbiAgdHJ5IHtcbiAgICBzZWxmLl9zb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyKHRvQXJyYXlCdWZmZXIoY2h1bmspKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBhcHBlbmRCdWZmZXIgY2FuIHRocm93IGZvciBhIG51bWJlciBvZiByZWFzb25zLCBtb3N0IG5vdGFibHkgd2hlbiB0aGUgZGF0YVxuICAgIC8vIGJlaW5nIGFwcGVuZGVkIGlzIGludmFsaWQgb3IgaWYgYXBwZW5kQnVmZmVyIGlzIGNhbGxlZCBhZnRlciBhbm90aGVyIGVycm9yXG4gICAgLy8gYWxyZWFkeSBvY2N1cnJlZCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gSW4gQ2hyb21lLCB0aGVyZSBtYXkgYmUgdXNlZnVsIGRlYnVnZ2luZ1xuICAgIC8vIGluZm8gaW4gY2hyb21lOi8vbWVkaWEtaW50ZXJuYWxzXG4gICAgc2VsZi5kZXN0cm95KGVycilcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLl9jYiA9IGNiXG59XG5cbk1lZGlhU291cmNlU3RyZWFtLnByb3RvdHlwZS5fZmxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuZGVzdHJveWVkIHx8ICFzZWxmLl9zb3VyY2VCdWZmZXIgfHwgc2VsZi5fc291cmNlQnVmZmVyLnVwZGF0aW5nKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi5fbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgLy8gY2hlY2sgYnVmZmVyIHNpemVcbiAgICBpZiAoc2VsZi5fZ2V0QnVmZmVyRHVyYXRpb24oKSA+IHNlbGYuX2J1ZmZlckR1cmF0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5fY2IpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgIHNlbGYuX2NiID0gbnVsbFxuICAgIGNiKClcbiAgfVxufVxuXG4vLyBUT0RPOiBpZiB6ZXJvIGFjdHVhbGx5IHdvcmtzIGluIGFsbCBicm93c2VycywgcmVtb3ZlIHRoZSBsb2dpYyBhc3NvY2lhdGVkIHdpdGggdGhpcyBiZWxvd1xudmFyIEVQU0lMT04gPSAwXG5cbk1lZGlhU291cmNlU3RyZWFtLnByb3RvdHlwZS5fZ2V0QnVmZmVyRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBidWZmZXJlZCA9IHNlbGYuX3NvdXJjZUJ1ZmZlci5idWZmZXJlZFxuICB2YXIgY3VycmVudFRpbWUgPSBzZWxmLl9lbGVtLmN1cnJlbnRUaW1lXG4gIHZhciBidWZmZXJFbmQgPSAtMSAvLyBlbmQgb2YgdGhlIGJ1ZmZlclxuICAvLyBUaGlzIGlzIGEgbGl0dGxlIG92ZXIgY29tcGxleCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgc2VlbSB0byBzZXBhcmF0ZSB0aGVcbiAgLy8gYnVmZmVyZWQgcmVnaW9uIGludG8gbXVsdGlwbGUgc2VjdGlvbnMgd2l0aCBzbGlnaHQgZ2Fwcy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpXG4gICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKSArIEVQU0lMT05cblxuICAgIGlmIChzdGFydCA+IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBSZWFjaGVkIHBhc3QgdGhlIGpvaW5lZCBidWZmZXJcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChidWZmZXJFbmQgPj0gMCB8fCBjdXJyZW50VGltZSA8PSBlbmQpIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBzdGFydC9jb250aW51YXRpb24gb2YgdGhlIGpvaW5lZCBidWZmZXJcbiAgICAgIGJ1ZmZlckVuZCA9IGVuZFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXJlZFRpbWUgPSBidWZmZXJFbmQgLSBjdXJyZW50VGltZVxuICBpZiAoYnVmZmVyZWRUaW1lIDwgMCkge1xuICAgIGJ1ZmZlcmVkVGltZSA9IDBcbiAgfVxuXG4gIHJldHVybiBidWZmZXJlZFRpbWVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gU3RvcmFnZVxuXG5mdW5jdGlvbiBTdG9yYWdlIChjaHVua0xlbmd0aCwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RvcmFnZSkpIHJldHVybiBuZXcgU3RvcmFnZShjaHVua0xlbmd0aCwgb3B0cylcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB0aGlzLmNodW5rTGVuZ3RoID0gTnVtYmVyKGNodW5rTGVuZ3RoKVxuICBpZiAoIXRoaXMuY2h1bmtMZW5ndGgpIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNodW5rIGxlbmd0aCcpXG5cbiAgdGhpcy5jaHVua3MgPSBbXVxuICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gIHRoaXMubGVuZ3RoID0gTnVtYmVyKG9wdHMubGVuZ3RoKSB8fCBJbmZpbml0eVxuXG4gIGlmICh0aGlzLmxlbmd0aCAhPT0gSW5maW5pdHkpIHtcbiAgICB0aGlzLmxhc3RDaHVua0xlbmd0aCA9ICh0aGlzLmxlbmd0aCAlIHRoaXMuY2h1bmtMZW5ndGgpIHx8IHRoaXMuY2h1bmtMZW5ndGhcbiAgICB0aGlzLmxhc3RDaHVua0luZGV4ID0gTWF0aC5jZWlsKHRoaXMubGVuZ3RoIC8gdGhpcy5jaHVua0xlbmd0aCkgLSAxXG4gIH1cbn1cblxuU3RvcmFnZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGluZGV4LCBidWYsIGNiKSB7XG4gIGlmICh0aGlzLmNsb3NlZCkgcmV0dXJuIG5leHRUaWNrKGNiLCBuZXcgRXJyb3IoJ1N0b3JhZ2UgaXMgY2xvc2VkJykpXG5cbiAgdmFyIGlzTGFzdENodW5rID0gKGluZGV4ID09PSB0aGlzLmxhc3RDaHVua0luZGV4KVxuICBpZiAoaXNMYXN0Q2h1bmsgJiYgYnVmLmxlbmd0aCAhPT0gdGhpcy5sYXN0Q2h1bmtMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignTGFzdCBjaHVuayBsZW5ndGggbXVzdCBiZSAnICsgdGhpcy5sYXN0Q2h1bmtMZW5ndGgpKVxuICB9XG4gIGlmICghaXNMYXN0Q2h1bmsgJiYgYnVmLmxlbmd0aCAhPT0gdGhpcy5jaHVua0xlbmd0aCkge1xuICAgIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdDaHVuayBsZW5ndGggbXVzdCBiZSAnICsgdGhpcy5jaHVua0xlbmd0aCkpXG4gIH1cbiAgdGhpcy5jaHVua3NbaW5kZXhdID0gYnVmXG4gIG5leHRUaWNrKGNiLCBudWxsKVxufVxuXG5TdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZ2V0KGluZGV4LCBudWxsLCBvcHRzKVxuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdTdG9yYWdlIGlzIGNsb3NlZCcpKVxuICB2YXIgYnVmID0gdGhpcy5jaHVua3NbaW5kZXhdXG4gIGlmICghYnVmKSByZXR1cm4gbmV4dFRpY2soY2IsIG5ldyBFcnJvcignQ2h1bmsgbm90IGZvdW5kJykpXG4gIGlmICghb3B0cykgcmV0dXJuIG5leHRUaWNrKGNiLCBudWxsLCBidWYpXG4gIHZhciBvZmZzZXQgPSBvcHRzLm9mZnNldCB8fCAwXG4gIHZhciBsZW4gPSBvcHRzLmxlbmd0aCB8fCAoYnVmLmxlbmd0aCAtIG9mZnNldClcbiAgbmV4dFRpY2soY2IsIG51bGwsIGJ1Zi5zbGljZShvZmZzZXQsIGxlbiArIG9mZnNldCkpXG59XG5cblN0b3JhZ2UucHJvdG90eXBlLmNsb3NlID0gU3RvcmFnZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiBuZXh0VGljayhjYiwgbmV3IEVycm9yKCdTdG9yYWdlIGlzIGNsb3NlZCcpKVxuICB0aGlzLmNsb3NlZCA9IHRydWVcbiAgdGhpcy5jaHVua3MgPSBudWxsXG4gIG5leHRUaWNrKGNiLCBudWxsKVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGVyciwgdmFsKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikgY2IoZXJyLCB2YWwpXG4gIH0pXG59XG4iLCIvLyBUaGlzIGlzIGFuIGludGVudGlvbmFsbHkgcmVjdXJzaXZlIHJlcXVpcmUuIEkgZG9uJ3QgbGlrZSBpdCBlaXRoZXIuXG52YXIgQm94ID0gcmVxdWlyZSgnLi9pbmRleCcpXG52YXIgRGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vZGVzY3JpcHRvcicpXG5cbnZhciBUSU1FX09GRlNFVCA9IDIwODI4NDQ4MDAwMDBcblxuLypcblRPRE86XG50ZXN0IHRoZXNlXG5hZGQgbmV3IGJveCB2ZXJzaW9uc1xuKi9cblxuLy8gVGhlc2UgaGF2ZSAndmVyc2lvbicgYW5kICdmbGFncycgZmllbGRzIGluIHRoZSBoZWFkZXJzXG5leHBvcnRzLmZ1bGxCb3hlcyA9IHt9XG52YXIgZnVsbEJveGVzID0gW1xuICAnbXZoZCcsXG4gICd0a2hkJyxcbiAgJ21kaGQnLFxuICAndm1oZCcsXG4gICdzbWhkJyxcbiAgJ3N0c2QnLFxuICAnZXNkcycsXG4gICdzdHN6JyxcbiAgJ3N0Y28nLFxuICAnc3RzcycsXG4gICdzdHRzJyxcbiAgJ2N0dHMnLFxuICAnc3RzYycsXG4gICdkcmVmJyxcbiAgJ2Vsc3QnLFxuICAnaGRscicsXG4gICdtZWhkJyxcbiAgJ3RyZXgnLFxuICAnbWZoZCcsXG4gICd0ZmhkJyxcbiAgJ3RmZHQnLFxuICAndHJ1bidcbl1cbmZ1bGxCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIGV4cG9ydHMuZnVsbEJveGVzW3R5cGVdID0gdHJ1ZVxufSlcblxuZXhwb3J0cy5mdHlwID0ge31cbmV4cG9ydHMuZnR5cC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5mdHlwLmVuY29kaW5nTGVuZ3RoKGJveCkpXG4gIHZhciBicmFuZHMgPSBib3guY29tcGF0aWJsZUJyYW5kcyB8fCBbXVxuICBidWYud3JpdGUoYm94LmJyYW5kLCAwLCA0LCAnYXNjaWknKVxuICBidWYud3JpdGVVSW50MzJCRShib3guYnJhbmRWZXJzaW9uLCA0KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJyYW5kcy5sZW5ndGg7IGkrKykgYnVmLndyaXRlKGJyYW5kc1tpXSwgOCArIChpICogNCksIDQsICdhc2NpaScpXG4gIGV4cG9ydHMuZnR5cC5lbmNvZGUuYnl0ZXMgPSA4ICsgYnJhbmRzLmxlbmd0aCAqIDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5mdHlwLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgYnJhbmQgPSBidWYudG9TdHJpbmcoJ2FzY2lpJywgMCwgNClcbiAgdmFyIHZlcnNpb24gPSBidWYucmVhZFVJbnQzMkJFKDQpXG4gIHZhciBjb21wYXRpYmxlQnJhbmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDg7IGkgPCBidWYubGVuZ3RoOyBpICs9IDQpIGNvbXBhdGlibGVCcmFuZHMucHVzaChidWYudG9TdHJpbmcoJ2FzY2lpJywgaSwgaSArIDQpKVxuICByZXR1cm4ge1xuICAgIGJyYW5kOiBicmFuZCxcbiAgICBicmFuZFZlcnNpb246IHZlcnNpb24sXG4gICAgY29tcGF0aWJsZUJyYW5kczogY29tcGF0aWJsZUJyYW5kc1xuICB9XG59XG5leHBvcnRzLmZ0eXAuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA4ICsgKGJveC5jb21wYXRpYmxlQnJhbmRzIHx8IFtdKS5sZW5ndGggKiA0XG59XG5cbmV4cG9ydHMubXZoZCA9IHt9XG5leHBvcnRzLm12aGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDk2KVxuICB3cml0ZURhdGUoYm94LmN0aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgMClcbiAgd3JpdGVEYXRlKGJveC5tdGltZSB8fCBuZXcgRGF0ZSgpLCBidWYsIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50aW1lU2NhbGUgfHwgMCwgOClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmR1cmF0aW9uIHx8IDAsIDEyKVxuICB3cml0ZUZpeGVkMzIoYm94LnByZWZlcnJlZFJhdGUgfHwgMCwgYnVmLCAxNilcbiAgd3JpdGVGaXhlZDE2KGJveC5wcmVmZXJyZWRWb2x1bWUgfHwgMCwgYnVmLCAyMClcbiAgd3JpdGVSZXNlcnZlZChidWYsIDIyLCAzMilcbiAgd3JpdGVNYXRyaXgoYm94Lm1hdHJpeCwgYnVmLCAzMilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnByZXZpZXdUaW1lIHx8IDAsIDY4KVxuICBidWYud3JpdGVVSW50MzJCRShib3gucHJldmlld0R1cmF0aW9uIHx8IDAsIDcyKVxuICBidWYud3JpdGVVSW50MzJCRShib3gucG9zdGVyVGltZSB8fCAwLCA3NilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnNlbGVjdGlvblRpbWUgfHwgMCwgODApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zZWxlY3Rpb25EdXJhdGlvbiB8fCAwLCA4NClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmN1cnJlbnRUaW1lIHx8IDAsIDg4KVxuICBidWYud3JpdGVVSW50MzJCRShib3gubmV4dFRyYWNrSWQgfHwgMCwgOTIpXG4gIGV4cG9ydHMubXZoZC5lbmNvZGUuYnl0ZXMgPSA5NlxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm12aGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgY3RpbWU6IHJlYWREYXRlKGJ1ZiwgMCksXG4gICAgbXRpbWU6IHJlYWREYXRlKGJ1ZiwgNCksXG4gICAgdGltZVNjYWxlOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDEyKSxcbiAgICBwcmVmZXJyZWRSYXRlOiByZWFkRml4ZWQzMihidWYsIDE2KSxcbiAgICBwcmVmZXJyZWRWb2x1bWU6IHJlYWRGaXhlZDE2KGJ1ZiwgMjApLFxuICAgIG1hdHJpeDogcmVhZE1hdHJpeChidWYuc2xpY2UoMzIsIDY4KSksXG4gICAgcHJldmlld1RpbWU6IGJ1Zi5yZWFkVUludDMyQkUoNjgpLFxuICAgIHByZXZpZXdEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSg3MiksXG4gICAgcG9zdGVyVGltZTogYnVmLnJlYWRVSW50MzJCRSg3NiksXG4gICAgc2VsZWN0aW9uVGltZTogYnVmLnJlYWRVSW50MzJCRSg4MCksXG4gICAgc2VsZWN0aW9uRHVyYXRpb246IGJ1Zi5yZWFkVUludDMyQkUoODQpLFxuICAgIGN1cnJlbnRUaW1lOiBidWYucmVhZFVJbnQzMkJFKDg4KSxcbiAgICBuZXh0VHJhY2tJZDogYnVmLnJlYWRVSW50MzJCRSg5MilcbiAgfVxufVxuZXhwb3J0cy5tdmhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOTZcbn1cblxuZXhwb3J0cy50a2hkID0ge31cbmV4cG9ydHMudGtoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoODApXG4gIHdyaXRlRGF0ZShib3guY3RpbWUgfHwgbmV3IERhdGUoKSwgYnVmLCAwKVxuICB3cml0ZURhdGUoYm94Lm10aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRyYWNrSWQgfHwgMCwgOClcbiAgd3JpdGVSZXNlcnZlZChidWYsIDEyLCAxNilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmR1cmF0aW9uIHx8IDAsIDE2KVxuICB3cml0ZVJlc2VydmVkKGJ1ZiwgMjAsIDI4KVxuICBidWYud3JpdGVVSW50MTZCRShib3gubGF5ZXIgfHwgMCwgMjgpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5hbHRlcm5hdGVHcm91cCB8fCAwLCAzMClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LnZvbHVtZSB8fCAwLCAzMilcbiAgd3JpdGVNYXRyaXgoYm94Lm1hdHJpeCwgYnVmLCAzNilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRyYWNrV2lkdGggfHwgMCwgNzIpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja0hlaWdodCB8fCAwLCA3NilcbiAgZXhwb3J0cy50a2hkLmVuY29kZS5ieXRlcyA9IDgwXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudGtoZC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgcmV0dXJuIHtcbiAgICBjdGltZTogcmVhZERhdGUoYnVmLCAwKSxcbiAgICBtdGltZTogcmVhZERhdGUoYnVmLCA0KSxcbiAgICB0cmFja0lkOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDE2KSxcbiAgICBsYXllcjogYnVmLnJlYWRVSW50MTZCRSgyOCksXG4gICAgYWx0ZXJuYXRlR3JvdXA6IGJ1Zi5yZWFkVUludDE2QkUoMzApLFxuICAgIHZvbHVtZTogYnVmLnJlYWRVSW50MTZCRSgzMiksXG4gICAgbWF0cml4OiByZWFkTWF0cml4KGJ1Zi5zbGljZSgzNiwgNzIpKSxcbiAgICB0cmFja1dpZHRoOiBidWYucmVhZFVJbnQzMkJFKDcyKSxcbiAgICB0cmFja0hlaWdodDogYnVmLnJlYWRVSW50MzJCRSg3NilcbiAgfVxufVxuZXhwb3J0cy50a2hkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gODBcbn1cblxuZXhwb3J0cy5tZGhkID0ge31cbmV4cG9ydHMubWRoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoMjApXG4gIHdyaXRlRGF0ZShib3guY3RpbWUgfHwgbmV3IERhdGUoKSwgYnVmLCAwKVxuICB3cml0ZURhdGUoYm94Lm10aW1lIHx8IG5ldyBEYXRlKCksIGJ1ZiwgNClcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LnRpbWVTY2FsZSB8fCAwLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShib3guZHVyYXRpb24gfHwgMCwgMTIpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5sYW5ndWFnZSB8fCAwLCAxNilcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LnF1YWxpdHkgfHwgMCwgMTgpXG4gIGV4cG9ydHMubWRoZC5lbmNvZGUuYnl0ZXMgPSAyMFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1kaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgY3RpbWU6IHJlYWREYXRlKGJ1ZiwgMCksXG4gICAgbXRpbWU6IHJlYWREYXRlKGJ1ZiwgNCksXG4gICAgdGltZVNjYWxlOiBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKDEyKSxcbiAgICBsYW5ndWFnZTogYnVmLnJlYWRVSW50MTZCRSgxNiksXG4gICAgcXVhbGl0eTogYnVmLnJlYWRVSW50MTZCRSgxOClcbiAgfVxufVxuZXhwb3J0cy5tZGhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gMjBcbn1cblxuZXhwb3J0cy52bWhkID0ge31cbmV4cG9ydHMudm1oZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoOClcbiAgYnVmLndyaXRlVUludDE2QkUoYm94LmdyYXBoaWNzTW9kZSB8fCAwLCAwKVxuICB2YXIgb3Bjb2xvciA9IGJveC5vcGNvbG9yIHx8IFswLCAwLCAwXVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzBdLCAyKVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzFdLCA0KVxuICBidWYud3JpdGVVSW50MTZCRShvcGNvbG9yWzJdLCA2KVxuICBleHBvcnRzLnZtaGQuZW5jb2RlLmJ5dGVzID0gOFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnZtaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgZ3JhcGhpY3NNb2RlOiBidWYucmVhZFVJbnQxNkJFKDApLFxuICAgIG9wY29sb3I6IFtidWYucmVhZFVJbnQxNkJFKDIpLCBidWYucmVhZFVJbnQxNkJFKDQpLCBidWYucmVhZFVJbnQxNkJFKDYpXVxuICB9XG59XG5leHBvcnRzLnZtaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA4XG59XG5cbmV4cG9ydHMuc21oZCA9IHt9XG5leHBvcnRzLnNtaGQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDQpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5iYWxhbmNlIHx8IDAsIDApXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAyLCA0KVxuICBleHBvcnRzLnNtaGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLnNtaGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgYmFsYW5jZTogYnVmLnJlYWRVSW50MTZCRSgwKVxuICB9XG59XG5leHBvcnRzLnNtaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMuc3RzZCA9IHt9XG5leHBvcnRzLnN0c2QuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3RzZC5lbmNvZGluZ0xlbmd0aChib3gpKVxuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgdmFyIHB0ciA9IDRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXVxuICAgIEJveC5lbmNvZGUoZW50cnksIGJ1ZiwgcHRyKVxuICAgIHB0ciArPSBCb3guZW5jb2RlLmJ5dGVzXG4gIH1cblxuICBleHBvcnRzLnN0c2QuZW5jb2RlLmJ5dGVzID0gcHRyXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3RzZC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG4gIHZhciBwdHIgPSA0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBlbnRyeSA9IEJveC5kZWNvZGUoYnVmLCBwdHIsIGVuZClcbiAgICBlbnRyaWVzW2ldID0gZW50cnlcbiAgICBwdHIgKz0gZW50cnkubGVuZ3RoXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHNkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICB2YXIgdG90YWxTaXplID0gNFxuICBpZiAoIWJveC5lbnRyaWVzKSByZXR1cm4gdG90YWxTaXplXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94LmVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbFNpemUgKz0gQm94LmVuY29kaW5nTGVuZ3RoKGJveC5lbnRyaWVzW2ldKVxuICB9XG4gIHJldHVybiB0b3RhbFNpemVcbn1cblxuZXhwb3J0cy5hdmMxID0gZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeSA9IHt9XG5leHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcihleHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgd3JpdGVSZXNlcnZlZChidWYsIDAsIDYpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5kYXRhUmVmZXJlbmNlSW5kZXggfHwgMCwgNilcbiAgd3JpdGVSZXNlcnZlZChidWYsIDgsIDI0KVxuICBidWYud3JpdGVVSW50MTZCRShib3gud2lkdGggfHwgMCwgMjQpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5oZWlnaHQgfHwgMCwgMjYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5oUmVzb2x1dGlvbiB8fCAweDQ4MDAwMCwgMjgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC52UmVzb2x1dGlvbiB8fCAweDQ4MDAwMCwgMzIpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAzNiwgNDApXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5mcmFtZUNvdW50IHx8IDEsIDQwKVxuICB2YXIgY29tcHJlc3Nvck5hbWUgPSBib3guY29tcHJlc3Nvck5hbWUgfHwgJydcbiAgdmFyIG5hbWVMZW4gPSBNYXRoLm1pbihjb21wcmVzc29yTmFtZS5sZW5ndGgsIDMxKVxuICBidWYud3JpdGVVSW50OChuYW1lTGVuLCA0MilcbiAgYnVmLndyaXRlKGNvbXByZXNzb3JOYW1lLCA0MywgbmFtZUxlbiwgJ3V0ZjgnKVxuICBidWYud3JpdGVVSW50MTZCRShib3guZGVwdGggfHwgMHgxOCwgNzQpXG4gIGJ1Zi53cml0ZUludDE2QkUoLTEsIDc2KVxuXG4gIHZhciBwdHIgPSA3OFxuICB2YXIgY2hpbGRyZW4gPSBib3guY2hpbGRyZW4gfHwgW11cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBCb3guZW5jb2RlKGNoaWxkLCBidWYsIHB0cilcbiAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICB9KVxuICBleHBvcnRzLlZpc3VhbFNhbXBsZUVudHJ5LmVuY29kZS5ieXRlcyA9IHB0clxufVxuZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0XG4gIHZhciBuYW1lTGVuID0gTWF0aC5taW4oYnVmLnJlYWRVSW50OCg0MiksIDMxKVxuICB2YXIgYm94ID0ge1xuICAgIGRhdGFSZWZlcmVuY2VJbmRleDogYnVmLnJlYWRVSW50MTZCRSg2KSxcbiAgICB3aWR0aDogYnVmLnJlYWRVSW50MTZCRSgyNCksXG4gICAgaGVpZ2h0OiBidWYucmVhZFVJbnQxNkJFKDI2KSxcbiAgICBoUmVzb2x1dGlvbjogYnVmLnJlYWRVSW50MzJCRSgyOCksXG4gICAgdlJlc29sdXRpb246IGJ1Zi5yZWFkVUludDMyQkUoMzIpLFxuICAgIGZyYW1lQ291bnQ6IGJ1Zi5yZWFkVUludDE2QkUoNDApLFxuICAgIGNvbXByZXNzb3JOYW1lOiBidWYudG9TdHJpbmcoJ3V0ZjgnLCA0MywgNDMgKyBuYW1lTGVuKSxcbiAgICBkZXB0aDogYnVmLnJlYWRVSW50MTZCRSg3NCksXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cblxuICB2YXIgcHRyID0gNzhcbiAgd2hpbGUgKGxlbmd0aCAtIHB0ciA+PSA4KSB7XG4gICAgdmFyIGNoaWxkID0gQm94LmRlY29kZShidWYsIHB0ciwgbGVuZ3RoKVxuICAgIGJveC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIGJveFtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgcHRyICs9IGNoaWxkLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGJveFxufVxuZXhwb3J0cy5WaXN1YWxTYW1wbGVFbnRyeS5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIGxlbiA9IDc4XG4gIHZhciBjaGlsZHJlbiA9IGJveC5jaGlsZHJlbiB8fCBbXVxuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGxlbiArPSBCb3guZW5jb2RpbmdMZW5ndGgoY2hpbGQpXG4gIH0pXG4gIHJldHVybiBsZW5cbn1cblxuZXhwb3J0cy5hdmNDID0ge31cbmV4cG9ydHMuYXZjQy5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IEJ1ZmZlcihib3guYnVmZmVyLmxlbmd0aClcblxuICBib3guYnVmZmVyLmNvcHkoYnVmKVxuICBleHBvcnRzLmF2Y0MuZW5jb2RlLmJ5dGVzID0gYm94LmJ1ZmZlci5sZW5ndGhcbn1cbmV4cG9ydHMuYXZjQy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0LCBlbmQpXG5cbiAgcmV0dXJuIHtcbiAgICBtaW1lQ29kZWM6IGJ1Zi50b1N0cmluZygnaGV4JywgMSwgNCksXG4gICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1ZilcbiAgfVxufVxuZXhwb3J0cy5hdmNDLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gYm94LmJ1ZmZlci5sZW5ndGhcbn1cblxuZXhwb3J0cy5tcDRhID0gZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5ID0ge31cbmV4cG9ydHMuQXVkaW9TYW1wbGVFbnRyeS5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgd3JpdGVSZXNlcnZlZChidWYsIDAsIDYpXG4gIGJ1Zi53cml0ZVVJbnQxNkJFKGJveC5kYXRhUmVmZXJlbmNlSW5kZXggfHwgMCwgNilcbiAgd3JpdGVSZXNlcnZlZChidWYsIDgsIDE2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guY2hhbm5lbENvdW50IHx8IDIsIDE2KVxuICBidWYud3JpdGVVSW50MTZCRShib3guc2FtcGxlU2l6ZSB8fCAxNiwgMTgpXG4gIHdyaXRlUmVzZXJ2ZWQoYnVmLCAyMCwgMjQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zYW1wbGVSYXRlIHx8IDAsIDI0KVxuXG4gIHZhciBwdHIgPSAyOFxuICB2YXIgY2hpbGRyZW4gPSBib3guY2hpbGRyZW4gfHwgW11cbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBCb3guZW5jb2RlKGNoaWxkLCBidWYsIHB0cilcbiAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICB9KVxuICBleHBvcnRzLkF1ZGlvU2FtcGxlRW50cnkuZW5jb2RlLmJ5dGVzID0gcHRyXG59XG5leHBvcnRzLkF1ZGlvU2FtcGxlRW50cnkuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldCwgZW5kKVxuICB2YXIgbGVuZ3RoID0gZW5kIC0gb2Zmc2V0XG4gIHZhciBib3ggPSB7XG4gICAgZGF0YVJlZmVyZW5jZUluZGV4OiBidWYucmVhZFVJbnQxNkJFKDYpLFxuICAgIGNoYW5uZWxDb3VudDogYnVmLnJlYWRVSW50MTZCRSgxNiksXG4gICAgc2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MTZCRSgxOCksXG4gICAgc2FtcGxlUmF0ZTogYnVmLnJlYWRVSW50MzJCRSgyNCksXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cblxuICB2YXIgcHRyID0gMjhcbiAgd2hpbGUgKGxlbmd0aCAtIHB0ciA+PSA4KSB7XG4gICAgdmFyIGNoaWxkID0gQm94LmRlY29kZShidWYsIHB0ciwgbGVuZ3RoKVxuICAgIGJveC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIGJveFtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgcHRyICs9IGNoaWxkLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGJveFxufVxuZXhwb3J0cy5BdWRpb1NhbXBsZUVudHJ5LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICB2YXIgbGVuID0gMjhcbiAgdmFyIGNoaWxkcmVuID0gYm94LmNoaWxkcmVuIHx8IFtdXG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgfSlcbiAgcmV0dXJuIGxlblxufVxuXG5leHBvcnRzLmVzZHMgPSB7fVxuZXhwb3J0cy5lc2RzLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogQnVmZmVyKGJveC5idWZmZXIubGVuZ3RoKVxuXG4gIGJveC5idWZmZXIuY29weShidWYsIDApXG4gIGV4cG9ydHMuZXNkcy5lbmNvZGUuYnl0ZXMgPSBib3guYnVmZmVyLmxlbmd0aFxufVxuZXhwb3J0cy5lc2RzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgZW5kKSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQsIGVuZClcblxuICB2YXIgZGVzYyA9IERlc2NyaXB0b3IuRGVzY3JpcHRvci5kZWNvZGUoYnVmLCAwLCBidWYubGVuZ3RoKVxuICB2YXIgZXNkID0gKGRlc2MudGFnTmFtZSA9PT0gJ0VTRGVzY3JpcHRvcicpID8gZGVzYyA6IHt9XG4gIHZhciBkY2QgPSBlc2QuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IgfHwge31cbiAgdmFyIG90aSA9IGRjZC5vdGkgfHwgMFxuICB2YXIgZHNpID0gZGNkLkRlY29kZXJTcGVjaWZpY0luZm9cbiAgdmFyIGF1ZGlvQ29uZmlnID0gZHNpID8gKGRzaS5idWZmZXIucmVhZFVJbnQ4KDApICYgMHhmOCkgPj4gMyA6IDBcblxuICB2YXIgbWltZUNvZGVjID0gbnVsbFxuICBpZiAob3RpKSB7XG4gICAgbWltZUNvZGVjID0gb3RpLnRvU3RyaW5nKDE2KVxuICAgIGlmIChhdWRpb0NvbmZpZykge1xuICAgICAgbWltZUNvZGVjICs9ICcuJyArIGF1ZGlvQ29uZmlnXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW1lQ29kZWM6IG1pbWVDb2RlYyxcbiAgICBidWZmZXI6IG5ldyBCdWZmZXIoYnVmLnNsaWNlKDApKVxuICB9XG59XG5leHBvcnRzLmVzZHMuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiBib3guYnVmZmVyLmxlbmd0aFxufVxuXG4vLyBUT0RPOiBpbnRlZ3JhdGUgdGhlIHR3byB2ZXJzaW9ucyBpbiBhIHNhbmVyIHdheVxuZXhwb3J0cy5zdHN6ID0ge31cbmV4cG9ydHMuc3Rzei5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogQnVmZmVyKGV4cG9ydHMuc3Rzei5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCA0KVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0sIGkgKiA0ICsgOClcbiAgfVxuXG4gIGV4cG9ydHMuc3Rzei5lbmNvZGUuYnl0ZXMgPSA4ICsgZW50cmllcy5sZW5ndGggKiA0XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuc3Rzei5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIHNpemUgPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDQpXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIGVudHJpZXNbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0ICsgOClcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cmllc1tpXSA9IHNpemVcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHN6LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gOCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDRcbn1cblxuZXhwb3J0cy5zdHNzID1cbmV4cG9ydHMuc3RjbyA9IHt9XG5leHBvcnRzLnN0Y28uZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5zdGNvLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXSwgaSAqIDQgKyA0KVxuICB9XG5cbiAgZXhwb3J0cy5zdGNvLmVuY29kZS5ieXRlcyA9IDQgKyBlbnRyaWVzLmxlbmd0aCAqIDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdGNvLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGVudHJpZXNbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50cmllczogZW50cmllc1xuICB9XG59XG5leHBvcnRzLnN0Y28uZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0ICsgYm94LmVudHJpZXMubGVuZ3RoICogNFxufVxuXG5leHBvcnRzLnN0dHMgPSB7fVxuZXhwb3J0cy5zdHRzLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBlbnRyaWVzID0gYm94LmVudHJpZXMgfHwgW11cbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuc3R0cy5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXMubGVuZ3RoLCAwKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogOCArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmNvdW50IHx8IDAsIHB0cilcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmR1cmF0aW9uIHx8IDAsIHB0ciArIDQpXG4gIH1cblxuICBleHBvcnRzLnN0dHMuZW5jb2RlLmJ5dGVzID0gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDhcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdHRzLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogOCArIDRcbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgY291bnQ6IGJ1Zi5yZWFkVUludDMyQkUocHRyKSxcbiAgICAgIGR1cmF0aW9uOiBidWYucmVhZFVJbnQzMkJFKHB0ciArIDQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuc3R0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiA4XG59XG5cbmV4cG9ydHMuY3R0cyA9IHt9XG5leHBvcnRzLmN0dHMuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5jdHRzLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiA4ICsgNFxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uY291bnQgfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uY29tcG9zaXRpb25PZmZzZXQgfHwgMCwgcHRyICsgNClcbiAgfVxuXG4gIGV4cG9ydHMuY3R0cy5lbmNvZGUuYnl0ZXMgPSA0ICsgZW50cmllcy5sZW5ndGggKiA4XG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuY3R0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgcHRyID0gaSAqIDggKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIGNvdW50OiBidWYucmVhZFVJbnQzMkJFKHB0ciksXG4gICAgICBjb21wb3NpdGlvbk9mZnNldDogYnVmLnJlYWRJbnQzMkJFKHB0ciArIDQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuY3R0cy5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDQgKyBib3guZW50cmllcy5sZW5ndGggKiA4XG59XG5cbmV4cG9ydHMuc3RzYyA9IHt9XG5leHBvcnRzLnN0c2MuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5zdHNjLmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLmZpcnN0Q2h1bmsgfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0uc2FtcGxlc1BlckNodW5rIHx8IDAsIHB0ciArIDQpXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cmllc1tpXS5zYW1wbGVEZXNjcmlwdGlvbklkIHx8IDAsIHB0ciArIDgpXG4gIH1cblxuICBleHBvcnRzLnN0c2MuZW5jb2RlLmJ5dGVzID0gNCArIGVudHJpZXMubGVuZ3RoICogMTJcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy5zdHNjLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICB2YXIgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB2YXIgZW50cmllcyA9IG5ldyBBcnJheShudW0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHZhciBwdHIgPSBpICogMTIgKyA0XG4gICAgZW50cmllc1tpXSA9IHtcbiAgICAgIGZpcnN0Q2h1bms6IGJ1Zi5yZWFkVUludDMyQkUocHRyKSxcbiAgICAgIHNhbXBsZXNQZXJDaHVuazogYnVmLnJlYWRVSW50MzJCRShwdHIgKyA0KSxcbiAgICAgIHNhbXBsZURlc2NyaXB0aW9uSWQ6IGJ1Zi5yZWFkVUludDMyQkUocHRyICsgOClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5zdHNjLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDEyXG59XG5cbmV4cG9ydHMuZHJlZiA9IHt9XG5leHBvcnRzLmRyZWYuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuZHJlZi5lbmNvZGluZ0xlbmd0aChib3gpKVxuICB2YXIgZW50cmllcyA9IGJveC5lbnRyaWVzIHx8IFtdXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgdmFyIHB0ciA9IDRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXVxuICAgIHZhciBzaXplID0gKGVudHJ5LmJ1ZiA/IGVudHJ5LmJ1Zi5sZW5ndGggOiAwKSArIDQgKyA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShzaXplLCBwdHIpXG4gICAgcHRyICs9IDRcblxuICAgIGJ1Zi53cml0ZShlbnRyeS50eXBlLCBwdHIsIDQsICdhc2NpaScpXG4gICAgcHRyICs9IDRcblxuICAgIGlmIChlbnRyeS5idWYpIHtcbiAgICAgIGVudHJ5LmJ1Zi5jb3B5KGJ1ZiwgcHRyKVxuICAgICAgcHRyICs9IGVudHJ5LmJ1Zi5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmRyZWYuZW5jb2RlLmJ5dGVzID0gcHRyXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuZHJlZi5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgdmFyIG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgdmFyIGVudHJpZXMgPSBuZXcgQXJyYXkobnVtKVxuICB2YXIgcHRyID0gNFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICB2YXIgc2l6ZSA9IGJ1Zi5yZWFkVUludDMyQkUocHRyKVxuICAgIHZhciB0eXBlID0gYnVmLnRvU3RyaW5nKCdhc2NpaScsIHB0ciArIDQsIHB0ciArIDgpXG4gICAgdmFyIHRtcCA9IGJ1Zi5zbGljZShwdHIgKyA4LCBwdHIgKyBzaXplKVxuICAgIHB0ciArPSBzaXplXG5cbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGJ1ZjogdG1wXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBlbnRyaWVzXG4gIH1cbn1cbmV4cG9ydHMuZHJlZi5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgdmFyIHRvdGFsU2l6ZSA9IDRcbiAgaWYgKCFib3guZW50cmllcykgcmV0dXJuIHRvdGFsU2l6ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5lbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGJveC5lbnRyaWVzW2ldLmJ1ZlxuICAgIHRvdGFsU2l6ZSArPSAoYnVmID8gYnVmLmxlbmd0aCA6IDApICsgNCArIDRcbiAgfVxuICByZXR1cm4gdG90YWxTaXplXG59XG5cbmV4cG9ydHMuZWxzdCA9IHt9XG5leHBvcnRzLmVsc3QuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGVudHJpZXMgPSBib3guZW50cmllcyB8fCBbXVxuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoZXhwb3J0cy5lbHN0LmVuY29kaW5nTGVuZ3RoKGJveCkpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoZW50cmllcy5sZW5ndGgsIDApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyaWVzW2ldLnRyYWNrRHVyYXRpb24gfHwgMCwgcHRyKVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGVudHJpZXNbaV0ubWVkaWFUaW1lIHx8IDAsIHB0ciArIDQpXG4gICAgd3JpdGVGaXhlZDMyKGVudHJpZXNbaV0ubWVkaWFSYXRlIHx8IDAsIGJ1ZiwgcHRyICsgOClcbiAgfVxuXG4gIGV4cG9ydHMuZWxzdC5lbmNvZGUuYnl0ZXMgPSA0ICsgZW50cmllcy5sZW5ndGggKiAxMlxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLmVsc3QuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHZhciBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApXG4gIHZhciBlbnRyaWVzID0gbmV3IEFycmF5KG51bSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgdmFyIHB0ciA9IGkgKiAxMiArIDRcbiAgICBlbnRyaWVzW2ldID0ge1xuICAgICAgdHJhY2tEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRShwdHIpLFxuICAgICAgbWVkaWFUaW1lOiBidWYucmVhZEludDMyQkUocHRyICsgNCksXG4gICAgICBtZWRpYVJhdGU6IHJlYWRGaXhlZDMyKGJ1ZiwgcHRyICsgOClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IGVudHJpZXNcbiAgfVxufVxuZXhwb3J0cy5lbHN0LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNCArIGJveC5lbnRyaWVzLmxlbmd0aCAqIDEyXG59XG5cbmV4cG9ydHMuaGRsciA9IHt9XG5leHBvcnRzLmhkbHIuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKGV4cG9ydHMuaGRsci5lbmNvZGluZ0xlbmd0aChib3gpKVxuXG4gIHZhciBsZW4gPSAyMSArIChib3gubmFtZSB8fCAnJykubGVuZ3RoXG4gIGJ1Zi5maWxsKDAsIDAsIGxlbilcblxuICBidWYud3JpdGUoYm94LmhhbmRsZXJUeXBlIHx8ICcnLCA0LCA0LCAnYXNjaWknKVxuICB3cml0ZVN0cmluZyhib3gubmFtZSB8fCAnJywgYnVmLCAyMClcblxuICBleHBvcnRzLmhkbHIuZW5jb2RlLmJ5dGVzID0gbGVuXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMuaGRsci5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGVuZCkge1xuICBidWYgPSBidWYuc2xpY2Uob2Zmc2V0KVxuICByZXR1cm4ge1xuICAgIGhhbmRsZXJUeXBlOiBidWYudG9TdHJpbmcoJ2FzY2lpJywgNCwgOCksXG4gICAgbmFtZTogcmVhZFN0cmluZyhidWYsIDIwLCBlbmQpXG4gIH1cbn1cbmV4cG9ydHMuaGRsci5lbmNvZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgcmV0dXJuIDIxICsgKGJveC5uYW1lIHx8ICcnKS5sZW5ndGhcbn1cblxuZXhwb3J0cy5tZWhkID0ge31cbmV4cG9ydHMubWVoZC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBidWYgPSBidWYgPyBidWYuc2xpY2Uob2Zmc2V0KSA6IG5ldyBCdWZmZXIoNClcblxuICBidWYud3JpdGVVSW50MzJCRShib3guZnJhZ21lbnREdXJhdGlvbiB8fCAwLCAwKVxuICBleHBvcnRzLm1laGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1laGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1Zi5zbGljZShvZmZzZXQpXG4gIHJldHVybiB7XG4gICAgZnJhZ21lbnREdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSgwKVxuICB9XG59XG5leHBvcnRzLm1laGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudHJleCA9IHt9XG5leHBvcnRzLnRyZXguZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDIwKVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC50cmFja0lkIHx8IDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kZWZhdWx0U2FtcGxlRGVzY3JpcHRpb25JbmRleCB8fCAwLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShib3guZGVmYXVsdFNhbXBsZUR1cmF0aW9uIHx8IDAsIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5kZWZhdWx0U2FtcGxlU2l6ZSB8fCAwLCAxMilcbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmRlZmF1bHRTYW1wbGVGbGFncyB8fCAwLCAxNilcbiAgZXhwb3J0cy50cmV4LmVuY29kZS5ieXRlcyA9IDIwXG4gIHJldHVybiBidWZcbn1cbmV4cG9ydHMudHJleC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmLnNsaWNlKG9mZnNldClcbiAgcmV0dXJuIHtcbiAgICB0cmFja0lkOiBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGRlZmF1bHRTYW1wbGVEZXNjcmlwdGlvbkluZGV4OiBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGRlZmF1bHRTYW1wbGVEdXJhdGlvbjogYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBkZWZhdWx0U2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MzJCRSgxMiksXG4gICAgZGVmYXVsdFNhbXBsZUZsYWdzOiBidWYucmVhZFVJbnQzMkJFKDE2KVxuICB9XG59XG5leHBvcnRzLnRyZXguZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiAyMFxufVxuXG5leHBvcnRzLm1maGQgPSB7fVxuZXhwb3J0cy5tZmhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5zZXF1ZW5jZU51bWJlciB8fCAwLCAwKVxuICBleHBvcnRzLm1maGQuZW5jb2RlLmJ5dGVzID0gNFxuICByZXR1cm4gYnVmXG59XG5leHBvcnRzLm1maGQuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0KSB7XG4gIHJldHVybiB7XG4gICAgc2VxdWVuY2VOdW1iZXI6IGJ1Zi5yZWFkVWludDMyQkUoMClcbiAgfVxufVxuZXhwb3J0cy5tZmhkLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICByZXR1cm4gNFxufVxuXG5leHBvcnRzLnRmaGQgPSB7fVxuZXhwb3J0cy50ZmhkLmVuY29kZSA9IGZ1bmN0aW9uIChib3gsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZiA9IGJ1ZiA/IGJ1Zi5zbGljZShvZmZzZXQpIDogbmV3IEJ1ZmZlcig0KVxuICBidWYud3JpdGVVSW50MzJCRShib3gudHJhY2tJZCwgMClcbiAgZXhwb3J0cy50ZmhkLmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy50ZmhkLmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAvLyBUT0RPOiB0aGlzXG59XG5leHBvcnRzLnRmaGQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIC8vIFRPRE86IHRoaXMgaXMgd3JvbmchXG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudGZkdCA9IHt9XG5leHBvcnRzLnRmZHQuZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDQpXG5cbiAgYnVmLndyaXRlVUludDMyQkUoYm94LmJhc2VNZWRpYURlY29kZVRpbWUgfHwgMCwgMClcbiAgZXhwb3J0cy50ZmR0LmVuY29kZS5ieXRlcyA9IDRcbiAgcmV0dXJuIGJ1ZlxufVxuZXhwb3J0cy50ZmR0LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCkge1xuICAvLyBUT0RPOiB0aGlzXG59XG5leHBvcnRzLnRmZHQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiA0XG59XG5cbmV4cG9ydHMudHJ1biA9IHt9XG5leHBvcnRzLnRydW4uZW5jb2RlID0gZnVuY3Rpb24gKGJveCwgYnVmLCBvZmZzZXQpIHtcbiAgYnVmID0gYnVmID8gYnVmLnNsaWNlKG9mZnNldCkgOiBuZXcgQnVmZmVyKDggKyBib3guZW50cmllcy5sZW5ndGggKiAxNilcblxuICAvLyBUT0RPOiB0aGlzIGlzIHdyb25nXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGJveC5lbnRyaWVzLmxlbmd0aCwgMClcbiAgYnVmLndyaXRlSW50MzJCRShib3guZGF0YU9mZnNldCwgNClcbiAgdmFyIHB0ciA9IDhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3guZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbnRyeSA9IGJveC5lbnRyaWVzW2ldXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlRHVyYXRpb24sIHB0cilcbiAgICBwdHIgKz0gNFxuXG4gICAgYnVmLndyaXRlVUludDMyQkUoZW50cnkuc2FtcGxlU2l6ZSwgcHRyKVxuICAgIHB0ciArPSA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyeS5zYW1wbGVGbGFncywgcHRyKVxuICAgIHB0ciArPSA0XG5cbiAgICBidWYud3JpdGVVSW50MzJCRShlbnRyeS5zYW1wbGVDb21wb3NpdGlvblRpbWVPZmZzZXQsIHB0cilcbiAgICBwdHIgKz0gNFxuICB9XG4gIGV4cG9ydHMudHJ1bi5lbmNvZGUuYnl0ZXMgPSBwdHJcbn1cbmV4cG9ydHMudHJ1bi5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgLy8gVE9ETzogdGhpc1xufVxuZXhwb3J0cy50cnVuLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGJveCkge1xuICAvLyBUT0RPOiB0aGlzIGlzIHdyb25nXG4gIHJldHVybiA4ICsgYm94LmVudHJpZXMubGVuZ3RoICogMTZcbn1cblxuZXhwb3J0cy5tZGF0ID0ge31cbmV4cG9ydHMubWRhdC5lbmNvZGUgPSBmdW5jdGlvbiAoYm94LCBidWYsIG9mZnNldCkge1xuICBpZiAoYm94LmJ1ZmZlcikge1xuICAgIGJveC5idWZmZXIuY29weShidWYsIG9mZnNldClcbiAgICBleHBvcnRzLm1kYXQuZW5jb2RlLmJ5dGVzID0gYm94LmJ1ZmZlci5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLm1kYXQuZW5jb2RlLmJ5dGVzID0gZXhwb3J0cy5tZGF0LmVuY29kaW5nTGVuZ3RoKGJveClcbiAgfVxufVxuZXhwb3J0cy5tZGF0LmRlY29kZSA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHtcbiAgICBidWZmZXI6IG5ldyBCdWZmZXIoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5leHBvcnRzLm1kYXQuZW5jb2RpbmdMZW5ndGggPSBmdW5jdGlvbiAoYm94KSB7XG4gIHJldHVybiBib3guYnVmZmVyID8gYm94LmJ1ZmZlci5sZW5ndGggOiBib3guY29udGVudExlbmd0aFxufVxuXG5mdW5jdGlvbiB3cml0ZVJlc2VydmVkIChidWYsIG9mZnNldCwgZW5kKSB7XG4gIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykgYnVmW2ldID0gMFxufVxuXG5mdW5jdGlvbiB3cml0ZURhdGUgKGRhdGUsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1Zi53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpICsgVElNRV9PRkZTRVQpIC8gMTAwMCksIG9mZnNldClcbn1cblxuLy8gVE9ETzogdGhpbmsgc29tZXRoaW5nIGlzIHdyb25nIGhlcmVcbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMiAobnVtLCBidWYsIG9mZnNldCkge1xuICBidWYud3JpdGVVSW50MTZCRShNYXRoLmZsb29yKG51bSkgJSAoMjU2ICogMjU2KSwgb2Zmc2V0KVxuICBidWYud3JpdGVVSW50MTZCRShNYXRoLmZsb29yKG51bSAqIDI1NiAqIDI1NikgJSAoMjU2ICogMjU2KSwgb2Zmc2V0ICsgMilcbn1cblxuZnVuY3Rpb24gd3JpdGVGaXhlZDE2IChudW0sIGJ1Ziwgb2Zmc2V0KSB7XG4gIGJ1ZltvZmZzZXRdID0gTWF0aC5mbG9vcihudW0pICUgMjU2XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IE1hdGguZmxvb3IobnVtICogMjU2KSAlIDI1NlxufVxuXG5mdW5jdGlvbiB3cml0ZU1hdHJpeCAobGlzdCwgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKCFsaXN0KSBsaXN0ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlRml4ZWQzMihsaXN0W2ldLCBidWYsIG9mZnNldCArIGkgKiA0KVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nIChzdHIsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBzdHJCdWZmZXIgPSBuZXcgQnVmZmVyKHN0ciwgJ3V0ZjgnKVxuICBzdHJCdWZmZXIuY29weShidWYsIG9mZnNldClcbiAgYnVmW29mZnNldCArIHN0ckJ1ZmZlci5sZW5ndGhdID0gMFxufVxuXG5mdW5jdGlvbiByZWFkTWF0cml4IChidWYpIHtcbiAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoYnVmLmxlbmd0aCAvIDQpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXSA9IHJlYWRGaXhlZDMyKGJ1ZiwgaSAqIDQpXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHJlYWREYXRlIChidWYsIG9mZnNldCkge1xuICByZXR1cm4gbmV3IERhdGUoYnVmLnJlYWRVSW50MzJCRShvZmZzZXQpICogMTAwMCAtIFRJTUVfT0ZGU0VUKVxufVxuXG5mdW5jdGlvbiByZWFkRml4ZWQzMiAoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0KSArIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0ICsgMikgLyAoMjU2ICogMjU2KVxufVxuXG5mdW5jdGlvbiByZWFkRml4ZWQxNiAoYnVmLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1ZltvZmZzZXRdICsgYnVmW29mZnNldCArIDFdIC8gMjU2XG59XG5cbmZ1bmN0aW9uIHJlYWRTdHJpbmcgKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltvZmZzZXQgKyBpXSA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIG9mZnNldCwgb2Zmc2V0ICsgaSlcbn1cbiIsInZhciB0YWdUb05hbWUgPSB7XG4gIDB4MDM6ICdFU0Rlc2NyaXB0b3InLFxuICAweDA0OiAnRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3InLFxuICAweDA1OiAnRGVjb2RlclNwZWNpZmljSW5mbycsXG4gIDB4MDY6ICdTTENvbmZpZ0Rlc2NyaXB0b3InXG59XG5cbmV4cG9ydHMuRGVzY3JpcHRvciA9IHt9XG5leHBvcnRzLkRlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgdGFnID0gYnVmLnJlYWRVSW50OChzdGFydClcbiAgdmFyIHB0ciA9IHN0YXJ0ICsgMVxuICB2YXIgbGVuQnl0ZVxuICB2YXIgbGVuID0gMFxuICBkbyB7XG4gICAgbGVuQnl0ZSA9IGJ1Zi5yZWFkVUludDgocHRyKyspXG4gICAgbGVuID0gKGxlbiA8PCA3KSB8IChsZW5CeXRlICYgMHg3ZilcbiAgfSB3aGlsZSAobGVuQnl0ZSAmIDB4ODApXG5cbiAgdmFyIG9ialxuICB2YXIgdGFnTmFtZSA9IHRhZ1RvTmFtZVt0YWddIC8vIE1heSBiZSB1bmRlZmluZWQ7IHRoYXQncyBva1xuICBpZiAoZXhwb3J0c1t0YWdOYW1lXSkge1xuICAgIG9iaiA9IGV4cG9ydHNbdGFnTmFtZV0uZGVjb2RlKGJ1ZiwgcHRyLCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgb2JqID0ge1xuICAgICAgYnVmZmVyOiBuZXcgQnVmZmVyKGJ1Zi5zbGljZShwdHIsIHB0ciArIGxlbikpXG4gICAgfVxuICB9XG5cbiAgb2JqLnRhZyA9IHRhZ1xuICBvYmoudGFnTmFtZSA9IHRhZ05hbWVcbiAgb2JqLmxlbmd0aCA9IChwdHIgLSBzdGFydCkgKyBsZW5cbiAgb2JqLmNvbnRlbnRzTGVuID0gbGVuXG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5EZXNjcmlwdG9yQXJyYXkgPSB7fVxuZXhwb3J0cy5EZXNjcmlwdG9yQXJyYXkuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcHRyID0gc3RhcnRcbiAgdmFyIG9iaiA9IHt9XG4gIHdoaWxlIChwdHIgKyAyIDw9IGVuZCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yLmRlY29kZShidWYsIHB0ciwgZW5kKVxuICAgIHB0ciArPSBkZXNjcmlwdG9yLmxlbmd0aFxuICAgIHZhciB0YWdOYW1lID0gdGFnVG9OYW1lW2Rlc2NyaXB0b3IudGFnXSB8fCAoJ0Rlc2NyaXB0b3InICsgZGVzY3JpcHRvci50YWcpXG4gICAgb2JqW3RhZ05hbWVdID0gZGVzY3JpcHRvclxuICB9XG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0cy5FU0Rlc2NyaXB0b3IgPSB7fVxuZXhwb3J0cy5FU0Rlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgZmxhZ3MgPSBidWYucmVhZFVJbnQ4KHN0YXJ0ICsgMilcbiAgdmFyIHB0ciA9IHN0YXJ0ICsgM1xuICBpZiAoZmxhZ3MgJiAweDgwKSB7XG4gICAgcHRyICs9IDJcbiAgfVxuICBpZiAoZmxhZ3MgJiAweDQwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5yZWFkVUludDgocHRyKVxuICAgIHB0ciArPSBsZW4gKyAxXG4gIH1cbiAgaWYgKGZsYWdzICYgMHgyMCkge1xuICAgIHB0ciArPSAyXG4gIH1cbiAgcmV0dXJuIGV4cG9ydHMuRGVzY3JpcHRvckFycmF5LmRlY29kZShidWYsIHB0ciwgZW5kKVxufVxuXG5leHBvcnRzLkRlY29kZXJDb25maWdEZXNjcmlwdG9yID0ge31cbmV4cG9ydHMuRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3IuZGVjb2RlID0gZnVuY3Rpb24gKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgb3RpID0gYnVmLnJlYWRVSW50OChzdGFydClcbiAgdmFyIG9iaiA9IGV4cG9ydHMuRGVzY3JpcHRvckFycmF5LmRlY29kZShidWYsIHN0YXJ0ICsgMTMsIGVuZClcbiAgb2JqLm90aSA9IG90aVxuICByZXR1cm4gb2JqXG59XG4iLCIvLyB2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciB1aW50NjRiZSA9IHJlcXVpcmUoJ3VpbnQ2NGJlJylcblxudmFyIGJveGVzID0gcmVxdWlyZSgnLi9ib3hlcycpXG5cbnZhciBVSU5UMzJfTUFYID0gNDI5NDk2NzI5NVxuXG52YXIgQm94ID0gZXhwb3J0c1xuXG4vKlxuICogTGlzdHMgdGhlIHByb3BlciBvcmRlciBmb3IgYm94ZXMgaW5zaWRlIGNvbnRhaW5lcnMuXG4gKiBGaXZlLWNoYXJhY3RlciBuYW1lcyBlbmRpbmcgaW4gJ3MnIGluZGljYXRlIGFycmF5cyBpbnN0ZWFkIG9mIHNpbmdsZSBlbGVtZW50cy5cbiAqL1xudmFyIGNvbnRhaW5lcnMgPSBleHBvcnRzLmNvbnRhaW5lcnMgPSB7XG4gICdtb292JzogWydtdmhkJywgJ21ldGEnLCAndHJha3MnLCAnbXZleCddLFxuICAndHJhayc6IFsndGtoZCcsICd0cmVmJywgJ3RyZ3InLCAnZWR0cycsICdtZXRhJywgJ21kaWEnLCAndWR0YSddLFxuICAnZWR0cyc6IFsnZWxzdCddLFxuICAnbWRpYSc6IFsnbWRoZCcsICdoZGxyJywgJ2VsbmcnLCAnbWluZiddLFxuICAnbWluZic6IFsndm1oZCcsICdzbWhkJywgJ2htaGQnLCAnc3RoZCcsICdubWhkJywgJ2RpbmYnLCAnc3RibCddLFxuICAnZGluZic6IFsnZHJlZiddLFxuICAnc3RibCc6IFsnc3RzZCcsICdzdHRzJywgJ2N0dHMnLCAnY3NsZycsICdzdHNjJywgJ3N0c3onLCAnc3R6MicsICdzdGNvJywgJ2NvNjQnLCAnc3RzcycsICdzdHNoJywgJ3BhZGInLCAnc3RkcCcsICdzZHRwJywgJ3NiZ3BzJywgJ3NncGRzJywgJ3N1YnNzJywgJ3NhaXpzJywgJ3NhaW9zJ10sXG4gICdtdmV4JzogWydtZWhkJywgJ3RyZXhzJywgJ2xldmEnXSxcbiAgJ21vb2YnOiBbJ21maGQnLCAnbWV0YScsICd0cmFmcyddLFxuICAndHJhZic6IFsndGZoZCcsICd0cnVuJywgJ3NiZ3BzJywgJ3NncGRzJywgJ3N1YnNzJywgJ3NhaXpzJywgJ3NhaW9zJywgJ3RmZHQnLCAnbWV0YSddXG59XG5cbkJveC5lbmNvZGUgPSBmdW5jdGlvbiAob2JqLCBidWZmZXIsIG9mZnNldCkge1xuICBCb3guZW5jb2RpbmdMZW5ndGgob2JqKSAvLyBzZXRzIGV2ZXJ5IGxldmVsIGFwcHJvcHJpYXRlbHlcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBCdWZmZXIob2JqLmxlbmd0aClcbiAgcmV0dXJuIEJveC5fZW5jb2RlKG9iaiwgYnVmZmVyLCBvZmZzZXQpXG59XG5cbkJveC5fZW5jb2RlID0gZnVuY3Rpb24gKG9iaiwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgdmFyIHR5cGUgPSBvYmoudHlwZVxuICB2YXIgbGVuID0gb2JqLmxlbmd0aFxuICBpZiAobGVuID4gVUlOVDMyX01BWCkge1xuICAgIGxlbiA9IDFcbiAgfVxuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldClcbiAgYnVmZmVyLndyaXRlKG9iai50eXBlLCBvZmZzZXQgKyA0LCA0LCAnYXNjaWknKVxuICB2YXIgcHRyID0gb2Zmc2V0ICsgOFxuICBpZiAobGVuID09PSAxKSB7XG4gICAgdWludDY0YmUuZW5jb2RlKG9iai5sZW5ndGgsIGJ1ZmZlciwgcHRyKVxuICAgIHB0ciArPSA4XG4gIH1cbiAgaWYgKGJveGVzLmZ1bGxCb3hlc1t0eXBlXSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9iai5mbGFncyB8fCAwLCBwdHIpXG4gICAgYnVmZmVyLndyaXRlVUludDgob2JqLnZlcnNpb24gfHwgMCwgcHRyKVxuICAgIHB0ciArPSA0XG4gIH1cblxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIHZhciBjb250ZW50cyA9IGNvbnRhaW5lcnNbdHlwZV1cbiAgICBjb250ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFR5cGUpIHtcbiAgICAgIGlmIChjaGlsZFR5cGUubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGNoaWxkVHlwZSA9IGNoaWxkVHlwZS5zdWJzdHIoMCwgNClcbiAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBCb3guX2VuY29kZShjaGlsZCwgYnVmZmVyLCBwdHIpXG4gICAgICAgICAgcHRyICs9IEJveC5lbmNvZGUuYnl0ZXNcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAob2JqW2NoaWxkVHlwZV0pIHtcbiAgICAgICAgQm94Ll9lbmNvZGUob2JqW2NoaWxkVHlwZV0sIGJ1ZmZlciwgcHRyKVxuICAgICAgICBwdHIgKz0gQm94LmVuY29kZS5ieXRlc1xuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKG9iai5vdGhlckJveGVzKSB7XG4gICAgICBvYmoub3RoZXJCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBCb3guX2VuY29kZShjaGlsZCwgYnVmZmVyLCBwdHIpXG4gICAgICAgIHB0ciArPSBCb3guZW5jb2RlLmJ5dGVzXG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIGlmIChib3hlc1t0eXBlXSkge1xuICAgIHZhciBlbmNvZGUgPSBib3hlc1t0eXBlXS5lbmNvZGVcbiAgICBlbmNvZGUob2JqLCBidWZmZXIsIHB0cilcbiAgICBwdHIgKz0gZW5jb2RlLmJ5dGVzXG4gIH0gZWxzZSBpZiAob2JqLmJ1ZmZlcikge1xuICAgIHZhciBidWYgPSBvYmouYnVmZmVyXG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwdHIpXG4gICAgcHRyICs9IG9iai5idWZmZXIubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgYHR5cGVgIG11c3QgYmUgc2V0IHRvIGEga25vd24gdHlwZSAobm90XFwnJyArIHR5cGUgKyAnXFwnKSBvciBgYnVmZmVyYCBtdXN0IGJlIHNldCcpXG4gIH1cblxuICBCb3guZW5jb2RlLmJ5dGVzID0gcHRyIC0gb2Zmc2V0XG4gIC8vIGFzc2VydC5lcXVhbChwdHIgLSBvZmZzZXQsIG9iai5sZW5ndGgsICdFcnJvciBlbmNvZGluZyBcXCcnICsgdHlwZSArICdcXCc6IHdyb3RlICcgKyBwdHIgLSBvZmZzZXQgKyAnIGJ5dGVzLCBleHBlY3RpbmcgJyArIG9iai5sZW5ndGgpXG4gIHJldHVybiBidWZmZXJcbn1cblxuLypcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHR5cGVgIGFuZCBgc2l6ZWAgZmllbGRzLFxuICogb3IgaWYgdGhlcmUgaXNuJ3QgZW5vdWdoIGRhdGEsIHJldHVybnMgdGhlIHRvdGFsXG4gKiBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIHJlYWQgdGhlIGhlYWRlcnNcbiAqL1xuQm94LnJlYWRIZWFkZXJzID0gZnVuY3Rpb24gKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgZW5kID0gZW5kIHx8IGJ1ZmZlci5sZW5ndGhcbiAgaWYgKGVuZCAtIHN0YXJ0IDwgOCkge1xuICAgIHJldHVybiA4XG4gIH1cblxuICB2YXIgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShzdGFydClcbiAgdmFyIHR5cGUgPSBidWZmZXIudG9TdHJpbmcoJ2FzY2lpJywgc3RhcnQgKyA0LCBzdGFydCArIDgpXG4gIHZhciBwdHIgPSBzdGFydCArIDhcblxuICBpZiAobGVuID09PSAxKSB7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDwgMTYpIHtcbiAgICAgIHJldHVybiAxNlxuICAgIH1cblxuICAgIGxlbiA9IHVpbnQ2NGJlLmRlY29kZShidWZmZXIsIHB0cilcbiAgICBwdHIgKz0gOFxuICB9XG5cbiAgdmFyIHZlcnNpb25cbiAgdmFyIGZsYWdzXG4gIGlmIChib3hlcy5mdWxsQm94ZXNbdHlwZV0pIHtcbiAgICB2ZXJzaW9uID0gYnVmZmVyLnJlYWRVSW50OChwdHIpXG4gICAgZmxhZ3MgPSBidWZmZXIucmVhZFVJbnQzMkJFKHB0cikgJiAweGZmZmZmZlxuICAgIHB0ciArPSA0XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogbGVuLFxuICAgIGhlYWRlcnNMZW46IHB0ciAtIHN0YXJ0LFxuICAgIGNvbnRlbnRMZW46IGxlbiAtIChwdHIgLSBzdGFydCksXG4gICAgdHlwZTogdHlwZSxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGZsYWdzOiBmbGFnc1xuICB9XG59XG5cbkJveC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBlbmQgPSBlbmQgfHwgYnVmZmVyLmxlbmd0aFxuICB2YXIgaGVhZGVycyA9IEJveC5yZWFkSGVhZGVycyhidWZmZXIsIHN0YXJ0LCBlbmQpXG4gIGlmICghaGVhZGVycyB8fCBoZWFkZXJzLmxlbmd0aCA+IGVuZCAtIHN0YXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHRvbyBzaG9ydCcpXG4gIH1cblxuICByZXR1cm4gQm94LmRlY29kZVdpdGhvdXRIZWFkZXJzKGhlYWRlcnMsIGJ1ZmZlciwgc3RhcnQgKyBoZWFkZXJzLmhlYWRlcnNMZW4sIHN0YXJ0ICsgaGVhZGVycy5sZW5ndGgpXG59XG5cbkJveC5kZWNvZGVXaXRob3V0SGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJzLCBidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IGVuZCB8fCBidWZmZXIubGVuZ3RoXG4gIHZhciB0eXBlID0gaGVhZGVycy50eXBlXG4gIHZhciBvYmogPSB7fVxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIG9iai5vdGhlckJveGVzID0gW11cbiAgICB2YXIgY29udGVudHMgPSBjb250YWluZXJzW3R5cGVdXG4gICAgdmFyIHB0ciA9IHN0YXJ0XG4gICAgd2hpbGUgKGVuZCAtIHB0ciA+PSA4KSB7XG4gICAgICB2YXIgY2hpbGQgPSBCb3guZGVjb2RlKGJ1ZmZlciwgcHRyLCBlbmQpXG4gICAgICBwdHIgKz0gY2hpbGQubGVuZ3RoXG4gICAgICBpZiAoY29udGVudHMuaW5kZXhPZihjaGlsZC50eXBlKSA+PSAwKSB7XG4gICAgICAgIG9ialtjaGlsZC50eXBlXSA9IGNoaWxkXG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRzLmluZGV4T2YoY2hpbGQudHlwZSArICdzJykgPj0gMCkge1xuICAgICAgICB2YXIgY2hpbGRUeXBlID0gY2hpbGQudHlwZSArICdzJ1xuICAgICAgICB2YXIgZW50cnkgPSBvYmpbY2hpbGRUeXBlXSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGVudHJ5LnB1c2goY2hpbGQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoub3RoZXJCb3hlcy5wdXNoKGNoaWxkKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChib3hlc1t0eXBlXSkge1xuICAgIHZhciBkZWNvZGUgPSBib3hlc1t0eXBlXS5kZWNvZGVcbiAgICBvYmogPSBkZWNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIG9iai5idWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxuXG4gIG9iai5sZW5ndGggPSBoZWFkZXJzLmxlbmd0aFxuICBvYmouY29udGVudExlbiA9IGhlYWRlcnMuY29udGVudExlblxuICBvYmoudHlwZSA9IGhlYWRlcnMudHlwZVxuICBvYmoudmVyc2lvbiA9IGhlYWRlcnMudmVyc2lvblxuICBvYmouZmxhZ3MgPSBoZWFkZXJzLmZsYWdzXG4gIHJldHVybiBvYmpcbn1cblxuQm94LmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgdHlwZSA9IG9iai50eXBlXG5cbiAgdmFyIGxlbiA9IDhcbiAgaWYgKGJveGVzLmZ1bGxCb3hlc1t0eXBlXSkge1xuICAgIGxlbiArPSA0XG4gIH1cblxuICBpZiAoY29udGFpbmVyc1t0eXBlXSkge1xuICAgIHZhciBjb250ZW50cyA9IGNvbnRhaW5lcnNbdHlwZV1cbiAgICBjb250ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFR5cGUpIHtcbiAgICAgIGlmIChjaGlsZFR5cGUubGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG9ialtjaGlsZFR5cGVdIHx8IFtdXG4gICAgICAgIGNoaWxkVHlwZSA9IGNoaWxkVHlwZS5zdWJzdHIoMCwgNClcbiAgICAgICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBjaGlsZC50eXBlID0gY2hpbGRUeXBlXG4gICAgICAgICAgbGVuICs9IEJveC5lbmNvZGluZ0xlbmd0aChjaGlsZClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAob2JqW2NoaWxkVHlwZV0pIHtcbiAgICAgICAgdmFyIGNoaWxkID0gb2JqW2NoaWxkVHlwZV1cbiAgICAgICAgY2hpbGQudHlwZSA9IGNoaWxkVHlwZVxuICAgICAgICBsZW4gKz0gQm94LmVuY29kaW5nTGVuZ3RoKGNoaWxkKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKG9iai5vdGhlckJveGVzKSB7XG4gICAgICBvYmoub3RoZXJCb3hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBsZW4gKz0gQm94LmVuY29kaW5nTGVuZ3RoKGNoaWxkKVxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm94ZXNbdHlwZV0pIHtcbiAgICBsZW4gKz0gYm94ZXNbdHlwZV0uZW5jb2RpbmdMZW5ndGgob2JqKVxuICB9IGVsc2UgaWYgKG9iai5idWZmZXIpIHtcbiAgICBsZW4gKz0gb2JqLmJ1ZmZlci5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBgdHlwZWAgbXVzdCBiZSBzZXQgdG8gYSBrbm93biB0eXBlIChub3RcXCcnICsgdHlwZSArICdcXCcpIG9yIGBidWZmZXJgIG11c3QgYmUgc2V0JylcbiAgfVxuXG4gIGlmIChsZW4gPiBVSU5UMzJfTUFYKSB7XG4gICAgbGVuICs9IDhcbiAgfVxuXG4gIG9iai5sZW5ndGggPSBsZW5cbiAgcmV0dXJuIGxlblxufVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbmV4dEV2ZW50ID0gcmVxdWlyZSgnbmV4dC1ldmVudCcpXG52YXIgQm94ID0gcmVxdWlyZSgnbXA0LWJveC1lbmNvZGluZycpXG5cbnZhciBFTVBUWSA9IG5ldyBCdWZmZXIoMClcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvZGVyXG5cbmZ1bmN0aW9uIERlY29kZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVjb2RlcikpIHJldHVybiBuZXcgRGVjb2RlcigpXG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIHRoaXMuX3BlbmRpbmcgPSAwXG4gIHRoaXMuX21pc3NpbmcgPSAwXG4gIHRoaXMuX2J1ZiA9IG51bGxcbiAgdGhpcy5fc3RyID0gbnVsbFxuICB0aGlzLl9jYiA9IG51bGxcbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fd3JpdGVCdWZmZXIgPSBudWxsXG4gIHRoaXMuX3dyaXRlQ2IgPSBudWxsXG5cbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fa2ljaygpXG59XG5cbmluaGVyaXRzKERlY29kZXIsIHN0cmVhbS5Xcml0YWJsZSlcblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jLCBuZXh0KSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkcmFpbmVkID0gIXRoaXMuX3N0ciB8fCAhdGhpcy5fc3RyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpblxuXG4gIHdoaWxlIChkYXRhLmxlbmd0aCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAoIXRoaXMuX21pc3NpbmcpIHtcbiAgICAgIHRoaXMuX3dyaXRlQnVmZmVyID0gZGF0YVxuICAgICAgdGhpcy5fd3JpdGVDYiA9IG5leHRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjb25zdW1lZCA9IGRhdGEubGVuZ3RoIDwgdGhpcy5fbWlzc2luZyA/IGRhdGEubGVuZ3RoIDogdGhpcy5fbWlzc2luZ1xuICAgIGlmICh0aGlzLl9idWYpIGRhdGEuY29weSh0aGlzLl9idWYsIHRoaXMuX2J1Zi5sZW5ndGggLSB0aGlzLl9taXNzaW5nKVxuICAgIGVsc2UgaWYgKHRoaXMuX3N0cikgZHJhaW5lZCA9IHRoaXMuX3N0ci53cml0ZShjb25zdW1lZCA9PT0gZGF0YS5sZW5ndGggPyBkYXRhIDogZGF0YS5zbGljZSgwLCBjb25zdW1lZCkpXG5cbiAgICB0aGlzLl9taXNzaW5nIC09IGNvbnN1bWVkXG5cbiAgICBpZiAoIXRoaXMuX21pc3NpbmcpIHtcbiAgICAgIHZhciBidWYgPSB0aGlzLl9idWZcbiAgICAgIHZhciBjYiA9IHRoaXMuX2NiXG4gICAgICB2YXIgc3RyZWFtID0gdGhpcy5fc3RyXG5cbiAgICAgIHRoaXMuX2J1ZiA9IHRoaXMuX2NiID0gdGhpcy5fc3RyID0gdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgICAgIGRyYWluZWQgPSB0cnVlXG5cbiAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS5lbmQoKVxuICAgICAgaWYgKGNiKSBjYihidWYpXG4gICAgfVxuXG4gICAgZGF0YSA9IGNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCA/IEVNUFRZIDogZGF0YS5zbGljZShjb25zdW1lZClcbiAgfVxuXG4gIGlmICh0aGlzLl9wZW5kaW5nICYmICF0aGlzLl9taXNzaW5nKSB7XG4gICAgdGhpcy5fd3JpdGVCdWZmZXIgPSBkYXRhXG4gICAgdGhpcy5fd3JpdGVDYiA9IG5leHRcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChkcmFpbmVkKSBuZXh0KClcbiAgZWxzZSB0aGlzLl9vbmRyYWluKG5leHQpXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9idWZmZXIgPSBmdW5jdGlvbiAoc2l6ZSwgY2IpIHtcbiAgdGhpcy5fbWlzc2luZyA9IHNpemVcbiAgdGhpcy5fYnVmID0gbmV3IEJ1ZmZlcihzaXplKVxuICB0aGlzLl9jYiA9IGNiXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9zdHJlYW0gPSBmdW5jdGlvbiAoc2l6ZSwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX21pc3NpbmcgPSBzaXplXG4gIHRoaXMuX3N0ciA9IG5ldyBNZWRpYURhdGEodGhpcylcbiAgdGhpcy5fb25kcmFpbiA9IG5leHRFdmVudCh0aGlzLl9zdHIsICdkcmFpbicpXG4gIHRoaXMuX3BlbmRpbmcrK1xuICB0aGlzLl9zdHIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wZW5kaW5nLS1cbiAgICBzZWxmLl9raWNrKClcbiAgfSlcbiAgdGhpcy5fY2IgPSBjYlxuICByZXR1cm4gdGhpcy5fc3RyXG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9yZWFkQm94ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgYnVmZmVySGVhZGVycyg4KVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckhlYWRlcnMgKGxlbiwgYnVmKSB7XG4gICAgc2VsZi5fYnVmZmVyKGxlbiwgZnVuY3Rpb24gKGFkZGl0aW9uYWxCdWYpIHtcbiAgICAgIGlmIChidWYpIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChidWYsIGFkZGl0aW9uYWxCdWYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBhZGRpdGlvbmFsQnVmXG4gICAgICB9XG4gICAgICB2YXIgaGVhZGVycyA9IEJveC5yZWFkSGVhZGVycyhidWYpXG4gICAgICBpZiAodHlwZW9mIGhlYWRlcnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ1ZmZlckhlYWRlcnMoaGVhZGVycyAtIGJ1Zi5sZW5ndGgsIGJ1ZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3BlbmRpbmcrK1xuICAgICAgICBzZWxmLl9oZWFkZXJzID0gaGVhZGVyc1xuICAgICAgICBzZWxmLmVtaXQoJ2JveCcsIGhlYWRlcnMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5zdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuX2hlYWRlcnMpIHRocm93IG5ldyBFcnJvcigndGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgb25jZSBhZnRlciBcXCdib3hcXCcgaXMgZW1pdHRlZCcpXG4gIHZhciBoZWFkZXJzID0gc2VsZi5faGVhZGVyc1xuICBzZWxmLl9oZWFkZXJzID0gbnVsbFxuXG4gIHJldHVybiBzZWxmLl9zdHJlYW0oaGVhZGVycy5jb250ZW50TGVuLCBudWxsKVxufVxuXG5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5faGVhZGVycykgdGhyb3cgbmV3IEVycm9yKCd0aGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIGFmdGVyIFxcJ2JveFxcJyBpcyBlbWl0dGVkJylcbiAgdmFyIGhlYWRlcnMgPSBzZWxmLl9oZWFkZXJzXG4gIHNlbGYuX2hlYWRlcnMgPSBudWxsXG5cbiAgc2VsZi5fYnVmZmVyKGhlYWRlcnMuY29udGVudExlbiwgZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBib3ggPSBCb3guZGVjb2RlV2l0aG91dEhlYWRlcnMoaGVhZGVycywgYnVmKVxuICAgIGNiKGJveClcbiAgICBzZWxmLl9wZW5kaW5nLS1cbiAgICBzZWxmLl9raWNrKClcbiAgfSlcbn1cblxuRGVjb2Rlci5wcm90b3R5cGUuaWdub3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLl9oZWFkZXJzKSB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UgYWZ0ZXIgXFwnYm94XFwnIGlzIGVtaXR0ZWQnKVxuICB2YXIgaGVhZGVycyA9IHNlbGYuX2hlYWRlcnNcbiAgc2VsZi5faGVhZGVycyA9IG51bGxcblxuICB0aGlzLl9taXNzaW5nID0gaGVhZGVycy5jb250ZW50TGVuXG4gIHRoaXMuX2NiID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3BlbmRpbmctLVxuICAgIHNlbGYuX2tpY2soKVxuICB9XG59XG5cbkRlY29kZXIucHJvdG90eXBlLl9raWNrID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcGVuZGluZykgcmV0dXJuXG4gIGlmICghdGhpcy5fYnVmICYmICF0aGlzLl9zdHIpIHRoaXMuX3JlYWRCb3goKVxuICBpZiAodGhpcy5fd3JpdGVCdWZmZXIpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX3dyaXRlQ2JcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fd3JpdGVCdWZmZXJcbiAgICB0aGlzLl93cml0ZUJ1ZmZlciA9IG51bGxcbiAgICB0aGlzLl93cml0ZUNiID0gbnVsbFxuICAgIHRoaXMuX3dyaXRlKGJ1ZmZlciwgbnVsbCwgbmV4dClcbiAgfVxufVxuXG5mdW5jdGlvbiBNZWRpYURhdGEgKHBhcmVudCkge1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICBzdHJlYW0uUGFzc1Rocm91Z2guY2FsbCh0aGlzKVxufVxuXG5pbmhlcml0cyhNZWRpYURhdGEsIHN0cmVhbS5QYXNzVGhyb3VnaClcblxuTWVkaWFEYXRhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgdGhpcy5fcGFyZW50LmRlc3Ryb3koZXJyKVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEJveCA9IHJlcXVpcmUoJ21wNC1ib3gtZW5jb2RpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXJcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBFbmNvZGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVuY29kZXIpKSByZXR1cm4gbmV3IEVuY29kZXIoKVxuICBzdHJlYW0uUmVhZGFibGUuY2FsbCh0aGlzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLl9yZWFkaW5nID0gZmFsc2VcbiAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICB0aGlzLl9kcmFpbiA9IG51bGxcbiAgdGhpcy5fd2FudCA9IGZhbHNlXG4gIHRoaXMuX29ucmVhZGFibGUgPSBvbnJlYWRhYmxlXG4gIHRoaXMuX29uZW5kID0gb25lbmRcblxuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBvbnJlYWRhYmxlICgpIHtcbiAgICBpZiAoIXNlbGYuX3dhbnQpIHJldHVyblxuICAgIHNlbGYuX3dhbnQgPSBmYWxzZVxuICAgIHNlbGYuX3JlYWQoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQgKCkge1xuICAgIHNlbGYuX3N0cmVhbSA9IG51bGxcbiAgfVxufVxuXG5pbmhlcml0cyhFbmNvZGVyLCBzdHJlYW0uUmVhZGFibGUpXG5cbkVuY29kZXIucHJvdG90eXBlLm1lZGlhRGF0YSA9XG5FbmNvZGVyLnByb3RvdHlwZS5tZGF0ID0gZnVuY3Rpb24gKHNpemUsIGNiKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgTWVkaWFEYXRhKHRoaXMpXG4gIHRoaXMuYm94KHt0eXBlOiAnbWRhdCcsIGNvbnRlbnRMZW5ndGg6IHNpemUsIGVuY29kZUJ1ZmZlckxlbjogOCwgc3RyZWFtOiBzdHJlYW19LCBjYilcbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5FbmNvZGVyLnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbiAoYm94LCBjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gY2IobmV3IEVycm9yKCdFbmNvZGVyIGlzIGRlc3Ryb3llZCcpKVxuXG4gIHZhciBidWZcbiAgaWYgKGJveC5lbmNvZGVCdWZmZXJMZW4pIHtcbiAgICBidWYgPSBuZXcgQnVmZmVyKGJveC5lbmNvZGVCdWZmZXJMZW4pXG4gIH1cbiAgaWYgKGJveC5zdHJlYW0pIHtcbiAgICBib3guYnVmZmVyID0gbnVsbFxuICAgIGJ1ZiA9IEJveC5lbmNvZGUoYm94LCBidWYpXG4gICAgdGhpcy5wdXNoKGJ1ZilcbiAgICB0aGlzLl9zdHJlYW0gPSBib3guc3RyZWFtXG4gICAgdGhpcy5fc3RyZWFtLm9uKCdyZWFkYWJsZScsIHRoaXMuX29ucmVhZGFibGUpXG4gICAgdGhpcy5fc3RyZWFtLm9uKCdlbmQnLCB0aGlzLl9vbmVuZClcbiAgICB0aGlzLl9zdHJlYW0ub24oJ2VuZCcsIGNiKVxuICAgIHRoaXMuX2ZvcndhcmQoKVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJveC5lbmNvZGUoYm94LCBidWYpXG4gICAgdmFyIGRyYWluZWQgPSB0aGlzLnB1c2goYnVmKVxuICAgIGlmIChkcmFpbmVkKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB0aGlzLl9kcmFpbiA9IGNiXG4gIH1cbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIGlmICh0aGlzLl9zdHJlYW0gJiYgdGhpcy5fc3RyZWFtLmRlc3Ryb3kpIHRoaXMuX3N0cmVhbS5kZXN0cm95KClcbiAgdGhpcy5fc3RyZWFtID0gbnVsbFxuICBpZiAodGhpcy5fZHJhaW4pIHtcbiAgICB2YXIgY2IgPSB0aGlzLl9kcmFpblxuICAgIHRoaXMuX2RyYWluID0gbnVsbFxuICAgIGNiKGVycilcbiAgfVxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucHVzaChudWxsKVxufVxuXG5FbmNvZGVyLnByb3RvdHlwZS5fZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9zdHJlYW0pIHJldHVyblxuXG4gIHdoaWxlICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICB2YXIgYnVmID0gdGhpcy5fc3RyZWFtLnJlYWQoKVxuXG4gICAgaWYgKCFidWYpIHtcbiAgICAgIHRoaXMuX3dhbnQgPSAhIXRoaXMuX3N0cmVhbVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnB1c2goYnVmKSkgcmV0dXJuXG4gIH1cbn1cblxuRW5jb2Rlci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9yZWFkaW5nIHx8IHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fcmVhZGluZyA9IHRydWVcblxuICBpZiAodGhpcy5fc3RyZWFtKSB0aGlzLl9mb3J3YXJkKClcbiAgaWYgKHRoaXMuX2RyYWluKSB7XG4gICAgdmFyIGRyYWluID0gdGhpcy5fZHJhaW5cbiAgICB0aGlzLl9kcmFpbiA9IG51bGxcbiAgICBkcmFpbigpXG4gIH1cblxuICB0aGlzLl9yZWFkaW5nID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gTWVkaWFEYXRhIChwYXJlbnQpIHtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgc3RyZWFtLlBhc3NUaHJvdWdoLmNhbGwodGhpcylcbn1cblxuaW5oZXJpdHMoTWVkaWFEYXRhLCBzdHJlYW0uUGFzc1Rocm91Z2gpXG5cbk1lZGlhRGF0YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX3BhcmVudC5kZXN0cm95KGVycilcbiAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG4iLCJleHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJylcbmV4cG9ydHMuZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBNdWx0aVN0cmVhbVxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxuaW5oZXJpdHMoTXVsdGlTdHJlYW0sIHN0cmVhbS5SZWFkYWJsZSlcblxuZnVuY3Rpb24gTXVsdGlTdHJlYW0gKHN0cmVhbXMsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpU3RyZWFtKSkgcmV0dXJuIG5ldyBNdWx0aVN0cmVhbShzdHJlYW1zLCBvcHRzKVxuICBzdHJlYW0uUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRzKVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLl9kcmFpbmVkID0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG4gIHRoaXMuX2N1cnJlbnQgPSBudWxsXG4gIHRoaXMuX3F1ZXVlID0gKHR5cGVvZiBzdHJlYW1zID09PSAnZnVuY3Rpb24nID8gc3RyZWFtcyA6IHN0cmVhbXMubWFwKHRvU3RyZWFtczIpKVxuXG4gIHRoaXMuX25leHQoKVxufVxuXG5NdWx0aVN0cmVhbS5vYmogPSBmdW5jdGlvbiAoc3RyZWFtcykge1xuICByZXR1cm4gbmV3IE11bHRpU3RyZWFtKHN0cmVhbXMsIHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogMTYgfSlcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kcmFpbmVkID0gdHJ1ZVxuICB0aGlzLl9mb3J3YXJkKClcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9mb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZm9yd2FyZGluZyB8fCAhdGhpcy5fZHJhaW5lZCB8fCAhdGhpcy5fY3VycmVudCkgcmV0dXJuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSB0cnVlXG5cbiAgdmFyIGNodW5rXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jdXJyZW50LnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICB0aGlzLl9kcmFpbmVkID0gdGhpcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG59XG5cbk11bHRpU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICBpZiAodGhpcy5fY3VycmVudCAmJiB0aGlzLl9jdXJyZW50LmRlc3Ryb3kpIHRoaXMuX2N1cnJlbnQuZGVzdHJveSgpXG4gIGlmICh0eXBlb2YgdGhpcy5fcXVldWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koKVxuICAgIH0pXG4gIH1cblxuICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuTXVsdGlTdHJlYW0ucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fY3VycmVudCA9IG51bGxcblxuICBpZiAodHlwZW9mIHNlbGYuX3F1ZXVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5fcXVldWUoZnVuY3Rpb24gKGVyciwgc3RyZWFtKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5kZXN0cm95KGVycilcbiAgICAgIHNlbGYuX2dvdE5leHRTdHJlYW0odG9TdHJlYW1zMihzdHJlYW0pKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmVhbSA9IHNlbGYuX3F1ZXVlLnNoaWZ0KClcbiAgICBpZiAodHlwZW9mIHN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykgc3RyZWFtID0gdG9TdHJlYW1zMihzdHJlYW0oKSlcbiAgICBzZWxmLl9nb3ROZXh0U3RyZWFtKHN0cmVhbSlcbiAgfVxufVxuXG5NdWx0aVN0cmVhbS5wcm90b3R5cGUuX2dvdE5leHRTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghc3RyZWFtKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpXG4gICAgc2VsZi5kZXN0cm95KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGYuX2N1cnJlbnQgPSBzdHJlYW1cbiAgc2VsZi5fZm9yd2FyZCgpXG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUpXG4gIHN0cmVhbS5vbignZW5kJywgb25FbmQpXG4gIHN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25DbG9zZSlcblxuICBmdW5jdGlvbiBvblJlYWRhYmxlICgpIHtcbiAgICBzZWxmLl9mb3J3YXJkKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UgKCkge1xuICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICBzZWxmLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kICgpIHtcbiAgICBzZWxmLl9jdXJyZW50ID0gbnVsbFxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvblJlYWRhYmxlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG4gICAgc2VsZi5fbmV4dCgpXG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yIChlcnIpIHtcbiAgICBzZWxmLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyZWFtczIgKHMpIHtcbiAgaWYgKCFzIHx8IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nIHx8IHMuX3JlYWRhYmxlU3RhdGUpIHJldHVybiBzXG5cbiAgdmFyIHdyYXAgPSBuZXcgc3RyZWFtLlJlYWRhYmxlKCkud3JhcChzKVxuICBpZiAocy5kZXN0cm95KSB7XG4gICAgd3JhcC5kZXN0cm95ID0gcy5kZXN0cm95LmJpbmQocylcbiAgfVxuICByZXR1cm4gd3JhcFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZXh0RXZlbnRcblxuZnVuY3Rpb24gbmV4dEV2ZW50IChlbWl0dGVyLCBuYW1lKSB7XG4gIHZhciBuZXh0ID0gbnVsbFxuICBlbWl0dGVyLm9uKG5hbWUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCFuZXh0KSByZXR1cm5cbiAgICB2YXIgZm4gPSBuZXh0XG4gICAgbmV4dCA9IG51bGxcbiAgICBmbihkYXRhKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAob25jZSkge1xuICAgIG5leHQgPSBvbmNlXG4gIH1cbn1cbiIsInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkob25jZSlcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZGVjb2RlVG9ycmVudEZpbGVcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IGRlY29kZVRvcnJlbnRGaWxlXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVUb3JyZW50RmlsZVxuXG52YXIgYmVuY29kZSA9IHJlcXVpcmUoJ2JlbmNvZGUnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcblxuLyoqXG4gKiBQYXJzZSBhIHRvcnJlbnQuIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHRvcnJlbnQgaXMgbWlzc2luZyByZXF1aXJlZCBmaWVsZHMuXG4gKiBAcGFyYW0gIHtCdWZmZXJ8T2JqZWN0fSB0b3JyZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBwYXJzZWQgdG9ycmVudFxuICovXG5mdW5jdGlvbiBkZWNvZGVUb3JyZW50RmlsZSAodG9ycmVudCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnQpKSB7XG4gICAgdG9ycmVudCA9IGJlbmNvZGUuZGVjb2RlKHRvcnJlbnQpXG4gIH1cblxuICAvLyBzYW5pdHkgY2hlY2tcbiAgZW5zdXJlKHRvcnJlbnQuaW5mbywgJ2luZm8nKVxuICBlbnN1cmUodG9ycmVudC5pbmZvWyduYW1lLnV0Zi04J10gfHwgdG9ycmVudC5pbmZvLm5hbWUsICdpbmZvLm5hbWUnKVxuICBlbnN1cmUodG9ycmVudC5pbmZvWydwaWVjZSBsZW5ndGgnXSwgJ2luZm9bXFwncGllY2UgbGVuZ3RoXFwnXScpXG4gIGVuc3VyZSh0b3JyZW50LmluZm8ucGllY2VzLCAnaW5mby5waWVjZXMnKVxuXG4gIGlmICh0b3JyZW50LmluZm8uZmlsZXMpIHtcbiAgICB0b3JyZW50LmluZm8uZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgZW5zdXJlKHR5cGVvZiBmaWxlLmxlbmd0aCA9PT0gJ251bWJlcicsICdpbmZvLmZpbGVzWzBdLmxlbmd0aCcpXG4gICAgICBlbnN1cmUoZmlsZVsncGF0aC51dGYtOCddIHx8IGZpbGUucGF0aCwgJ2luZm8uZmlsZXNbMF0ucGF0aCcpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBlbnN1cmUodHlwZW9mIHRvcnJlbnQuaW5mby5sZW5ndGggPT09ICdudW1iZXInLCAnaW5mby5sZW5ndGgnKVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG4gIHJlc3VsdC5pbmZvID0gdG9ycmVudC5pbmZvXG4gIHJlc3VsdC5pbmZvQnVmZmVyID0gYmVuY29kZS5lbmNvZGUodG9ycmVudC5pbmZvKVxuICByZXN1bHQuaW5mb0hhc2ggPSBzaGExLnN5bmMocmVzdWx0LmluZm9CdWZmZXIpXG4gIHJlc3VsdC5pbmZvSGFzaEJ1ZmZlciA9IG5ldyBCdWZmZXIocmVzdWx0LmluZm9IYXNoLCAnaGV4JylcblxuICByZXN1bHQubmFtZSA9ICh0b3JyZW50LmluZm9bJ25hbWUudXRmLTgnXSB8fCB0b3JyZW50LmluZm8ubmFtZSkudG9TdHJpbmcoKVxuXG4gIGlmICh0b3JyZW50LmluZm8ucHJpdmF0ZSAhPT0gdW5kZWZpbmVkKSByZXN1bHQucHJpdmF0ZSA9ICEhdG9ycmVudC5pbmZvLnByaXZhdGVcblxuICBpZiAodG9ycmVudFsnY3JlYXRpb24gZGF0ZSddKSByZXN1bHQuY3JlYXRlZCA9IG5ldyBEYXRlKHRvcnJlbnRbJ2NyZWF0aW9uIGRhdGUnXSAqIDEwMDApXG4gIGlmICh0b3JyZW50WydjcmVhdGVkIGJ5J10pIHJlc3VsdC5jcmVhdGVkQnkgPSB0b3JyZW50WydjcmVhdGVkIGJ5J10udG9TdHJpbmcoKVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodG9ycmVudC5jb21tZW50KSkgcmVzdWx0LmNvbW1lbnQgPSB0b3JyZW50LmNvbW1lbnQudG9TdHJpbmcoKVxuXG4gIC8vIGFubm91bmNlIGFuZCBhbm5vdW5jZS1saXN0IHdpbGwgYmUgbWlzc2luZyBpZiBtZXRhZGF0YSBmZXRjaGVkIHZpYSB1dF9tZXRhZGF0YVxuICByZXN1bHQuYW5ub3VuY2UgPSBbXVxuICBpZiAodG9ycmVudFsnYW5ub3VuY2UtbGlzdCddICYmIHRvcnJlbnRbJ2Fubm91bmNlLWxpc3QnXS5sZW5ndGgpIHtcbiAgICB0b3JyZW50Wydhbm5vdW5jZS1saXN0J10uZm9yRWFjaChmdW5jdGlvbiAodXJscykge1xuICAgICAgdXJscy5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmVzdWx0LmFubm91bmNlLnB1c2godXJsLnRvU3RyaW5nKCkpXG4gICAgICB9KVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodG9ycmVudC5hbm5vdW5jZSkge1xuICAgIHJlc3VsdC5hbm5vdW5jZS5wdXNoKHRvcnJlbnQuYW5ub3VuY2UudG9TdHJpbmcoKSlcbiAgfVxuXG4gIC8vIGhhbmRsZSB1cmwtbGlzdCAoQkVQMTkgLyB3ZWIgc2VlZGluZylcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3JyZW50Wyd1cmwtbGlzdCddKSkge1xuICAgIC8vIHNvbWUgY2xpZW50cyBzZXQgdXJsLWxpc3QgdG8gZW1wdHkgc3RyaW5nXG4gICAgdG9ycmVudFsndXJsLWxpc3QnXSA9IHRvcnJlbnRbJ3VybC1saXN0J10ubGVuZ3RoID4gMFxuICAgICAgPyBbIHRvcnJlbnRbJ3VybC1saXN0J10gXVxuICAgICAgOiBbXVxuICB9XG4gIHJlc3VsdC51cmxMaXN0ID0gKHRvcnJlbnRbJ3VybC1saXN0J10gfHwgW10pLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpXG4gIH0pXG5cbiAgdW5pcShyZXN1bHQuYW5ub3VuY2UpXG4gIHVuaXEocmVzdWx0LnVybExpc3QpXG5cbiAgdmFyIGZpbGVzID0gdG9ycmVudC5pbmZvLmZpbGVzIHx8IFsgdG9ycmVudC5pbmZvIF1cbiAgcmVzdWx0LmZpbGVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlLCBpKSB7XG4gICAgdmFyIHBhcnRzID0gW10uY29uY2F0KHJlc3VsdC5uYW1lLCBmaWxlWydwYXRoLnV0Zi04J10gfHwgZmlsZS5wYXRoIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwLnRvU3RyaW5nKClcbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLmpvaW4uYXBwbHkobnVsbCwgW3BhdGguc2VwXS5jb25jYXQocGFydHMpKS5zbGljZSgxKSxcbiAgICAgIG5hbWU6IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLFxuICAgICAgbGVuZ3RoOiBmaWxlLmxlbmd0aCxcbiAgICAgIG9mZnNldDogZmlsZXMuc2xpY2UoMCwgaSkucmVkdWNlKHN1bUxlbmd0aCwgMClcbiAgICB9XG4gIH0pXG5cbiAgcmVzdWx0Lmxlbmd0aCA9IGZpbGVzLnJlZHVjZShzdW1MZW5ndGgsIDApXG5cbiAgdmFyIGxhc3RGaWxlID0gcmVzdWx0LmZpbGVzW3Jlc3VsdC5maWxlcy5sZW5ndGggLSAxXVxuXG4gIHJlc3VsdC5waWVjZUxlbmd0aCA9IHRvcnJlbnQuaW5mb1sncGllY2UgbGVuZ3RoJ11cbiAgcmVzdWx0Lmxhc3RQaWVjZUxlbmd0aCA9ICgobGFzdEZpbGUub2Zmc2V0ICsgbGFzdEZpbGUubGVuZ3RoKSAlIHJlc3VsdC5waWVjZUxlbmd0aCkgfHwgcmVzdWx0LnBpZWNlTGVuZ3RoXG4gIHJlc3VsdC5waWVjZXMgPSBzcGxpdFBpZWNlcyh0b3JyZW50LmluZm8ucGllY2VzKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcGFyc2VkIHRvcnJlbnQgb2JqZWN0IGJhY2sgaW50byBhIC50b3JyZW50IGZpbGUgYnVmZmVyLlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJzZWQgcGFyc2VkIHRvcnJlbnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVG9ycmVudEZpbGUgKHBhcnNlZCkge1xuICB2YXIgdG9ycmVudCA9IHtcbiAgICBpbmZvOiBwYXJzZWQuaW5mb1xuICB9XG5cbiAgdG9ycmVudFsnYW5ub3VuY2UtbGlzdCddID0gKHBhcnNlZC5hbm5vdW5jZSB8fCBbXSkubWFwKGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIXRvcnJlbnQuYW5ub3VuY2UpIHRvcnJlbnQuYW5ub3VuY2UgPSB1cmxcbiAgICB1cmwgPSBuZXcgQnVmZmVyKHVybCwgJ3V0ZjgnKVxuICAgIHJldHVybiBbIHVybCBdXG4gIH0pXG5cbiAgdG9ycmVudFsndXJsLWxpc3QnXSA9IHBhcnNlZC51cmxMaXN0IHx8IFtdXG5cbiAgaWYgKHBhcnNlZC5jcmVhdGVkKSB7XG4gICAgdG9ycmVudFsnY3JlYXRpb24gZGF0ZSddID0gKHBhcnNlZC5jcmVhdGVkLmdldFRpbWUoKSAvIDEwMDApIHwgMFxuICB9XG5cbiAgaWYgKHBhcnNlZC5jcmVhdGVkQnkpIHtcbiAgICB0b3JyZW50WydjcmVhdGVkIGJ5J10gPSBwYXJzZWQuY3JlYXRlZEJ5XG4gIH1cblxuICBpZiAocGFyc2VkLmNvbW1lbnQpIHtcbiAgICB0b3JyZW50LmNvbW1lbnQgPSBwYXJzZWQuY29tbWVudFxuICB9XG5cbiAgcmV0dXJuIGJlbmNvZGUuZW5jb2RlKHRvcnJlbnQpXG59XG5cbmZ1bmN0aW9uIHN1bUxlbmd0aCAoc3VtLCBmaWxlKSB7XG4gIHJldHVybiBzdW0gKyBmaWxlLmxlbmd0aFxufVxuXG5mdW5jdGlvbiBzcGxpdFBpZWNlcyAoYnVmKSB7XG4gIHZhciBwaWVjZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMjApIHtcbiAgICBwaWVjZXMucHVzaChidWYuc2xpY2UoaSwgaSArIDIwKS50b1N0cmluZygnaGV4JykpXG4gIH1cbiAgcmV0dXJuIHBpZWNlc1xufVxuXG5mdW5jdGlvbiBlbnN1cmUgKGJvb2wsIGZpZWxkTmFtZSkge1xuICBpZiAoIWJvb2wpIHRocm93IG5ldyBFcnJvcignVG9ycmVudCBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkOiAnICsgZmllbGROYW1lKVxufVxuIiwidmFyIERpY3QgPSByZXF1aXJlKFwiLi9kaWN0XCIpXG5cbi8qKlxuICogRGVjb2RlcyBiZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcn0gZGF0YVxuICogQHBhcmFtICB7TnVtYmVyfSBzdGFydCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGVuY29kaW5nIChvcHRpb25hbClcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKCBkYXRhLCBzdGFydCwgZW5kLCBlbmNvZGluZyApIHtcbiAgXG4gIGlmKCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBzdGFydFxuICAgIHN0YXJ0ID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGlmKCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gZW5kXG4gICAgZW5kID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gISggQnVmZmVyLmlzQnVmZmVyKGRhdGEpIClcbiAgICA/IG5ldyBCdWZmZXIoIGRhdGEgKVxuICAgIDogZGF0YS5zbGljZSggc3RhcnQsIGVuZCApXG4gIFxuICBkZWNvZGUuYnl0ZXMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgXG4gIHJldHVybiBkZWNvZGUubmV4dCgpXG5cbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgICAgID0gbnVsbFxuZGVjb2RlLmVuY29kaW5nID0gbnVsbFxuXG5kZWNvZGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gIHN3aXRjaCggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSApIHtcbiAgICBjYXNlIDB4NjQ6IHJldHVybiBkZWNvZGUuZGljdGlvbmFyeSgpOyBicmVha1xuICAgIGNhc2UgMHg2QzogcmV0dXJuIGRlY29kZS5saXN0KCk7IGJyZWFrXG4gICAgY2FzZSAweDY5OiByZXR1cm4gZGVjb2RlLmludGVnZXIoKTsgYnJlYWtcbiAgICBkZWZhdWx0OiAgIHJldHVybiBkZWNvZGUuYnVmZmVyKCk7IGJyZWFrXG4gIH1cblxufVxuXG5kZWNvZGUuZmluZCA9IGZ1bmN0aW9uKCBjaHIgKSB7XG5cbiAgdmFyIGkgPSBkZWNvZGUucG9zaXRpb25cbiAgdmFyIGMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgdmFyIGQgPSBkZWNvZGUuZGF0YVxuXG4gIHdoaWxlKCBpIDwgYyApIHtcbiAgICBpZiggZFtpXSA9PT0gY2hyIClcbiAgICAgIHJldHVybiBpXG4gICAgaSsrXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0ludmFsaWQgZGF0YTogTWlzc2luZyBkZWxpbWl0ZXIgXCInICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaHIgKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoIDE2ICkgKyAnXSdcbiAgKVxuXG59XG5cbmRlY29kZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgZGljdCA9IG5ldyBEaWN0KClcblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBkaWN0LmJpbmFyeVNldChkZWNvZGUuYnVmZmVyKCksIGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBkaWN0XG5cbn1cblxuZGVjb2RlLmxpc3QgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBsc3QgPSBbXVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGxzdC5wdXNoKCBkZWNvZGUubmV4dCgpIClcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGxzdFxuXG59XG5cbmRlY29kZS5pbnRlZ2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGVuZCAgICA9IGRlY29kZS5maW5kKCAweDY1IClcbiAgdmFyIG51bWJlciA9IGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24gKyAxLCBlbmQgKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KCBudW1iZXIsIDEwIClcblxufVxuXG5kZWNvZGUuYnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNlcCAgICA9IGRlY29kZS5maW5kKCAweDNBIClcbiAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXAgKSwgMTAgKVxuICB2YXIgZW5kICAgID0gKytzZXAgKyBsZW5ndGhcblxuICBkZWNvZGUucG9zaXRpb24gPSBlbmRcblxuICByZXR1cm4gZGVjb2RlLmVuY29kaW5nXG4gICAgPyBkZWNvZGUuZGF0YS50b1N0cmluZyggZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZCApXG4gICAgOiBkZWNvZGUuZGF0YS5zbGljZSggc2VwLCBlbmQgKVxuXG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlXG4iLCIvKipcbiAqIEVuY29kZXMgZGF0YSBpbiBiZW5jb2RlLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcnxBcnJheXxTdHJpbmd8T2JqZWN0fE51bWJlcnxCb29sZWFufSBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZSggZGF0YSwgYnVmZmVyLCBvZmZzZXQgKSB7XG4gIFxuICB2YXIgYnVmZmVycyA9IFtdXG4gIHZhciByZXN1bHQgPSBudWxsXG4gIFxuICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YSApXG4gIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoIGJ1ZmZlcnMgKVxuICBlbmNvZGUuYnl0ZXMgPSByZXN1bHQubGVuZ3RoXG4gIFxuICBpZiggQnVmZmVyLmlzQnVmZmVyKCBidWZmZXIgKSApIHtcbiAgICByZXN1bHQuY29weSggYnVmZmVyLCBvZmZzZXQgKVxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdFxuICBcbn1cblxuZW5jb2RlLmJ5dGVzID0gLTFcbmVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSBmYWxzZVxuXG5lbmNvZGUuX2VuY29kZSA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGlmKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCggdHlwZW9mIGRhdGEgKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGVuY29kZS5idWZmZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KCBidWZmZXJzLCBkYXRhIClcbiAgICAgICAgOiBlbmNvZGUuZGljdCggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSA/IDEgOiAwIClcbiAgICAgIGJyZWFrXG4gIH1cblxufVxuXG52YXIgYnVmZl9lID0gbmV3IEJ1ZmZlcignZScpXG4gICwgYnVmZl9kID0gbmV3IEJ1ZmZlcignZCcpXG4gICwgYnVmZl9sID0gbmV3IEJ1ZmZlcignbCcpXG5cbmVuY29kZS5idWZmZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoIGRhdGEgKSArICc6JyArIGRhdGEpIClcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuICB2YXIgbWF4TG8gPSAweDgwMDAwMDAwXG4gIHZhciBoaSA9ICggZGF0YSAvIG1heExvICkgPDwgMFxuICB2YXIgbG8gPSAoIGRhdGEgJSBtYXhMbyAgKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoICdpJyArIHZhbCArICdlJyApKVxuXG4gIGlmKCB2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgKSB7XG4gICAgZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCA9IHRydWVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV0FSTklORzogUG9zc2libGUgZGF0YSBjb3JydXB0aW9uIGRldGVjdGVkIHdpdGggdmFsdWUgXCInK2RhdGErJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicrdmFsKydcIidcbiAgICApXG4gICAgY29uc29sZS50cmFjZSgpXG4gIH1cblxufVxuXG5lbmNvZGUuZGljdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9kIClcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcbiAgLy8gZml4IGZvciBpc3N1ZSAjMTMgLSBzb3J0ZWQgZGljdHNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZGF0YSApLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciggOyBqIDwga2wgOyBqKyspIHtcbiAgICBrPWtleXNbal1cbiAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBrIClcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtrXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgdmFyIGkgPSAwLCBqID0gMVxuICB2YXIgYyA9IGRhdGEubGVuZ3RoXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9sIClcblxuICBmb3IoIDsgaSA8IGM7IGkrKyApIHtcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtpXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG5cbn1cblxuLy8gRXhwb3NlXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuIiwiLyogZ2xvYmFsIEJsb2IgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVRvcnJlbnRcbm1vZHVsZS5leHBvcnRzLnJlbW90ZSA9IHBhcnNlVG9ycmVudFJlbW90ZVxuXG52YXIgYmxvYlRvQnVmZmVyID0gcmVxdWlyZSgnYmxvYi10by1idWZmZXInKVxudmFyIGZzID0gcmVxdWlyZSgnZnMnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBnZXQgPSByZXF1aXJlKCdzaW1wbGUtZ2V0JylcbnZhciBtYWduZXQgPSByZXF1aXJlKCdtYWduZXQtdXJpJylcbnZhciBwYXJzZVRvcnJlbnRGaWxlID0gcmVxdWlyZSgncGFyc2UtdG9ycmVudC1maWxlJylcblxubW9kdWxlLmV4cG9ydHMudG9NYWduZXRVUkkgPSBtYWduZXQuZW5jb2RlXG5tb2R1bGUuZXhwb3J0cy50b1RvcnJlbnRGaWxlID0gcGFyc2VUb3JyZW50RmlsZS5lbmNvZGVcblxuLyoqXG4gKiBQYXJzZSBhIHRvcnJlbnQgaWRlbnRpZmllciAobWFnbmV0IHVyaSwgLnRvcnJlbnQgZmlsZSwgaW5mbyBoYXNoKVxuICogQHBhcmFtICB7c3RyaW5nfEJ1ZmZlcnxPYmplY3R9IHRvcnJlbnRJZFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZVRvcnJlbnQgKHRvcnJlbnRJZCkge1xuICBpZiAodHlwZW9mIHRvcnJlbnRJZCA9PT0gJ3N0cmluZycgJiYgL14oc3RyZWFtLSk/bWFnbmV0Oi8udGVzdCh0b3JyZW50SWQpKSB7XG4gICAgLy8gbWFnbmV0IHVyaSAoc3RyaW5nKVxuICAgIHJldHVybiBtYWduZXQodG9ycmVudElkKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0b3JyZW50SWQgPT09ICdzdHJpbmcnICYmICgvXlthLWYwLTldezQwfSQvaS50ZXN0KHRvcnJlbnRJZCkgfHwgL15bYS16Mi03XXszMn0kL2kudGVzdCh0b3JyZW50SWQpKSkge1xuICAgIC8vIGluZm8gaGFzaCAoaGV4L2Jhc2UtMzIgc3RyaW5nKVxuICAgIHJldHVybiBtYWduZXQoJ21hZ25ldDo/eHQ9dXJuOmJ0aWg6JyArIHRvcnJlbnRJZClcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodG9ycmVudElkKSAmJiB0b3JyZW50SWQubGVuZ3RoID09PSAyMCkge1xuICAgIC8vIGluZm8gaGFzaCAoYnVmZmVyKVxuICAgIHJldHVybiBtYWduZXQoJ21hZ25ldDo/eHQ9dXJuOmJ0aWg6JyArIHRvcnJlbnRJZC50b1N0cmluZygnaGV4JykpXG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcnJlbnRJZCkpIHtcbiAgICAvLyAudG9ycmVudCBmaWxlIChidWZmZXIpXG4gICAgcmV0dXJuIHBhcnNlVG9ycmVudEZpbGUodG9ycmVudElkKSAvLyBtaWdodCB0aHJvd1xuICB9IGVsc2UgaWYgKHRvcnJlbnRJZCAmJiB0b3JyZW50SWQuaW5mb0hhc2gpIHtcbiAgICAvLyBwYXJzZWQgdG9ycmVudCAoZnJvbSBgcGFyc2UtdG9ycmVudGAsIGBwYXJzZS10b3JyZW50LWZpbGVgLCBvciBgbWFnbmV0LXVyaWApXG4gICAgaWYgKCF0b3JyZW50SWQuYW5ub3VuY2UpIHRvcnJlbnRJZC5hbm5vdW5jZSA9IFtdXG4gICAgaWYgKHR5cGVvZiB0b3JyZW50SWQuYW5ub3VuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0b3JyZW50SWQuYW5ub3VuY2UgPSBbIHRvcnJlbnRJZC5hbm5vdW5jZSBdXG4gICAgfVxuICAgIGlmICghdG9ycmVudElkLnVybExpc3QpIHRvcnJlbnRJZC51cmxMaXN0ID0gW11cbiAgICByZXR1cm4gdG9ycmVudElkXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRvcnJlbnQgaWRlbnRpZmllcicpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUb3JyZW50UmVtb3RlICh0b3JyZW50SWQsIGNiKSB7XG4gIHZhciBwYXJzZWRUb3JyZW50XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvbicpXG5cbiAgdHJ5IHtcbiAgICBwYXJzZWRUb3JyZW50ID0gcGFyc2VUb3JyZW50KHRvcnJlbnRJZClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWYgdG9ycmVudCBmYWlscyB0byBwYXJzZSwgaXQgY291bGQgYmUgYSBCbG9iLCBodHRwL2h0dHBzIFVSTCBvclxuICAgIC8vIGZpbGVzeXN0ZW0gcGF0aCwgc28gZG9uJ3QgY29uc2lkZXIgaXQgYW4gZXJyb3IgeWV0LlxuICB9XG5cbiAgaWYgKHBhcnNlZFRvcnJlbnQgJiYgcGFyc2VkVG9ycmVudC5pbmZvSGFzaCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2IobnVsbCwgcGFyc2VkVG9ycmVudClcbiAgICB9KVxuICB9IGVsc2UgaWYgKGlzQmxvYih0b3JyZW50SWQpKSB7XG4gICAgYmxvYlRvQnVmZmVyKHRvcnJlbnRJZCwgZnVuY3Rpb24gKGVyciwgdG9ycmVudEJ1Zikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKG5ldyBFcnJvcignRXJyb3IgY29udmVydGluZyBCbG9iOiAnICsgZXJyLm1lc3NhZ2UpKVxuICAgICAgcGFyc2VPclRocm93KHRvcnJlbnRCdWYpXG4gICAgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2V0ID09PSAnZnVuY3Rpb24nICYmIC9eaHR0cHM/Oi8udGVzdCh0b3JyZW50SWQpKSB7XG4gICAgLy8gaHR0cCwgb3IgaHR0cHMgdXJsIHRvIHRvcnJlbnQgZmlsZVxuICAgIGdldC5jb25jYXQoe1xuICAgICAgdXJsOiB0b3JyZW50SWQsXG4gICAgICBoZWFkZXJzOiB7ICd1c2VyLWFnZW50JzogJ1dlYlRvcnJlbnQgKGh0dHA6Ly93ZWJ0b3JyZW50LmlvKScgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcywgdG9ycmVudEJ1Zikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKG5ldyBFcnJvcignRXJyb3IgZG93bmxvYWRpbmcgdG9ycmVudDogJyArIGVyci5tZXNzYWdlKSlcbiAgICAgIHBhcnNlT3JUaHJvdyh0b3JyZW50QnVmKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGZzLnJlYWRGaWxlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0b3JyZW50SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gYXNzdW1lIGl0J3MgYSBmaWxlc3lzdGVtIHBhdGhcbiAgICBmcy5yZWFkRmlsZSh0b3JyZW50SWQsIGZ1bmN0aW9uIChlcnIsIHRvcnJlbnRCdWYpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihuZXcgRXJyb3IoJ0ludmFsaWQgdG9ycmVudCBpZGVudGlmaWVyJykpXG4gICAgICBwYXJzZU9yVGhyb3codG9ycmVudEJ1ZilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2IobmV3IEVycm9yKCdJbnZhbGlkIHRvcnJlbnQgaWRlbnRpZmllcicpKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9yVGhyb3cgKHRvcnJlbnRCdWYpIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVG9ycmVudCA9IHBhcnNlVG9ycmVudCh0b3JyZW50QnVmKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG4gICAgaWYgKHBhcnNlZFRvcnJlbnQgJiYgcGFyc2VkVG9ycmVudC5pbmZvSGFzaCkgY2IobnVsbCwgcGFyc2VkVG9ycmVudClcbiAgICBlbHNlIGNiKG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKSlcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVzNDIGBCbG9iYCBvciBgRmlsZWAgb2JqZWN0XG4gKiBAcGFyYW0gIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQmxvYiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgQmxvYlxufVxuXG4vLyBXb3JrYXJvdW5kIEJyb3dzZXJpZnkgdjEzIGJ1Z1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL25vZGUtYnJvd3NlcmlmeS9pc3N1ZXMvMTQ4M1xuOyhmdW5jdGlvbiAoKSB7IEJ1ZmZlcigwKSB9KSgpXG4iLCIvKipcbiAqIEpTT04gcGFyc2UuXG4gKlxuICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC87XG52YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcbnZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG52YXIgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xudmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XG52YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpIHtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCwgJycpLnJlcGxhY2UocnRyaW1SaWdodCwgJycpO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICBpZiAoZ2xvYmFsLkpTT04gJiYgSlNPTi5wYXJzZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG5cbiAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxuICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXG4gICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcbiAgfVxufTsiLCIvKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiBxcnk7XG59O1xuIiwiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gICAgdmFyIHNyYyA9IHN0cixcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxuICAgICAgICB1cmkgPSB7fSxcbiAgICAgICAgaSA9IDE0O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1cmk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCJ2YXIgY2xvc2VzdCA9IHJlcXVpcmUoJ2Nsb3Nlc3QtdG8nKVxuXG4vLyBDcmVhdGUgYSByYW5nZSBmcm9tIDE2a2LigJM0bWJcbnZhciBzaXplcyA9IFtdXG5mb3IgKHZhciBpID0gMTQ7IGkgPD0gMjI7IGkrKykge1xuICBzaXplcy5wdXNoKE1hdGgucG93KDIsIGkpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcmV0dXJuIGNsb3Nlc3QoXG4gICAgc2l6ZSAvIE1hdGgucG93KDIsIDEwKSwgc2l6ZXMgXG4gIClcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIGVvcyA9IHJlcXVpcmUoJ2VuZC1vZi1zdHJlYW0nKVxudmFyIGZzID0gcmVxdWlyZSgnZnMnKSAvLyB3ZSBvbmx5IG5lZWQgZnMgdG8gZ2V0IHRoZSBSZWFkU3RyZWFtIGFuZCBXcml0ZVN0cmVhbSBwcm90b3R5cGVzXG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxudmFyIGlzRm4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG52YXIgaXNGUyA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgcmV0dXJuIChzdHJlYW0gaW5zdGFuY2VvZiAoZnMuUmVhZFN0cmVhbSB8fCBub29wKSB8fCBzdHJlYW0gaW5zdGFuY2VvZiAoZnMuV3JpdGVTdHJlYW0gfHwgbm9vcCkpICYmIGlzRm4oc3RyZWFtLmNsb3NlKVxufVxuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiBpc0ZuKHN0cmVhbS5hYm9ydClcbn1cblxudmFyIGRlc3Ryb3llciA9IGZ1bmN0aW9uIChzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICB2YXIgY2xvc2VkID0gZmFsc2VcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gIH0pXG5cbiAgZW9zKHN0cmVhbSwge3JlYWRhYmxlOiByZWFkaW5nLCB3cml0YWJsZTogd3JpdGluZ30sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGNsb3NlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gIH0pXG5cbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuXG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgaWYgKGlzRlMoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5jbG9zZSgpIC8vIHVzZSBjbG9zZSBmb3IgZnMgc3RyZWFtcyB0byBhdm9pZCBmZCBsZWFrc1xuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpIC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNGbihzdHJlYW0uZGVzdHJveSkpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpXG5cbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVycm9yKCdzdHJlYW0gd2FzIGRlc3Ryb3llZCcpKVxuICB9XG59XG5cbnZhciBjYWxsID0gZnVuY3Rpb24gKGZuKSB7XG4gIGZuKClcbn1cblxudmFyIHBpcGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0bylcbn1cblxudmFyIHB1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHJlYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB2YXIgY2FsbGJhY2sgPSBpc0ZuKHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSB8fCBub29wKSAmJiBzdHJlYW1zLnBvcCgpIHx8IG5vb3BcblxuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF1cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdwdW1wIHJlcXVpcmVzIHR3byBzdHJlYW1zIHBlciBtaW5pbXVtJylcblxuICB2YXIgZXJyb3JcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIHZhciB3cml0aW5nID0gaSA+IDBcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnJcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm5cbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbClcbiAgICAgIGNhbGxiYWNrKGVycm9yKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHVtcFxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwidmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIgb2Zmc2V0ID0gMFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChvZmZzZXQgPT09IGxpc3QubGVuZ3RoKSByZXR1cm4gbnVsbFxuXG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoIC0gb2Zmc2V0XG4gICAgdmFyIGkgPSAoTWF0aC5yYW5kb20oKSAqIGxlbikgfCAwXG4gICAgdmFyIGVsID0gbGlzdFtvZmZzZXQgKyBpXVxuXG4gICAgdmFyIHRtcCA9IGxpc3Rbb2Zmc2V0XVxuICAgIGxpc3Rbb2Zmc2V0XSA9IGVsXG4gICAgbGlzdFtvZmZzZXQgKyBpXSA9IHRtcFxuICAgIG9mZnNldCsrXG5cbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGl0ZXJhdGVcbiIsIi8qXG5JbnN0YW5jZSBvZiB3cml0YWJsZSBzdHJlYW0uXG5cbmNhbGwgLmdldChsZW5ndGgpIG9yIC5kaXNjYXJkKGxlbmd0aCkgdG8gZ2V0IGEgc3RyZWFtIChyZWxhdGl2ZSB0byB0aGUgbGFzdCBlbmQpXG5cbmVtaXRzICdzdGFsbGVkJyBvbmNlIGV2ZXJ5dGhpbmcgaXMgd3JpdHRlblxuXG5cbiovXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZVNsaWNlU3RyZWFtXG5cbmluaGVyaXRzKFJhbmdlU2xpY2VTdHJlYW0sIHN0cmVhbS5Xcml0YWJsZSlcblxuZnVuY3Rpb24gUmFuZ2VTbGljZVN0cmVhbSAob2Zmc2V0KSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoIShzZWxmIGluc3RhbmNlb2YgUmFuZ2VTbGljZVN0cmVhbSkpIHJldHVybiBuZXcgUmFuZ2VTbGljZVN0cmVhbShvZmZzZXQpXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuXHRzZWxmLl9xdWV1ZSA9IFtdXG5cdHNlbGYuX3Bvc2l0aW9uID0gb2Zmc2V0IHx8IDBcblx0c2VsZi5fY2IgPSBudWxsXG5cdHNlbGYuX2J1ZmZlciA9IG51bGxcblx0c2VsZi5fb3V0ID0gbnVsbFxufVxuXG5SYW5nZVNsaWNlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgZHJhaW5lZCA9IHRydWVcblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGlmIChzZWxmLmRlc3Ryb3llZCkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gV2FpdCBmb3IgbW9yZSBxdWV1ZSBlbnRyaWVzXG5cdFx0aWYgKHNlbGYuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0c2VsZi5fYnVmZmVyID0gY2h1bmtcblx0XHRcdHNlbGYuX2NiID0gY2Jcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHNlbGYuX2J1ZmZlciA9IG51bGxcblx0XHR2YXIgY3VyclJhbmdlID0gc2VsZi5fcXVldWVbMF1cblx0XHQvLyBSZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgY2h1bmssIHdoYXQgZGF0YSBkbyB3ZSBuZWVkP1xuXHRcdHZhciB3cml0ZVN0YXJ0ID0gTWF0aC5tYXgoY3VyclJhbmdlLnN0YXJ0IC0gc2VsZi5fcG9zaXRpb24sIDApXG5cdFx0dmFyIHdyaXRlRW5kID0gY3VyclJhbmdlLmVuZCAtIHNlbGYuX3Bvc2l0aW9uXG5cblx0XHQvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHRocm93IGl0IGFsbCBhd2F5XG5cdFx0aWYgKHdyaXRlU3RhcnQgPj0gY2h1bmsubGVuZ3RoKSB7XG5cdFx0XHRzZWxmLl9wb3NpdGlvbiArPSBjaHVuay5sZW5ndGhcblx0XHRcdHJldHVybiBjYihudWxsKVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXNlIGl0IGFsbFxuXHRcdHZhciB0b1dyaXRlXG5cdFx0aWYgKHdyaXRlRW5kID4gY2h1bmsubGVuZ3RoKSB7XG5cdFx0XHRzZWxmLl9wb3NpdGlvbiArPSBjaHVuay5sZW5ndGhcblx0XHRcdGlmICh3cml0ZVN0YXJ0ID09PSAwKSB7XG5cdFx0XHRcdHRvV3JpdGUgPSBjaHVua1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9Xcml0ZSA9IGNodW5rLnNsaWNlKHdyaXRlU3RhcnQpXG5cdFx0XHR9XG5cdFx0XHRkcmFpbmVkID0gY3VyclJhbmdlLnN0cmVhbS53cml0ZSh0b1dyaXRlKSAmJiBkcmFpbmVkXG5cdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHNlbGYuX3Bvc2l0aW9uICs9IHdyaXRlRW5kXG5cdFx0aWYgKHdyaXRlU3RhcnQgPT09IDAgJiYgd3JpdGVFbmQgPT09IGNodW5rLmxlbmd0aCkge1xuXHRcdFx0dG9Xcml0ZSA9IGNodW5rXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvV3JpdGUgPSBjaHVuay5zbGljZSh3cml0ZVN0YXJ0LCB3cml0ZUVuZClcblx0XHR9XG5cdFx0ZHJhaW5lZCA9IGN1cnJSYW5nZS5zdHJlYW0ud3JpdGUodG9Xcml0ZSkgJiYgZHJhaW5lZFxuXHRcdGlmIChjdXJyUmFuZ2UubGFzdCkge1xuXHRcdFx0Y3VyclJhbmdlLnN0cmVhbS5lbmQoKVxuXHRcdH1cblx0XHRjaHVuayA9IGNodW5rLnNsaWNlKHdyaXRlRW5kKVxuXHRcdHNlbGYuX3F1ZXVlLnNoaWZ0KClcblx0fVxuXG5cdGlmIChkcmFpbmVkKSB7XG5cdFx0Y2IobnVsbClcblx0fSBlbHNlIHtcblx0XHRjdXJyUmFuZ2Uuc3RyZWFtLm9uY2UoJ2RyYWluJywgY2IuYmluZChudWxsLCBudWxsKSlcblx0fVxufVxuXG5SYW5nZVNsaWNlU3RyZWFtLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChyYW5nZXMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gbnVsbFxuXG5cdGlmICghKHJhbmdlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdHJhbmdlcyA9IFtyYW5nZXNdXG5cdH1cblxuXHR2YXIgc3RyID0gbmV3IHN0cmVhbS5QYXNzVGhyb3VnaCgpXG5cblx0cmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlLCBpKSB7XG5cdFx0c2VsZi5fcXVldWUucHVzaCh7XG5cdFx0XHRzdGFydDogcmFuZ2Uuc3RhcnQsXG5cdFx0XHRlbmQ6IHJhbmdlLmVuZCxcblx0XHRcdHN0cmVhbTogc3RyLFxuXHRcdFx0bGFzdDogaSA9PT0gKHJhbmdlcy5sZW5ndGggLSAxKVxuXHRcdH0pXG5cdH0pXG5cdGlmIChzZWxmLl9idWZmZXIpIHtcblx0XHRzZWxmLl93cml0ZShzZWxmLl9idWZmZXIsIG51bGwsIHNlbGYuX2NiKVxuXHR9XG5cblx0cmV0dXJuIHN0clxufVxuXG5SYW5nZVNsaWNlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblx0c2VsZi5kZXN0cm95ZWQgPSB0cnVlXG5cblx0aWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBoYXNQcmVwZW5kTGlzdGVuZXIgPSB0eXBlb2YgRUUucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICBpZiAoaGFzUHJlcGVuZExpc3RlbmVyKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZVxuICAvLyBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAvLyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGUgdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWxcbiAgLy8gaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXQgPSBudWxsO2Vsc2UgaWYgKG9iamVjdE1vZGUpIHJldCA9IGxpc3Quc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpIHJldCA9IGxpc3Quam9pbignJyk7ZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldCA9IGxpc3RbMF07ZWxzZSByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCA9ICcnO2Vsc2UgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgX2J1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgX2J1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKSByZXQgKz0gX2J1Zi5zbGljZSgwLCBjcHkpO2Vsc2UgX2J1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgX2J1Zi5sZW5ndGgpIGxpc3RbMF0gPSBfYnVmLnNsaWNlKGNweSk7ZWxzZSBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG4gIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxuICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3dcbiAgLy8gaWYgaXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59IiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbn1cbiIsImV4cG9ydHMucmVuZGVyID0gcmVuZGVyXG5leHBvcnRzLmFwcGVuZCA9IGFwcGVuZFxudmFyIG1pbWUgPSBleHBvcnRzLm1pbWUgPSByZXF1aXJlKCcuL2xpYi9taW1lLmpzb24nKVxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdyZW5kZXItbWVkaWEnKVxudmFyIGlzQXNjaWkgPSByZXF1aXJlKCdpcy1hc2NpaScpXG52YXIgTWVkaWFFbGVtZW50V3JhcHBlciA9IHJlcXVpcmUoJ21lZGlhc291cmNlJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgc3RyZWFtVG9CbG9iVVJMID0gcmVxdWlyZSgnc3RyZWFtLXRvLWJsb2ItdXJsJylcbnZhciB2aWRlb3N0cmVhbSA9IHJlcXVpcmUoJ3ZpZGVvc3RyZWFtJylcblxudmFyIFZJREVPU1RSRUFNX0VYVFMgPSBbICcubXA0JywgJy5tNHYnLCAnLm00YScgXVxuXG52YXIgTUVESUFTT1VSQ0VfVklERU9fRVhUUyA9IFsgJy5tcDQnLCAnLm00dicsICcud2VibScsICcubWt2JyBdXG52YXIgTUVESUFTT1VSQ0VfQVVESU9fRVhUUyA9IFsgJy5tNGEnLCAnLm1wMycgXVxudmFyIE1FRElBU09VUkNFX0VYVFMgPSBNRURJQVNPVVJDRV9WSURFT19FWFRTLmNvbmNhdChNRURJQVNPVVJDRV9BVURJT19FWFRTKVxuXG52YXIgQVVESU9fRVhUUyA9IFsgJy53YXYnLCAnLmFhYycsICcub2dnJywgJy5vZ2EnIF1cbnZhciBJTUFHRV9FWFRTID0gWyAnLmpwZycsICcuanBlZycsICcucG5nJywgJy5naWYnLCAnLmJtcCcgXVxudmFyIElGUkFNRV9FWFRTID0gWyAnLmNzcycsICcuaHRtbCcsICcuanMnLCAnLm1kJywgJy5wZGYnLCAnLnR4dCcgXVxuXG52YXIgTWVkaWFTb3VyY2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWVkaWFTb3VyY2VcblxuZnVuY3Rpb24gcmVuZGVyIChmaWxlLCBlbGVtLCBjYikge1xuICB2YWxpZGF0ZUZpbGUoZmlsZSlcbiAgaWYgKHR5cGVvZiBlbGVtID09PSAnc3RyaW5nJykgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbSlcblxuICByZW5kZXJNZWRpYShmaWxlLCBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIGlmIChlbGVtLm5vZGVOYW1lICE9PSB0YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKGZpbGUubmFtZSkudG9Mb3dlckNhc2UoKVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3QgcmVuZGVyIFwiJyArIGV4dG5hbWUgKyAnXCIgaW5zaWRlIGEgXCInICtcbiAgICAgICAgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICsgJ1wiIGVsZW1lbnQsIGV4cGVjdGVkIFwiJyArIHRhZ05hbWUgKyAnXCInXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1cbiAgfSwgY2IpXG59XG5cbmZ1bmN0aW9uIGFwcGVuZCAoZmlsZSwgcm9vdEVsZW0sIGNiKSB7XG4gIGlmICghY2IpIGNiID0gZnVuY3Rpb24gKCkge31cbiAgdmFsaWRhdGVGaWxlKGZpbGUpXG4gIGlmICh0eXBlb2Ygcm9vdEVsZW0gPT09ICdzdHJpbmcnKSByb290RWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdEVsZW0pXG5cbiAgaWYgKHJvb3RFbGVtICYmIChyb290RWxlbS5ub2RlTmFtZSA9PT0gJ1ZJREVPJyB8fCByb290RWxlbS5ub2RlTmFtZSA9PT0gJ0FVRElPJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2aWRlby9hdWRpbyBub2RlIGFyZ3VtZW50LiBBcmd1bWVudCBtdXN0IGJlIHJvb3QgZWxlbWVudCB0aGF0ICcgK1xuICAgICAgJ3ZpZGVvL2F1ZGlvIHRhZyB3aWxsIGJlIGFwcGVuZGVkIHRvLidcbiAgICApXG4gIH1cblxuICByZW5kZXJNZWRpYShmaWxlLCBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIGlmICh0YWdOYW1lID09PSAndmlkZW8nIHx8IHRhZ05hbWUgPT09ICdhdWRpbycpIHJldHVybiBjcmVhdGVNZWRpYSh0YWdOYW1lKVxuICAgIGVsc2UgcmV0dXJuIGNyZWF0ZUVsZW0odGFnTmFtZSlcbiAgfSwgZnVuY3Rpb24gKGVyciwgZWxlbSkge1xuICAgIGlmIChlcnIgJiYgZWxlbSkgZWxlbS5yZW1vdmUoKVxuICAgIGNiKGVyciwgZWxlbSlcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVNZWRpYSAodGFnTmFtZSkge1xuICAgIHZhciBlbGVtID0gY3JlYXRlRWxlbSh0YWdOYW1lKVxuICAgIGVsZW0uY29udHJvbHMgPSB0cnVlXG4gICAgZWxlbS5hdXRvcGxheSA9IHRydWVcbiAgICByb290RWxlbS5hcHBlbmRDaGlsZChlbGVtKVxuICAgIHJldHVybiBlbGVtXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtICh0YWdOYW1lKSB7XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpXG4gICAgcm9vdEVsZW0uYXBwZW5kQ2hpbGQoZWxlbSlcbiAgICByZXR1cm4gZWxlbVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1lZGlhIChmaWxlLCBnZXRFbGVtLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IGZ1bmN0aW9uICgpIHt9XG4gIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKGZpbGUubmFtZSkudG9Mb3dlckNhc2UoKVxuICB2YXIgY3VycmVudFRpbWUgPSAwXG4gIHZhciBlbGVtXG5cbiAgaWYgKE1FRElBU09VUkNFX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVyTWVkaWFTb3VyY2UoKVxuICB9IGVsc2UgaWYgKEFVRElPX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVyQXVkaW8oKVxuICB9IGVsc2UgaWYgKElNQUdFX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgcmVuZGVySW1hZ2UoKVxuICB9IGVsc2UgaWYgKElGUkFNRV9FWFRTLmluZGV4T2YoZXh0bmFtZSkgPj0gMCkge1xuICAgIHJlbmRlcklmcmFtZSgpXG4gIH0gZWxzZSB7XG4gICAgdHJ5UmVuZGVySWZyYW1lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlck1lZGlhU291cmNlICgpIHtcbiAgICB2YXIgdGFnTmFtZSA9IE1FRElBU09VUkNFX1ZJREVPX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwID8gJ3ZpZGVvJyA6ICdhdWRpbydcblxuICAgIGlmIChNZWRpYVNvdXJjZSkge1xuICAgICAgaWYgKFZJREVPU1RSRUFNX0VYVFMuaW5kZXhPZihleHRuYW1lKSA+PSAwKSB7XG4gICAgICAgIHVzZVZpZGVvc3RyZWFtKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVzZU1lZGlhU291cmNlKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXNlQmxvYlVSTCgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlVmlkZW9zdHJlYW0gKCkge1xuICAgICAgZGVidWcoJ1VzZSBgdmlkZW9zdHJlYW1gIHBhY2thZ2UgZm9yICcgKyBmaWxlLm5hbWUpXG4gICAgICBwcmVwYXJlRWxlbSgpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZmFsbGJhY2tUb01lZGlhU291cmNlKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBvbkxvYWRTdGFydClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICAgIHZpZGVvc3RyZWFtKGZpbGUsIGVsZW0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlTWVkaWFTb3VyY2UgKCkge1xuICAgICAgZGVidWcoJ1VzZSBNZWRpYVNvdXJjZSBBUEkgZm9yICcgKyBmaWxlLm5hbWUpXG4gICAgICBwcmVwYXJlRWxlbSgpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZmFsbGJhY2tUb0Jsb2JVUkwpXG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5Jywgb25DYW5QbGF5KVxuXG4gICAgICB2YXIgd3JhcHBlciA9IG5ldyBNZWRpYUVsZW1lbnRXcmFwcGVyKGVsZW0pXG4gICAgICB2YXIgd3JpdGFibGUgPSB3cmFwcGVyLmNyZWF0ZVdyaXRlU3RyZWFtKGdldENvZGVjKGZpbGUubmFtZSkpXG4gICAgICBmaWxlLmNyZWF0ZVJlYWRTdHJlYW0oKS5waXBlKHdyaXRhYmxlKVxuXG4gICAgICBpZiAoY3VycmVudFRpbWUpIGVsZW0uY3VycmVudFRpbWUgPSBjdXJyZW50VGltZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVzZUJsb2JVUkwgKCkge1xuICAgICAgZGVidWcoJ1VzZSBCbG9iIFVSTCBmb3IgJyArIGZpbGUubmFtZSlcbiAgICAgIHByZXBhcmVFbGVtKClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYXRhbEVycm9yKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBvbkxvYWRTdGFydClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICAgIGdldEJsb2JVUkwoZmlsZSwgZnVuY3Rpb24gKGVyciwgdXJsKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBmYXRhbEVycm9yKGVycilcbiAgICAgICAgZWxlbS5zcmMgPSB1cmxcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lKSBlbGVtLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmFsbGJhY2tUb01lZGlhU291cmNlIChlcnIpIHtcbiAgICAgIGRlYnVnKCd2aWRlb3N0cmVhbSBlcnJvcjogZmFsbGJhY2sgdG8gTWVkaWFTb3VyY2UgQVBJOiAlbycsIGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYWxsYmFja1RvTWVkaWFTb3VyY2UpXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXkpXG5cbiAgICAgIHVzZU1lZGlhU291cmNlKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWxsYmFja1RvQmxvYlVSTCAoZXJyKSB7XG4gICAgICBkZWJ1ZygnTWVkaWFTb3VyY2UgQVBJIGVycm9yOiBmYWxsYmFjayB0byBCbG9iIFVSTDogJW8nLCBlcnIubWVzc2FnZSB8fCBlcnIpXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZmFsbGJhY2tUb0Jsb2JVUkwpXG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXkpXG5cbiAgICAgIHVzZUJsb2JVUkwoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVFbGVtICgpIHtcbiAgICAgIGlmICghZWxlbSkge1xuICAgICAgICBlbGVtID0gZ2V0RWxlbSh0YWdOYW1lKVxuXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3VycmVudFRpbWUgPSBlbGVtLmN1cnJlbnRUaW1lXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyQXVkaW8gKCkge1xuICAgIGVsZW0gPSBnZXRFbGVtKCdhdWRpbycpXG4gICAgZ2V0QmxvYlVSTChmaWxlLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBmYXRhbEVycm9yKGVycilcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmYXRhbEVycm9yKVxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBvbkxvYWRTdGFydClcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICAgIGVsZW0uc3JjID0gdXJsXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTG9hZFN0YXJ0ICgpIHtcbiAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIG9uTG9hZFN0YXJ0KVxuICAgIGVsZW0ucGxheSgpXG4gIH1cblxuICBmdW5jdGlvbiBvbkNhblBsYXkgKCkge1xuICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheSlcbiAgICBjYihudWxsLCBlbGVtKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVySW1hZ2UgKCkge1xuICAgIGVsZW0gPSBnZXRFbGVtKCdpbWcnKVxuICAgIGdldEJsb2JVUkwoZmlsZSwgZnVuY3Rpb24gKGVyciwgdXJsKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZmF0YWxFcnJvcihlcnIpXG4gICAgICBlbGVtLnNyYyA9IHVybFxuICAgICAgZWxlbS5hbHQgPSBmaWxlLm5hbWVcbiAgICAgIGNiKG51bGwsIGVsZW0pXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlcklmcmFtZSAoKSB7XG4gICAgZWxlbSA9IGdldEVsZW0oJ2lmcmFtZScpXG5cbiAgICBnZXRCbG9iVVJMKGZpbGUsIGZ1bmN0aW9uIChlcnIsIHVybCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGZhdGFsRXJyb3IoZXJyKVxuICAgICAgZWxlbS5zcmMgPSB1cmxcbiAgICAgIGlmIChleHRuYW1lICE9PSAnLnBkZicpIGVsZW0uc2FuZGJveCA9ICdhbGxvdy1mb3JtcyBhbGxvdy1zY3JpcHRzJ1xuICAgICAgY2IobnVsbCwgZWxlbSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5UmVuZGVySWZyYW1lICgpIHtcbiAgICBkZWJ1ZygnVW5rbm93biBmaWxlIGV4dGVuc2lvbiBcIiVzXCIgLSB3aWxsIGF0dGVtcHQgdG8gcmVuZGVyIGludG8gaWZyYW1lJywgZXh0bmFtZSlcblxuICAgIHZhciBzdHIgPSAnJ1xuICAgIGZpbGUuY3JlYXRlUmVhZFN0cmVhbSh7IHN0YXJ0OiAwLCBlbmQ6IDEwMDAgfSlcbiAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc3RyICs9IGNodW5rXG4gICAgICB9KVxuICAgICAgLm9uKCdlbmQnLCBkb25lKVxuICAgICAgLm9uKCdlcnJvcicsIGNiKVxuXG4gICAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgICBpZiAoaXNBc2NpaShzdHIpKSB7XG4gICAgICAgIGRlYnVnKCdGaWxlIGV4dGVuc2lvbiBcIiVzXCIgYXBwZWFycyBhc2NpaSwgc28gd2lsbCByZW5kZXIuJywgZXh0bmFtZSlcbiAgICAgICAgcmVuZGVySWZyYW1lKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdGaWxlIGV4dGVuc2lvbiBcIiVzXCIgYXBwZWFycyBub24tYXNjaWksIHdpbGwgbm90IHJlbmRlci4nLCBleHRuYW1lKVxuICAgICAgICBjYihuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZSBcIicgKyBleHRuYW1lICsgJ1wiOiBDYW5ub3QgYXBwZW5kIHRvIERPTScpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZhdGFsRXJyb3IgKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gJ0Vycm9yIHJlbmRlcmluZyBmaWxlIFwiJyArIGZpbGUubmFtZSArICdcIjogJyArIGVyci5tZXNzYWdlXG4gICAgZGVidWcoZXJyLm1lc3NhZ2UpXG4gICAgY2IoZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJsb2JVUkwgKGZpbGUsIGNiKSB7XG4gIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKGZpbGUubmFtZSkudG9Mb3dlckNhc2UoKVxuICBzdHJlYW1Ub0Jsb2JVUkwoZmlsZS5jcmVhdGVSZWFkU3RyZWFtKCksIG1pbWVbZXh0bmFtZV0sIGNiKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbGUgKGZpbGUpIHtcbiAgaWYgKGZpbGUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlsZSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKVxuICB9XG4gIGlmICh0eXBlb2YgZmlsZS5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvciBpbnZhbGlkIGZpbGUubmFtZSBwcm9wZXJ0eScpXG4gIH1cbiAgaWYgKHR5cGVvZiBmaWxlLmNyZWF0ZVJlYWRTdHJlYW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3IgaW52YWxpZCBmaWxlLmNyZWF0ZVJlYWRTdHJlYW0gcHJvcGVydHknKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvZGVjIChuYW1lKSB7XG4gIHZhciBleHRuYW1lID0gcGF0aC5leHRuYW1lKG5hbWUpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHtcbiAgICAnLm00YSc6ICdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wNGEuNDAuNVwiJyxcbiAgICAnLm00dic6ICd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNjQwMDI5LCBtcDRhLjQwLjVcIicsXG4gICAgJy5ta3YnOiAndmlkZW8vd2VibTsgY29kZWNzPVwiYXZjMS42NDAwMjksIG1wNGEuNDAuNVwiJyxcbiAgICAnLm1wMyc6ICdhdWRpby9tcGVnJyxcbiAgICAnLm1wNCc6ICd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNjQwMDI5LCBtcDRhLjQwLjVcIicsXG4gICAgJy53ZWJtJzogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZvcmJpcywgdnA4XCInXG4gIH1bZXh0bmFtZV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIuM2dwXCI6IFwidmlkZW8vM2dwcFwiLFxuICBcIi5hYWNcIjogXCJhdWRpby9hYWNcIixcbiAgXCIuYWlmXCI6IFwiYXVkaW8veC1haWZmXCIsXG4gIFwiLmFpZmZcIjogXCJhdWRpby94LWFpZmZcIixcbiAgXCIuYXRvbVwiOiBcImFwcGxpY2F0aW9uL2F0b20reG1sXCIsXG4gIFwiLmF2aVwiOiBcInZpZGVvL3gtbXN2aWRlb1wiLFxuICBcIi5ibXBcIjogXCJpbWFnZS9ibXBcIixcbiAgXCIuYnoyXCI6IFwiYXBwbGljYXRpb24veC1iemlwMlwiLFxuICBcIi5jb25mXCI6IFwidGV4dC9wbGFpblwiLFxuICBcIi5jc3NcIjogXCJ0ZXh0L2Nzc1wiLFxuICBcIi5jc3ZcIjogXCJ0ZXh0L2NzdlwiLFxuICBcIi5kaWZmXCI6IFwidGV4dC94LWRpZmZcIixcbiAgXCIuZG9jXCI6IFwiYXBwbGljYXRpb24vbXN3b3JkXCIsXG4gIFwiLmZsdlwiOiBcInZpZGVvL3gtZmx2XCIsXG4gIFwiLmdpZlwiOiBcImltYWdlL2dpZlwiLFxuICBcIi5nelwiOiBcImFwcGxpY2F0aW9uL3gtZ3ppcFwiLFxuICBcIi5odG1cIjogXCJ0ZXh0L2h0bWxcIixcbiAgXCIuaHRtbFwiOiBcInRleHQvaHRtbFwiLFxuICBcIi5pY29cIjogXCJpbWFnZS92bmQubWljcm9zb2Z0Lmljb25cIixcbiAgXCIuaWNzXCI6IFwidGV4dC9jYWxlbmRhclwiLFxuICBcIi5pc29cIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgXCIuamFyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwiLmpwZWdcIjogXCJpbWFnZS9qcGVnXCIsXG4gIFwiLmpwZ1wiOiBcImltYWdlL2pwZWdcIixcbiAgXCIuanNcIjogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIsXG4gIFwiLmpzb25cIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIFwiLmxlc3NcIjogXCJ0ZXh0L2Nzc1wiLFxuICBcIi5sb2dcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiLm0zdVwiOiBcImF1ZGlvL3gtbXBlZ3VybFwiLFxuICBcIi5tNGFcIjogXCJhdWRpby9tcDRcIixcbiAgXCIubTR2XCI6IFwidmlkZW8vbXA0XCIsXG4gIFwiLm1hbmlmZXN0XCI6IFwidGV4dC9jYWNoZS1tYW5pZmVzdFwiLFxuICBcIi5tYXJrZG93blwiOiBcInRleHQveC1tYXJrZG93blwiLFxuICBcIi5tYXRobWxcIjogXCJhcHBsaWNhdGlvbi9tYXRobWwreG1sXCIsXG4gIFwiLm1kXCI6IFwidGV4dC94LW1hcmtkb3duXCIsXG4gIFwiLm1pZFwiOiBcImF1ZGlvL21pZGlcIixcbiAgXCIubWlkaVwiOiBcImF1ZGlvL21pZGlcIixcbiAgXCIubW92XCI6IFwidmlkZW8vcXVpY2t0aW1lXCIsXG4gIFwiLm1wM1wiOiBcImF1ZGlvL21wZWdcIixcbiAgXCIubXA0XCI6IFwidmlkZW8vbXA0XCIsXG4gIFwiLm1wNHZcIjogXCJ2aWRlby9tcDRcIixcbiAgXCIubXBlZ1wiOiBcInZpZGVvL21wZWdcIixcbiAgXCIubXBnXCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIi5vZHBcIjogXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvblwiLFxuICBcIi5vZHNcIjogXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0XCIsXG4gIFwiLm9kdFwiOiBcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dFwiLFxuICBcIi5vZ2FcIjogXCJhdWRpby9vZ2dcIixcbiAgXCIub2dnXCI6IFwiYXBwbGljYXRpb24vb2dnXCIsXG4gIFwiLnBkZlwiOiBcImFwcGxpY2F0aW9uL3BkZlwiLFxuICBcIi5wbmdcIjogXCJpbWFnZS9wbmdcIixcbiAgXCIucHBzXCI6IFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnRcIixcbiAgXCIucHB0XCI6IFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnRcIixcbiAgXCIucHNcIjogXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCIsXG4gIFwiLnBzZFwiOiBcImltYWdlL3ZuZC5hZG9iZS5waG90b3Nob3BcIixcbiAgXCIucXRcIjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgXCIucmFyXCI6IFwiYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZFwiLFxuICBcIi5yZGZcIjogXCJhcHBsaWNhdGlvbi9yZGYreG1sXCIsXG4gIFwiLnJzc1wiOiBcImFwcGxpY2F0aW9uL3Jzcyt4bWxcIixcbiAgXCIucnRmXCI6IFwiYXBwbGljYXRpb24vcnRmXCIsXG4gIFwiLnN2Z1wiOiBcImltYWdlL3N2Zyt4bWxcIixcbiAgXCIuc3ZnelwiOiBcImltYWdlL3N2Zyt4bWxcIixcbiAgXCIuc3dmXCI6IFwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIixcbiAgXCIudGFyXCI6IFwiYXBwbGljYXRpb24veC10YXJcIixcbiAgXCIudGJ6XCI6IFwiYXBwbGljYXRpb24veC1iemlwLWNvbXByZXNzZWQtdGFyXCIsXG4gIFwiLnRleHRcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiLnRpZlwiOiBcImltYWdlL3RpZmZcIixcbiAgXCIudGlmZlwiOiBcImltYWdlL3RpZmZcIixcbiAgXCIudG9ycmVudFwiOiBcImFwcGxpY2F0aW9uL3gtYml0dG9ycmVudFwiLFxuICBcIi50dGZcIjogXCJhcHBsaWNhdGlvbi94LWZvbnQtdHRmXCIsXG4gIFwiLnR4dFwiOiBcInRleHQvcGxhaW5cIixcbiAgXCIud2F2XCI6IFwiYXVkaW8vd2F2XCIsXG4gIFwiLndlYm1cIjogXCJ2aWRlby93ZWJtXCIsXG4gIFwiLndtYVwiOiBcImF1ZGlvL3gtbXMtd21hXCIsXG4gIFwiLndtdlwiOiBcInZpZGVvL3gtbXMtd212XCIsXG4gIFwiLnhsc1wiOiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiLFxuICBcIi54bWxcIjogXCJhcHBsaWNhdGlvbi94bWxcIixcbiAgXCIueWFtbFwiOiBcInRleHQveWFtbFwiLFxuICBcIi55bWxcIjogXCJ0ZXh0L3lhbWxcIixcbiAgXCIuemlwXCI6IFwiYXBwbGljYXRpb24vemlwXCJcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhc2tzLCBsaW1pdCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKVxuICB2YXIgcmVzdWx0cywgbGVuLCBwZW5kaW5nLCBrZXlzLCBpc0Vycm9yZWRcbiAgdmFyIGlzU3luYyA9IHRydWVcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0YXNrcykpIHtcbiAgICByZXN1bHRzID0gW11cbiAgICBwZW5kaW5nID0gbGVuID0gdGFza3MubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHRhc2tzKVxuICAgIHJlc3VsdHMgPSB7fVxuICAgIHBlbmRpbmcgPSBsZW4gPSBrZXlzLmxlbmd0aFxuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XG4gICAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIGlmIChjYikgY2IoZXJyLCByZXN1bHRzKVxuICAgICAgY2IgPSBudWxsXG4gICAgfVxuICAgIGlmIChpc1N5bmMpIHByb2Nlc3MubmV4dFRpY2soZW5kKVxuICAgIGVsc2UgZW5kKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2ggKGksIGVyciwgcmVzdWx0KSB7XG4gICAgcmVzdWx0c1tpXSA9IHJlc3VsdFxuICAgIGlmIChlcnIpIGlzRXJyb3JlZCA9IHRydWVcbiAgICBpZiAoLS1wZW5kaW5nID09PSAwIHx8IGVycikge1xuICAgICAgZG9uZShlcnIpXG4gICAgfSBlbHNlIGlmICghaXNFcnJvcmVkICYmIG5leHQgPCBsZW4pIHtcbiAgICAgIHZhciBrZXlcbiAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgIGtleSA9IGtleXNbbmV4dF1cbiAgICAgICAgbmV4dCArPSAxXG4gICAgICAgIHRhc2tzW2tleV0oZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goa2V5LCBlcnIsIHJlc3VsdCkgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IG5leHRcbiAgICAgICAgbmV4dCArPSAxXG4gICAgICAgIHRhc2tzW2tleV0oZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goa2V5LCBlcnIsIHJlc3VsdCkgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dCA9IGxpbWl0XG4gIGlmICghcGVuZGluZykge1xuICAgIC8vIGVtcHR5XG4gICAgZG9uZShudWxsKVxuICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAvLyBvYmplY3RcbiAgICBrZXlzLnNvbWUoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgICAgaWYgKGkgPT09IGxpbWl0IC0gMSkgcmV0dXJuIHRydWUgLy8gZWFybHkgcmV0dXJuXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBhcnJheVxuICAgIHRhc2tzLnNvbWUoZnVuY3Rpb24gKHRhc2ssIGkpIHtcbiAgICAgIHRhc2soZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7IGVhY2goaSwgZXJyLCByZXN1bHQpIH0pXG4gICAgICBpZiAoaSA9PT0gbGltaXQgLSAxKSByZXR1cm4gdHJ1ZSAvLyBlYXJseSByZXR1cm5cbiAgICB9KVxuICB9XG5cbiAgaXNTeW5jID0gZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhc2tzLCBjYikge1xuICB2YXIgcmVzdWx0cywgcGVuZGluZywga2V5c1xuICB2YXIgaXNTeW5jID0gdHJ1ZVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhc2tzKSkge1xuICAgIHJlc3VsdHMgPSBbXVxuICAgIHBlbmRpbmcgPSB0YXNrcy5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModGFza3MpXG4gICAgcmVzdWx0cyA9IHt9XG4gICAgcGVuZGluZyA9IGtleXMubGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiBkb25lIChlcnIpIHtcbiAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgaWYgKGNiKSBjYihlcnIsIHJlc3VsdHMpXG4gICAgICBjYiA9IG51bGxcbiAgICB9XG4gICAgaWYgKGlzU3luYykgcHJvY2Vzcy5uZXh0VGljayhlbmQpXG4gICAgZWxzZSBlbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gZWFjaCAoaSwgZXJyLCByZXN1bHQpIHtcbiAgICByZXN1bHRzW2ldID0gcmVzdWx0XG4gICAgaWYgKC0tcGVuZGluZyA9PT0gMCB8fCBlcnIpIHtcbiAgICAgIGRvbmUoZXJyKVxuICAgIH1cbiAgfVxuXG4gIGlmICghcGVuZGluZykge1xuICAgIC8vIGVtcHR5XG4gICAgZG9uZShudWxsKVxuICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAvLyBvYmplY3RcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdGFza3Nba2V5XShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsgZWFjaChrZXksIGVyciwgcmVzdWx0KSB9KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gYXJyYXlcbiAgICB0YXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrLCBpKSB7XG4gICAgICB0YXNrKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgeyBlYWNoKGksIGVyciwgcmVzdWx0KSB9KVxuICAgIH0pXG4gIH1cblxuICBpc1N5bmMgPSBmYWxzZVxufVxuIiwiLypcbiAqIFJ1c2hhLCBhIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsXG4gKiBhcyBkZWZpbmVkIGluIEZJUFMgUFVCIDE4MC0xLCB0dW5lZCBmb3IgaGlnaCBwZXJmb3JtYW5jZSB3aXRoIGxhcmdlIGlucHV0cy5cbiAqIChodHRwOi8vZ2l0aHViLmNvbS9zcmlqcy9ydXNoYSlcbiAqXG4gKiBJbnNwaXJlZCBieSBQYXVsIEpvaG5zdG9ucyBpbXBsZW1lbnRhdGlvbiAoaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIFNhbSBSaWpzIChodHRwOi8vYXdlc2FtLmRlKS5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UgYXMgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuICogSU4gVEhFIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciB1dGlsID0ge1xuICAgICAgICAgICAgZ2V0RGF0YVR5cGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdidWZmZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3ZpZXcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdibG9iJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgLy8gVGhlIFJ1c2hhIG9iamVjdCBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBsb3ctbGV2ZWwgUnVzaGFDb3JlLlxuICAgIC8vIEl0IHByb3ZpZGVzIG1lYW5zIG9mIGNvbnZlcnRpbmcgZGlmZmVyZW50IGlucHV0cyB0byB0aGVcbiAgICAvLyBmb3JtYXQgYWNjZXB0ZWQgYnkgUnVzaGFDb3JlIGFzIHdlbGwgYXMgb3RoZXIgdXRpbGl0eSBtZXRob2RzLlxuICAgIGZ1bmN0aW9uIFJ1c2hhKGNodW5rU2l6ZSkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIC8vIFByaXZhdGUgb2JqZWN0IHN0cnVjdHVyZS5cbiAgICAgICAgdmFyIHNlbGYkMiA9IHsgZmlsbDogMCB9O1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBidWZmZXIgdGhhdCB0aGUgc2hhMSByb3V0aW5lIHVzZXNcbiAgICAgICAgLy8gaW5jbHVkaW5nIHRoZSBwYWRkaW5nLlxuICAgICAgICB2YXIgcGFkbGVuID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICAgICAgZm9yIChsZW4gKz0gOTsgbGVuICUgNjQgPiAwOyBsZW4gKz0gMSk7XG4gICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFkWmVyb2VzID0gZnVuY3Rpb24gKGJpbiwgbGVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVuID4+IDI7IGkgPCBiaW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYmluW2ldID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhZERhdGEgPSBmdW5jdGlvbiAoYmluLCBjaHVua0xlbiwgbXNnTGVuKSB7XG4gICAgICAgICAgICBiaW5bY2h1bmtMZW4gPj4gMl0gfD0gMTI4IDw8IDI0IC0gKGNodW5rTGVuICUgNCA8PCAzKTtcbiAgICAgICAgICAgIGJpblsoKGNodW5rTGVuID4+IDIpICsgMiAmIH4xNSkgKyAxNF0gPSBtc2dMZW4gPj4gMjk7XG4gICAgICAgICAgICBiaW5bKChjaHVua0xlbiA+PiAyKSArIDIgJiB+MTUpICsgMTVdID0gbXNnTGVuIDw8IDM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENvbnZlcnQgYSBiaW5hcnkgc3RyaW5nIGFuZCB3cml0ZSBpdCB0byB0aGUgaGVhcC5cbiAgICAgICAgLy8gQSBiaW5hcnkgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIG9ubHkgY29udGFpbiBjaGFyIGNvZGVzIDwgMjU2LlxuICAgICAgICB2YXIgY29udlN0ciA9IGZ1bmN0aW9uIChIOCwgSDMyLCBzdGFydCwgbGVuLCBvZmYpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSB0aGlzLCBpLCBvbSA9IG9mZiAlIDQsIGxtID0gbGVuICUgNCwgaiA9IGxlbiAtIGxtO1xuICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvbSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMyB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMiB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDEgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMik7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gb207IGkgPCBqOyBpID0gaSArIDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgSDMyW29mZiArIGkgPj4gMl0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIGkpIDw8IDI0IHwgc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBpICsgMSkgPDwgMTYgfCBzdHIuY2hhckNvZGVBdChzdGFydCArIGkgKyAyKSA8PCA4IHwgc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBpICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGxtKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDEgfCAwXSA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgaiArIDIpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAyIHwgMF0gPSBzdHIuY2hhckNvZGVBdChzdGFydCArIGogKyAxKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMyB8IDBdID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQgKyBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCBhIGJ1ZmZlciBvciBhcnJheSBhbmQgd3JpdGUgaXQgdG8gdGhlIGhlYXAuXG4gICAgICAgIC8vIFRoZSBidWZmZXIgb3IgYXJyYXkgaXMgZXhwZWN0ZWQgdG8gb25seSBjb250YWluIGVsZW1lbnRzIDwgMjU2LlxuICAgICAgICB2YXIgY29udkJ1ZiA9IGZ1bmN0aW9uIChIOCwgSDMyLCBzdGFydCwgbGVuLCBvZmYpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSB0aGlzLCBpLCBvbSA9IG9mZiAlIDQsIGxtID0gbGVuICUgNCwgaiA9IGxlbiAtIGxtO1xuICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvbSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMyB8IDBdID0gYnVmW3N0YXJ0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIEg4W29mZiArIDIgfCAwXSA9IGJ1ZltzdGFydCArIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgSDhbb2ZmICsgMSB8IDBdID0gYnVmW3N0YXJ0ICsgMl07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgfCAwXSA9IGJ1ZltzdGFydCArIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDQgLSBvbTsgaSA8IGo7IGkgPSBpICs9IDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgSDMyW29mZiArIGkgPj4gMl0gPSBidWZbc3RhcnQgKyBpXSA8PCAyNCB8IGJ1ZltzdGFydCArIGkgKyAxXSA8PCAxNiB8IGJ1ZltzdGFydCArIGkgKyAyXSA8PCA4IHwgYnVmW3N0YXJ0ICsgaSArIDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChsbSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIEg4W29mZiArIGogKyAxIHwgMF0gPSBidWZbc3RhcnQgKyBqICsgMl07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDIgfCAwXSA9IGJ1ZltzdGFydCArIGogKyAxXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBIOFtvZmYgKyBqICsgMyB8IDBdID0gYnVmW3N0YXJ0ICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb252QmxvYiA9IGZ1bmN0aW9uIChIOCwgSDMyLCBzdGFydCwgbGVuLCBvZmYpIHtcbiAgICAgICAgICAgIHZhciBibG9iID0gdGhpcywgaSwgb20gPSBvZmYgJSA0LCBsbSA9IGxlbiAlIDQsIGogPSBsZW4gLSBsbTtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYi5zbGljZShzdGFydCwgc3RhcnQgKyBsZW4pKSk7XG4gICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9tKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAzIHwgMF0gPSBidWZbMF07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAyIHwgMF0gPSBidWZbMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgKyAxIHwgMF0gPSBidWZbMl07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBIOFtvZmYgfCAwXSA9IGJ1ZlszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSA0IC0gb207IGkgPCBqOyBpID0gaSArPSA0IHwgMCkge1xuICAgICAgICAgICAgICAgIEgzMltvZmYgKyBpID4+IDJdID0gYnVmW2ldIDw8IDI0IHwgYnVmW2kgKyAxXSA8PCAxNiB8IGJ1ZltpICsgMl0gPDwgOCB8IGJ1ZltpICsgM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGxtKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDEgfCAwXSA9IGJ1ZltqICsgMl07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDIgfCAwXSA9IGJ1ZltqICsgMV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgSDhbb2ZmICsgaiArIDMgfCAwXSA9IGJ1ZltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnZGbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHV0aWwuZ2V0RGF0YVR5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZTdHIuYmluZChkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udkJ1Zi5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udkJ1Zi5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QnVmLmJpbmQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICAgICAgY2FzZSAndmlldyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZCdWYuYmluZChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb252QmxvYi5iaW5kKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2xpY2UgPSBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHV0aWwuZ2V0RGF0YVR5cGUoZGF0YSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShvZmZzZXQpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICAgICBjYXNlICd2aWV3JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5idWZmZXIuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCBhbiBBcnJheUJ1ZmZlciBpbnRvIGl0cyBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICAgIHZhciBoZXggPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBpLCB4LCBoZXhfdGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnLCByZXMgPSBbXSwgYmluYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gYmluYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gaGV4X3RhYi5jaGFyQXQoeCA+PiA0ICYgMTUpICsgaGV4X3RhYi5jaGFyQXQoeCA+PiAwICYgMTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNlaWxIZWFwU2l6ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAvLyBUaGUgYXNtLmpzIHNwZWMgc2F5czpcbiAgICAgICAgICAgIC8vIFRoZSBoZWFwIG9iamVjdCdzIGJ5dGVMZW5ndGggbXVzdCBiZSBlaXRoZXJcbiAgICAgICAgICAgIC8vIDJebiBmb3IgbiBpbiBbMTIsIDI0KSBvciAyXjI0ICogbiBmb3IgbiDiiaUgMS5cbiAgICAgICAgICAgIC8vIEFsc28sIGJ5dGVMZW5ndGhzIHNtYWxsZXIgdGhhbiAyXjE2IGFyZSBkZXByZWNhdGVkLlxuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICAvLyBJZiB2IGlzIHNtYWxsZXIgdGhhbiAyXjE2LCB0aGUgc21hbGxlc3QgcG9zc2libGUgc29sdXRpb25cbiAgICAgICAgICAgIC8vIGlzIDJeMTYuXG4gICAgICAgICAgICBpZiAodiA8PSA2NTUzNilcbiAgICAgICAgICAgICAgICByZXR1cm4gNjU1MzY7XG4gICAgICAgICAgICAvLyBJZiB2IDwgMl4yNCwgd2Ugcm91bmQgdXAgdG8gMl5uLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHJvdW5kIHVwIHRvIDJeMjQgKiBuLlxuICAgICAgICAgICAgaWYgKHYgPCAxNjc3NzIxNikge1xuICAgICAgICAgICAgICAgIGZvciAocCA9IDE7IHAgPCB2OyBwID0gcCA8PCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChwID0gMTY3NzcyMTY7IHAgPCB2OyBwICs9IDE2Nzc3MjE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMgdG8gYSBuZXcgY2FwYWNpdHkuXG4gICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIGlmIChzaXplICUgNjQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaHVuayBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxMjggYml0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmJDIubWF4Q2h1bmtMZW4gPSBzaXplO1xuICAgICAgICAgICAgc2VsZiQyLnBhZE1heENodW5rTGVuID0gcGFkbGVuKHNpemUpO1xuICAgICAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIGhlYXAgaXMgdGhlIHN1bSBvZjpcbiAgICAgICAgICAgIC8vIDEuIFRoZSBwYWRkZWQgaW5wdXQgbWVzc2FnZSBzaXplXG4gICAgICAgICAgICAvLyAyLiBUaGUgZXh0ZW5kZWQgc3BhY2UgdGhlIGFsZ29yaXRobSBuZWVkcyAoMzIwIGJ5dGUpXG4gICAgICAgICAgICAvLyAzLiBUaGUgMTYwIGJpdCBzdGF0ZSB0aGUgYWxnb3JpdG0gdXNlc1xuICAgICAgICAgICAgc2VsZiQyLmhlYXAgPSBuZXcgQXJyYXlCdWZmZXIoY2VpbEhlYXBTaXplKHNlbGYkMi5wYWRNYXhDaHVua0xlbiArIDMyMCArIDIwKSk7XG4gICAgICAgICAgICBzZWxmJDIuaDMyID0gbmV3IEludDMyQXJyYXkoc2VsZiQyLmhlYXApO1xuICAgICAgICAgICAgc2VsZiQyLmg4ID0gbmV3IEludDhBcnJheShzZWxmJDIuaGVhcCk7XG4gICAgICAgICAgICBzZWxmJDIuY29yZSA9IG5ldyBSdXNoYS5fY29yZSh7XG4gICAgICAgICAgICAgICAgSW50MzJBcnJheTogSW50MzJBcnJheSxcbiAgICAgICAgICAgICAgICBEYXRhVmlldzogRGF0YVZpZXdcbiAgICAgICAgICAgIH0sIHt9LCBzZWxmJDIuaGVhcCk7XG4gICAgICAgICAgICBzZWxmJDIuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWluaXRpYWxpemV0aGUgZGF0YXN0cnVjdHVyZXMgYWNjb3JkaW5nXG4gICAgICAgIC8vIHRvIGEgY2h1bmsgc2l5emUuXG4gICAgICAgIGluaXQoY2h1bmtTaXplIHx8IDY0ICogMTAyNCk7XG4gICAgICAgIHZhciBpbml0U3RhdGUgPSBmdW5jdGlvbiAoaGVhcCwgcGFkTXNnTGVuKSB7XG4gICAgICAgICAgICB2YXIgaW8gPSBuZXcgSW50MzJBcnJheShoZWFwLCBwYWRNc2dMZW4gKyAzMjAsIDUpO1xuICAgICAgICAgICAgaW9bMF0gPSAxNzMyNTg0MTkzO1xuICAgICAgICAgICAgaW9bMV0gPSAtMjcxNzMzODc5O1xuICAgICAgICAgICAgaW9bMl0gPSAtMTczMjU4NDE5NDtcbiAgICAgICAgICAgIGlvWzNdID0gMjcxNzMzODc4O1xuICAgICAgICAgICAgaW9bNF0gPSAtMTAwOTU4OTc3NjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhZENodW5rID0gZnVuY3Rpb24gKGNodW5rTGVuLCBtc2dMZW4pIHtcbiAgICAgICAgICAgIHZhciBwYWRDaHVua0xlbiA9IHBhZGxlbihjaHVua0xlbik7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBJbnQzMkFycmF5KHNlbGYkMi5oZWFwLCAwLCBwYWRDaHVua0xlbiA+PiAyKTtcbiAgICAgICAgICAgIHBhZFplcm9lcyh2aWV3LCBjaHVua0xlbik7XG4gICAgICAgICAgICBwYWREYXRhKHZpZXcsIGNodW5rTGVuLCBtc2dMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHBhZENodW5rTGVuO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXcml0ZSBkYXRhIHRvIHRoZSBoZWFwLlxuICAgICAgICB2YXIgd3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgY2h1bmtPZmZzZXQsIGNodW5rTGVuKSB7XG4gICAgICAgICAgICBjb252Rm4oZGF0YSkoc2VsZiQyLmg4LCBzZWxmJDIuaDMyLCBjaHVua09mZnNldCwgY2h1bmtMZW4sIDApO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBjYWxsIHRoZSBSdXNoYUNvcmUsXG4gICAgICAgIC8vIGFzc3VtaW5nIGFuIGlucHV0IGJ1ZmZlciBvZiBsZW5ndGggbGVuICogNC5cbiAgICAgICAgdmFyIGNvcmVDYWxsID0gZnVuY3Rpb24gKGRhdGEsIGNodW5rT2Zmc2V0LCBjaHVua0xlbiwgbXNnTGVuLCBmaW5hbGl6ZSkge1xuICAgICAgICAgICAgdmFyIHBhZENodW5rTGVuID0gY2h1bmtMZW47XG4gICAgICAgICAgICBpZiAoZmluYWxpemUpIHtcbiAgICAgICAgICAgICAgICBwYWRDaHVua0xlbiA9IHBhZENodW5rKGNodW5rTGVuLCBtc2dMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGUoZGF0YSwgY2h1bmtPZmZzZXQsIGNodW5rTGVuKTtcbiAgICAgICAgICAgIHNlbGYkMi5jb3JlLmhhc2gocGFkQ2h1bmtMZW4sIHNlbGYkMi5wYWRNYXhDaHVua0xlbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRSYXdEaWdlc3QgPSBmdW5jdGlvbiAoaGVhcCwgcGFkTWF4Q2h1bmtMZW4pIHtcbiAgICAgICAgICAgIHZhciBpbyA9IG5ldyBJbnQzMkFycmF5KGhlYXAsIHBhZE1heENodW5rTGVuICsgMzIwLCA1KTtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgSW50MzJBcnJheSg1KTtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgRGF0YVZpZXcob3V0LmJ1ZmZlcik7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoMCwgaW9bMF0sIGZhbHNlKTtcbiAgICAgICAgICAgIGFyci5zZXRJbnQzMig0LCBpb1sxXSwgZmFsc2UpO1xuICAgICAgICAgICAgYXJyLnNldEludDMyKDgsIGlvWzJdLCBmYWxzZSk7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoMTIsIGlvWzNdLCBmYWxzZSk7XG4gICAgICAgICAgICBhcnIuc2V0SW50MzIoMTYsIGlvWzRdLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGhhc2ggZGlnZXN0IGFzIGFuIGFycmF5IG9mIDUgMzJiaXQgaW50ZWdlcnMuXG4gICAgICAgIHZhciByYXdEaWdlc3QgPSB0aGlzLnJhd0RpZ2VzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnTGVuID0gc3RyLmJ5dGVMZW5ndGggfHwgc3RyLmxlbmd0aCB8fCBzdHIuc2l6ZSB8fCAwO1xuICAgICAgICAgICAgICAgIGluaXRTdGF0ZShzZWxmJDIuaGVhcCwgc2VsZiQyLnBhZE1heENodW5rTGVuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSAwLCBjaHVua0xlbiA9IHNlbGYkMi5tYXhDaHVua0xlbiwgbGFzdDtcbiAgICAgICAgICAgICAgICBmb3IgKGNodW5rT2Zmc2V0ID0gMDsgbXNnTGVuID4gY2h1bmtPZmZzZXQgKyBjaHVua0xlbjsgY2h1bmtPZmZzZXQgKz0gY2h1bmtMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29yZUNhbGwoc3RyLCBjaHVua09mZnNldCwgY2h1bmtMZW4sIG1zZ0xlbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3JlQ2FsbChzdHIsIGNodW5rT2Zmc2V0LCBtc2dMZW4gLSBjaHVua09mZnNldCwgbXNnTGVuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmF3RGlnZXN0KHNlbGYkMi5oZWFwLCBzZWxmJDIucGFkTWF4Q2h1bmtMZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIGRpZ2VzdCBhbmQgZGlnZXN0RnJvbSogaW50ZXJmYWNlIHJldHVybnMgdGhlIGhhc2ggZGlnZXN0XG4gICAgICAgIC8vIGFzIGEgaGV4IHN0cmluZy5cbiAgICAgICAgdGhpcy5kaWdlc3QgPSB0aGlzLmRpZ2VzdEZyb21TdHJpbmcgPSB0aGlzLmRpZ2VzdEZyb21CdWZmZXIgPSB0aGlzLmRpZ2VzdEZyb21BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXgocmF3RGlnZXN0KHN0cikuYnVmZmVyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgO1xuICAgIC8vIFRoZSBsb3ctbGV2ZWwgUnVzaENvcmUgbW9kdWxlIHByb3ZpZGVzIHRoZSBoZWFydCBvZiBSdXNoYSxcbiAgICAvLyBhIGhpZ2gtc3BlZWQgc2hhMSBpbXBsZW1lbnRhdGlvbiB3b3JraW5nIG9uIGFuIEludDMyQXJyYXkgaGVhcC5cbiAgICAvLyBBdCBmaXJzdCBnbGFuY2UsIHRoZSBpbXBsZW1lbnRhdGlvbiBzZWVtcyBjb21wbGljYXRlZCwgaG93ZXZlclxuICAgIC8vIHdpdGggdGhlIFNIQTEgc3BlYyBhdCBoYW5kLCBpdCBpcyBvYnZpb3VzIHRoaXMgYWxtb3N0IGEgdGV4dGJvb2tcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiB0aGF0IGhhcyBhIGZldyBmdW5jdGlvbnMgaGFuZC1pbmxpbmVkIGFuZCBhIGZldyBsb29wc1xuICAgIC8vIGhhbmQtdW5yb2xsZWQuXG4gICAgUnVzaGEuX2NvcmUgPSBmdW5jdGlvbiBSdXNoYUNvcmUoc3RkbGliLCBmb3JlaWduLCBoZWFwKSB7XG4gICAgICAgICd1c2UgYXNtJztcbiAgICAgICAgdmFyIEggPSBuZXcgc3RkbGliLkludDMyQXJyYXkoaGVhcCk7XG4gICAgICAgIGZ1bmN0aW9uIGhhc2goaywgeCkge1xuICAgICAgICAgICAgLy8gayBpbiBieXRlc1xuICAgICAgICAgICAgayA9IGsgfCAwO1xuICAgICAgICAgICAgeCA9IHggfCAwO1xuICAgICAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgeTAgPSAwLCB6MCA9IDAsIHkxID0gMCwgejEgPSAwLCB5MiA9IDAsIHoyID0gMCwgeTMgPSAwLCB6MyA9IDAsIHk0ID0gMCwgejQgPSAwLCB0MCA9IDAsIHQxID0gMDtcbiAgICAgICAgICAgIHkwID0gSFt4ICsgMzIwID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHkxID0gSFt4ICsgMzI0ID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHkyID0gSFt4ICsgMzI4ID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHkzID0gSFt4ICsgMzMyID4+IDJdIHwgMDtcbiAgICAgICAgICAgIHk0ID0gSFt4ICsgMzM2ID4+IDJdIHwgMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IChpIHwgMCkgPCAoayB8IDApOyBpID0gaSArIDY0IHwgMCkge1xuICAgICAgICAgICAgICAgIHowID0geTA7XG4gICAgICAgICAgICAgICAgejEgPSB5MTtcbiAgICAgICAgICAgICAgICB6MiA9IHkyO1xuICAgICAgICAgICAgICAgIHozID0geTM7XG4gICAgICAgICAgICAgICAgejQgPSB5NDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyAoaiB8IDApIDwgNjQ7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSBIW2kgKyBqID4+IDJdIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxICYgeTIgfCB+eTEgJiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApICsgMTUxODUwMDI0OSB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2sgKyBqID4+IDJdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyA2NCB8IDA7IChqIHwgMCkgPCAoayArIDgwIHwgMCk7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pIDw8IDEgfCAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pID4+PiAzMTtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxICYgeTIgfCB+eTEgJiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApICsgMTUxODUwMDI0OSB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDgwIHwgMDsgKGogfCAwKSA8IChrICsgMTYwIHwgMCk7IGogPSBqICsgNCB8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pIDw8IDEgfCAoSFtqIC0gMTIgPj4gMl0gXiBIW2ogLSAzMiA+PiAyXSBeIEhbaiAtIDU2ID4+IDJdIF4gSFtqIC0gNjQgPj4gMl0pID4+PiAzMTtcbiAgICAgICAgICAgICAgICAgICAgdDAgPSAoKHkwIDw8IDUgfCB5MCA+Pj4gMjcpICsgKHkxIF4geTIgXiB5MykgfCAwKSArICgodDEgKyB5NCB8IDApICsgMTg1OTc3NTM5MyB8IDApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgeTQgPSB5MztcbiAgICAgICAgICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB5MSA8PCAzMCB8IHkxID4+PiAyO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHQwO1xuICAgICAgICAgICAgICAgICAgICBIW2ogPj4gMl0gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE2MCB8IDA7IChqIHwgMCkgPCAoayArIDI0MCB8IDApOyBqID0gaiArIDQgfCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA8PCAxIHwgKEhbaiAtIDEyID4+IDJdIF4gSFtqIC0gMzIgPj4gMl0gXiBIW2ogLSA1NiA+PiAyXSBeIEhbaiAtIDY0ID4+IDJdKSA+Pj4gMzE7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gKCh5MCA8PCA1IHwgeTAgPj4+IDI3KSArICh5MSAmIHkyIHwgeTEgJiB5MyB8IHkyICYgeTMpIHwgMCkgKyAoKHQxICsgeTQgfCAwKSAtIDE4OTQwMDc1ODggfCAwKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIHk0ID0geTM7XG4gICAgICAgICAgICAgICAgICAgIHkzID0geTI7XG4gICAgICAgICAgICAgICAgICAgIHkyID0geTEgPDwgMzAgfCB5MSA+Pj4gMjtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB0MDtcbiAgICAgICAgICAgICAgICAgICAgSFtqID4+IDJdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyAyNDAgfCAwOyAoaiB8IDApIDwgKGsgKyAzMjAgfCAwKTsgaiA9IGogKyA0IHwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPDwgMSB8IChIW2ogLSAxMiA+PiAyXSBeIEhbaiAtIDMyID4+IDJdIF4gSFtqIC0gNTYgPj4gMl0gXiBIW2ogLSA2NCA+PiAyXSkgPj4+IDMxO1xuICAgICAgICAgICAgICAgICAgICB0MCA9ICgoeTAgPDwgNSB8IHkwID4+PiAyNykgKyAoeTEgXiB5MiBeIHkzKSB8IDApICsgKCh0MSArIHk0IHwgMCkgLSA4OTk0OTc1MTQgfCAwKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIHk0ID0geTM7XG4gICAgICAgICAgICAgICAgICAgIHkzID0geTI7XG4gICAgICAgICAgICAgICAgICAgIHkyID0geTEgPDwgMzAgfCB5MSA+Pj4gMjtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB0MDtcbiAgICAgICAgICAgICAgICAgICAgSFtqID4+IDJdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkwID0geTAgKyB6MCB8IDA7XG4gICAgICAgICAgICAgICAgeTEgPSB5MSArIHoxIHwgMDtcbiAgICAgICAgICAgICAgICB5MiA9IHkyICsgejIgfCAwO1xuICAgICAgICAgICAgICAgIHkzID0geTMgKyB6MyB8IDA7XG4gICAgICAgICAgICAgICAgeTQgPSB5NCArIHo0IHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhbeCArIDMyMCA+PiAyXSA9IHkwO1xuICAgICAgICAgICAgSFt4ICsgMzI0ID4+IDJdID0geTE7XG4gICAgICAgICAgICBIW3ggKyAzMjggPj4gMl0gPSB5MjtcbiAgICAgICAgICAgIEhbeCArIDMzMiA+PiAyXSA9IHkzO1xuICAgICAgICAgICAgSFt4ICsgMzM2ID4+IDJdID0geTQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaGFzaDogaGFzaCB9O1xuICAgIH07XG4gICAgLy8gSWYgd2UnZSBydW5uaW5nIGluIE5vZGUuSlMsIGV4cG9ydCBhIG1vZHVsZS5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBSdXNoYTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5SdXNoYSA9IFJ1c2hhO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGluIGEgd2Vid29ya2VyLCBhY2NlcHRcbiAgICAvLyBtZXNzYWdlcyBjb250YWluaW5nIGEgam9iaWQgYW5kIGEgYnVmZmVyXG4gICAgLy8gb3IgYmxvYiBvYmplY3QsIGFuZCByZXR1cm4gdGhlIGhhc2ggcmVzdWx0LlxuICAgIGlmICh0eXBlb2YgRmlsZVJlYWRlclN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlclN5bmMoKSwgaGFzaGVyID0gbmV3IFJ1c2hhKDQgKiAxMDI0ICogMTAyNCk7XG4gICAgICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFzaCwgZGF0YSA9IGV2ZW50LmRhdGEuZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFzaCA9IGhhc2hlci5kaWdlc3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBldmVudC5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBoYXNoOiBoYXNoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBldmVudC5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZS5uYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2J1ZmZlcicpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJlYW0sIGNiKSB7XG4gIHZhciBjaHVua3MgPSBbXVxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBjaHVua3MucHVzaChjaHVuaylcbiAgfSlcbiAgc3RyZWFtLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIGNiKG51bGwsIEJ1ZmZlci5jb25jYXQoY2h1bmtzKSlcbiAgICBjYiA9IG51bGxcbiAgfSlcbiAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjYikgY2IoZXJyKVxuICAgIGNiID0gbnVsbFxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzaW1wbGVHZXRcblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIHVuemlwUmVzcG9uc2UgPSByZXF1aXJlKCd1bnppcC1yZXNwb25zZScpIC8vIGV4Y2x1ZGVkIGZyb20gYnJvd3NlciBidWlsZFxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbmZ1bmN0aW9uIHNpbXBsZUdldCAob3B0cywgY2IpIHtcbiAgb3B0cyA9IHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJyA/IHsgdXJsOiBvcHRzIH0gOiBleHRlbmQob3B0cylcbiAgY2IgPSBvbmNlKGNiKVxuXG4gIGlmIChvcHRzLnVybCkgcGFyc2VPcHRzVXJsKG9wdHMpXG4gIGlmIChvcHRzLmhlYWRlcnMgPT0gbnVsbCkgb3B0cy5oZWFkZXJzID0ge31cbiAgaWYgKG9wdHMubWF4UmVkaXJlY3RzID09IG51bGwpIG9wdHMubWF4UmVkaXJlY3RzID0gMTBcblxuICB2YXIgYm9keSA9IG9wdHMuanNvbiA/IEpTT04uc3RyaW5naWZ5KG9wdHMuYm9keSkgOiBvcHRzLmJvZHlcbiAgb3B0cy5ib2R5ID0gdW5kZWZpbmVkXG4gIGlmIChib2R5ICYmICFvcHRzLm1ldGhvZCkgb3B0cy5tZXRob2QgPSAnUE9TVCdcblxuICBpZiAob3B0cy5qc29uKSBvcHRzLmhlYWRlcnMuYWNjZXB0ID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gIGlmIChvcHRzLmpzb24gJiYgYm9keSkgb3B0cy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuXG4gIC8vIFJlcXVlc3QgZ3ppcC9kZWZsYXRlXG4gIHZhciBjdXN0b21BY2NlcHRFbmNvZGluZyA9IE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykuc29tZShmdW5jdGlvbiAoaCkge1xuICAgIHJldHVybiBoLnRvTG93ZXJDYXNlKCkgPT09ICdhY2NlcHQtZW5jb2RpbmcnXG4gIH0pXG4gIGlmICghY3VzdG9tQWNjZXB0RW5jb2RpbmcpIG9wdHMuaGVhZGVyc1snYWNjZXB0LWVuY29kaW5nJ10gPSAnZ3ppcCwgZGVmbGF0ZSdcblxuICAvLyBTdXBwb3J0IGh0dHA6IGFuZCBodHRwczogdXJsc1xuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cFxuICB2YXIgcmVxID0gcHJvdG9jb2wucmVxdWVzdChvcHRzLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgLy8gRm9sbG93IDN4eCByZWRpcmVjdHNcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMzAwICYmIHJlcy5zdGF0dXNDb2RlIDwgNDAwICYmICdsb2NhdGlvbicgaW4gcmVzLmhlYWRlcnMpIHtcbiAgICAgIG9wdHMudXJsID0gcmVzLmhlYWRlcnMubG9jYXRpb25cbiAgICAgIHBhcnNlT3B0c1VybChvcHRzKVxuICAgICAgcmVzLnJlc3VtZSgpIC8vIERpc2NhcmQgcmVzcG9uc2VcblxuICAgICAgb3B0cy5tYXhSZWRpcmVjdHMgLT0gMVxuICAgICAgaWYgKG9wdHMubWF4UmVkaXJlY3RzID4gMCkgc2ltcGxlR2V0KG9wdHMsIGNiKVxuICAgICAgZWxzZSBjYihuZXcgRXJyb3IoJ3RvbyBtYW55IHJlZGlyZWN0cycpKVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjYihudWxsLCB0eXBlb2YgdW56aXBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyA/IHVuemlwUmVzcG9uc2UocmVzKSA6IHJlcylcbiAgfSlcbiAgcmVxLm9uKCdlcnJvcicsIGNiKVxuICByZXEuZW5kKGJvZHkpXG4gIHJldHVybiByZXFcbn1cblxubW9kdWxlLmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIHJldHVybiBzaW1wbGVHZXQob3B0cywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICB2YXIgY2h1bmtzID0gW11cbiAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgIH0pXG4gICAgcmVzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGF0YSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKVxuICAgICAgaWYgKG9wdHMuanNvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVyciwgcmVzLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYihudWxsLCByZXMsIGRhdGEpXG4gICAgfSlcbiAgfSlcbn1cblxuO1snZ2V0JywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2hlYWQnLCAnZGVsZXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIG1vZHVsZS5leHBvcnRzW21ldGhvZF0gPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSBvcHRzID0geyB1cmw6IG9wdHMgfVxuICAgIG9wdHMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gc2ltcGxlR2V0KG9wdHMsIGNiKVxuICB9XG59KVxuXG5mdW5jdGlvbiBwYXJzZU9wdHNVcmwgKG9wdHMpIHtcbiAgdmFyIGxvYyA9IHVybC5wYXJzZShvcHRzLnVybClcbiAgaWYgKGxvYy5ob3N0bmFtZSkgb3B0cy5ob3N0bmFtZSA9IGxvYy5ob3N0bmFtZVxuICBpZiAobG9jLnBvcnQpIG9wdHMucG9ydCA9IGxvYy5wb3J0XG4gIGlmIChsb2MucHJvdG9jb2wpIG9wdHMucHJvdG9jb2wgPSBsb2MucHJvdG9jb2xcbiAgaWYgKGxvYy5hdXRoKSBvcHRzLmF1dGggPSBsb2MuYXV0aFxuICBvcHRzLnBhdGggPSBsb2MucGF0aFxuICBkZWxldGUgb3B0cy51cmxcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gUGVlclxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzaW1wbGUtcGVlcicpXG52YXIgZ2V0QnJvd3NlclJUQyA9IHJlcXVpcmUoJ2dldC1icm93c2VyLXJ0YycpXG52YXIgaGF0ID0gcmVxdWlyZSgnaGF0JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxuaW5oZXJpdHMoUGVlciwgc3RyZWFtLkR1cGxleClcblxuLyoqXG4gKiBXZWJSVEMgcGVlciBjb25uZWN0aW9uLiBTYW1lIEFQSSBhcyBub2RlIGNvcmUgYG5ldC5Tb2NrZXRgLCBwbHVzIGEgZmV3IGV4dHJhIG1ldGhvZHMuXG4gKiBEdXBsZXggc3RyZWFtLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZnVuY3Rpb24gUGVlciAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFBlZXIpKSByZXR1cm4gbmV3IFBlZXIob3B0cylcbiAgc2VsZi5fZGVidWcoJ25ldyBwZWVyICVvJywgb3B0cylcblxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBvcHRzLmFsbG93SGFsZk9wZW4gPSBmYWxzZVxuICBpZiAob3B0cy5oaWdoV2F0ZXJNYXJrID09IG51bGwpIG9wdHMuaGlnaFdhdGVyTWFyayA9IDEwMjQgKiAxMDI0XG5cbiAgc3RyZWFtLkR1cGxleC5jYWxsKHNlbGYsIG9wdHMpXG5cbiAgc2VsZi5pbml0aWF0b3IgPSBvcHRzLmluaXRpYXRvciB8fCBmYWxzZVxuICBzZWxmLmNoYW5uZWxDb25maWcgPSBvcHRzLmNoYW5uZWxDb25maWcgfHwgUGVlci5jaGFubmVsQ29uZmlnXG4gIHNlbGYuY2hhbm5lbE5hbWUgPSBvcHRzLmluaXRpYXRvciA/IChvcHRzLmNoYW5uZWxOYW1lIHx8IGhhdCgxNjApKSA6IG51bGxcbiAgc2VsZi5jb25maWcgPSBvcHRzLmNvbmZpZyB8fCBQZWVyLmNvbmZpZ1xuICBzZWxmLmNvbnN0cmFpbnRzID0gb3B0cy5jb25zdHJhaW50cyB8fCBQZWVyLmNvbnN0cmFpbnRzXG4gIHNlbGYub2ZmZXJDb25zdHJhaW50cyA9IG9wdHMub2ZmZXJDb25zdHJhaW50c1xuICBzZWxmLmFuc3dlckNvbnN0cmFpbnRzID0gb3B0cy5hbnN3ZXJDb25zdHJhaW50c1xuICBzZWxmLnJlY29ubmVjdFRpbWVyID0gb3B0cy5yZWNvbm5lY3RUaW1lciB8fCBmYWxzZVxuICBzZWxmLnNkcFRyYW5zZm9ybSA9IG9wdHMuc2RwVHJhbnNmb3JtIHx8IGZ1bmN0aW9uIChzZHApIHsgcmV0dXJuIHNkcCB9XG4gIHNlbGYuc3RyZWFtID0gb3B0cy5zdHJlYW0gfHwgZmFsc2VcbiAgc2VsZi50cmlja2xlID0gb3B0cy50cmlja2xlICE9PSB1bmRlZmluZWQgPyBvcHRzLnRyaWNrbGUgOiB0cnVlXG5cbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgLy8gc28gUGVlciBvYmplY3QgYWx3YXlzIGhhcyBzYW1lIHNoYXBlIChWOCBvcHRpbWl6YXRpb24pXG4gIHNlbGYucmVtb3RlQWRkcmVzcyA9IHVuZGVmaW5lZFxuICBzZWxmLnJlbW90ZUZhbWlseSA9IHVuZGVmaW5lZFxuICBzZWxmLnJlbW90ZVBvcnQgPSB1bmRlZmluZWRcbiAgc2VsZi5sb2NhbEFkZHJlc3MgPSB1bmRlZmluZWRcbiAgc2VsZi5sb2NhbFBvcnQgPSB1bmRlZmluZWRcblxuICBzZWxmLl9pc1dydGMgPSAhIW9wdHMud3J0YyAvLyBIQUNLOiB0byBmaXggYHdydGNgIGJ1Zy4gU2VlIGlzc3VlOiAjNjBcbiAgc2VsZi5fd3J0YyA9IChvcHRzLndydGMgJiYgdHlwZW9mIG9wdHMud3J0YyA9PT0gJ29iamVjdCcpXG4gICAgPyBvcHRzLndydGNcbiAgICA6IGdldEJyb3dzZXJSVEMoKVxuICBpZiAoIXNlbGYuX3dydGMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IFNwZWNpZnkgYG9wdHMud3J0Y2Agb3B0aW9uIGluIHRoaXMgZW52aXJvbm1lbnQnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBOb3QgYSBzdXBwb3J0ZWQgYnJvd3NlcicpXG4gICAgfVxuICB9XG5cbiAgc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQgPSBvcHRzLmhpZ2hXYXRlck1hcmtcbiAgc2VsZi5fcGNSZWFkeSA9IGZhbHNlXG4gIHNlbGYuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG4gIHNlbGYuX2ljZUNvbXBsZXRlID0gZmFsc2UgLy8gaWNlIGNhbmRpZGF0ZSB0cmlja2xlIGRvbmUgKGdvdCBudWxsIGNhbmRpZGF0ZSlcbiAgc2VsZi5fY2hhbm5lbCA9IG51bGxcbiAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuXG4gIHNlbGYuX2NodW5rID0gbnVsbFxuICBzZWxmLl9jYiA9IG51bGxcbiAgc2VsZi5faW50ZXJ2YWwgPSBudWxsXG4gIHNlbGYuX3JlY29ubmVjdFRpbWVvdXQgPSBudWxsXG5cbiAgc2VsZi5fcGMgPSBuZXcgKHNlbGYuX3dydGMuUlRDUGVlckNvbm5lY3Rpb24pKHNlbGYuY29uZmlnLCBzZWxmLmNvbnN0cmFpbnRzKVxuICBzZWxmLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgpXG4gIH1cbiAgc2VsZi5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKClcbiAgfVxuICBzZWxmLl9wYy5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlbGYuX29uSWNlQ2FuZGlkYXRlKGV2ZW50KVxuICB9XG5cbiAgaWYgKHNlbGYuc3RyZWFtKSBzZWxmLl9wYy5hZGRTdHJlYW0oc2VsZi5zdHJlYW0pXG4gIHNlbGYuX3BjLm9uYWRkc3RyZWFtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgc2VsZi5fb25BZGRTdHJlYW0oZXZlbnQpXG4gIH1cblxuICBpZiAoc2VsZi5pbml0aWF0b3IpIHtcbiAgICBzZWxmLl9zZXR1cERhdGEoe1xuICAgICAgY2hhbm5lbDogc2VsZi5fcGMuY3JlYXRlRGF0YUNoYW5uZWwoc2VsZi5jaGFubmVsTmFtZSwgc2VsZi5jaGFubmVsQ29uZmlnKVxuICAgIH0pXG4gICAgc2VsZi5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fY3JlYXRlT2ZmZXIoKVxuICAgIH0pXG4gICAgLy8gT25seSBDaHJvbWUgdHJpZ2dlcnMgXCJuZWdvdGlhdGlvbm5lZWRlZFwiOyB0aGlzIGlzIGEgd29ya2Fyb3VuZCBmb3Igb3RoZXJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnNcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgc2VsZi5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCgpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3BjLm9uZGF0YWNoYW5uZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHNlbGYuX3NldHVwRGF0YShldmVudClcbiAgICB9XG4gIH1cblxuICBzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuY29ubmVjdGVkKSB7XG4gICAgICAvLyBXaGVuIGxvY2FsIHBlZXIgaXMgZmluaXNoZWQgd3JpdGluZywgY2xvc2UgY29ubmVjdGlvbiB0byByZW1vdGUgcGVlci5cbiAgICAgIC8vIEhhbGYgb3BlbiBjb25uZWN0aW9ucyBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuXG4gICAgICAvLyBXYWl0IGEgYml0IGJlZm9yZSBkZXN0cm95aW5nIHNvIHRoZSBkYXRhY2hhbm5lbCBmbHVzaGVzLlxuICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICB9LCAxMDApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGRhdGEgY2hhbm5lbCBpcyBub3QgY29ubmVjdGVkIHdoZW4gbG9jYWwgcGVlciBpcyBmaW5pc2hlZCB3cml0aW5nLCB3YWl0IHVudGlsXG4gICAgICAvLyBkYXRhIGlzIGZsdXNoZWQgdG8gbmV0d29yayBhdCBcImNvbm5lY3RcIiBldmVudC5cbiAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgbW9yZSByZWxpYWJsZSB3YXkgdG8gYWNjb21wbGlzaCB0aGlzP1xuICAgICAgc2VsZi5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9kZXN0cm95KClcbiAgICAgICAgfSwgMTAwKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cblBlZXIuV0VCUlRDX1NVUFBPUlQgPSAhIWdldEJyb3dzZXJSVEMoKVxuXG4vKipcbiAqIEV4cG9zZSBjb25maWcsIGNvbnN0cmFpbnRzLCBhbmQgZGF0YSBjaGFubmVsIGNvbmZpZyBmb3Igb3ZlcnJpZGluZyBhbGwgUGVlclxuICogaW5zdGFuY2VzLiBPdGhlcndpc2UsIGp1c3Qgc2V0IG9wdHMuY29uZmlnLCBvcHRzLmNvbnN0cmFpbnRzLCBvciBvcHRzLmNoYW5uZWxDb25maWdcbiAqIHdoZW4gY29uc3RydWN0aW5nIGEgUGVlci5cbiAqL1xuUGVlci5jb25maWcgPSB7XG4gIGljZVNlcnZlcnM6IFtcbiAgICB7XG4gICAgICB1cmw6ICdzdHVuOjIzLjIxLjE1MC4xMjEnLCAvLyBkZXByZWNhdGVkLCByZXBsYWNlZCBieSBgdXJsc2BcbiAgICAgIHVybHM6ICdzdHVuOjIzLjIxLjE1MC4xMjEnXG4gICAgfVxuICBdXG59XG5QZWVyLmNvbnN0cmFpbnRzID0ge31cblBlZXIuY2hhbm5lbENvbmZpZyA9IHt9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZWVyLnByb3RvdHlwZSwgJ2J1ZmZlclNpemUnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHJldHVybiAoc2VsZi5fY2hhbm5lbCAmJiBzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KSB8fCAwXG4gIH1cbn0pXG5cblBlZXIucHJvdG90eXBlLmFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4geyBwb3J0OiBzZWxmLmxvY2FsUG9ydCwgZmFtaWx5OiAnSVB2NCcsIGFkZHJlc3M6IHNlbGYubG9jYWxBZGRyZXNzIH1cbn1cblxuUGVlci5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2lnbmFsIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJylcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGF0YSA9IHt9XG4gICAgfVxuICB9XG4gIHNlbGYuX2RlYnVnKCdzaWduYWwoKScpXG5cbiAgZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5fcGMuYWRkSWNlQ2FuZGlkYXRlKFxuICAgICAgICBuZXcgc2VsZi5fd3J0Yy5SVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2VsZi5fZGVzdHJveShuZXcgRXJyb3IoJ2Vycm9yIGFkZGluZyBjYW5kaWRhdGU6ICcgKyBlcnIubWVzc2FnZSkpXG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGEuc2RwKSB7XG4gICAgc2VsZi5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IChzZWxmLl93cnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoZGF0YSksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoc2VsZi5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykgc2VsZi5fY3JlYXRlQW5zd2VyKClcblxuICAgICAgc2VsZi5fcGVuZGluZ0NhbmRpZGF0ZXMuZm9yRWFjaChhZGRJY2VDYW5kaWRhdGUpXG4gICAgICBzZWxmLl9wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdXG4gICAgfSwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSlcbiAgfVxuICBpZiAoZGF0YS5jYW5kaWRhdGUpIHtcbiAgICBpZiAoc2VsZi5fcGMucmVtb3RlRGVzY3JpcHRpb24pIGFkZEljZUNhbmRpZGF0ZShkYXRhLmNhbmRpZGF0ZSlcbiAgICBlbHNlIHNlbGYuX3BlbmRpbmdDYW5kaWRhdGVzLnB1c2goZGF0YS5jYW5kaWRhdGUpXG4gIH1cbiAgaWYgKCFkYXRhLnNkcCAmJiAhZGF0YS5jYW5kaWRhdGUpIHtcbiAgICBzZWxmLl9kZXN0cm95KG5ldyBFcnJvcignc2lnbmFsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBzaWduYWwgZGF0YScpKVxuICB9XG59XG5cbi8qKlxuICogU2VuZCB0ZXh0L2JpbmFyeSBkYXRhIHRvIHRoZSByZW1vdGUgcGVlci5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheVZpZXd8QXJyYXlCdWZmZXJ8QnVmZmVyfHN0cmluZ3xCbG9ifE9iamVjdH0gY2h1bmtcbiAqL1xuUGVlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICAvLyBIQUNLOiBgd3J0Y2AgbW9kdWxlIGRvZXNuJ3QgYWNjZXB0IG5vZGUuanMgYnVmZmVyLiBTZWUgaXNzdWU6ICM2MFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiBzZWxmLl9pc1dydGMpIHtcbiAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKVxuICB9XG5cbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aCB8fCBjaHVuay5ieXRlTGVuZ3RoIHx8IGNodW5rLnNpemVcbiAgc2VsZi5fY2hhbm5lbC5zZW5kKGNodW5rKVxuICBzZWxmLl9kZWJ1Zygnd3JpdGU6ICVkIGJ5dGVzJywgbGVuKVxufVxuXG5QZWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9uY2xvc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2Rlc3Ryb3kobnVsbCwgb25jbG9zZSlcbn1cblxuUGVlci5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAob25jbG9zZSkgc2VsZi5vbmNlKCdjbG9zZScsIG9uY2xvc2UpXG5cbiAgc2VsZi5fZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgZXJyLm1lc3NhZ2UpXG5cbiAgc2VsZi5yZWFkYWJsZSA9IHNlbGYud3JpdGFibGUgPSBmYWxzZVxuXG4gIGlmICghc2VsZi5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgc2VsZi5wdXNoKG51bGwpXG4gIGlmICghc2VsZi5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgc2VsZi5lbmQoKVxuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG4gIHNlbGYuX3BjUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuXG4gIHNlbGYuX2NodW5rID0gbnVsbFxuICBzZWxmLl9jYiA9IG51bGxcbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbClcbiAgY2xlYXJUaW1lb3V0KHNlbGYuX3JlY29ubmVjdFRpbWVvdXQpXG5cbiAgaWYgKHNlbGYuX3BjKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX3BjLmNsb3NlKClcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBzZWxmLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uYWRkc3RyZWFtID0gbnVsbFxuICAgIHNlbGYuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBudWxsXG4gICAgc2VsZi5fcGMub25kYXRhY2hhbm5lbCA9IG51bGxcbiAgfVxuXG4gIGlmIChzZWxmLl9jaGFubmVsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX2NoYW5uZWwuY2xvc2UoKVxuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIHNlbGYuX2NoYW5uZWwub25tZXNzYWdlID0gbnVsbFxuICAgIHNlbGYuX2NoYW5uZWwub25vcGVuID0gbnVsbFxuICAgIHNlbGYuX2NoYW5uZWwub25jbG9zZSA9IG51bGxcbiAgfVxuICBzZWxmLl9wYyA9IG51bGxcbiAgc2VsZi5fY2hhbm5lbCA9IG51bGxcblxuICBpZiAoZXJyKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICBzZWxmLmVtaXQoJ2Nsb3NlJylcbn1cblxuUGVlci5wcm90b3R5cGUuX3NldHVwRGF0YSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fY2hhbm5lbCA9IGV2ZW50LmNoYW5uZWxcbiAgc2VsZi5jaGFubmVsTmFtZSA9IHNlbGYuX2NoYW5uZWwubGFiZWxcblxuICBzZWxmLl9jaGFubmVsLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIHNlbGYuX2NoYW5uZWwub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgc2VsZi5fb25DaGFubmVsTWVzc2FnZShldmVudClcbiAgfVxuICBzZWxmLl9jaGFubmVsLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkNoYW5uZWxPcGVuKClcbiAgfVxuICBzZWxmLl9jaGFubmVsLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25DaGFubmVsQ2xvc2UoKVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge31cblxuUGVlci5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJykpXG5cbiAgaWYgKHNlbGYuY29ubmVjdGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuc2VuZChjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBzZWxmLl9vbkVycm9yKGVycilcbiAgICB9XG4gICAgaWYgKHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCkge1xuICAgICAgc2VsZi5fZGVidWcoJ3N0YXJ0IGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCBzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KVxuICAgICAgc2VsZi5fY2IgPSBjYlxuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9kZWJ1Zygnd3JpdGUgYmVmb3JlIGNvbm5lY3QnKVxuICAgIHNlbGYuX2NodW5rID0gY2h1bmtcbiAgICBzZWxmLl9jYiA9IGNiXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX2NyZWF0ZU9mZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBzZWxmLl9wYy5jcmVhdGVPZmZlcihmdW5jdGlvbiAob2ZmZXIpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIG9mZmVyLnNkcCA9IHNlbGYuc2RwVHJhbnNmb3JtKG9mZmVyLnNkcClcbiAgICBzZWxmLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyLCBub29wLCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9KVxuICAgIHZhciBzZW5kT2ZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2lnbmFsID0gc2VsZi5fcGMubG9jYWxEZXNjcmlwdGlvbiB8fCBvZmZlclxuICAgICAgc2VsZi5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgdHlwZTogc2lnbmFsLnR5cGUsXG4gICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHNlbGYudHJpY2tsZSB8fCBzZWxmLl9pY2VDb21wbGV0ZSkgc2VuZE9mZmVyKClcbiAgICBlbHNlIHNlbGYub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZE9mZmVyKSAvLyB3YWl0IGZvciBjYW5kaWRhdGVzXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0sIHNlbGYub2ZmZXJDb25zdHJhaW50cylcbn1cblxuUGVlci5wcm90b3R5cGUuX2NyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcGMuY3JlYXRlQW5zd2VyKGZ1bmN0aW9uIChhbnN3ZXIpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIGFuc3dlci5zZHAgPSBzZWxmLnNkcFRyYW5zZm9ybShhbnN3ZXIuc2RwKVxuICAgIHNlbGYuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyLCBub29wLCBmdW5jdGlvbiAoZXJyKSB7IHNlbGYuX29uRXJyb3IoZXJyKSB9KVxuICAgIHZhciBzZW5kQW5zd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpZ25hbCA9IHNlbGYuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgYW5zd2VyXG4gICAgICBzZWxmLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgIHNlbGYuZW1pdCgnc2lnbmFsJywge1xuICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgc2RwOiBzaWduYWwuc2RwXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoc2VsZi50cmlja2xlIHx8IHNlbGYuX2ljZUNvbXBsZXRlKSBzZW5kQW5zd2VyKClcbiAgICBlbHNlIHNlbGYub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZEFuc3dlcilcbiAgfSwgZnVuY3Rpb24gKGVycikgeyBzZWxmLl9vbkVycm9yKGVycikgfSwgc2VsZi5hbnN3ZXJDb25zdHJhaW50cylcbn1cblxuUGVlci5wcm90b3R5cGUuX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgdmFyIGljZUdhdGhlcmluZ1N0YXRlID0gc2VsZi5fcGMuaWNlR2F0aGVyaW5nU3RhdGVcbiAgdmFyIGljZUNvbm5lY3Rpb25TdGF0ZSA9IHNlbGYuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZVxuICBzZWxmLl9kZWJ1ZygnaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlICVzICVzJywgaWNlR2F0aGVyaW5nU3RhdGUsIGljZUNvbm5lY3Rpb25TdGF0ZSlcbiAgc2VsZi5lbWl0KCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UnLCBpY2VHYXRoZXJpbmdTdGF0ZSwgaWNlQ29ubmVjdGlvblN0YXRlKVxuICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYuX3JlY29ubmVjdFRpbWVvdXQpXG4gICAgc2VsZi5fcGNSZWFkeSA9IHRydWVcbiAgICBzZWxmLl9tYXliZVJlYWR5KClcbiAgfVxuICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgIGlmIChzZWxmLnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAvLyBJZiB1c2VyIGhhcyBzZXQgYG9wdC5yZWNvbm5lY3RUaW1lcmAsIGFsbG93IHRpbWUgZm9yIElDRSB0byBhdHRlbXB0IGEgcmVjb25uZWN0XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVjb25uZWN0VGltZW91dClcbiAgICAgIHNlbGYuX3JlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICB9LCBzZWxmLnJlY29ubmVjdFRpbWVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9kZXN0cm95KClcbiAgICB9XG4gIH1cbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICBzZWxmLl9kZXN0cm95KClcbiAgfVxuICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHNlbGYuX2Rlc3Ryb3koKVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuX3BjLmdldFN0YXRzKSB7IC8vIE5vIGFiaWxpdHkgdG8gY2FsbCBzdGF0c1xuICAgIGNiKFtdKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7IC8vIE1vemlsbGFcbiAgICBzZWxmLl9wYy5nZXRTdGF0cyhudWxsLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgfSlcbiAgICAgIGNiKGl0ZW1zKVxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5fb25FcnJvcihlcnIpIH0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fcGMuZ2V0U3RhdHMoZnVuY3Rpb24gKHJlcykgeyAvLyBDaHJvbWVcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICByZXMucmVzdWx0KCkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBpdGVtID0ge31cbiAgICAgICAgcmVzdWx0Lm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGl0ZW1bbmFtZV0gPSByZXN1bHQuc3RhdChuYW1lKVxuICAgICAgICB9KVxuICAgICAgICBpdGVtLmlkID0gcmVzdWx0LmlkXG4gICAgICAgIGl0ZW0udHlwZSA9IHJlc3VsdC50eXBlXG4gICAgICAgIGl0ZW0udGltZXN0YW1wID0gcmVzdWx0LnRpbWVzdGFtcFxuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG4gICAgICB9KVxuICAgICAgY2IoaXRlbXMpXG4gICAgfSlcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fbWF5YmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2RlYnVnKCdtYXliZVJlYWR5IHBjICVzIGNoYW5uZWwgJXMnLCBzZWxmLl9wY1JlYWR5LCBzZWxmLl9jaGFubmVsUmVhZHkpXG4gIGlmIChzZWxmLmNvbm5lY3RlZCB8fCBzZWxmLl9jb25uZWN0aW5nIHx8ICFzZWxmLl9wY1JlYWR5IHx8ICFzZWxmLl9jaGFubmVsUmVhZHkpIHJldHVyblxuICBzZWxmLl9jb25uZWN0aW5nID0gdHJ1ZVxuXG4gIHNlbGYuZ2V0U3RhdHMoZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgc2VsZi5fY29ubmVjdGluZyA9IGZhbHNlXG4gICAgc2VsZi5jb25uZWN0ZWQgPSB0cnVlXG5cbiAgICB2YXIgcmVtb3RlQ2FuZGlkYXRlcyA9IHt9XG4gICAgdmFyIGxvY2FsQ2FuZGlkYXRlcyA9IHt9XG5cbiAgICBmdW5jdGlvbiBzZXRBY3RpdmVDYW5kaWRhdGVzIChpdGVtKSB7XG4gICAgICB2YXIgbG9jYWwgPSBsb2NhbENhbmRpZGF0ZXNbaXRlbS5sb2NhbENhbmRpZGF0ZUlkXVxuICAgICAgdmFyIHJlbW90ZSA9IHJlbW90ZUNhbmRpZGF0ZXNbaXRlbS5yZW1vdGVDYW5kaWRhdGVJZF1cblxuICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgIHNlbGYubG9jYWxBZGRyZXNzID0gbG9jYWwuaXBBZGRyZXNzXG4gICAgICAgIHNlbGYubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsLnBvcnROdW1iZXIpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmdvb2dMb2NhbEFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFNvbWV0aW1lcyBgaXRlbS5pZGAgaXMgdW5kZWZpbmVkIGluIGB3cnRjYCBhbmQgQ2hyb21lXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlci9pc3N1ZXMvNjZcbiAgICAgICAgbG9jYWwgPSBpdGVtLmdvb2dMb2NhbEFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICBzZWxmLmxvY2FsQWRkcmVzcyA9IGxvY2FsWzBdXG4gICAgICAgIHNlbGYubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsWzFdKVxuICAgICAgfVxuICAgICAgc2VsZi5fZGVidWcoJ2Nvbm5lY3QgbG9jYWw6ICVzOiVzJywgc2VsZi5sb2NhbEFkZHJlc3MsIHNlbGYubG9jYWxQb3J0KVxuXG4gICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgIHNlbGYucmVtb3RlQWRkcmVzcyA9IHJlbW90ZS5pcEFkZHJlc3NcbiAgICAgICAgc2VsZi5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZS5wb3J0TnVtYmVyKVxuICAgICAgICBzZWxmLnJlbW90ZUZhbWlseSA9ICdJUHY0J1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS5nb29nUmVtb3RlQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVtb3RlID0gaXRlbS5nb29nUmVtb3RlQWRkcmVzcy5zcGxpdCgnOicpXG4gICAgICAgIHNlbGYucmVtb3RlQWRkcmVzcyA9IHJlbW90ZVswXVxuICAgICAgICBzZWxmLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlWzFdKVxuICAgICAgICBzZWxmLnJlbW90ZUZhbWlseSA9ICdJUHY0J1xuICAgICAgfVxuICAgICAgc2VsZi5fZGVidWcoJ2Nvbm5lY3QgcmVtb3RlOiAlczolcycsIHNlbGYucmVtb3RlQWRkcmVzcywgc2VsZi5yZW1vdGVQb3J0KVxuICAgIH1cblxuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdyZW1vdGVjYW5kaWRhdGUnKSByZW1vdGVDYW5kaWRhdGVzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2xvY2FsY2FuZGlkYXRlJykgbG9jYWxDYW5kaWRhdGVzW2l0ZW0uaWRdID0gaXRlbVxuICAgIH0pXG5cbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgaXNDYW5kaWRhdGVQYWlyID0gKFxuICAgICAgICAoaXRlbS50eXBlID09PSAnZ29vZ0NhbmRpZGF0ZVBhaXInICYmIGl0ZW0uZ29vZ0FjdGl2ZUNvbm5lY3Rpb24gPT09ICd0cnVlJykgfHxcbiAgICAgICAgKGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZXBhaXInICYmIGl0ZW0uc2VsZWN0ZWQpXG4gICAgICApXG4gICAgICBpZiAoaXNDYW5kaWRhdGVQYWlyKSBzZXRBY3RpdmVDYW5kaWRhdGVzKGl0ZW0pXG4gICAgfSlcblxuICAgIGlmIChzZWxmLl9jaHVuaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5zZW5kKHNlbGYuX2NodW5rKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9vbkVycm9yKGVycilcbiAgICAgIH1cbiAgICAgIHNlbGYuX2NodW5rID0gbnVsbFxuICAgICAgc2VsZi5fZGVidWcoJ3NlbnQgY2h1bmsgZnJvbSBcIndyaXRlIGJlZm9yZSBjb25uZWN0XCInKVxuXG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYihudWxsKVxuICAgIH1cblxuICAgIHNlbGYuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmLl9jYiB8fCAhc2VsZi5fY2hhbm5lbCB8fCBzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHJldHVyblxuICAgICAgc2VsZi5fZGVidWcoJ2VuZGluZyBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgICBzZWxmLl9jYiA9IG51bGxcbiAgICAgIGNiKG51bGwpXG4gICAgfSwgMTUwKVxuICAgIGlmIChzZWxmLl9pbnRlcnZhbC51bnJlZikgc2VsZi5faW50ZXJ2YWwudW5yZWYoKVxuXG4gICAgc2VsZi5fZGVidWcoJ2Nvbm5lY3QnKVxuICAgIHNlbGYuZW1pdCgnY29ubmVjdCcpXG4gIH0pXG59XG5cblBlZXIucHJvdG90eXBlLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlICVzJywgc2VsZi5fcGMuc2lnbmFsaW5nU3RhdGUpXG4gIHNlbGYuZW1pdCgnc2lnbmFsaW5nU3RhdGVDaGFuZ2UnLCBzZWxmLl9wYy5zaWduYWxpbmdTdGF0ZSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAoZXZlbnQuY2FuZGlkYXRlICYmIHNlbGYudHJpY2tsZSkge1xuICAgIHNlbGYuZW1pdCgnc2lnbmFsJywge1xuICAgICAgY2FuZGlkYXRlOiB7XG4gICAgICAgIGNhbmRpZGF0ZTogZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgc2RwTUxpbmVJbmRleDogZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgIHNkcE1pZDogZXZlbnQuY2FuZGlkYXRlLnNkcE1pZFxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoIWV2ZW50LmNhbmRpZGF0ZSkge1xuICAgIHNlbGYuX2ljZUNvbXBsZXRlID0gdHJ1ZVxuICAgIHNlbGYuZW1pdCgnX2ljZUNvbXBsZXRlJylcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgdmFyIGRhdGEgPSBldmVudC5kYXRhXG4gIHNlbGYuX2RlYnVnKCdyZWFkOiAlZCBieXRlcycsIGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aClcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuICBzZWxmLnB1c2goZGF0YSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbE9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5jb25uZWN0ZWQgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gY2hhbm5lbCBvcGVuJylcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gdHJ1ZVxuICBzZWxmLl9tYXliZVJlYWR5KClcbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbENsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIGNoYW5uZWwgY2xvc2UnKVxuICBzZWxmLl9kZXN0cm95KClcbn1cblxuUGVlci5wcm90b3R5cGUuX29uQWRkU3RyZWFtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gYWRkIHN0cmVhbScpXG4gIHNlbGYuZW1pdCgnc3RyZWFtJywgZXZlbnQuc3RyZWFtKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdlcnJvciAlcycsIGVyci5tZXNzYWdlIHx8IGVycilcbiAgc2VsZi5fZGVzdHJveShlcnIpXG59XG5cblBlZXIucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIHZhciBpZCA9IHNlbGYuY2hhbm5lbE5hbWUgJiYgc2VsZi5jaGFubmVsTmFtZS5zdWJzdHJpbmcoMCwgNylcbiAgYXJnc1swXSA9ICdbJyArIGlkICsgJ10gJyArIGFyZ3NbMF1cbiAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuIiwidmFyIFJ1c2hhID0gcmVxdWlyZSgncnVzaGEnKVxuXG52YXIgcnVzaGEgPSBuZXcgUnVzaGFcbnZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0byB8fCB7fVxudmFyIHN1YnRsZSA9IGNyeXB0by5zdWJ0bGUgfHwgY3J5cHRvLndlYmtpdFN1YnRsZVxuXG5mdW5jdGlvbiBzaGExc3luYyAoYnVmKSB7XG4gIHJldHVybiBydXNoYS5kaWdlc3QoYnVmKVxufVxuXG4vLyBCcm93c2VycyB0aHJvdyBpZiB0aGV5IGxhY2sgc3VwcG9ydCBmb3IgYW4gYWxnb3JpdGhtLlxuLy8gUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIG9uIG5vbi1zZWN1cmUgb3JpZ2lucy4gKGh0dHA6Ly9nb28uZ2wvbHE0Z0NvKVxudHJ5IHtcbiAgc3VidGxlLmRpZ2VzdCh7IG5hbWU6ICdzaGEtMScgfSwgbmV3IFVpbnQ4QXJyYXkpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICBzdWJ0bGUgPSBmYWxzZVxuICB9KVxufSBjYXRjaCAoZXJyKSB7IHN1YnRsZSA9IGZhbHNlIH1cblxuZnVuY3Rpb24gc2hhMSAoYnVmLCBjYikge1xuICBpZiAoIXN1YnRsZSkge1xuICAgIC8vIFVzZSBSdXNoYVxuICAgIHNldFRpbWVvdXQoY2IsIDAsIHNoYTFzeW5jKGJ1ZikpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSB1aW50OGFycmF5KGJ1ZilcbiAgfVxuXG4gIHN1YnRsZS5kaWdlc3QoeyBuYW1lOiAnc2hhLTEnIH0sIGJ1ZilcbiAgICAudGhlbihmdW5jdGlvbiBzdWNjZWVkIChyZXN1bHQpIHtcbiAgICAgIGNiKGhleChuZXcgVWludDhBcnJheShyZXN1bHQpKSlcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGZhaWwgKGVycm9yKSB7XG4gICAgICBjYihzaGExc3luYyhidWYpKVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHVpbnQ4YXJyYXkgKHMpIHtcbiAgdmFyIGwgPSBzLmxlbmd0aFxuICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShsKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGFycmF5W2ldID0gcy5jaGFyQ29kZUF0KGkpXG4gIH1cbiAgcmV0dXJuIGFycmF5XG59XG5cbmZ1bmN0aW9uIGhleCAoYnVmKSB7XG4gIHZhciBsID0gYnVmLmxlbmd0aFxuICB2YXIgY2hhcnMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBiaXRlID0gYnVmW2ldXG4gICAgY2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKVxuICAgIGNoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpXG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhMVxubW9kdWxlLmV4cG9ydHMuc3luYyA9IHNoYTFzeW5jXG4iLCIvKiBnbG9iYWwgV2ViU29ja2V0ICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0XG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NpbXBsZS13ZWJzb2NrZXQnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgd3MgPSByZXF1aXJlKCd3cycpIC8vIHdlYnNvY2tldHMgaW4gbm9kZSAtIHdpbGwgYmUgZW1wdHkgb2JqZWN0IGluIGJyb3dzZXJcblxudmFyIF9XZWJTb2NrZXQgPSB0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJyA/IFdlYlNvY2tldCA6IHdzXG5cbmluaGVyaXRzKFNvY2tldCwgc3RyZWFtLkR1cGxleClcblxuLyoqXG4gKiBXZWJTb2NrZXQuIFNhbWUgQVBJIGFzIG5vZGUgY29yZSBgbmV0LlNvY2tldGAuIER1cGxleCBzdHJlYW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHdlYnNvY2tldCBzZXJ2ZXIgdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBvcHRpb25zIHRvIHN0cmVhbS5EdXBsZXhcbiAqL1xuZnVuY3Rpb24gU29ja2V0ICh1cmwsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmwsIG9wdHMpXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIGRlYnVnKCduZXcgd2Vic29ja2V0OiAlcyAlbycsIHVybCwgb3B0cylcblxuICBvcHRzLmFsbG93SGFsZk9wZW4gPSBmYWxzZVxuICBpZiAob3B0cy5oaWdoV2F0ZXJNYXJrID09IG51bGwpIG9wdHMuaGlnaFdhdGVyTWFyayA9IDEwMjQgKiAxMDI0XG5cbiAgc3RyZWFtLkR1cGxleC5jYWxsKHNlbGYsIG9wdHMpXG5cbiAgc2VsZi51cmwgPSB1cmxcbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQgPSBvcHRzLmhpZ2hXYXRlck1hcmtcbiAgc2VsZi5fY2h1bmsgPSBudWxsXG4gIHNlbGYuX2NiID0gbnVsbFxuICBzZWxmLl9pbnRlcnZhbCA9IG51bGxcblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gYHdzYCBwYWNrYWdlIGFjY2VwdHMgb3B0aW9uc1xuICAgICAgc2VsZi5fd3MgPSBuZXcgX1dlYlNvY2tldChzZWxmLnVybCwgb3B0cylcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fd3MgPSBuZXcgX1dlYlNvY2tldChzZWxmLnVybClcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fb25FcnJvcihlcnIpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLl93cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICBzZWxmLl93cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fb25PcGVuKClcbiAgfVxuICBzZWxmLl93cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBzZWxmLl9vbk1lc3NhZ2UoZXZlbnQpXG4gIH1cbiAgc2VsZi5fd3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkNsb3NlKClcbiAgfVxuICBzZWxmLl93cy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uRXJyb3IobmV3IEVycm9yKCdjb25uZWN0aW9uIGVycm9yIHRvICcgKyBzZWxmLnVybCkpXG4gIH1cblxuICBzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuY29ubmVjdGVkKSB7XG4gICAgICAvLyBXaGVuIHN0cmVhbSBpcyBmaW5pc2hlZCB3cml0aW5nLCBjbG9zZSBzb2NrZXQgY29ubmVjdGlvbi4gSGFsZiBvcGVuIGNvbm5lY3Rpb25zXG4gICAgICAvLyBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuXG4gICAgICAvLyBXYWl0IGEgYml0IGJlZm9yZSBkZXN0cm95aW5nIHNvIHRoZSBzb2NrZXQgZmx1c2hlcy5cbiAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgbW9yZSByZWxpYWJsZSB3YXkgdG8gYWNjb21wbGlzaCB0aGlzP1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgfSwgMTAwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCB3aGVuIHN0cmVhbSBpcyBmaW5pc2hlZCB3cml0aW5nLCB3YWl0IHVudGlsIGRhdGEgaXNcbiAgICAgIC8vIGZsdXNoZWQgdG8gbmV0d29yayBhdCBcImNvbm5lY3RcIiBldmVudC5cbiAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgbW9yZSByZWxpYWJsZSB3YXkgdG8gYWNjb21wbGlzaCB0aGlzP1xuICAgICAgc2VsZi5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9kZXN0cm95KClcbiAgICAgICAgfSwgMTAwKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cblNvY2tldC5XRUJTT0NLRVRfU1VQUE9SVCA9ICEhX1dlYlNvY2tldFxuXG4vKipcbiAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgV2ViU29ja2V0IHNlcnZlci5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheVZpZXd8QXJyYXlCdWZmZXJ8QnVmZmVyfHN0cmluZ3xCbG9ifE9iamVjdH0gY2h1bmtcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGggfHwgY2h1bmsuYnl0ZUxlbmd0aCB8fCBjaHVuay5zaXplXG4gIHNlbGYuX3dzLnNlbmQoY2h1bmspXG4gIGRlYnVnKCd3cml0ZTogJWQgYnl0ZXMnLCBsZW4pXG59XG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZXN0cm95KG51bGwsIG9uY2xvc2UpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAob25jbG9zZSkgc2VsZi5vbmNlKCdjbG9zZScsIG9uY2xvc2UpXG5cbiAgZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgZXJyLm1lc3NhZ2UpXG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSBmYWxzZVxuXG4gIGlmICghc2VsZi5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgc2VsZi5wdXNoKG51bGwpXG4gIGlmICghc2VsZi5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgc2VsZi5lbmQoKVxuXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbClcbiAgc2VsZi5faW50ZXJ2YWwgPSBudWxsXG4gIHNlbGYuX2NodW5rID0gbnVsbFxuICBzZWxmLl9jYiA9IG51bGxcblxuICBpZiAoc2VsZi5fd3MpIHtcbiAgICB2YXIgd3MgPSBzZWxmLl93c1xuICAgIHZhciBvbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgd3Mub25jbG9zZSA9IG51bGxcbiAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICAgIH1cbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gX1dlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgIG9uQ2xvc2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB3cy5vbmNsb3NlID0gb25DbG9zZVxuICAgICAgICB3cy5jbG9zZSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgb25DbG9zZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3Mub25vcGVuID0gbnVsbFxuICAgIHdzLm9ubWVzc2FnZSA9IG51bGxcbiAgICB3cy5vbmVycm9yID0gbnVsbFxuICB9XG4gIHNlbGYuX3dzID0gbnVsbFxuXG4gIGlmIChlcnIpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG59XG5cblNvY2tldC5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7fVxuXG5Tb2NrZXQucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYihuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhZnRlciBzb2NrZXQgaXMgZGVzdHJveWVkJykpXG5cbiAgaWYgKHNlbGYuY29ubmVjdGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuc2VuZChjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBzZWxmLl9vbkVycm9yKGVycilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3cyAhPT0gJ2Z1bmN0aW9uJyAmJiBzZWxmLl93cy5idWZmZXJlZEFtb3VudCA+IHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50KSB7XG4gICAgICBkZWJ1Zygnc3RhcnQgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX3dzLmJ1ZmZlcmVkQW1vdW50KVxuICAgICAgc2VsZi5fY2IgPSBjYlxuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1Zygnd3JpdGUgYmVmb3JlIGNvbm5lY3QnKVxuICAgIHNlbGYuX2NodW5rID0gY2h1bmtcbiAgICBzZWxmLl9jYiA9IGNiXG4gIH1cbn1cblxuU29ja2V0LnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFcbiAgZGVidWcoJ3JlYWQ6ICVkIGJ5dGVzJywgZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoKVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpXG4gIHNlbGYucHVzaChkYXRhKVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5jb25uZWN0ZWQgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmNvbm5lY3RlZCA9IHRydWVcblxuICBpZiAoc2VsZi5fY2h1bmspIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5zZW5kKHNlbGYuX2NodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHNlbGYuX29uRXJyb3IoZXJyKVxuICAgIH1cbiAgICBzZWxmLl9jaHVuayA9IG51bGxcbiAgICBkZWJ1Zygnc2VudCBjaHVuayBmcm9tIFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcIicpXG5cbiAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgIHNlbGYuX2NiID0gbnVsbFxuICAgIGNiKG51bGwpXG4gIH1cblxuICAvLyBObyBiYWNrcHJlc3N1cmUgaW4gbm9kZS4gVGhlIGB3c2AgbW9kdWxlIGhhcyBhIGJ1Z2d5IGBidWZmZXJlZEFtb3VudGAgcHJvcGVydHkuXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzQ5MlxuICBpZiAodHlwZW9mIHdzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNlbGYuX2NiIHx8ICFzZWxmLl93cyB8fCBzZWxmLl93cy5idWZmZXJlZEFtb3VudCA+IHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZGVidWcoJ2VuZGluZyBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fd3MuYnVmZmVyZWRBbW91bnQpXG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYihudWxsKVxuICAgIH0sIDE1MClcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwudW5yZWYpIHNlbGYuX2ludGVydmFsLnVucmVmKClcbiAgfVxuXG4gIGRlYnVnKCdjb25uZWN0JylcbiAgc2VsZi5lbWl0KCdjb25uZWN0Jylcbn1cblxuU29ja2V0LnByb3RvdHlwZS5fb25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGRlYnVnKCdvbiBjbG9zZScpXG4gIHNlbGYuX2Rlc3Ryb3koKVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgZGVidWcoJ2Vycm9yOiAlcycsIGVyci5tZXNzYWdlIHx8IGVycilcbiAgc2VsZi5fZGVzdHJveShlcnIpXG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cblxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBwYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcbiAgICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGZuKXtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlIC0gdGhpcy5sYXN0UGluZyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbihuc3Ape1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3ApO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldm5ldCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihzb2NrZXQpe1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24oZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3ViO1xuICB3aGlsZSAoc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCkpIHN1Yi5kZXN0cm95KCk7XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1Zygnb25jbG9zZScpO1xuXG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbihlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgY29ubmVjdGluZzogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxLFxuICBwaW5nOiAxLFxuICBwb25nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGlmIChwYWNrZXQubnNwICE9IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbihpZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbihjb21wcmVzcyl7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcbiAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG4iLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG4gIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICAgIGlmIChpc0J1ZihkYXRhKSkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGpzb24gPSByZXF1aXJlKCdqc29uMycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHRyeSB7XG4gICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cbiIsIi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcbiIsInZhciB0aWNrID0gMVxudmFyIG1heFRpY2sgPSA2NTUzNVxudmFyIHJlc29sdXRpb24gPSA0XG52YXIgaW5jID0gZnVuY3Rpb24gKCkge1xuICB0aWNrID0gKHRpY2sgKyAxKSAmIG1heFRpY2tcbn1cblxudmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoaW5jLCAoMTAwMCAvIHJlc29sdXRpb24pIHwgMClcbmlmICh0aW1lci51bnJlZikgdGltZXIudW5yZWYoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWNvbmRzKSB7XG4gIHZhciBzaXplID0gcmVzb2x1dGlvbiAqIChzZWNvbmRzIHx8IDUpXG4gIHZhciBidWZmZXIgPSBbMF1cbiAgdmFyIHBvaW50ZXIgPSAxXG4gIHZhciBsYXN0ID0gKHRpY2sgLSAxKSAmIG1heFRpY2tcblxuICByZXR1cm4gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgdmFyIGRpc3QgPSAodGljayAtIGxhc3QpICYgbWF4VGlja1xuICAgIGlmIChkaXN0ID4gc2l6ZSkgZGlzdCA9IHNpemVcbiAgICBsYXN0ID0gdGlja1xuXG4gICAgd2hpbGUgKGRpc3QtLSkge1xuICAgICAgaWYgKHBvaW50ZXIgPT09IHNpemUpIHBvaW50ZXIgPSAwXG4gICAgICBidWZmZXJbcG9pbnRlcl0gPSBidWZmZXJbcG9pbnRlciA9PT0gMCA/IHNpemUgLSAxIDogcG9pbnRlciAtIDFdXG4gICAgICBwb2ludGVyKytcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEpIGJ1ZmZlcltwb2ludGVyIC0gMV0gKz0gZGVsdGFcblxuICAgIHZhciB0b3AgPSBidWZmZXJbcG9pbnRlciAtIDFdXG4gICAgdmFyIGJ0bSA9IGJ1ZmZlci5sZW5ndGggPCBzaXplID8gMCA6IGJ1ZmZlcltwb2ludGVyID09PSBzaXplID8gMCA6IHBvaW50ZXJdXG5cbiAgICByZXR1cm4gYnVmZmVyLmxlbmd0aCA8IHJlc29sdXRpb24gPyB0b3AgOiAodG9wIC0gYnRtKSAqIHJlc29sdXRpb24gLyBidWZmZXIubGVuZ3RoXG4gIH1cbn1cbiIsInZhciBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHN0YXR1c0NvZGVzID0gcmVxdWlyZSgnYnVpbHRpbi1zdGF0dXMtY29kZXMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwID0gZXhwb3J0c1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcblx0XHRvcHRzID0gdXJsLnBhcnNlKG9wdHMpXG5cdGVsc2Vcblx0XHRvcHRzID0gZXh0ZW5kKG9wdHMpXG5cblx0Ly8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcblx0Ly8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG5cdC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG5cdHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuXHR2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuXHR2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cdHZhciBwb3J0ID0gb3B0cy5wb3J0XG5cdHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG5cdC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcblx0aWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuXHRcdGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cblx0Ly8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXHRvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuXHRvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuXHQvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cblx0dmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG5cdGlmIChjYilcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgY2IpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5nZXQgPSBmdW5jdGlvbiBnZXQgKG9wdHMsIGNiKSB7XG5cdHZhciByZXEgPSBodHRwLnJlcXVlc3Qob3B0cywgY2IpXG5cdHJlcS5lbmQoKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fVxuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDRcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSBzdGF0dXNDb2Rlc1xuXG5odHRwLk1FVEhPRFMgPSBbXG5cdCdDSEVDS09VVCcsXG5cdCdDT05ORUNUJyxcblx0J0NPUFknLFxuXHQnREVMRVRFJyxcblx0J0dFVCcsXG5cdCdIRUFEJyxcblx0J0xPQ0snLFxuXHQnTS1TRUFSQ0gnLFxuXHQnTUVSR0UnLFxuXHQnTUtBQ1RJVklUWScsXG5cdCdNS0NPTCcsXG5cdCdNT1ZFJyxcblx0J05PVElGWScsXG5cdCdPUFRJT05TJyxcblx0J1BBVENIJyxcblx0J1BPU1QnLFxuXHQnUFJPUEZJTkQnLFxuXHQnUFJPUFBBVENIJyxcblx0J1BVUkdFJyxcblx0J1BVVCcsXG5cdCdSRVBPUlQnLFxuXHQnU0VBUkNIJyxcblx0J1NVQlNDUklCRScsXG5cdCdUUkFDRScsXG5cdCdVTkxPQ0snLFxuXHQnVU5TVUJTQ1JJQkUnXG5dIiwiZXhwb3J0cy5mZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsLmZldGNoKSAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5SZWFkYWJsZUJ5dGVTdHJlYW0pXG5cbmV4cG9ydHMuYmxvYkNvbnN0cnVjdG9yID0gZmFsc2VcbnRyeSB7XG5cdG5ldyBCbG9iKFtuZXcgQXJyYXlCdWZmZXIoMSldKVxuXHRleHBvcnRzLmJsb2JDb25zdHJ1Y3RvciA9IHRydWVcbn0gY2F0Y2ggKGUpIHt9XG5cbnZhciB4aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcbi8vIElmIGxvY2F0aW9uLmhvc3QgaXMgZW1wdHksIGUuZy4gaWYgdGhpcyBwYWdlL3dvcmtlciB3YXMgbG9hZGVkXG4vLyBmcm9tIGEgQmxvYiwgdGhlbiB1c2UgZXhhbXBsZS5jb20gdG8gYXZvaWQgYW4gZXJyb3Jcbnhoci5vcGVuKCdHRVQnLCBnbG9iYWwubG9jYXRpb24uaG9zdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJylcblxuZnVuY3Rpb24gY2hlY2tUeXBlU3VwcG9ydCAodHlwZSkge1xuXHR0cnkge1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSB0eXBlXG5cdFx0cmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09IHR5cGVcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlXG59XG5cbi8vIEZvciBzb21lIHN0cmFuZ2UgcmVhc29uLCBTYWZhcmkgNy4wIHJlcG9ydHMgdHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciA9PT0gJ29iamVjdCcuXG4vLyBTYWZhcmkgNy4xIGFwcGVhcnMgdG8gaGF2ZSBmaXhlZCB0aGlzIGJ1Zy5cbnZhciBoYXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhdmVTbGljZSA9IGhhdmVBcnJheUJ1ZmZlciAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5BcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UpXG5cbmV4cG9ydHMuYXJyYXlidWZmZXIgPSBoYXZlQXJyYXlCdWZmZXIgJiYgY2hlY2tUeXBlU3VwcG9ydCgnYXJyYXlidWZmZXInKVxuLy8gVGhlc2UgbmV4dCB0d28gdGVzdHMgdW5hdm9pZGFibHkgc2hvdyB3YXJuaW5ncyBpbiBDaHJvbWUuIFNpbmNlIGZldGNoIHdpbGwgYWx3YXlzXG4vLyBiZSB1c2VkIGlmIGl0J3MgYXZhaWxhYmxlLCBqdXN0IHJldHVybiBmYWxzZSBmb3IgdGhlc2UgdG8gYXZvaWQgdGhlIHdhcm5pbmdzLlxuZXhwb3J0cy5tc3N0cmVhbSA9ICFleHBvcnRzLmZldGNoICYmIGhhdmVTbGljZSAmJiBjaGVja1R5cGVTdXBwb3J0KCdtcy1zdHJlYW0nKVxuZXhwb3J0cy5tb3pjaHVua2VkYXJyYXlidWZmZXIgPSAhZXhwb3J0cy5mZXRjaCAmJiBoYXZlQXJyYXlCdWZmZXIgJiZcblx0Y2hlY2tUeXBlU3VwcG9ydCgnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKVxuZXhwb3J0cy5vdmVycmlkZU1pbWVUeXBlID0gaXNGdW5jdGlvbih4aHIub3ZlcnJpZGVNaW1lVHlwZSlcbmV4cG9ydHMudmJBcnJheSA9IGlzRnVuY3Rpb24oZ2xvYmFsLlZCQXJyYXkpXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cblxueGhyID0gbnVsbCAvLyBIZWxwIGdjXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIHRvQXJyYXlCdWZmZXIgPSByZXF1aXJlKCd0by1hcnJheWJ1ZmZlcicpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5KSB7XG5cdGlmIChjYXBhYmlsaXR5LmZldGNoKSB7XG5cdFx0cmV0dXJuICdmZXRjaCdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1vemNodW5rZWRhcnJheWJ1ZmZlcikge1xuXHRcdHJldHVybiAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tc3N0cmVhbSkge1xuXHRcdHJldHVybiAnbXMtc3RyZWFtJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkuYXJyYXlidWZmZXIgJiYgcHJlZmVyQmluYXJ5KSB7XG5cdFx0cmV0dXJuICdhcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LnZiQXJyYXkgJiYgcHJlZmVyQmluYXJ5KSB7XG5cdFx0cmV0dXJuICd0ZXh0OnZiYXJyYXknXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICd0ZXh0J1xuXHR9XG59XG5cbnZhciBDbGllbnRSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9vcHRzID0gb3B0c1xuXHRzZWxmLl9ib2R5ID0gW11cblx0c2VsZi5faGVhZGVycyA9IHt9XG5cdGlmIChvcHRzLmF1dGgpXG5cdFx0c2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIG5ldyBCdWZmZXIob3B0cy5hdXRoKS50b1N0cmluZygnYmFzZTY0JykpXG5cdE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdHNlbGYuc2V0SGVhZGVyKG5hbWUsIG9wdHMuaGVhZGVyc1tuYW1lXSlcblx0fSlcblxuXHR2YXIgcHJlZmVyQmluYXJ5XG5cdGlmIChvcHRzLm1vZGUgPT09ICdwcmVmZXItc3RyZWFtaW5nJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBhIGhpZ2ggcHJpb3JpdHkgYnV0IGJpbmFyeSBjb21wYXRpYmlsaXR5IGFuZFxuXHRcdC8vIHRoZSBhY2N1cmFjeSBvZiB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyIGFyZW4ndFxuXHRcdHByZWZlckJpbmFyeSA9IGZhbHNlXG5cdH0gZWxzZSBpZiAob3B0cy5tb2RlID09PSAnYWxsb3ctd3JvbmctY29udGVudC10eXBlJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIHByZXNlcnZpbmcgdGhlICdjb250ZW50LXR5cGUnIGhlYWRlclxuXHRcdHByZWZlckJpbmFyeSA9ICFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGVcblx0fSBlbHNlIGlmICghb3B0cy5tb2RlIHx8IG9wdHMubW9kZSA9PT0gJ2RlZmF1bHQnIHx8IG9wdHMubW9kZSA9PT0gJ3ByZWZlci1mYXN0Jykge1xuXHRcdC8vIFVzZSBiaW5hcnkgaWYgdGV4dCBzdHJlYW1pbmcgbWF5IGNvcnJ1cHQgZGF0YSBvciB0aGUgY29udGVudC10eXBlIGhlYWRlciwgb3IgZm9yIHNwZWVkXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igb3B0cy5tb2RlJylcblx0fVxuXHRzZWxmLl9tb2RlID0gZGVjaWRlTW9kZShwcmVmZXJCaW5hcnkpXG5cblx0c2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuX29uRmluaXNoKClcblx0fSlcbn1cblxuaW5oZXJpdHMoQ2xpZW50UmVxdWVzdCwgc3RyZWFtLldyaXRhYmxlKVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHZhciBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblx0Ly8gVGhpcyBjaGVjayBpcyBub3QgbmVjZXNzYXJ5LCBidXQgaXQgcHJldmVudHMgd2FybmluZ3MgZnJvbSBicm93c2VycyBhYm91dCBzZXR0aW5nIHVuc2FmZVxuXHQvLyBoZWFkZXJzLiBUbyBiZSBob25lc3QgSSdtIG5vdCBlbnRpcmVseSBzdXJlIGhpZGluZyB0aGVzZSB3YXJuaW5ncyBpcyBhIGdvb2QgdGhpbmcsIGJ1dFxuXHQvLyBodHRwLWJyb3dzZXJpZnkgZGlkIGl0LCBzbyBJIHdpbGwgdG9vLlxuXHRpZiAodW5zYWZlSGVhZGVycy5pbmRleE9mKGxvd2VyTmFtZSkgIT09IC0xKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX2hlYWRlcnNbbG93ZXJOYW1lXSA9IHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRyZXR1cm4gc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldLnZhbHVlXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblx0dmFyIG9wdHMgPSBzZWxmLl9vcHRzXG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5XG5cdGlmIChvcHRzLm1ldGhvZCA9PT0gJ1BPU1QnIHx8IG9wdHMubWV0aG9kID09PSAnUFVUJyB8fCBvcHRzLm1ldGhvZCA9PT0gJ1BBVENIJykge1xuXHRcdGlmIChjYXBhYmlsaXR5LmJsb2JDb25zdHJ1Y3Rvcikge1xuXHRcdFx0Ym9keSA9IG5ldyBnbG9iYWwuQmxvYihzZWxmLl9ib2R5Lm1hcChmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRcdHJldHVybiB0b0FycmF5QnVmZmVyKGJ1ZmZlcilcblx0XHRcdH0pLCB7XG5cdFx0XHRcdHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJydcblx0XHRcdH0pXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGdldCB1dGY4IHN0cmluZ1xuXHRcdFx0Ym9keSA9IEJ1ZmZlci5jb25jYXQoc2VsZi5fYm9keSkudG9TdHJpbmcoKVxuXHRcdH1cblx0fVxuXG5cdGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0dmFyIGhlYWRlcnMgPSBPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBbaGVhZGVyc09ialtuYW1lXS5uYW1lLCBoZWFkZXJzT2JqW25hbWVdLnZhbHVlXVxuXHRcdH0pXG5cblx0XHRnbG9iYWwuZmV0Y2goc2VsZi5fb3B0cy51cmwsIHtcblx0XHRcdG1ldGhvZDogc2VsZi5fb3B0cy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0Ym9keTogYm9keSxcblx0XHRcdG1vZGU6ICdjb3JzJyxcblx0XHRcdGNyZWRlbnRpYWxzOiBvcHRzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbidcblx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgcmVhc29uKVxuXHRcdH0pXG5cdH0gZWxzZSB7XG5cdFx0dmFyIHhociA9IHNlbGYuX3hociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbihzZWxmLl9vcHRzLm1ldGhvZCwgc2VsZi5fb3B0cy51cmwsIHRydWUpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBDYW4ndCBzZXQgcmVzcG9uc2VUeXBlIG9uIHJlYWxseSBvbGQgYnJvd3NlcnNcblx0XHRpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHNlbGYuX21vZGUuc3BsaXQoJzonKVswXVxuXG5cdFx0aWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocilcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzXG5cblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ3RleHQnICYmICdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpXG5cblx0XHRPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJzT2JqW25hbWVdLm5hbWUsIGhlYWRlcnNPYmpbbmFtZV0udmFsdWUpXG5cdFx0fSlcblxuXHRcdHNlbGYuX3Jlc3BvbnNlID0gbnVsbFxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5MT0FESU5HOlxuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuRE9ORTpcblx0XHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkXG5cdFx0Ly8gaW4gb25wcm9ncmVzcywgbm90IGluIG9ucmVhZHlzdGF0ZWNoYW5nZSB3aXRoIHhoci5yZWFkeVN0YXRlID0gM1xuXHRcdGlmIChzZWxmLl9tb2RlID09PSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKSB7XG5cdFx0XHR4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1hIUiBlcnJvcicpKVxuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR4aHIuc2VuZChib2R5KVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHhoci5zdGF0dXMgaXMgcmVhZGFibGUgYW5kIG5vbi16ZXJvLCBpbmRpY2F0aW5nIG5vIGVycm9yLlxuICogRXZlbiB0aG91Z2ggdGhlIHNwZWMgc2F5cyBpdCBzaG91bGQgYmUgYXZhaWxhYmxlIGluIHJlYWR5U3RhdGUgMyxcbiAqIGFjY2Vzc2luZyBpdCB0aHJvd3MgYW4gZXhjZXB0aW9uIGluIElFOFxuICovXG5mdW5jdGlvbiBzdGF0dXNWYWxpZCAoeGhyKSB7XG5cdHRyeSB7XG5cdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXNcblx0XHRyZXR1cm4gKHN0YXR1cyAhPT0gbnVsbCAmJiBzdGF0dXMgIT09IDApXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKCFzdGF0dXNWYWxpZChzZWxmLl94aHIpIHx8IHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRpZiAoIXNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX2Nvbm5lY3QoKVxuXG5cdHNlbGYuX3Jlc3BvbnNlLl9vblhIUlByb2dyZXNzKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5fcmVzcG9uc2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKHNlbGYuX3hociwgc2VsZi5fZmV0Y2hSZXNwb25zZSwgc2VsZi5fbW9kZSlcblx0c2VsZi5lbWl0KCdyZXNwb25zZScsIHNlbGYuX3Jlc3BvbnNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9ib2R5LnB1c2goY2h1bmspXG5cdGNiKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fcmVzcG9uc2UuX2Rlc3Ryb3llZCA9IHRydWVcblx0aWYgKHNlbGYuX3hocilcblx0XHRzZWxmLl94aHIuYWJvcnQoKVxuXHQvLyBDdXJyZW50bHksIHRoZXJlIGlzbid0IGEgd2F5IHRvIHRydWx5IGFib3J0IGEgZmV0Y2guXG5cdC8vIElmIHlvdSBsaWtlIGJpa2VzaGVkZGluZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzI3XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNiID0gZGF0YVxuXHRcdGRhdGEgPSB1bmRlZmluZWRcblx0fVxuXG5cdHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwoc2VsZiwgZGF0YSwgZW5jb2RpbmcsIGNiKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5mbHVzaEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXROb0RlbGF5ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFNvY2tldEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1zZXRyZXF1ZXN0aGVhZGVyJTI4JTI5LW1ldGhvZFxudmFyIHVuc2FmZUhlYWRlcnMgPSBbXG5cdCdhY2NlcHQtY2hhcnNldCcsXG5cdCdhY2NlcHQtZW5jb2RpbmcnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJyxcblx0J2Nvbm5lY3Rpb24nLFxuXHQnY29udGVudC1sZW5ndGgnLFxuXHQnY29va2llJyxcblx0J2Nvb2tpZTInLFxuXHQnZGF0ZScsXG5cdCdkbnQnLFxuXHQnZXhwZWN0Jyxcblx0J2hvc3QnLFxuXHQna2VlcC1hbGl2ZScsXG5cdCdvcmlnaW4nLFxuXHQncmVmZXJlcicsXG5cdCd0ZScsXG5cdCd0cmFpbGVyJyxcblx0J3RyYW5zZmVyLWVuY29kaW5nJyxcblx0J3VwZ3JhZGUnLFxuXHQndXNlci1hZ2VudCcsXG5cdCd2aWEnXG5dXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxudmFyIHJTdGF0ZXMgPSBleHBvcnRzLnJlYWR5U3RhdGVzID0ge1xuXHRVTlNFTlQ6IDAsXG5cdE9QRU5FRDogMSxcblx0SEVBREVSU19SRUNFSVZFRDogMixcblx0TE9BRElORzogMyxcblx0RE9ORTogNFxufVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gZXhwb3J0cy5JbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbiAoeGhyLCByZXNwb25zZSwgbW9kZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLlJlYWRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9tb2RlID0gbW9kZVxuXHRzZWxmLmhlYWRlcnMgPSB7fVxuXHRzZWxmLnJhd0hlYWRlcnMgPSBbXVxuXHRzZWxmLnRyYWlsZXJzID0ge31cblx0c2VsZi5yYXdUcmFpbGVycyA9IFtdXG5cblx0Ly8gRmFrZSB0aGUgJ2Nsb3NlJyBldmVudCwgYnV0IG9ubHkgb25jZSAnZW5kJyBmaXJlc1xuXHRzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlIG5leHRUaWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSAncmVxdWVzdCcgbW9kdWxlIGZyb20gY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wXG5cdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Nsb3NlJylcblx0XHR9KVxuXHR9KVxuXG5cdGlmIChtb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cblx0XHRzZWxmLnVybCA9IHJlc3BvbnNlLnVybFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSB2ZXJzaW9uIG9mIGZvciAoPGl0ZW0+IG9mIDxpdGVyYWJsZT4pOlxuXHRcdC8vIGZvciAodmFyIDxpdGVtPixfaSxfaXQgPSA8aXRlcmFibGU+W1N5bWJvbC5pdGVyYXRvcl0oKTsgPGl0ZW0+ID0gKF9pID0gX2l0Lm5leHQoKSkudmFsdWUsIV9pLmRvbmU7KVxuXHRcdGZvciAodmFyIGhlYWRlciwgX2ksIF9pdCA9IHJlc3BvbnNlLmhlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXSgpOyBoZWFkZXIgPSAoX2kgPSBfaXQubmV4dCgpKS52YWx1ZSwgIV9pLmRvbmU7KSB7XG5cdFx0XHRzZWxmLmhlYWRlcnNbaGVhZGVyWzBdLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyWzFdXG5cdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChoZWFkZXJbMF0sIGhlYWRlclsxXSlcblx0XHR9XG5cblx0XHQvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgcmVzcGVjdCBiYWNrcHJlc3N1cmUuIE9uY2UgV3JpdGFibGVTdHJlYW0gaXMgYXZhaWxhYmxlLCB0aGlzIGNhbiBiZSBmaXhlZFxuXHRcdHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpXG5cdFx0ZnVuY3Rpb24gcmVhZCAoKSB7XG5cdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihyZXN1bHQudmFsdWUpKVxuXHRcdFx0XHRyZWFkKClcblx0XHRcdH0pXG5cdFx0fVxuXHRcdHJlYWQoKVxuXG5cdH0gZWxzZSB7XG5cdFx0c2VsZi5feGhyID0geGhyXG5cdFx0c2VsZi5fcG9zID0gMFxuXG5cdFx0c2VsZi51cmwgPSB4aHIucmVzcG9uc2VVUkxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1c1RleHRcblx0XHR2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pXG5cdFx0aGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pXG5cdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHR2YXIga2V5ID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuXHRcdFx0XHRcdGlmIChzZWxmLmhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IFtdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldLnB1c2gobWF0Y2hlc1syXSlcblx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLmhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIG1hdGNoZXNbMl1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IG1hdGNoZXNbMl1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChtYXRjaGVzWzFdLCBtYXRjaGVzWzJdKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRzZWxmLl9jaGFyc2V0ID0gJ3gtdXNlci1kZWZpbmVkJ1xuXHRcdGlmICghY2FwYWJpbGl0eS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHR2YXIgbWltZVR5cGUgPSBzZWxmLnJhd0hlYWRlcnNbJ21pbWUtdHlwZSddXG5cdFx0XHRpZiAobWltZVR5cGUpIHtcblx0XHRcdFx0dmFyIGNoYXJzZXRNYXRjaCA9IG1pbWVUeXBlLm1hdGNoKC87XFxzKmNoYXJzZXQ9KFteO10pKDt8JCkvKVxuXHRcdFx0XHRpZiAoY2hhcnNldE1hdGNoKSB7XG5cdFx0XHRcdFx0c2VsZi5fY2hhcnNldCA9IGNoYXJzZXRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghc2VsZi5fY2hhcnNldClcblx0XHRcdFx0c2VsZi5fY2hhcnNldCA9ICd1dGYtOCcgLy8gYmVzdCBndWVzc1xuXHRcdH1cblx0fVxufVxuXG5pbmhlcml0cyhJbmNvbWluZ01lc3NhZ2UsIHN0cmVhbS5SZWFkYWJsZSlcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciB4aHIgPSBzZWxmLl94aHJcblxuXHR2YXIgcmVzcG9uc2UgPSBudWxsXG5cdHN3aXRjaCAoc2VsZi5fbW9kZSkge1xuXHRcdGNhc2UgJ3RleHQ6dmJhcnJheSc6IC8vIEZvciBJRTlcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5ET05FKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gVGhpcyBmYWlscyBpbiBJRThcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgZ2xvYmFsLlZCQXJyYXkoeGhyLnJlc3BvbnNlQm9keSkudG9BcnJheSgpXG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0aWYgKHJlc3BvbnNlICE9PSBudWxsKSB7XG5cdFx0XHRcdHNlbGYucHVzaChuZXcgQnVmZmVyKHJlc3BvbnNlKSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdC8vIEZhbGxzIHRocm91Z2ggaW4gSUU4XHRcblx0XHRjYXNlICd0ZXh0Jzpcblx0XHRcdHRyeSB7IC8vIFRoaXMgd2lsbCBmYWlsIHdoZW4gcmVhZHlTdGF0ZSA9IDMgaW4gSUU5LiBTd2l0Y2ggbW9kZSBhbmQgd2FpdCBmb3IgcmVhZHlTdGF0ZSA9IDRcblx0XHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHNlbGYuX21vZGUgPSAndGV4dDp2YmFycmF5J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlc3BvbnNlLmxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHR2YXIgbmV3RGF0YSA9IHJlc3BvbnNlLnN1YnN0cihzZWxmLl9wb3MpXG5cdFx0XHRcdGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobmV3RGF0YS5sZW5ndGgpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0YnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZlxuXG5cdFx0XHRcdFx0c2VsZi5wdXNoKGJ1ZmZlcilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3RGF0YSwgc2VsZi5fY2hhcnNldClcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9wb3MgPSByZXNwb25zZS5sZW5ndGhcblx0XHRcdH1cblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInOiAvLyB0YWtlIHdob2xlXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbXMtc3RyZWFtJzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcblx0XHRcdFx0YnJlYWtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgZ2xvYmFsLk1TU3RyZWFtUmVhZGVyKClcblx0XHRcdHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdC5zbGljZShzZWxmLl9wb3MpKSkpXG5cdFx0XHRcdFx0c2VsZi5fcG9zID0gcmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVhZGVyLm9uZXJyb3IgPSA/Pz8gLy8gVE9ETzogdGhpc1xuXHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHJlc3BvbnNlKVxuXHRcdFx0YnJlYWtcblx0fVxuXG5cdC8vIFRoZSBtcy1zdHJlYW0gY2FzZSBoYW5kbGVzIGVuZCBzZXBhcmF0ZWx5IGluIHJlYWRlci5vbmxvYWQoKVxuXHRpZiAoc2VsZi5feGhyLnJlYWR5U3RhdGUgPT09IHJTdGF0ZXMuRE9ORSAmJiBzZWxmLl9tb2RlICE9PSAnbXMtc3RyZWFtJykge1xuXHRcdHNlbGYucHVzaChudWxsKVxuXHR9XG59XG4iLCIvKiBnbG9iYWwgVVJMICovXG5cbnZhciBnZXRCbG9iID0gcmVxdWlyZSgnc3RyZWFtLXRvLWJsb2InKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJsb2JVUkwgKHN0cmVhbSwgbWltZVR5cGUsIGNiKSB7XG4gIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdmdW5jdGlvbicpIHJldHVybiBnZXRCbG9iVVJMKHN0cmVhbSwgbnVsbCwgbWltZVR5cGUpXG4gIGdldEJsb2Ioc3RyZWFtLCBtaW1lVHlwZSwgZnVuY3Rpb24gKGVyciwgYmxvYikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICBjYihudWxsLCB1cmwpXG4gIH0pXG59XG4iLCIvKiBnbG9iYWwgQmxvYiAqL1xuXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJsb2IgKHN0cmVhbSwgbWltZVR5cGUsIGNiKSB7XG4gIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdmdW5jdGlvbicpIHJldHVybiBnZXRCbG9iKHN0cmVhbSwgbnVsbCwgbWltZVR5cGUpXG4gIGNiID0gb25jZShjYilcbiAgdmFyIGNodW5rcyA9IFtdXG4gIHN0cmVhbVxuICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgfSlcbiAgICAub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBibG9iID0gbWltZVR5cGVcbiAgICAgICAgPyBuZXcgQmxvYihjaHVua3MsIHsgdHlwZTogbWltZVR5cGUgfSlcbiAgICAgICAgOiBuZXcgQmxvYihjaHVua3MpXG4gICAgICBjYihudWxsLCBibG9iKVxuICAgIH0pXG4gICAgLm9uKCdlcnJvcicsIGNiKVxufVxuIiwidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCdWZmZXIgKHN0cmVhbSwgbGVuZ3RoLCBjYikge1xuICBjYiA9IG9uY2UoY2IpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgdmFyIG9mZnNldCA9IDBcbiAgc3RyZWFtXG4gICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBjaHVuay5jb3B5KGJ1Ziwgb2Zmc2V0KVxuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aFxuICAgIH0pXG4gICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7IGNiKG51bGwsIGJ1ZikgfSlcbiAgICAub24oJ2Vycm9yJywgY2IpXG59XG4iLCJ2YXIgYWRkclRvSVBQb3J0ID0gcmVxdWlyZSgnYWRkci10by1pcC1wb3J0JylcbnZhciBpcGFkZHIgPSByZXF1aXJlKCdpcGFkZHIuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhZGRycykge1xuICBpZiAodHlwZW9mIGFkZHJzID09PSAnc3RyaW5nJykge1xuICAgIGFkZHJzID0gWyBhZGRycyBdXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChhZGRycy5tYXAoZnVuY3Rpb24gKGFkZHIpIHtcbiAgICB2YXIgcyA9IGFkZHJUb0lQUG9ydChhZGRyKVxuICAgIGlmIChzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHJlc3MgZm9ybWF0LCBleHBlY3Rpbmc6IDEwLjEwLjEwLjU6MTI4JylcbiAgICB9XG5cbiAgICB2YXIgaXAgPSBpcGFkZHIucGFyc2Uoc1swXSlcbiAgICB2YXIgaXBCdWYgPSBuZXcgQnVmZmVyKGlwLnRvQnl0ZUFycmF5KCkpXG4gICAgdmFyIHBvcnQgPSBOdW1iZXIoc1sxXSlcbiAgICB2YXIgcG9ydEJ1ZiA9IG5ldyBCdWZmZXIoMilcbiAgICBwb3J0QnVmLndyaXRlVUludDE2QkUocG9ydCwgMClcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbaXBCdWYsIHBvcnRCdWZdKVxuICB9KSlcbn1cblxuLyoqXG4gKiBBbHNvIHN1cHBvcnQgdGhpcyB1c2FnZTpcbiAqICAgc3RyaW5nMmNvbXBhY3QubXVsdGkoWyAnMTAuMTAuMTAuNToxMjgnLCAnMTAwLjU2LjU4Ljk5OjI4NTI1JyBdKVxuICpcbiAqIGZvciBwYXJhbGxlbGlzbSB3aXRoIHRoZSBgY29tcGFjdDJzdHJpbmdgIG1vZHVsZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMubXVsdGkgPSBtb2R1bGUuZXhwb3J0c1xubW9kdWxlLmV4cG9ydHMubXVsdGk2ID0gbW9kdWxlLmV4cG9ydHNcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwiLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbkNvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWxcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiAgICAgIFxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBcblRIRSBTT0ZUV0FSRS5cbiovXG5cbnZhciBiYXNlMzIgPSByZXF1aXJlKCcuL3RoaXJ0eS10d28nKTtcblxuZXhwb3J0cy5lbmNvZGUgPSBiYXNlMzIuZW5jb2RlO1xuZXhwb3J0cy5kZWNvZGUgPSBiYXNlMzIuZGVjb2RlO1xuIiwiLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbkNvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWxcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiovXG5cbnZhciBjaGFyVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCI7XG52YXIgYnl0ZVRhYmxlID0gW1xuICAgIDB4ZmYsIDB4ZmYsIDB4MWEsIDB4MWIsIDB4MWMsIDB4MWQsIDB4MWUsIDB4MWYsXG4gICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgICAweGZmLCAweDAwLCAweDAxLCAweDAyLCAweDAzLCAweDA0LCAweDA1LCAweDA2LFxuICAgIDB4MDcsIDB4MDgsIDB4MDksIDB4MGEsIDB4MGIsIDB4MGMsIDB4MGQsIDB4MGUsXG4gICAgMHgwZiwgMHgxMCwgMHgxMSwgMHgxMiwgMHgxMywgMHgxNCwgMHgxNSwgMHgxNixcbiAgICAweDE3LCAweDE4LCAweDE5LCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAgIDB4ZmYsIDB4MDAsIDB4MDEsIDB4MDIsIDB4MDMsIDB4MDQsIDB4MDUsIDB4MDYsXG4gICAgMHgwNywgMHgwOCwgMHgwOSwgMHgwYSwgMHgwYiwgMHgwYywgMHgwZCwgMHgwZSxcbiAgICAweDBmLCAweDEwLCAweDExLCAweDEyLCAweDEzLCAweDE0LCAweDE1LCAweDE2LFxuICAgIDB4MTcsIDB4MTgsIDB4MTksIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmZcbl07XG5cbmZ1bmN0aW9uIHF1aW50ZXRDb3VudChidWZmKSB7XG4gICAgdmFyIHF1aW50ZXRzID0gTWF0aC5mbG9vcihidWZmLmxlbmd0aCAvIDUpO1xuICAgIHJldHVybiBidWZmLmxlbmd0aCAlIDUgPT0gMCA/IHF1aW50ZXRzOiBxdWludGV0cyArIDE7XG59XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24ocGxhaW4pIHtcbiAgICBpZighQnVmZmVyLmlzQnVmZmVyKHBsYWluKSl7XG4gICAgXHRwbGFpbiA9IG5ldyBCdWZmZXIocGxhaW4pO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBzaGlmdEluZGV4ID0gMDtcbiAgICB2YXIgZGlnaXQgPSAwO1xuICAgIHZhciBlbmNvZGVkID0gbmV3IEJ1ZmZlcihxdWludGV0Q291bnQocGxhaW4pICogOCk7XG5cbiAgICAvKiBieXRlIGJ5IGJ5dGUgaXNuJ3QgYXMgcHJldHR5IGFzIHF1aW50ZXQgYnkgcXVpbnRldCBidXQgdGVzdHMgYSBiaXRcbiAgICAgICAgZmFzdGVyLiB3aWxsIGhhdmUgdG8gcmV2aXNpdC4gKi9cbiAgICB3aGlsZShpIDwgcGxhaW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcGxhaW5baV07XG4gICAgXG4gICAgICAgIGlmKHNoaWZ0SW5kZXggPiAzKSB7XG4gICAgICAgICAgICBkaWdpdCA9IGN1cnJlbnQgJiAoMHhmZiA+PiBzaGlmdEluZGV4KTtcbiAgICAgICAgICAgIHNoaWZ0SW5kZXggPSAoc2hpZnRJbmRleCArIDUpICUgODtcbiAgICAgICAgICAgIGRpZ2l0ID0gKGRpZ2l0IDw8IHNoaWZ0SW5kZXgpIHwgKChpICsgMSA8IHBsYWluLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgIHBsYWluW2kgKyAxXSA6IDApID4+ICg4IC0gc2hpZnRJbmRleCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWdpdCA9IChjdXJyZW50ID4+ICg4IC0gKHNoaWZ0SW5kZXggKyA1KSkpICYgMHgxZjtcbiAgICAgICAgICAgIHNoaWZ0SW5kZXggPSAoc2hpZnRJbmRleCArIDUpICUgODsgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHNoaWZ0SW5kZXggPT0gMCkgaSsrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBlbmNvZGVkW2pdID0gY2hhclRhYmxlLmNoYXJDb2RlQXQoZGlnaXQpO1xuICAgICAgICBqKys7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBqOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKylcbiAgICAgICAgZW5jb2RlZFtpXSA9IDB4M2Q7IC8vJz0nLmNoYXJDb2RlQXQoMClcbiAgICAgICAgXG4gICAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICB2YXIgc2hpZnRJbmRleCA9IDA7XG4gICAgdmFyIHBsYWluRGlnaXQgPSAwO1xuICAgIHZhciBwbGFpbkNoYXI7XG4gICAgdmFyIHBsYWluUG9zID0gMDtcbiAgICBpZighQnVmZmVyLmlzQnVmZmVyKGVuY29kZWQpKXtcbiAgICBcdGVuY29kZWQgPSBuZXcgQnVmZmVyKGVuY29kZWQpO1xuICAgIH1cbiAgICB2YXIgZGVjb2RlZCA9IG5ldyBCdWZmZXIoTWF0aC5jZWlsKGVuY29kZWQubGVuZ3RoICogNSAvIDgpKTtcbiAgICBcbiAgICAvKiBieXRlIGJ5IGJ5dGUgaXNuJ3QgYXMgcHJldHR5IGFzIG9jdGV0IGJ5IG9jdGV0IGJ1dCB0ZXN0cyBhIGJpdFxuICAgICAgICBmYXN0ZXIuIHdpbGwgaGF2ZSB0byByZXZpc2l0LiAqLyAgICBcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgIFx0aWYoZW5jb2RlZFtpXSA9PSAweDNkKXsgLy8nPSdcbiAgICBcdFx0YnJlYWs7XG4gICAgXHR9XG4gICAgXHRcdFxuICAgICAgICB2YXIgZW5jb2RlZEJ5dGUgPSBlbmNvZGVkW2ldIC0gMHgzMDtcbiAgICAgICAgXG4gICAgICAgIGlmKGVuY29kZWRCeXRlIDwgYnl0ZVRhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgcGxhaW5EaWdpdCA9IGJ5dGVUYWJsZVtlbmNvZGVkQnl0ZV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHNoaWZ0SW5kZXggPD0gMykge1xuICAgICAgICAgICAgICAgIHNoaWZ0SW5kZXggPSAoc2hpZnRJbmRleCArIDUpICUgODtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihzaGlmdEluZGV4ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhaW5DaGFyIHw9IHBsYWluRGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWRbcGxhaW5Qb3NdID0gcGxhaW5DaGFyO1xuICAgICAgICAgICAgICAgICAgICBwbGFpblBvcysrO1xuICAgICAgICAgICAgICAgICAgICBwbGFpbkNoYXIgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYWluQ2hhciB8PSAweGZmICYgKHBsYWluRGlnaXQgPDwgKDggLSBzaGlmdEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGlmdEluZGV4ID0gKHNoaWZ0SW5kZXggKyA1KSAlIDg7XG4gICAgICAgICAgICAgICAgcGxhaW5DaGFyIHw9IDB4ZmYgJiAocGxhaW5EaWdpdCA+Pj4gc2hpZnRJbmRleCk7XG4gICAgICAgICAgICAgICAgZGVjb2RlZFtwbGFpblBvc10gPSBwbGFpbkNoYXI7XG4gICAgICAgICAgICAgICAgcGxhaW5Qb3MrKztcblxuICAgICAgICAgICAgICAgIHBsYWluQ2hhciA9IDB4ZmYgJiAocGxhaW5EaWdpdCA8PCAoOCAtIHNoaWZ0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgXHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgLSBpdCBpcyBub3QgYmFzZTMyIGVuY29kZWQgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuc2xpY2UoMCwgcGxhaW5Qb3MpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJ1Zikge1xuXHQvLyBJZiB0aGUgYnVmZmVyIGlzIGJhY2tlZCBieSBhIFVpbnQ4QXJyYXksIGEgZmFzdGVyIHZlcnNpb24gd2lsbCB3b3JrXG5cdGlmIChidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdFx0Ly8gSWYgdGhlIGJ1ZmZlciBpc24ndCBhIHN1YmFycmF5LCByZXR1cm4gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXJcblx0XHRpZiAoYnVmLmJ5dGVPZmZzZXQgPT09IDAgJiYgYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBidWYuYnVmZmVyLnNsaWNlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBnZXQgYSBwcm9wZXIgY29weVxuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpXG5cdFx0fVxuXHR9XG5cblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG5cdFx0Ly8gVGhpcyBpcyB0aGUgc2xvdyB2ZXJzaW9uIHRoYXQgd2lsbCB3b3JrIHdpdGggYW55IEJ1ZmZlclxuXHRcdC8vIGltcGxlbWVudGF0aW9uIChldmVuIGluIG9sZCBicm93c2Vycylcblx0XHR2YXIgYXJyYXlDb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmxlbmd0aClcblx0XHR2YXIgbGVuID0gYnVmLmxlbmd0aFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFycmF5Q29weVtpXSA9IGJ1ZltpXVxuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXlDb3B5LmJ1ZmZlclxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG5cdH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gRGlzY292ZXJ5XG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3RvcnJlbnQtZGlzY292ZXJ5JylcbnZhciBESFQgPSByZXF1aXJlKCdiaXR0b3JyZW50LWRodC9jbGllbnQnKSAvLyBlbXB0eSBvYmplY3QgaW4gYnJvd3NlclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBwYXJhbGxlbCA9IHJlcXVpcmUoJ3J1bi1wYXJhbGxlbCcpXG52YXIgVHJhY2tlciA9IHJlcXVpcmUoJ2JpdHRvcnJlbnQtdHJhY2tlci9jbGllbnQnKVxuXG5pbmhlcml0cyhEaXNjb3ZlcnksIEV2ZW50RW1pdHRlcilcblxuZnVuY3Rpb24gRGlzY292ZXJ5IChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgRGlzY292ZXJ5KSkgcmV0dXJuIG5ldyBEaXNjb3Zlcnkob3B0cylcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcblxuICBpZiAoIW9wdHMucGVlcklkKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBgcGVlcklkYCBpcyByZXF1aXJlZCcpXG4gIGlmICghb3B0cy5pbmZvSGFzaCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYGluZm9IYXNoYCBpcyByZXF1aXJlZCcpXG4gIGlmICghcHJvY2Vzcy5icm93c2VyICYmICFvcHRzLnBvcnQpIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGBwb3J0YCBpcyByZXF1aXJlZCcpXG5cbiAgc2VsZi5wZWVySWQgPSB0eXBlb2Ygb3B0cy5wZWVySWQgPT09ICdzdHJpbmcnXG4gICAgPyBvcHRzLnBlZXJJZFxuICAgIDogb3B0cy5wZWVySWQudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuaW5mb0hhc2ggPSB0eXBlb2Ygb3B0cy5pbmZvSGFzaCA9PT0gJ3N0cmluZydcbiAgICA/IG9wdHMuaW5mb0hhc2hcbiAgICA6IG9wdHMuaW5mb0hhc2gudG9TdHJpbmcoJ2hleCcpXG4gIHNlbGYuX3BvcnQgPSBvcHRzLnBvcnQgLy8gdG9ycmVudCBwb3J0XG5cbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuXG4gIHNlbGYuX2Fubm91bmNlID0gb3B0cy5hbm5vdW5jZSB8fCBbXVxuICBzZWxmLl9pbnRlcnZhbE1zID0gb3B0cy5pbnRlcnZhbE1zIHx8ICgxNSAqIDYwICogMTAwMClcbiAgc2VsZi5fdHJhY2tlck9wdHMgPSBudWxsXG4gIHNlbGYuX2RodEFubm91bmNpbmcgPSBmYWxzZVxuICBzZWxmLl9kaHRUaW1lb3V0ID0gZmFsc2VcbiAgc2VsZi5faW50ZXJuYWxESFQgPSBmYWxzZSAvLyBpcyB0aGUgREhUIGNyZWF0ZWQgaW50ZXJuYWxseT9cblxuICBzZWxmLl9vbldhcm5pbmcgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5lbWl0KCd3YXJuaW5nJywgZXJyKVxuICB9XG4gIHNlbGYuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuICBzZWxmLl9vbkRIVFBlZXIgPSBmdW5jdGlvbiAocGVlciwgaW5mb0hhc2gpIHtcbiAgICBpZiAoaW5mb0hhc2gudG9TdHJpbmcoJ2hleCcpICE9PSBzZWxmLmluZm9IYXNoKSByZXR1cm5cbiAgICBzZWxmLmVtaXQoJ3BlZXInLCBwZWVyLmhvc3QgKyAnOicgKyBwZWVyLnBvcnQpXG4gIH1cbiAgc2VsZi5fb25UcmFja2VyUGVlciA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgc2VsZi5lbWl0KCdwZWVyJywgcGVlcilcbiAgfVxuICBzZWxmLl9vblRyYWNrZXJBbm5vdW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3RyYWNrZXJBbm5vdW5jZScpXG4gIH1cblxuICBpZiAob3B0cy50cmFja2VyID09PSBmYWxzZSkge1xuICAgIHNlbGYudHJhY2tlciA9IG51bGxcbiAgfSBlbHNlIGlmIChvcHRzLnRyYWNrZXIgJiYgdHlwZW9mIG9wdHMudHJhY2tlciA9PT0gJ29iamVjdCcpIHtcbiAgICBzZWxmLl90cmFja2VyT3B0cyA9IGV4dGVuZChvcHRzLnRyYWNrZXIpXG4gICAgc2VsZi50cmFja2VyID0gc2VsZi5fY3JlYXRlVHJhY2tlcigpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi50cmFja2VyID0gc2VsZi5fY3JlYXRlVHJhY2tlcigpXG4gIH1cblxuICBpZiAob3B0cy5kaHQgPT09IGZhbHNlIHx8IHR5cGVvZiBESFQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLmRodCA9IG51bGxcbiAgfSBlbHNlIGlmIChvcHRzLmRodCAmJiB0eXBlb2Ygb3B0cy5kaHQuYWRkTm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuZGh0ID0gb3B0cy5kaHRcbiAgfSBlbHNlIGlmIChvcHRzLmRodCAmJiB0eXBlb2Ygb3B0cy5kaHQgPT09ICdvYmplY3QnKSB7XG4gICAgc2VsZi5kaHQgPSBjcmVhdGVESFQob3B0cy5kaHRQb3J0LCBvcHRzLmRodClcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRodCA9IGNyZWF0ZURIVChvcHRzLmRodFBvcnQpXG4gIH1cblxuICBpZiAoc2VsZi5kaHQpIHtcbiAgICBzZWxmLmRodC5vbigncGVlcicsIHNlbGYuX29uREhUUGVlcilcbiAgICBzZWxmLl9kaHRBbm5vdW5jZSgpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVESFQgKHBvcnQsIG9wdHMpIHtcbiAgICB2YXIgZGh0ID0gbmV3IERIVChvcHRzKVxuICAgIGRodC5vbignd2FybmluZycsIHNlbGYuX29uV2FybmluZylcbiAgICBkaHQub24oJ2Vycm9yJywgc2VsZi5fb25FcnJvcilcbiAgICBkaHQubGlzdGVuKHBvcnQpXG4gICAgc2VsZi5faW50ZXJuYWxESFQgPSB0cnVlXG4gICAgcmV0dXJuIGRodFxuICB9XG59XG5cbkRpc2NvdmVyeS5wcm90b3R5cGUudXBkYXRlUG9ydCA9IGZ1bmN0aW9uIChwb3J0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAocG9ydCA9PT0gc2VsZi5fcG9ydCkgcmV0dXJuXG4gIHNlbGYuX3BvcnQgPSBwb3J0XG5cbiAgaWYgKHNlbGYuZGh0KSBzZWxmLl9kaHRBbm5vdW5jZSgpXG5cbiAgaWYgKHNlbGYudHJhY2tlcikge1xuICAgIHNlbGYudHJhY2tlci5zdG9wKClcbiAgICBzZWxmLnRyYWNrZXIuZGVzdHJveShmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnRyYWNrZXIgPSBzZWxmLl9jcmVhdGVUcmFja2VyKClcbiAgICB9KVxuICB9XG59XG5cbkRpc2NvdmVyeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgY2xlYXJUaW1lb3V0KHNlbGYuX2RodFRpbWVvdXQpXG5cbiAgdmFyIHRhc2tzID0gW11cblxuICBpZiAoc2VsZi50cmFja2VyKSB7XG4gICAgc2VsZi50cmFja2VyLnN0b3AoKVxuICAgIHNlbGYudHJhY2tlci5yZW1vdmVMaXN0ZW5lcignd2FybmluZycsIHNlbGYuX29uV2FybmluZylcbiAgICBzZWxmLnRyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fb25FcnJvcilcbiAgICBzZWxmLnRyYWNrZXIucmVtb3ZlTGlzdGVuZXIoJ3BlZXInLCBzZWxmLl9vblRyYWNrZXJQZWVyKVxuICAgIHNlbGYudHJhY2tlci5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgc2VsZi5fb25UcmFja2VyQW5ub3VuY2UpXG4gICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHNlbGYudHJhY2tlci5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBpZiAoc2VsZi5kaHQpIHtcbiAgICBzZWxmLmRodC5yZW1vdmVMaXN0ZW5lcigncGVlcicsIHNlbGYuX29uREhUUGVlcilcbiAgfVxuXG4gIGlmIChzZWxmLl9pbnRlcm5hbERIVCkge1xuICAgIHNlbGYuZGh0LnJlbW92ZUxpc3RlbmVyKCd3YXJuaW5nJywgc2VsZi5fb25XYXJuaW5nKVxuICAgIHNlbGYuZGh0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG4gICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHNlbGYuZGh0LmRlc3Ryb3koY2IpXG4gICAgfSlcbiAgfVxuXG4gIHBhcmFsbGVsKHRhc2tzLCBjYilcblxuICAvLyBjbGVhbnVwXG4gIHNlbGYuZGh0ID0gbnVsbFxuICBzZWxmLnRyYWNrZXIgPSBudWxsXG4gIHNlbGYuX2Fubm91bmNlID0gbnVsbFxufVxuXG5EaXNjb3ZlcnkucHJvdG90eXBlLl9jcmVhdGVUcmFja2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgb3B0cyA9IGV4dGVuZChzZWxmLl90cmFja2VyT3B0cywge1xuICAgIGluZm9IYXNoOiBzZWxmLmluZm9IYXNoLFxuICAgIGFubm91bmNlOiBzZWxmLl9hbm5vdW5jZSxcbiAgICBwZWVySWQ6IHNlbGYucGVlcklkLFxuICAgIHBvcnQ6IHNlbGYuX3BvcnRcbiAgfSlcblxuICB2YXIgdHJhY2tlciA9IG5ldyBUcmFja2VyKG9wdHMpXG4gIHRyYWNrZXIub24oJ3dhcm5pbmcnLCBzZWxmLl9vbldhcm5pbmcpXG4gIHRyYWNrZXIub24oJ2Vycm9yJywgc2VsZi5fb25FcnJvcilcbiAgdHJhY2tlci5vbigncGVlcicsIHNlbGYuX29uVHJhY2tlclBlZXIpXG4gIHRyYWNrZXIub24oJ3VwZGF0ZScsIHNlbGYuX29uVHJhY2tlckFubm91bmNlKVxuICB0cmFja2VyLnNldEludGVydmFsKHNlbGYuX2ludGVydmFsTXMpXG4gIHRyYWNrZXIuc3RhcnQoKVxuICByZXR1cm4gdHJhY2tlclxufVxuXG5EaXNjb3ZlcnkucHJvdG90eXBlLl9kaHRBbm5vdW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLl9kaHRBbm5vdW5jaW5nKSByZXR1cm5cbiAgZGVidWcoJ2RodCBhbm5vdW5jZScpXG5cbiAgc2VsZi5fZGh0QW5ub3VuY2luZyA9IHRydWVcbiAgY2xlYXJUaW1lb3V0KHNlbGYuX2RodFRpbWVvdXQpXG5cbiAgc2VsZi5kaHQuYW5ub3VuY2Uoc2VsZi5pbmZvSGFzaCwgc2VsZi5fcG9ydCwgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX2RodEFubm91bmNpbmcgPSBmYWxzZVxuICAgIGRlYnVnKCdkaHQgYW5ub3VuY2UgY29tcGxldGUnKVxuXG4gICAgaWYgKGVycikgc2VsZi5lbWl0KCd3YXJuaW5nJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnZGh0QW5ub3VuY2UnKVxuXG4gICAgaWYgKCFzZWxmLmRlc3Ryb3llZCkge1xuICAgICAgc2VsZi5fZGh0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kaHRBbm5vdW5jZSgpXG4gICAgICB9LCBnZXRSYW5kb21UaW1lb3V0KCkpXG4gICAgICBpZiAoc2VsZi5fZGh0VGltZW91dC51bnJlZikgc2VsZi5fZGh0VGltZW91dC51bnJlZigpXG4gICAgfVxuICB9KVxuXG4gIC8vIFJldHVybnMgdGltZW91dCBpbnRlcnZhbCwgd2l0aCBzb21lIHJhbmRvbSBqaXR0ZXJcbiAgZnVuY3Rpb24gZ2V0UmFuZG9tVGltZW91dCAoKSB7XG4gICAgcmV0dXJuIHNlbGYuX2ludGVydmFsTXMgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzZWxmLl9pbnRlcnZhbE1zIC8gNSlcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBQaWVjZVxuXG52YXIgQkxPQ0tfTEVOR1RIID0gMSA8PCAxNFxuXG5mdW5jdGlvbiBQaWVjZSAobGVuZ3RoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQaWVjZSkpIHJldHVybiBuZXcgUGllY2UobGVuZ3RoKVxuXG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMubWlzc2luZyA9IGxlbmd0aFxuICB0aGlzLnNvdXJjZXMgPSBudWxsXG5cbiAgdGhpcy5fY2h1bmtzID0gTWF0aC5jZWlsKGxlbmd0aCAvIEJMT0NLX0xFTkdUSClcbiAgdGhpcy5fcmVtYWluZGVyID0gKGxlbmd0aCAlIEJMT0NLX0xFTkdUSCkgfHwgQkxPQ0tfTEVOR1RIXG4gIHRoaXMuX2J1ZmZlcmVkID0gMFxuICB0aGlzLl9idWZmZXIgPSBudWxsXG4gIHRoaXMuX2NhbmNlbGxhdGlvbnMgPSBudWxsXG4gIHRoaXMuX3Jlc2VydmF0aW9ucyA9IDBcbiAgdGhpcy5fZmx1c2hlZCA9IGZhbHNlXG59XG5cblBpZWNlLkJMT0NLX0xFTkdUSCA9IEJMT0NLX0xFTkdUSFxuXG5QaWVjZS5wcm90b3R5cGUuY2h1bmtMZW5ndGggPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gaSA9PT0gdGhpcy5fY2h1bmtzIC0gMSA/IHRoaXMuX3JlbWFpbmRlciA6IEJMT0NLX0xFTkdUSFxufVxuXG5QaWVjZS5wcm90b3R5cGUuY2h1bmtMZW5ndGhSZW1haW5pbmcgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gdGhpcy5sZW5ndGggLSAoaSAqIEJMT0NLX0xFTkdUSClcbn1cblxuUGllY2UucHJvdG90eXBlLmNodW5rT2Zmc2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIGkgKiBCTE9DS19MRU5HVEhcbn1cblxuUGllY2UucHJvdG90eXBlLnJlc2VydmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pbml0KCkpIHJldHVybiAtMVxuICBpZiAodGhpcy5fY2FuY2VsbGF0aW9ucy5sZW5ndGgpIHJldHVybiB0aGlzLl9jYW5jZWxsYXRpb25zLnBvcCgpXG4gIGlmICh0aGlzLl9yZXNlcnZhdGlvbnMgPCB0aGlzLl9jaHVua3MpIHJldHVybiB0aGlzLl9yZXNlcnZhdGlvbnMrK1xuICByZXR1cm4gLTFcbn1cblxuUGllY2UucHJvdG90eXBlLnJlc2VydmVSZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pbml0KCkpIHJldHVybiAtMVxuICBpZiAodGhpcy5fcmVzZXJ2YXRpb25zIDwgdGhpcy5fY2h1bmtzKSB7XG4gICAgdmFyIG1pbiA9IHRoaXMuX3Jlc2VydmF0aW9uc1xuICAgIHRoaXMuX3Jlc2VydmF0aW9ucyA9IHRoaXMuX2NodW5rc1xuICAgIHJldHVybiBtaW5cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuUGllY2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChpKSB7XG4gIGlmICghdGhpcy5pbml0KCkpIHJldHVyblxuICB0aGlzLl9jYW5jZWxsYXRpb25zLnB1c2goaSlcbn1cblxuUGllY2UucHJvdG90eXBlLmNhbmNlbFJlbWFpbmluZyA9IGZ1bmN0aW9uIChpKSB7XG4gIGlmICghdGhpcy5pbml0KCkpIHJldHVyblxuICB0aGlzLl9yZXNlcnZhdGlvbnMgPSBpXG59XG5cblBpZWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICBpZiAoIXRoaXMuaW5pdCgpKSByZXR1cm4gbnVsbFxuICByZXR1cm4gdGhpcy5fYnVmZmVyW2ldXG59XG5cblBpZWNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaSwgZGF0YSwgc291cmNlKSB7XG4gIGlmICghdGhpcy5pbml0KCkpIHJldHVybiBmYWxzZVxuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIGJsb2NrcyA9IE1hdGguY2VpbChsZW4gLyBCTE9DS19MRU5HVEgpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tzOyBqKyspIHtcbiAgICBpZiAoIXRoaXMuX2J1ZmZlcltpICsgal0pIHtcbiAgICAgIHZhciBvZmZzZXQgPSBqICogQkxPQ0tfTEVOR1RIXG4gICAgICB2YXIgc3BsaXREYXRhID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIEJMT0NLX0xFTkdUSClcbiAgICAgIHRoaXMuX2J1ZmZlcmVkKytcbiAgICAgIHRoaXMuX2J1ZmZlcltpICsgal0gPSBzcGxpdERhdGFcbiAgICAgIHRoaXMubWlzc2luZyAtPSBzcGxpdERhdGEubGVuZ3RoXG4gICAgICBpZiAodGhpcy5zb3VyY2VzLmluZGV4T2Yoc291cmNlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VzLnB1c2goc291cmNlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5fYnVmZmVyZWQgPT09IHRoaXMuX2NodW5rc1xufVxuXG5QaWVjZS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fYnVmZmVyIHx8IHRoaXMuX2NodW5rcyAhPT0gdGhpcy5fYnVmZmVyZWQpIHJldHVybiBudWxsXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZmZlciwgdGhpcy5sZW5ndGgpXG4gIHRoaXMuX2J1ZmZlciA9IG51bGxcbiAgdGhpcy5fY2FuY2VsbGF0aW9ucyA9IG51bGxcbiAgdGhpcy5zb3VyY2VzID0gbnVsbFxuICB0aGlzLl9mbHVzaGVkID0gdHJ1ZVxuICByZXR1cm4gYnVmZmVyXG59XG5cblBpZWNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZmx1c2hlZCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0aGlzLl9idWZmZXIpIHJldHVybiB0cnVlXG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9jaHVua3MpXG4gIHRoaXMuX2NhbmNlbGxhdGlvbnMgPSBbXVxuICB0aGlzLnNvdXJjZXMgPSBbXVxuICByZXR1cm4gdHJ1ZVxufVxuIiwiLyoqXG4gKiBDb252ZXJ0IGEgdHlwZWQgYXJyYXkgdG8gYSBCdWZmZXIgd2l0aG91dCBhIGNvcHlcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgdHlwZWRhcnJheS10by1idWZmZXJgXG4gKi9cblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkYXJyYXknKS5zdHJpY3RcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0eXBlZGFycmF5VG9CdWZmZXIgKGFycikge1xuICBpZiAoaXNUeXBlZEFycmF5KGFycikpIHtcbiAgICAvLyBUbyBhdm9pZCBhIGNvcHksIHVzZSB0aGUgdHlwZWQgYXJyYXkncyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyIHRvIGJhY2sgbmV3IEJ1ZmZlclxuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGFyci5idWZmZXIpXG4gICAgaWYgKGFyci5ieXRlTGVuZ3RoICE9PSBhcnIuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIC8vIFJlc3BlY3QgdGhlIFwidmlld1wiLCBpLmUuIGJ5dGVPZmZzZXQgYW5kIGJ5dGVMZW5ndGgsIHdpdGhvdXQgZG9pbmcgYSBjb3B5XG4gICAgICBidWYgPSBidWYuc2xpY2UoYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlT2Zmc2V0ICsgYXJyLmJ5dGVMZW5ndGgpXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfSBlbHNlIHtcbiAgICAvLyBQYXNzIHRocm91Z2ggYWxsIG90aGVyIHR5cGVzIHRvIHRoZSBgQnVmZmVyYCBjb25zdHJ1Y3RvclxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFycilcbiAgfVxufVxuIiwidmFyIFVJTlRfMzJfTUFYID0gMHhmZmZmZmZmZlxuXG5leHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gOFxufVxuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW0sIGJ1Ziwgb2Zmc2V0KSB7XG4gIGlmICghYnVmKSBidWYgPSBuZXcgQnVmZmVyKDgpXG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIHRvcCA9IE1hdGguZmxvb3IobnVtIC8gVUlOVF8zMl9NQVgpXG4gIHZhciByZW0gPSBudW0gLSB0b3AgKiBVSU5UXzMyX01BWFxuXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKHRvcCwgb2Zmc2V0KVxuICBidWYud3JpdGVVSW50MzJCRShyZW0sIG9mZnNldCArIDQpXG4gIHJldHVybiBidWZcbn1cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQpIHtcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICBpZiAoIWJ1ZikgYnVmID0gbmV3IEJ1ZmZlcig0KVxuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIHZhciB0b3AgPSBidWYucmVhZFVJbnQzMkJFKG9mZnNldClcbiAgdmFyIHJlbSA9IGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgNClcblxuICByZXR1cm4gdG9wICogVUlOVF8zMl9NQVggKyByZW1cbn1cblxuZXhwb3J0cy5lbmNvZGUuYnl0ZXMgPSA4XG5leHBvcnRzLmRlY29kZS5ieXRlcyA9IDhcbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGI9bGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihjb21wYXJlKGEsIGIpKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWVfZXEobGlzdCkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYiA9IGxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2ksIGI9YSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihhICE9PSBiKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCwgY29tcGFyZSwgc29ydGVkKSB7XG4gIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICBpZihjb21wYXJlKSB7XG4gICAgaWYoIXNvcnRlZCkge1xuICAgICAgbGlzdC5zb3J0KGNvbXBhcmUpXG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKVxuICB9XG4gIGlmKCFzb3J0ZWQpIHtcbiAgICBsaXN0LnNvcnQoKVxuICB9XG4gIHJldHVybiB1bmlxdWVfZXEobGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlXG5cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpKSB7XG4gIGlmIChpID49IGFyci5sZW5ndGggfHwgaSA8IDApIHJldHVyblxuICB2YXIgbGFzdCA9IGFyci5wb3AoKVxuICBpZiAoaSA8IGFyci5sZW5ndGgpIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldXG4gICAgYXJyW2ldID0gbGFzdFxuICAgIHJldHVybiB0bXBcbiAgfVxuICByZXR1cm4gbGFzdFxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJ2YXIgYmVuY29kZSA9IHJlcXVpcmUoJ2JlbmNvZGUnKVxudmFyIEJpdEZpZWxkID0gcmVxdWlyZSgnYml0ZmllbGQnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd1dF9tZXRhZGF0YScpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2hhMSA9IHJlcXVpcmUoJ3NpbXBsZS1zaGExJylcblxudmFyIE1BWF9NRVRBREFUQV9TSVpFID0gMTAwMDAwMDAgLy8gMTBNQlxudmFyIEJJVEZJRUxEX0dST1cgPSAxMDAwXG52YXIgUElFQ0VfTEVOR1RIID0gMTYgKiAxMDI0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gIGluaGVyaXRzKHV0TWV0YWRhdGEsIEV2ZW50RW1pdHRlcilcblxuICBmdW5jdGlvbiB1dE1ldGFkYXRhICh3aXJlKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICAgIHRoaXMuX3dpcmUgPSB3aXJlXG5cbiAgICB0aGlzLl9tZXRhZGF0YUNvbXBsZXRlID0gZmFsc2VcbiAgICB0aGlzLl9tZXRhZGF0YVNpemUgPSBudWxsXG4gICAgdGhpcy5fcmVtYWluaW5nUmVqZWN0cyA9IG51bGwgLy8gaG93IG1hbnkgcmVqZWN0IG1lc3NhZ2VzIHRvIHRvbGVyYXRlIGJlZm9yZSBxdWl0dGluZ1xuICAgIHRoaXMuX2ZldGNoaW5nID0gZmFsc2VcblxuICAgIC8vIFRoZSBsYXJnZXN0IC50b3JyZW50IGZpbGUgdGhhdCBJIGtub3cgb2YgaXMgfjEtMk1CLCB3aGljaCBpcyB+MTAwIHBpZWNlcy5cbiAgICAvLyBUaGVyZWZvcmUsIGNhcCB0aGUgYml0ZmllbGQgdG8gMTB4IHRoYXQgKDEwMDAgcGllY2VzKSBzbyBhIG1hbGljaW91cyBwZWVyIGNhbid0XG4gICAgLy8gbWFrZSBpdCBncm93IHRvIGZpbGwgYWxsIG1lbW9yeS5cbiAgICB0aGlzLl9iaXRmaWVsZCA9IG5ldyBCaXRGaWVsZCgwLCB7IGdyb3c6IEJJVEZJRUxEX0dST1cgfSlcblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIobWV0YWRhdGEpKSB7XG4gICAgICB0aGlzLnNldE1ldGFkYXRhKG1ldGFkYXRhKVxuICAgIH1cbiAgfVxuXG4gIC8vIE5hbWUgb2YgdGhlIGJpdHRvcnJlbnQtcHJvdG9jb2wgZXh0ZW5zaW9uXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLm5hbWUgPSAndXRfbWV0YWRhdGEnXG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCwgZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuX2luZm9IYXNoID0gaW5mb0hhc2hcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLm9uRXh0ZW5kZWRIYW5kc2hha2UgPSBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgaWYgKCFoYW5kc2hha2UubSB8fCAhaGFuZHNoYWtlLm0udXRfbWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BlZXIgZG9lcyBub3Qgc3VwcG9ydCB1dF9tZXRhZGF0YScpKVxuICAgIH1cbiAgICBpZiAoIWhhbmRzaGFrZS5tZXRhZGF0YV9zaXplKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIGRvZXMgbm90IGhhdmUgbWV0YWRhdGEnKSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kc2hha2UubWV0YWRhdGFfc2l6ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgTUFYX01FVEFEQVRBX1NJWkUgPCBoYW5kc2hha2UubWV0YWRhdGFfc2l6ZSB8fFxuICAgICAgICBoYW5kc2hha2UubWV0YWRhdGFfc2l6ZSA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIGdhdmUgaW52YWxpZCBtZXRhZGF0YSBzaXplJykpXG4gICAgfVxuXG4gICAgdGhpcy5fbWV0YWRhdGFTaXplID0gaGFuZHNoYWtlLm1ldGFkYXRhX3NpemVcbiAgICB0aGlzLl9udW1QaWVjZXMgPSBNYXRoLmNlaWwodGhpcy5fbWV0YWRhdGFTaXplIC8gUElFQ0VfTEVOR1RIKVxuICAgIHRoaXMuX3JlbWFpbmluZ1JlamVjdHMgPSB0aGlzLl9udW1QaWVjZXMgKiAyXG5cbiAgICBpZiAodGhpcy5fZmV0Y2hpbmcpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RQaWVjZXMoKVxuICAgIH1cbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICB2YXIgZGljdCwgdHJhaWxlclxuICAgIHRyeSB7XG4gICAgICB2YXIgc3RyID0gYnVmLnRvU3RyaW5nKClcbiAgICAgIHZhciB0cmFpbGVySW5kZXggPSBzdHIuaW5kZXhPZignZWUnKSArIDJcbiAgICAgIGRpY3QgPSBiZW5jb2RlLmRlY29kZShzdHIuc3Vic3RyaW5nKDAsIHRyYWlsZXJJbmRleCkpXG4gICAgICB0cmFpbGVyID0gYnVmLnNsaWNlKHRyYWlsZXJJbmRleClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGRyb3AgaW52YWxpZCBtZXNzYWdlc1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3dpdGNoIChkaWN0Lm1zZ190eXBlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIHV0X21ldGFkYXRhIHJlcXVlc3QgKGZyb20gcGVlcilcbiAgICAgICAgLy8gZXhhbXBsZTogeyAnbXNnX3R5cGUnOiAwLCAncGllY2UnOiAwIH1cbiAgICAgICAgdGhpcy5fb25SZXF1ZXN0KGRpY3QucGllY2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHV0X21ldGFkYXRhIGRhdGEgKGluIHJlc3BvbnNlIHRvIG91ciByZXF1ZXN0KVxuICAgICAgICAvLyBleGFtcGxlOiB7ICdtc2dfdHlwZSc6IDEsICdwaWVjZSc6IDAsICd0b3RhbF9zaXplJzogMzQyNSB9XG4gICAgICAgIHRoaXMuX29uRGF0YShkaWN0LnBpZWNlLCB0cmFpbGVyLCBkaWN0LnRvdGFsX3NpemUpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIHV0X21ldGFkYXRhIHJlamVjdCAocGVlciBkb2Vzbid0IGhhdmUgcGllY2Ugd2UgcmVxdWVzdGVkKVxuICAgICAgICAvLyB7ICdtc2dfdHlwZSc6IDIsICdwaWVjZSc6IDAgfVxuICAgICAgICB0aGlzLl9vblJlamVjdChkaWN0LnBpZWNlKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc2sgdGhlIHBlZXIgdG8gc2VuZCBtZXRhZGF0YS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX21ldGFkYXRhQ29tcGxldGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLl9mZXRjaGluZyA9IHRydWVcbiAgICBpZiAodGhpcy5fbWV0YWRhdGFTaXplKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0UGllY2VzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhc2tpbmcgdGhlIHBlZXIgdG8gc2VuZCBtZXRhZGF0YS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZldGNoaW5nID0gZmFsc2VcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLnNldE1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgaWYgKHRoaXMuX21ldGFkYXRhQ29tcGxldGUpIHJldHVybiB0cnVlXG4gICAgZGVidWcoJ3NldCBtZXRhZGF0YScpXG5cbiAgICAvLyBpZiBmdWxsIHRvcnJlbnQgZGljdGlvbmFyeSB3YXMgcGFzc2VkIGluLCBwdWxsIG91dCBqdXN0IGBpbmZvYCBrZXlcbiAgICB0cnkge1xuICAgICAgdmFyIGluZm8gPSBiZW5jb2RlLmRlY29kZShtZXRhZGF0YSkuaW5mb1xuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgbWV0YWRhdGEgPSBiZW5jb2RlLmVuY29kZShpbmZvKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIC8vIGNoZWNrIGhhc2hcbiAgICBpZiAodGhpcy5faW5mb0hhc2ggJiYgdGhpcy5faW5mb0hhc2ggIT09IHNoYTEuc3luYyhtZXRhZGF0YSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuY2FuY2VsKClcblxuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YVxuICAgIHRoaXMuX21ldGFkYXRhQ29tcGxldGUgPSB0cnVlXG4gICAgdGhpcy5fbWV0YWRhdGFTaXplID0gdGhpcy5tZXRhZGF0YS5sZW5ndGhcbiAgICB0aGlzLl93aXJlLmV4dGVuZGVkSGFuZHNoYWtlLm1ldGFkYXRhX3NpemUgPSB0aGlzLl9tZXRhZGF0YVNpemVcblxuICAgIHRoaXMuZW1pdCgnbWV0YWRhdGEnLCBiZW5jb2RlLmVuY29kZSh7IGluZm86IGJlbmNvZGUuZGVjb2RlKHRoaXMubWV0YWRhdGEpIH0pKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24gKGRpY3QsIHRyYWlsZXIpIHtcbiAgICB2YXIgYnVmID0gYmVuY29kZS5lbmNvZGUoZGljdClcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHRyYWlsZXIpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHRyYWlsZXJdKVxuICAgIH1cbiAgICB0aGlzLl93aXJlLmV4dGVuZGVkKCd1dF9tZXRhZGF0YScsIGJ1ZilcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgdGhpcy5fc2VuZCh7IG1zZ190eXBlOiAwLCBwaWVjZTogcGllY2UgfSlcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9kYXRhID0gZnVuY3Rpb24gKHBpZWNlLCBidWYsIHRvdGFsU2l6ZSkge1xuICAgIHZhciBtc2cgPSB7IG1zZ190eXBlOiAxLCBwaWVjZTogcGllY2UgfVxuICAgIGlmICh0eXBlb2YgdG90YWxTaXplID09PSAnbnVtYmVyJykge1xuICAgICAgbXNnLnRvdGFsX3NpemUgPSB0b3RhbFNpemVcbiAgICB9XG4gICAgdGhpcy5fc2VuZChtc2csIGJ1ZilcbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9yZWplY3QgPSBmdW5jdGlvbiAocGllY2UpIHtcbiAgICB0aGlzLl9zZW5kKHsgbXNnX3R5cGU6IDIsIHBpZWNlOiBwaWVjZSB9KVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX29uUmVxdWVzdCA9IGZ1bmN0aW9uIChwaWVjZSkge1xuICAgIGlmICghdGhpcy5fbWV0YWRhdGFDb21wbGV0ZSkge1xuICAgICAgdGhpcy5fcmVqZWN0KHBpZWNlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzdGFydCA9IHBpZWNlICogUElFQ0VfTEVOR1RIXG4gICAgdmFyIGVuZCA9IHN0YXJ0ICsgUElFQ0VfTEVOR1RIXG4gICAgaWYgKGVuZCA+IHRoaXMuX21ldGFkYXRhU2l6ZSkge1xuICAgICAgZW5kID0gdGhpcy5fbWV0YWRhdGFTaXplXG4gICAgfVxuICAgIHZhciBidWYgPSB0aGlzLm1ldGFkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgdGhpcy5fZGF0YShwaWVjZSwgYnVmLCB0aGlzLl9tZXRhZGF0YVNpemUpXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fb25EYXRhID0gZnVuY3Rpb24gKHBpZWNlLCBidWYsIHRvdGFsU2l6ZSkge1xuICAgIGlmIChidWYubGVuZ3RoID4gUElFQ0VfTEVOR1RIKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYnVmLmNvcHkodGhpcy5tZXRhZGF0YSwgcGllY2UgKiBQSUVDRV9MRU5HVEgpXG4gICAgdGhpcy5fYml0ZmllbGQuc2V0KHBpZWNlKVxuICAgIHRoaXMuX2NoZWNrRG9uZSgpXG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fb25SZWplY3QgPSBmdW5jdGlvbiAocGllY2UpIHtcbiAgICBpZiAodGhpcy5fcmVtYWluaW5nUmVqZWN0cyA+IDAgJiYgdGhpcy5fZmV0Y2hpbmcpIHtcbiAgICAgIC8vIElmIHdlIGhhdmVuJ3QgYmVlbiByZWplY3RlZCB0b28gbXVjaCwgdGhlbiB0cnkgdG8gcmVxdWVzdCB0aGUgcGllY2UgYWdhaW5cbiAgICAgIHRoaXMuX3JlcXVlc3QocGllY2UpXG4gICAgICB0aGlzLl9yZW1haW5pbmdSZWplY3RzIC09IDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCd3YXJuaW5nJywgbmV3IEVycm9yKCdQZWVyIHNlbnQgXCJyZWplY3RcIiB0b28gbXVjaCcpKVxuICAgIH1cbiAgfVxuXG4gIHV0TWV0YWRhdGEucHJvdG90eXBlLl9yZXF1ZXN0UGllY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubWV0YWRhdGEgPSBCdWZmZXIuYWxsb2ModGhpcy5fbWV0YWRhdGFTaXplKVxuICAgIGZvciAodmFyIHBpZWNlID0gMDsgcGllY2UgPCB0aGlzLl9udW1QaWVjZXM7IHBpZWNlKyspIHtcbiAgICAgIHRoaXMuX3JlcXVlc3QocGllY2UpXG4gICAgfVxuICB9XG5cbiAgdXRNZXRhZGF0YS5wcm90b3R5cGUuX2NoZWNrRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9uZSA9IHRydWVcbiAgICBmb3IgKHZhciBwaWVjZSA9IDA7IHBpZWNlIDwgdGhpcy5fbnVtUGllY2VzOyBwaWVjZSsrKSB7XG4gICAgICBpZiAoIXRoaXMuX2JpdGZpZWxkLmdldChwaWVjZSkpIHtcbiAgICAgICAgZG9uZSA9IGZhbHNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZG9uZSkgcmV0dXJuXG5cbiAgICAvLyBhdHRlbXB0IHRvIHNldCBtZXRhZGF0YSAtLSBtYXkgZmFpbCBzaGExIGNoZWNrXG4gICAgdmFyIHN1Y2Nlc3MgPSB0aGlzLnNldE1ldGFkYXRhKHRoaXMubWV0YWRhdGEpXG5cbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX2ZhaWxlZE1ldGFkYXRhKClcbiAgICB9XG4gIH1cblxuICB1dE1ldGFkYXRhLnByb3RvdHlwZS5fZmFpbGVkTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVzZXQgYml0ZmllbGQgJiB0cnkgYWdhaW5cbiAgICB0aGlzLl9iaXRmaWVsZCA9IG5ldyBCaXRGaWVsZCgwLCB7IGdyb3c6IEJJVEZJRUxEX0dST1cgfSlcbiAgICB0aGlzLl9yZW1haW5pbmdSZWplY3RzIC09IHRoaXMuX251bVBpZWNlc1xuICAgIGlmICh0aGlzLl9yZW1haW5pbmdSZWplY3RzID4gMCkge1xuICAgICAgdGhpcy5fcmVxdWVzdFBpZWNlcygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnd2FybmluZycsIG5ldyBFcnJvcignUGVlciBzZW50IGludmFsaWQgbWV0YWRhdGEnKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXRNZXRhZGF0YVxufVxuIiwiLyoganNoaW50IGNhbWVsY2FzZTogZmFsc2UgKi9cblxuLy8gVE9ETzogaXB2NiBzdXBwb3J0XG4vLyBUT0RPOiBwYXJzZSBhbmQgc2VuZCBwZWVyIGZsYWdzIChjdXJyZW50bHkgdW51c2VkKVxuLy8gTk9URTogYWRkUGVlciBzaG91bGQgdGFrZSBpbiBhbiBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQsIGZsYWdzXG4vLyBUT0RPOiBkZXN0cm95IHdpcmUgaWYgcGVlciBzZW5kcyBQRVggbWVzc2FnZXMgdG9vIGZyZXF1ZW50bHlcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGNvbXBhY3Qyc3RyaW5nID0gcmVxdWlyZSgnY29tcGFjdDJzdHJpbmcnKVxudmFyIHN0cmluZzJjb21wYWN0ID0gcmVxdWlyZSgnc3RyaW5nMmNvbXBhY3QnKVxudmFyIGJlbmNvZGUgPSByZXF1aXJlKCdiZW5jb2RlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxudmFyIFBFWF9JTlRFUlZBTCA9IDY1MDAwIC8vIGp1c3Qgb3ZlciBvbmUgbWludXRlXG52YXIgUEVYX01BWF9QRUVSUyA9IDUwICAgIC8vIG1heCBudW1iZXIgb2YgcGVlcnMgdG8gYWR2ZXJ0aXNlIHBlciBQRVggbWVzc2FnZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgaW5oZXJpdHModXRfcGV4LCBFdmVudEVtaXR0ZXIpXG5cbiAgZnVuY3Rpb24gdXRfcGV4ICh3aXJlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcblxuICAgIHNlbGYuX3dpcmUgPSB3aXJlXG4gICAgc2VsZi5faW50ZXJ2YWxJZCA9IG51bGxcblxuICAgIHNlbGYucmVzZXQoKVxuICB9XG5cbiAgdXRfcGV4LnByb3RvdHlwZS5uYW1lID0gJ3V0X3BleCdcblxuICAvKipcbiAgICogU3RhcnQgc2VuZGluZyByZWd1bGFyIFBFWCB1cGRhdGVzIHRvIHJlbW90ZSBwZWVyLlxuICAgKi9cbiAgdXRfcGV4LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsSWQpXG4gICAgc2VsZi5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHNlbGYuX3NlbmRNZXNzYWdlLmJpbmQoc2VsZiksIFBFWF9JTlRFUlZBTClcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWxJZC51bnJlZikgc2VsZi5faW50ZXJ2YWxJZC51bnJlZigpXG4gIH1cblxuICAvKipcbiAgICogU3RvcCBzZW5kaW5nIFBFWCB1cGRhdGVzIHRvIHRoZSByZW1vdGUgcGVlci5cbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsSWQpXG4gICAgc2VsZi5faW50ZXJ2YWxJZCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBzZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIHJlbW90ZSBwZWVyIGFuZCByZXNldHMgaW50ZXJuYWwgc3RhdGUgb2YgcGVlcnMgc2Vlbi5cbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgc2VsZi5fcmVtb3RlQWRkZWRQZWVycyA9IHt9XG4gICAgc2VsZi5fcmVtb3RlRHJvcHBlZFBlZXJzID0ge31cbiAgICBzZWxmLl9sb2NhbEFkZGVkUGVlcnMgPSB7fVxuICAgIHNlbGYuX2xvY2FsRHJvcHBlZFBlZXJzID0ge31cbiAgICBzZWxmLnN0b3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwZWVyIHRvIHRoZSBsb2NhbGx5IGRpc2NvdmVyZWQgcGVlciBsaXN0IGZvciB0aGUgbmV4dCBQRVggbWVzc2FnZS5cbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUuYWRkUGVlciA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgaWYgKHBlZXIuaW5kZXhPZignOicpIDwgMCkgcmV0dXJuIC8vIGRpc3JlZ2FyZCBpbnZhbGlkIHBlZXJzXG4gICAgaWYgKHBlZXIgaW4gc2VsZi5fcmVtb3RlQWRkZWRQZWVycykgcmV0dXJuIC8vIG5ldmVyIGFkdmVydGlzZSBwZWVyIHRoZSByZW1vdGUgd2lyZSBhbHJlYWR5IHNlbnQgdXNcbiAgICBpZiAocGVlciBpbiBzZWxmLl9sb2NhbERyb3BwZWRQZWVycykgZGVsZXRlIHNlbGYuX2xvY2FsRHJvcHBlZFBlZXJzW3BlZXJdXG4gICAgc2VsZi5fbG9jYWxBZGRlZFBlZXJzW3BlZXJdID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwZWVyIHRvIHRoZSBsb2NhbGx5IGRyb3BwZWQgcGVlciBsaXN0IGZvciB0aGUgbmV4dCBQRVggbWVzc2FnZS5cbiAgICovXG4gIHV0X3BleC5wcm90b3R5cGUuZHJvcFBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGlmIChwZWVyLmluZGV4T2YoJzonKSA8IDApIHJldHVybiAvLyBkaXNyZWdhcmQgaW52YWxpZCBwZWVyc1xuICAgIGlmIChwZWVyIGluIHNlbGYuX3JlbW90ZURyb3BwZWRQZWVycykgcmV0dXJuIC8vIG5ldmVyIGFkdmVydGlzZSBwZWVyIHRoZSByZW1vdGUgd2lyZSBhbHJlYWR5IHNlbnQgdXNcbiAgICBpZiAocGVlciBpbiBzZWxmLl9sb2NhbEFkZGVkUGVlcnMpIGRlbGV0ZSBzZWxmLl9sb2NhbEFkZGVkUGVlcnNbcGVlcl1cbiAgICBzZWxmLl9sb2NhbERyb3BwZWRQZWVyc1twZWVyXSA9IHRydWVcbiAgfVxuXG4gIHV0X3BleC5wcm90b3R5cGUub25FeHRlbmRlZEhhbmRzaGFrZSA9IGZ1bmN0aW9uIChoYW5kc2hha2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoIWhhbmRzaGFrZS5tIHx8ICFoYW5kc2hha2UubS51dF9wZXgpIHtcbiAgICAgIHJldHVybiBzZWxmLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BlZXIgZG9lcyBub3Qgc3VwcG9ydCB1dF9wZXgnKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUEVYIG1lc3NhZ2VzIGFyZSBiZW5jb2RlZCBkaWN0aW9uYXJpZXMgd2l0aCB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAqICdhZGRlZCcgICAgIDogYXJyYXkgb2YgcGVlcnMgbWV0IHNpbmNlIGxhc3QgUEVYIG1lc3NhZ2VcbiAgICogJ2FkZGVkLmYnICAgOiBhcnJheSBvZiBmbGFncyBwZXIgcGVlclxuICAgKiAgJzB4MDEnICAgICA6IHBlZXIgcHJlZmVycyBlbmNyeXB0aW9uXG4gICAqICAnMHgwMicgICAgIDogcGVlciBpcyBzZWVkZXJcbiAgICogJ2Ryb3BwZWQnICAgOiBhcnJheSBvZiBwZWVycyBsb2NhbGx5IGRyb3BwZWQgZnJvbSBzd2FybSBzaW5jZSBsYXN0IFBFWCBtZXNzYWdlXG4gICAqICdhZGRlZDYnICAgIDogaXB2NiB2ZXJzaW9uIG9mICdhZGRlZCdcbiAgICogJ2FkZGVkNi5mJyAgOiBpcHY2IHZlcnNpb24gb2YgJ2FkZGVkLmYnXG4gICAqICdkcm9wcGVkLmYnIDogaXB2NiB2ZXJzaW9uIG9mICdkcm9wcGVkJ1xuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIGJlbmNvZGVkIFBFWCBkaWN0aW9uYXJ5XG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB2YXIgbWVzc2FnZVxuXG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2UgPSBiZW5jb2RlLmRlY29kZShidWYpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBkcm9wIGludmFsaWQgbWVzc2FnZXNcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLmFkZGVkKSB7XG4gICAgICBjb21wYWN0MnN0cmluZy5tdWx0aShtZXNzYWdlLmFkZGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl9yZW1vdGVEcm9wcGVkUGVlcnNbcGVlcl1cbiAgICAgICAgaWYgKCEocGVlciBpbiBzZWxmLl9yZW1vdGVBZGRlZFBlZXJzKSkge1xuICAgICAgICAgIHNlbGYuX3JlbW90ZUFkZGVkUGVlcnNbcGVlcl0gPSB0cnVlXG4gICAgICAgICAgc2VsZi5lbWl0KCdwZWVyJywgcGVlcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS5kcm9wcGVkKSB7XG4gICAgICBjb21wYWN0MnN0cmluZy5tdWx0aShtZXNzYWdlLmRyb3BwZWQpLmZvckVhY2goZnVuY3Rpb24gKHBlZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGYuX3JlbW90ZUFkZGVkUGVlcnNbcGVlcl1cbiAgICAgICAgaWYgKCEocGVlciBpbiBzZWxmLl9yZW1vdGVEcm9wcGVkUGVlcnMpKSB7XG4gICAgICAgICAgc2VsZi5fcmVtb3RlRHJvcHBlZFBlZXJzW3BlZXJdID0gdHJ1ZVxuICAgICAgICAgIHNlbGYuZW1pdCgnZHJvcHBlZCcsIHBlZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgUEVYIG1lc3NhZ2UgdG8gdGhlIHJlbW90ZSBwZWVyIGluY2x1ZGluZyBpbmZvcm1hdGlvbiBhYm91dCBhbnkgbG9jYWxseVxuICAgKiBhZGRlZCAvIGRyb3BwZWQgcGVlcnMuXG4gICAqL1xuICB1dF9wZXgucHJvdG90eXBlLl9zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIHZhciBsb2NhbEFkZGVkID0gT2JqZWN0LmtleXMoc2VsZi5fbG9jYWxBZGRlZFBlZXJzKS5zbGljZSgwLCBQRVhfTUFYX1BFRVJTKVxuICAgIHZhciBsb2NhbERyb3BwZWQgPSBPYmplY3Qua2V5cyhzZWxmLl9sb2NhbERyb3BwZWRQZWVycykuc2xpY2UoMCwgUEVYX01BWF9QRUVSUylcblxuICAgIHZhciBhZGRlZCA9IEJ1ZmZlci5jb25jYXQobG9jYWxBZGRlZC5tYXAoc3RyaW5nMmNvbXBhY3QpKVxuICAgIHZhciBkcm9wcGVkID0gQnVmZmVyLmNvbmNhdChsb2NhbERyb3BwZWQubWFwKHN0cmluZzJjb21wYWN0KSlcblxuICAgIHZhciBhZGRlZEZsYWdzID0gQnVmZmVyLmNvbmNhdChsb2NhbEFkZGVkLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGZsYWdzXG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcihbMF0pXG4gICAgfSkpXG5cbiAgICAvLyB1cGRhdGUgbG9jYWwgZGVsdGFzXG4gICAgbG9jYWxBZGRlZC5mb3JFYWNoKGZ1bmN0aW9uIChwZWVyKSB7IGRlbGV0ZSBzZWxmLl9sb2NhbEFkZGVkUGVlcnNbcGVlcl0gfSlcbiAgICBsb2NhbERyb3BwZWQuZm9yRWFjaChmdW5jdGlvbiAocGVlcikgeyBkZWxldGUgc2VsZi5fbG9jYWxEcm9wcGVkUGVlcnNbcGVlcl0gfSlcblxuICAgIC8vIHNlbmQgUEVYIG1lc3NhZ2VcbiAgICBzZWxmLl93aXJlLmV4dGVuZGVkKCd1dF9wZXgnLCB7XG4gICAgICAnYWRkZWQnOiBhZGRlZCxcbiAgICAgICdhZGRlZC5mJzogYWRkZWRGbGFncyxcbiAgICAgICdkcm9wcGVkJzogZHJvcHBlZCxcbiAgICAgICdhZGRlZDYnOiBuZXcgQnVmZmVyKDApLFxuICAgICAgJ2FkZGVkNi5mJzogbmV3IEJ1ZmZlcigwKSxcbiAgICAgICdkcm9wcGVkNic6IG5ldyBCdWZmZXIoMClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHV0X3BleFxufVxuIiwidmFyIERpY3QgPSByZXF1aXJlKFwiLi9kaWN0XCIpXG5cbi8qKlxuICogRGVjb2RlcyBiZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcn0gZGF0YVxuICogQHBhcmFtICB7TnVtYmVyfSBzdGFydCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZCAob3B0aW9uYWwpXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGVuY29kaW5nIChvcHRpb25hbClcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheXxCdWZmZXJ8U3RyaW5nfE51bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKCBkYXRhLCBzdGFydCwgZW5kLCBlbmNvZGluZyApIHtcbiAgXG4gIGlmKCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInICYmIGVuY29kaW5nID09IG51bGwgKSB7XG4gICAgZW5jb2RpbmcgPSBzdGFydFxuICAgIHN0YXJ0ID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGlmKCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyAmJiBlbmNvZGluZyA9PSBudWxsICkge1xuICAgIGVuY29kaW5nID0gZW5kXG4gICAgZW5kID0gdW5kZWZpbmVkXG4gIH1cbiAgXG4gIGRlY29kZS5wb3NpdGlvbiA9IDBcbiAgZGVjb2RlLmVuY29kaW5nID0gZW5jb2RpbmcgfHwgbnVsbFxuXG4gIGRlY29kZS5kYXRhID0gISggQnVmZmVyLmlzQnVmZmVyKGRhdGEpIClcbiAgICA/IG5ldyBCdWZmZXIoIGRhdGEgKVxuICAgIDogZGF0YS5zbGljZSggc3RhcnQsIGVuZCApXG4gIFxuICBkZWNvZGUuYnl0ZXMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgXG4gIHJldHVybiBkZWNvZGUubmV4dCgpXG5cbn1cblxuZGVjb2RlLmJ5dGVzID0gMFxuZGVjb2RlLnBvc2l0aW9uID0gMFxuZGVjb2RlLmRhdGEgICAgID0gbnVsbFxuZGVjb2RlLmVuY29kaW5nID0gbnVsbFxuXG5kZWNvZGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuXG4gIHN3aXRjaCggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSApIHtcbiAgICBjYXNlIDB4NjQ6IHJldHVybiBkZWNvZGUuZGljdGlvbmFyeSgpOyBicmVha1xuICAgIGNhc2UgMHg2QzogcmV0dXJuIGRlY29kZS5saXN0KCk7IGJyZWFrXG4gICAgY2FzZSAweDY5OiByZXR1cm4gZGVjb2RlLmludGVnZXIoKTsgYnJlYWtcbiAgICBkZWZhdWx0OiAgIHJldHVybiBkZWNvZGUuYnVmZmVyKCk7IGJyZWFrXG4gIH1cblxufVxuXG5kZWNvZGUuZmluZCA9IGZ1bmN0aW9uKCBjaHIgKSB7XG5cbiAgdmFyIGkgPSBkZWNvZGUucG9zaXRpb25cbiAgdmFyIGMgPSBkZWNvZGUuZGF0YS5sZW5ndGhcbiAgdmFyIGQgPSBkZWNvZGUuZGF0YVxuXG4gIHdoaWxlKCBpIDwgYyApIHtcbiAgICBpZiggZFtpXSA9PT0gY2hyIClcbiAgICAgIHJldHVybiBpXG4gICAgaSsrXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0ludmFsaWQgZGF0YTogTWlzc2luZyBkZWxpbWl0ZXIgXCInICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBjaHIgKSArICdcIiBbMHgnICtcbiAgICBjaHIudG9TdHJpbmcoIDE2ICkgKyAnXSdcbiAgKVxuXG59XG5cbmRlY29kZS5kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgZGVjb2RlLnBvc2l0aW9uKytcblxuICB2YXIgZGljdCA9IG5ldyBEaWN0KClcblxuICB3aGlsZSggZGVjb2RlLmRhdGFbZGVjb2RlLnBvc2l0aW9uXSAhPT0gMHg2NSApIHtcbiAgICBkaWN0LmJpbmFyeVNldChkZWNvZGUuYnVmZmVyKCksIGRlY29kZS5uZXh0KCkpXG4gIH1cblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHJldHVybiBkaWN0XG5cbn1cblxuZGVjb2RlLmxpc3QgPSBmdW5jdGlvbigpIHtcblxuICBkZWNvZGUucG9zaXRpb24rK1xuXG4gIHZhciBsc3QgPSBbXVxuXG4gIHdoaWxlKCBkZWNvZGUuZGF0YVtkZWNvZGUucG9zaXRpb25dICE9PSAweDY1ICkge1xuICAgIGxzdC5wdXNoKCBkZWNvZGUubmV4dCgpIClcbiAgfVxuXG4gIGRlY29kZS5wb3NpdGlvbisrXG5cbiAgcmV0dXJuIGxzdFxuXG59XG5cbmRlY29kZS5pbnRlZ2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGVuZCAgICA9IGRlY29kZS5maW5kKCAweDY1IClcbiAgdmFyIG51bWJlciA9IGRlY29kZS5kYXRhLnRvU3RyaW5nKCAnYXNjaWknLCBkZWNvZGUucG9zaXRpb24gKyAxLCBlbmQgKVxuXG4gIGRlY29kZS5wb3NpdGlvbiArPSBlbmQgKyAxIC0gZGVjb2RlLnBvc2l0aW9uXG5cbiAgcmV0dXJuIHBhcnNlSW50KCBudW1iZXIsIDEwIClcblxufVxuXG5kZWNvZGUuYnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNlcCAgICA9IGRlY29kZS5maW5kKCAweDNBIClcbiAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KCBkZWNvZGUuZGF0YS50b1N0cmluZyggJ2FzY2lpJywgZGVjb2RlLnBvc2l0aW9uLCBzZXAgKSwgMTAgKVxuICB2YXIgZW5kICAgID0gKytzZXAgKyBsZW5ndGhcblxuICBkZWNvZGUucG9zaXRpb24gPSBlbmRcblxuICByZXR1cm4gZGVjb2RlLmVuY29kaW5nXG4gICAgPyBkZWNvZGUuZGF0YS50b1N0cmluZyggZGVjb2RlLmVuY29kaW5nLCBzZXAsIGVuZCApXG4gICAgOiBkZWNvZGUuZGF0YS5zbGljZSggc2VwLCBlbmQgKVxuXG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlXG4iLCIvKipcbiAqIEVuY29kZXMgZGF0YSBpbiBiZW5jb2RlLlxuICpcbiAqIEBwYXJhbSAge0J1ZmZlcnxBcnJheXxTdHJpbmd8T2JqZWN0fE51bWJlcnxCb29sZWFufSBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZSggZGF0YSwgYnVmZmVyLCBvZmZzZXQgKSB7XG4gIFxuICB2YXIgYnVmZmVycyA9IFtdXG4gIHZhciByZXN1bHQgPSBudWxsXG4gIFxuICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YSApXG4gIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoIGJ1ZmZlcnMgKVxuICBlbmNvZGUuYnl0ZXMgPSByZXN1bHQubGVuZ3RoXG4gIFxuICBpZiggQnVmZmVyLmlzQnVmZmVyKCBidWZmZXIgKSApIHtcbiAgICByZXN1bHQuY29weSggYnVmZmVyLCBvZmZzZXQgKVxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdFxuICBcbn1cblxuZW5jb2RlLmJ5dGVzID0gLTFcbmVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgPSBmYWxzZVxuXG5lbmNvZGUuX2VuY29kZSA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGlmKCBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgKSB7XG4gICAgYnVmZmVycy5wdXNoKG5ldyBCdWZmZXIoZGF0YS5sZW5ndGggKyAnOicpKVxuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCggdHlwZW9mIGRhdGEgKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGVuY29kZS5idWZmZXIoIGJ1ZmZlcnMsIGRhdGEgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBkYXRhLmNvbnN0cnVjdG9yID09PSBBcnJheVxuICAgICAgICA/IGVuY29kZS5saXN0KCBidWZmZXJzLCBkYXRhIClcbiAgICAgICAgOiBlbmNvZGUuZGljdCggYnVmZmVycywgZGF0YSApXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgZW5jb2RlLm51bWJlciggYnVmZmVycywgZGF0YSA/IDEgOiAwIClcbiAgICAgIGJyZWFrXG4gIH1cblxufVxuXG52YXIgYnVmZl9lID0gbmV3IEJ1ZmZlcignZScpXG4gICwgYnVmZl9kID0gbmV3IEJ1ZmZlcignZCcpXG4gICwgYnVmZl9sID0gbmV3IEJ1ZmZlcignbCcpXG5cbmVuY29kZS5idWZmZXIgPSBmdW5jdGlvbiggYnVmZmVycywgZGF0YSApIHtcblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoQnVmZmVyLmJ5dGVMZW5ndGgoIGRhdGEgKSArICc6JyArIGRhdGEpIClcbn1cblxuZW5jb2RlLm51bWJlciA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuICB2YXIgbWF4TG8gPSAweDgwMDAwMDAwXG4gIHZhciBoaSA9ICggZGF0YSAvIG1heExvICkgPDwgMFxuICB2YXIgbG8gPSAoIGRhdGEgJSBtYXhMbyAgKSA8PCAwXG4gIHZhciB2YWwgPSBoaSAqIG1heExvICsgbG9cblxuICBidWZmZXJzLnB1c2goIG5ldyBCdWZmZXIoICdpJyArIHZhbCArICdlJyApKVxuXG4gIGlmKCB2YWwgIT09IGRhdGEgJiYgIWVuY29kZS5fZmxvYXRDb252ZXJzaW9uRGV0ZWN0ZWQgKSB7XG4gICAgZW5jb2RlLl9mbG9hdENvbnZlcnNpb25EZXRlY3RlZCA9IHRydWVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV0FSTklORzogUG9zc2libGUgZGF0YSBjb3JydXB0aW9uIGRldGVjdGVkIHdpdGggdmFsdWUgXCInK2RhdGErJ1wiOicsXG4gICAgICAnQmVuY29kaW5nIG9ubHkgZGVmaW5lcyBzdXBwb3J0IGZvciBpbnRlZ2VycywgdmFsdWUgd2FzIGNvbnZlcnRlZCB0byBcIicrdmFsKydcIidcbiAgICApXG4gICAgY29uc29sZS50cmFjZSgpXG4gIH1cblxufVxuXG5lbmNvZGUuZGljdCA9IGZ1bmN0aW9uKCBidWZmZXJzLCBkYXRhICkge1xuXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9kIClcblxuICB2YXIgaiA9IDBcbiAgdmFyIGtcbiAgLy8gZml4IGZvciBpc3N1ZSAjMTMgLSBzb3J0ZWQgZGljdHNcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZGF0YSApLnNvcnQoKVxuICB2YXIga2wgPSBrZXlzLmxlbmd0aFxuXG4gIGZvciggOyBqIDwga2wgOyBqKyspIHtcbiAgICBrPWtleXNbal1cbiAgICBlbmNvZGUuYnVmZmVyKCBidWZmZXJzLCBrIClcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtrXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG59XG5cbmVuY29kZS5saXN0ID0gZnVuY3Rpb24oIGJ1ZmZlcnMsIGRhdGEgKSB7XG5cbiAgdmFyIGkgPSAwLCBqID0gMVxuICB2YXIgYyA9IGRhdGEubGVuZ3RoXG4gIGJ1ZmZlcnMucHVzaCggYnVmZl9sIClcblxuICBmb3IoIDsgaSA8IGM7IGkrKyApIHtcbiAgICBlbmNvZGUuX2VuY29kZSggYnVmZmVycywgZGF0YVtpXSApXG4gIH1cblxuICBidWZmZXJzLnB1c2goIGJ1ZmZfZSApXG5cbn1cblxuLy8gRXhwb3NlXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsInZhciBicyA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gnKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1wNCA9IHJlcXVpcmUoJ21wNC1zdHJlYW0nKVxudmFyIEJveCA9IHJlcXVpcmUoJ21wNC1ib3gtZW5jb2RpbmcnKVxudmFyIFJhbmdlU2xpY2VTdHJlYW0gPSByZXF1aXJlKCdyYW5nZS1zbGljZS1zdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1QNFJlbXV4ZXJcblxuZnVuY3Rpb24gTVA0UmVtdXhlciAoZmlsZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0RXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcblx0c2VsZi5fdHJhY2tzID0gW11cblx0c2VsZi5fZnJhZ21lbnRTZXF1ZW5jZSA9IDFcblx0c2VsZi5fZmlsZSA9IGZpbGVcblx0c2VsZi5fZGVjb2RlciA9IG51bGxcblx0c2VsZi5fZmluZE1vb3YoMClcbn1cblxuaW5oZXJpdHMoTVA0UmVtdXhlciwgRXZlbnRFbWl0dGVyKVxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5fZmluZE1vb3YgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZWNvZGVyKSB7XG5cdFx0c2VsZi5fZGVjb2Rlci5kZXN0cm95KClcblx0fVxuXG5cdHNlbGYuX2RlY29kZXIgPSBtcDQuZGVjb2RlKClcblx0dmFyIGZpbGVTdHJlYW0gPSBzZWxmLl9maWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1xuXHRcdHN0YXJ0OiBvZmZzZXRcblx0fSlcblx0ZmlsZVN0cmVhbS5waXBlKHNlbGYuX2RlY29kZXIpXG5cblx0c2VsZi5fZGVjb2Rlci5vbmNlKCdib3gnLCBmdW5jdGlvbiAoaGVhZGVycykge1xuXHRcdGlmIChoZWFkZXJzLnR5cGUgPT09ICdtb292Jykge1xuXHRcdFx0c2VsZi5fZGVjb2Rlci5kZWNvZGUoZnVuY3Rpb24gKG1vb3YpIHtcblx0XHRcdFx0ZmlsZVN0cmVhbS5kZXN0cm95KClcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzZWxmLl9wcm9jZXNzTW9vdihtb292KVxuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRlcnIubWVzc2FnZSA9ICdDYW5ub3QgcGFyc2UgbXA0IGZpbGU6ICcgKyBlcnIubWVzc2FnZVxuXHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZpbGVTdHJlYW0uZGVzdHJveSgpXG5cdFx0XHRzZWxmLl9maW5kTW9vdihvZmZzZXQgKyBoZWFkZXJzLmxlbmd0aClcblx0XHR9XG5cdH0pXG59XG5cbmZ1bmN0aW9uIFJ1bkxlbmd0aEluZGV4IChlbnRyaWVzLCBjb3VudE5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuX2VudHJpZXMgPSBlbnRyaWVzXG5cdHNlbGYuX2NvdW50TmFtZSA9IGNvdW50TmFtZSB8fCAnY291bnQnXG5cdHNlbGYuX2luZGV4ID0gMFxuXHRzZWxmLl9vZmZzZXQgPSAwXG5cblx0c2VsZi52YWx1ZSA9IHNlbGYuX2VudHJpZXNbMF1cbn1cblxuUnVuTGVuZ3RoSW5kZXgucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuX29mZnNldCsrXG5cdGlmIChzZWxmLl9vZmZzZXQgPj0gc2VsZi5fZW50cmllc1tzZWxmLl9pbmRleF1bc2VsZi5fY291bnROYW1lXSkge1xuXHRcdHNlbGYuX2luZGV4Kytcblx0XHRzZWxmLl9vZmZzZXQgPSAwXG5cdH1cblxuXHRzZWxmLnZhbHVlID0gc2VsZi5fZW50cmllc1tzZWxmLl9pbmRleF1cbn1cblxuTVA0UmVtdXhlci5wcm90b3R5cGUuX3Byb2Nlc3NNb292ID0gZnVuY3Rpb24gKG1vb3YpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHRyYWtzID0gbW9vdi50cmFrc1xuXHRzZWxmLl90cmFja3MgPSBbXVxuXHRzZWxmLl9oYXNWaWRlbyA9IGZhbHNlXG5cdHNlbGYuX2hhc0F1ZGlvID0gZmFsc2Vcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0cmFrcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0cmFrID0gdHJha3NbaV1cblx0XHR2YXIgc3RibCA9IHRyYWsubWRpYS5taW5mLnN0Ymxcblx0XHR2YXIgc3RzZEVudHJ5ID0gc3RibC5zdHNkLmVudHJpZXNbMF1cblx0XHR2YXIgaGFuZGxlclR5cGUgPSB0cmFrLm1kaWEuaGRsci5oYW5kbGVyVHlwZVxuXHRcdHZhciBjb2RlY1xuXHRcdHZhciBtaW1lXG5cdFx0aWYgKGhhbmRsZXJUeXBlID09PSAndmlkZScgJiYgc3RzZEVudHJ5LnR5cGUgPT09ICdhdmMxJykge1xuXHRcdFx0aWYgKHNlbGYuX2hhc1ZpZGVvKSB7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9oYXNWaWRlbyA9IHRydWVcblx0XHRcdGNvZGVjID0gJ2F2YzEnXG5cdFx0XHRpZiAoc3RzZEVudHJ5LmF2Y0MpIHtcblx0XHRcdFx0Y29kZWMgKz0gJy4nICsgc3RzZEVudHJ5LmF2Y0MubWltZUNvZGVjXG5cdFx0XHR9XG5cdFx0XHRtaW1lID0gJ3ZpZGVvL21wNDsgY29kZWNzPVwiJyArIGNvZGVjICsgJ1wiJ1xuXHRcdH0gZWxzZSBpZiAoaGFuZGxlclR5cGUgPT09ICdzb3VuJyAmJiBzdHNkRW50cnkudHlwZSA9PT0gJ21wNGEnKSB7XG5cdFx0XHRpZiAoc2VsZi5faGFzQXVkaW8pIHtcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH1cblx0XHRcdHNlbGYuX2hhc0F1ZGlvID0gdHJ1ZVxuXHRcdFx0Y29kZWMgPSAnbXA0YSdcblx0XHRcdGlmIChzdHNkRW50cnkuZXNkcyAmJiBzdHNkRW50cnkuZXNkcy5taW1lQ29kZWMpIHtcblx0XHRcdFx0Y29kZWMgKz0gJy4nICsgc3RzZEVudHJ5LmVzZHMubWltZUNvZGVjXG5cdFx0XHR9XG5cdFx0XHRtaW1lID0gJ2F1ZGlvL21wNDsgY29kZWNzPVwiJyArIGNvZGVjICsgJ1wiJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250aW51ZVxuXHRcdH1cblxuXHRcdHZhciBzYW1wbGVzID0gW11cblx0XHR2YXIgc2FtcGxlID0gMFxuXG5cdFx0Ly8gQ2h1bmsvcG9zaXRpb24gZGF0YVxuXHRcdHZhciBzYW1wbGVJbkNodW5rID0gMFxuXHRcdHZhciBjaHVuayA9IDBcblx0XHR2YXIgb2Zmc2V0SW5DaHVuayA9IDBcblx0XHR2YXIgc2FtcGxlVG9DaHVua0luZGV4ID0gMFxuXG5cdFx0Ly8gVGltZSBkYXRhXG5cdFx0dmFyIGR0cyA9IDBcblx0XHR2YXIgZGVjb2RpbmdUaW1lRW50cnkgPSBuZXcgUnVuTGVuZ3RoSW5kZXgoc3RibC5zdHRzLmVudHJpZXMpXG5cdFx0dmFyIHByZXNlbnRhdGlvbk9mZnNldEVudHJ5ID0gbnVsbFxuXHRcdGlmIChzdGJsLmN0dHMpIHtcblx0XHRcdHByZXNlbnRhdGlvbk9mZnNldEVudHJ5ID0gbmV3IFJ1bkxlbmd0aEluZGV4KHN0YmwuY3R0cy5lbnRyaWVzKVxuXHRcdH1cblxuXHRcdC8vIFN5bmMgdGFibGUgaW5kZXhcblx0XHR2YXIgc3luY1NhbXBsZUluZGV4ID0gMFxuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdHZhciBjdXJyQ2h1bmtFbnRyeSA9IHN0Ymwuc3RzYy5lbnRyaWVzW3NhbXBsZVRvQ2h1bmtJbmRleF1cblxuXHRcdFx0Ly8gQ29tcHV0ZSBzaXplXG5cdFx0XHR2YXIgc2l6ZSA9IHN0Ymwuc3Rzei5lbnRyaWVzW3NhbXBsZV1cblxuXHRcdFx0Ly8gQ29tcHV0ZSB0aW1lIGRhdGFcblx0XHRcdHZhciBkdXJhdGlvbiA9IGRlY29kaW5nVGltZUVudHJ5LnZhbHVlLmR1cmF0aW9uXG5cdFx0XHR2YXIgcHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uT2Zmc2V0RW50cnkgPyBwcmVzZW50YXRpb25PZmZzZXRFbnRyeS52YWx1ZS5jb21wb3NpdGlvbk9mZnNldCA6IDBcblxuXHRcdFx0Ly8gQ29tcHV0ZSBzeW5jXG5cdFx0XHR2YXIgc3luYyA9IHRydWVcblx0XHRcdGlmIChzdGJsLnN0c3MpIHtcblx0XHRcdFx0c3luYyA9IHN0Ymwuc3Rzcy5lbnRyaWVzW3N5bmNTYW1wbGVJbmRleF0gPT09IHNhbXBsZSArIDFcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ3JlYXRlIG5ldyBzYW1wbGUgZW50cnlcblx0XHRcdHNhbXBsZXMucHVzaCh7XG5cdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0ZHRzOiBkdHMsXG5cdFx0XHRcdHByZXNlbnRhdGlvbk9mZnNldDogcHJlc2VudGF0aW9uT2Zmc2V0LFxuXHRcdFx0XHRzeW5jOiBzeW5jLFxuXHRcdFx0XHRvZmZzZXQ6IG9mZnNldEluQ2h1bmsgKyBzdGJsLnN0Y28uZW50cmllc1tjaHVua11cblx0XHRcdH0pXG5cblx0XHRcdC8vIEdvIHRvIG5leHQgc2FtcGxlXG5cdFx0XHRzYW1wbGUrK1xuXHRcdFx0aWYgKHNhbXBsZSA+PSBzdGJsLnN0c3ouZW50cmllcy5sZW5ndGgpIHtcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTW92ZSBwb3NpdGlvbi9jaHVua1xuXHRcdFx0c2FtcGxlSW5DaHVuaysrXG5cdFx0XHRvZmZzZXRJbkNodW5rICs9IHNpemVcblx0XHRcdGlmIChzYW1wbGVJbkNodW5rID49IGN1cnJDaHVua0VudHJ5LnNhbXBsZXNQZXJDaHVuaykge1xuXHRcdFx0XHQvLyBNb3ZlIHRvIG5ldyBjaHVua1xuXHRcdFx0XHRzYW1wbGVJbkNodW5rID0gMFxuXHRcdFx0XHRvZmZzZXRJbkNodW5rID0gMFxuXHRcdFx0XHRjaHVuaysrXG5cdFx0XHRcdC8vIE1vdmUgc2FtcGxlIHRvIGNodW5rIGJveCBpbmRleFxuXHRcdFx0XHR2YXIgbmV4dENodW5rRW50cnkgPSBzdGJsLnN0c2MuZW50cmllc1tzYW1wbGVUb0NodW5rSW5kZXggKyAxXVxuXHRcdFx0XHRpZiAobmV4dENodW5rRW50cnkgJiYgY2h1bmsgKyAxID49IG5leHRDaHVua0VudHJ5LmZpcnN0Q2h1bmspIHtcblx0XHRcdFx0XHRzYW1wbGVUb0NodW5rSW5kZXgrK1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1vdmUgdGltZSBmb3J3YXJkXG5cdFx0XHRkdHMgKz0gZHVyYXRpb25cblx0XHRcdGRlY29kaW5nVGltZUVudHJ5LmluYygpXG5cdFx0XHRwcmVzZW50YXRpb25PZmZzZXRFbnRyeSAmJiBwcmVzZW50YXRpb25PZmZzZXRFbnRyeS5pbmMoKVxuXG5cdFx0XHQvLyBNb3ZlIHN5bmMgdGFibGUgaW5kZXhcblx0XHRcdGlmIChzeW5jKSB7XG5cdFx0XHRcdHN5bmNTYW1wbGVJbmRleCsrXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dHJhay5tZGlhLm1kaGQuZHVyYXRpb24gPSAwXG5cdFx0dHJhay50a2hkLmR1cmF0aW9uID0gMFxuXG5cdFx0dmFyIGRlZmF1bHRTYW1wbGVEZXNjcmlwdGlvbkluZGV4ID0gY3VyckNodW5rRW50cnkuc2FtcGxlRGVzY3JpcHRpb25JZFxuXG5cdFx0dmFyIHRyYWNrTW9vdiA9IHtcblx0XHRcdHR5cGU6ICdtb292Jyxcblx0XHRcdG12aGQ6IG1vb3YubXZoZCxcblx0XHRcdHRyYWtzOiBbe1xuXHRcdFx0XHR0a2hkOiB0cmFrLnRraGQsXG5cdFx0XHRcdG1kaWE6IHtcblx0XHRcdFx0XHRtZGhkOiB0cmFrLm1kaWEubWRoZCxcblx0XHRcdFx0XHRoZGxyOiB0cmFrLm1kaWEuaGRscixcblx0XHRcdFx0XHRlbG5nOiB0cmFrLm1kaWEuZWxuZyxcblx0XHRcdFx0XHRtaW5mOiB7XG5cdFx0XHRcdFx0XHR2bWhkOiB0cmFrLm1kaWEubWluZi52bWhkLFxuXHRcdFx0XHRcdFx0c21oZDogdHJhay5tZGlhLm1pbmYuc21oZCxcblx0XHRcdFx0XHRcdGRpbmY6IHRyYWsubWRpYS5taW5mLmRpbmYsXG5cdFx0XHRcdFx0XHRzdGJsOiB7XG5cdFx0XHRcdFx0XHRcdHN0c2Q6IHN0Ymwuc3RzZCxcblx0XHRcdFx0XHRcdFx0c3R0czogZW1wdHkoKSxcblx0XHRcdFx0XHRcdFx0Y3R0czogZW1wdHkoKSxcblx0XHRcdFx0XHRcdFx0c3RzYzogZW1wdHkoKSxcblx0XHRcdFx0XHRcdFx0c3RzejogZW1wdHkoKSxcblx0XHRcdFx0XHRcdFx0c3RjbzogZW1wdHkoKSxcblx0XHRcdFx0XHRcdFx0c3RzczogZW1wdHkoKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fV0sXG5cdFx0XHRtdmV4OiB7XG5cdFx0XHRcdG1laGQ6IHtcblx0XHRcdFx0XHRmcmFnbWVudER1cmF0aW9uOiBtb292Lm12aGQuZHVyYXRpb25cblx0XHRcdFx0fSxcblx0XHRcdFx0dHJleHM6IFt7XG5cdFx0XHRcdFx0dHJhY2tJZDogdHJhay50a2hkLnRyYWNrSWQsXG5cdFx0XHRcdFx0ZGVmYXVsdFNhbXBsZURlc2NyaXB0aW9uSW5kZXg6IGRlZmF1bHRTYW1wbGVEZXNjcmlwdGlvbkluZGV4LFxuXHRcdFx0XHRcdGRlZmF1bHRTYW1wbGVEdXJhdGlvbjogMCxcblx0XHRcdFx0XHRkZWZhdWx0U2FtcGxlU2l6ZTogMCxcblx0XHRcdFx0XHRkZWZhdWx0U2FtcGxlRmxhZ3M6IDBcblx0XHRcdFx0fV1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZWxmLl90cmFja3MucHVzaCh7XG5cdFx0XHR0cmFja0lkOiB0cmFrLnRraGQudHJhY2tJZCxcblx0XHRcdHRpbWVTY2FsZTogdHJhay5tZGlhLm1kaGQudGltZVNjYWxlLFxuXHRcdFx0c2FtcGxlczogc2FtcGxlcyxcblx0XHRcdGN1cnJTYW1wbGU6IG51bGwsXG5cdFx0XHRjdXJyVGltZTogbnVsbCxcblx0XHRcdG1vb3Y6IHRyYWNrTW9vdixcblx0XHRcdG1pbWU6IG1pbWVcblx0XHR9KVxuXHR9XG5cblx0aWYgKHNlbGYuX3RyYWNrcy5sZW5ndGggPT09IDApIHtcblx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyBwbGF5YWJsZSB0cmFja3MnKSlcblx0XHRyZXR1cm5cblx0fVxuXG5cdC8vIE11c3QgYmUgc2V0IGxhc3Qgc2luY2UgdGhpcyBpcyB1c2VkIGFib3ZlXG5cdG1vb3YubXZoZC5kdXJhdGlvbiA9IDBcblxuXHRzZWxmLl9mdHlwID0ge1xuXHRcdHR5cGU6ICdmdHlwJyxcblx0XHRicmFuZDogJ2lzbzUnLFxuXHRcdGJyYW5kVmVyc2lvbjogMCxcblx0XHRjb21wYXRpYmxlQnJhbmRzOiBbXG5cdFx0XHQnaXNvNSdcblx0XHRdXG5cdH1cblxuXHR2YXIgZnR5cEJ1ZiA9IEJveC5lbmNvZGUoc2VsZi5fZnR5cClcblx0dmFyIGRhdGEgPSBzZWxmLl90cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuXHRcdHZhciBtb292QnVmID0gQm94LmVuY29kZSh0cmFjay5tb292KVxuXHRcdHJldHVybiB7XG5cdFx0XHRtaW1lOiB0cmFjay5taW1lLFxuXHRcdFx0aW5pdDogQnVmZmVyLmNvbmNhdChbZnR5cEJ1ZiwgbW9vdkJ1Zl0pXG5cdFx0fVxuXHR9KVxuXG5cdHNlbGYuZW1pdCgncmVhZHknLCBkYXRhKVxufVxuXG5mdW5jdGlvbiBlbXB0eSAoKSB7XG5cdHJldHVybiB7XG5cdFx0dmVyc2lvbjogMCxcblx0XHRmbGFnczogMCxcblx0XHRlbnRyaWVzOiBbXVxuXHR9XG59XG5cbk1QNFJlbXV4ZXIucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAodGltZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKCFzZWxmLl90cmFja3MpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vdCByZWFkeSB5ZXQ7IHdhaXQgZm9yIFxcJ3JlYWR5XFwnIGV2ZW50Jylcblx0fVxuXG5cdGlmIChzZWxmLl9maWxlU3RyZWFtKSB7XG5cdFx0c2VsZi5fZmlsZVN0cmVhbS5kZXN0cm95KClcblx0XHRzZWxmLl9maWxlU3RyZWFtID0gbnVsbFxuXHR9XG5cblx0dmFyIHN0YXJ0T2Zmc2V0ID0gLTFcblx0c2VsZi5fdHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2ssIGkpIHtcblx0XHQvLyBmaW5kIHRoZSBrZXlmcmFtZSBiZWZvcmUgdGhlIHRpbWVcblx0XHQvLyBzdHJlYW0gZnJvbSB0aGVyZVxuXHRcdGlmICh0cmFjay5vdXRTdHJlYW0pIHtcblx0XHRcdHRyYWNrLm91dFN0cmVhbS5kZXN0cm95KClcblx0XHR9XG5cdFx0aWYgKHRyYWNrLmluU3RyZWFtKSB7XG5cdFx0XHR0cmFjay5pblN0cmVhbS5kZXN0cm95KClcblx0XHRcdHRyYWNrLmluU3RyZWFtID0gbnVsbFxuXHRcdH1cblx0XHR2YXIgb3V0U3RyZWFtID0gdHJhY2sub3V0U3RyZWFtID0gbXA0LmVuY29kZSgpXG5cdFx0dmFyIGZyYWdtZW50ID0gc2VsZi5fZ2VuZXJhdGVGcmFnbWVudChpLCB0aW1lKVxuXHRcdGlmICghZnJhZ21lbnQpIHtcblx0XHRcdHJldHVybiBvdXRTdHJlYW0uZmluYWxpemUoKVxuXHRcdH1cblxuXHRcdGlmIChzdGFydE9mZnNldCA9PT0gLTEgfHwgZnJhZ21lbnQucmFuZ2VzWzBdLnN0YXJ0IDwgc3RhcnRPZmZzZXQpIHtcblx0XHRcdHN0YXJ0T2Zmc2V0ID0gZnJhZ21lbnQucmFuZ2VzWzBdLnN0YXJ0XG5cdFx0fVxuXG5cdFx0d3JpdGVGcmFnbWVudChmcmFnbWVudClcblxuXHRcdGZ1bmN0aW9uIHdyaXRlRnJhZ21lbnQgKGZyYWcpIHtcblx0XHRcdGlmIChvdXRTdHJlYW0uZGVzdHJveWVkKSByZXR1cm5cblx0XHRcdG91dFN0cmVhbS5ib3goZnJhZy5tb29mLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdGlmIChlcnIpIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0XHRpZiAob3V0U3RyZWFtLmRlc3Ryb3llZCkgcmV0dXJuXG5cdFx0XHRcdHZhciBzbGljZWRTdHJlYW0gPSB0cmFjay5pblN0cmVhbS5zbGljZShmcmFnLnJhbmdlcylcblx0XHRcdFx0c2xpY2VkU3RyZWFtLnBpcGUob3V0U3RyZWFtLm1lZGlhRGF0YShmcmFnLmxlbmd0aCwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRcdGlmIChlcnIpIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0XHRcdGlmIChvdXRTdHJlYW0uZGVzdHJveWVkKSByZXR1cm5cblx0XHRcdFx0XHR2YXIgbmV4dEZyYWcgPSBzZWxmLl9nZW5lcmF0ZUZyYWdtZW50KGkpXG5cdFx0XHRcdFx0aWYgKCFuZXh0RnJhZykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG91dFN0cmVhbS5maW5hbGl6ZSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdyaXRlRnJhZ21lbnQobmV4dEZyYWcpXG5cdFx0XHRcdH0pKVxuXHRcdFx0fSlcblx0XHR9XG5cdH0pXG5cblx0aWYgKHN0YXJ0T2Zmc2V0ID49IDApIHtcblx0XHR2YXIgZmlsZVN0cmVhbSA9IHNlbGYuX2ZpbGVTdHJlYW0gPSBzZWxmLl9maWxlLmNyZWF0ZVJlYWRTdHJlYW0oe1xuXHRcdFx0c3RhcnQ6IHN0YXJ0T2Zmc2V0XG5cdFx0fSlcblxuXHRcdHNlbGYuX3RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuXHRcdFx0dHJhY2suaW5TdHJlYW0gPSBuZXcgUmFuZ2VTbGljZVN0cmVhbShzdGFydE9mZnNldClcblx0XHRcdGZpbGVTdHJlYW0ucGlwZSh0cmFjay5pblN0cmVhbSlcblx0XHR9KVxuXHR9XG5cblx0cmV0dXJuIHNlbGYuX3RyYWNrcy5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XG5cdFx0cmV0dXJuIHRyYWNrLm91dFN0cmVhbVxuXHR9KVxufVxuXG5NUDRSZW11eGVyLnByb3RvdHlwZS5fZmluZFNhbXBsZUJlZm9yZSA9IGZ1bmN0aW9uICh0cmFja0luZCwgdGltZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgdHJhY2sgPSBzZWxmLl90cmFja3NbdHJhY2tJbmRdXG5cdHZhciBzY2FsZWRUaW1lID0gTWF0aC5mbG9vcih0cmFjay50aW1lU2NhbGUgKiB0aW1lKVxuXHR2YXIgc2FtcGxlID0gYnModHJhY2suc2FtcGxlcywgc2NhbGVkVGltZSwgZnVuY3Rpb24gKHNhbXBsZSwgdCkge1xuXHRcdHZhciBwdHMgPSBzYW1wbGUuZHRzICsgc2FtcGxlLnByZXNlbnRhdGlvbk9mZnNldC8vIC0gdHJhY2suZWRpdFNoaWZ0XG5cdFx0cmV0dXJuIHB0cyAtIHRcblx0fSlcblx0aWYgKHNhbXBsZSA9PT0gLTEpIHtcblx0XHRzYW1wbGUgPSAwXG5cdH0gZWxzZSBpZiAoc2FtcGxlIDwgMCkge1xuXHRcdHNhbXBsZSA9IC1zYW1wbGUgLSAyXG5cdH1cblx0Ly8gc2FtcGxlIGlzIG5vdyB0aGUgbGFzdCBzYW1wbGUgd2l0aCBkdHMgPD0gdGltZVxuXHQvLyBGaW5kIHRoZSBwcmVjZWVkaW5nIHN5bmMgc2FtcGxlXG5cdHdoaWxlICghdHJhY2suc2FtcGxlc1tzYW1wbGVdLnN5bmMpIHtcblx0XHRzYW1wbGUtLVxuXHR9XG5cdHJldHVybiBzYW1wbGVcbn1cblxudmFyIE1JTl9GUkFHTUVOVF9EVVJBVElPTiA9IDEgLy8gc2Vjb25kXG5cbk1QNFJlbXV4ZXIucHJvdG90eXBlLl9nZW5lcmF0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKHRyYWNrLCB0aW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHQvKlxuXHQxLiBGaW5kIGNvcnJlY3Qgc2FtcGxlXG5cdDIuIFByb2Nlc3MgYmFja3dhcmQgdW50aWwgc3luYyBzYW1wbGUgZm91bmRcblx0My4gUHJvY2VzcyBmb3J3YXJkIHVudGlsIG5leHQgc3luYyBzYW1wbGUgYWZ0ZXIgTUlOX0ZSQUdNRU5UX0RVUkFUSU9OIGZvdW5kXG5cdCovXG5cdHZhciBjdXJyVHJhY2sgPSBzZWxmLl90cmFja3NbdHJhY2tdXG5cdHZhciBmaXJzdFNhbXBsZVxuXHRpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Zmlyc3RTYW1wbGUgPSBzZWxmLl9maW5kU2FtcGxlQmVmb3JlKHRyYWNrLCB0aW1lKVxuXHR9IGVsc2Uge1xuXHRcdGZpcnN0U2FtcGxlID0gY3VyclRyYWNrLmN1cnJTYW1wbGVcblx0fVxuXG5cdGlmIChmaXJzdFNhbXBsZSA+PSBjdXJyVHJhY2suc2FtcGxlcy5sZW5ndGgpXG5cdFx0cmV0dXJuIG51bGxcblxuXHR2YXIgc3RhcnREdHMgPSBjdXJyVHJhY2suc2FtcGxlc1tmaXJzdFNhbXBsZV0uZHRzXG5cblx0dmFyIHRvdGFsTGVuID0gMFxuXHR2YXIgcmFuZ2VzID0gW11cblx0Zm9yICh2YXIgY3VyclNhbXBsZSA9IGZpcnN0U2FtcGxlOyBjdXJyU2FtcGxlIDwgY3VyclRyYWNrLnNhbXBsZXMubGVuZ3RoOyBjdXJyU2FtcGxlKyspIHtcblx0XHR2YXIgc2FtcGxlID0gY3VyclRyYWNrLnNhbXBsZXNbY3VyclNhbXBsZV1cblx0XHRpZiAoc2FtcGxlLnN5bmMgJiYgc2FtcGxlLmR0cyAtIHN0YXJ0RHRzID49IGN1cnJUcmFjay50aW1lU2NhbGUgKiBNSU5fRlJBR01FTlRfRFVSQVRJT04pIHtcblx0XHRcdGJyZWFrIC8vIFRoaXMgaXMgYSByZWFzb25hYmxlIHBsYWNlIHRvIGVuZCB0aGUgZnJhZ21lbnRcblx0XHR9XG5cblx0XHR0b3RhbExlbiArPSBzYW1wbGUuc2l6ZVxuXHRcdHZhciBjdXJyUmFuZ2UgPSByYW5nZXMubGVuZ3RoIC0gMVxuXHRcdGlmIChjdXJyUmFuZ2UgPCAwIHx8IHJhbmdlc1tjdXJyUmFuZ2VdLmVuZCAhPT0gc2FtcGxlLm9mZnNldCkge1xuXHRcdFx0Ly8gUHVzaCBhIG5ldyByYW5nZVxuXHRcdFx0cmFuZ2VzLnB1c2goe1xuXHRcdFx0XHRzdGFydDogc2FtcGxlLm9mZnNldCxcblx0XHRcdFx0ZW5kOiBzYW1wbGUub2Zmc2V0ICsgc2FtcGxlLnNpemVcblx0XHRcdH0pXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJhbmdlc1tjdXJyUmFuZ2VdLmVuZCArPSBzYW1wbGUuc2l6ZVxuXHRcdH1cblx0fVxuXG5cdGN1cnJUcmFjay5jdXJyU2FtcGxlID0gY3VyclNhbXBsZVxuXG5cdHJldHVybiB7XG5cdFx0bW9vZjogc2VsZi5fZ2VuZXJhdGVNb29mKHRyYWNrLCBmaXJzdFNhbXBsZSwgY3VyclNhbXBsZSksXG5cdFx0cmFuZ2VzOiByYW5nZXMsXG5cdFx0bGVuZ3RoOiB0b3RhbExlblxuXHR9XG59XG5cbk1QNFJlbXV4ZXIucHJvdG90eXBlLl9nZW5lcmF0ZU1vb2YgPSBmdW5jdGlvbiAodHJhY2ssIGZpcnN0U2FtcGxlLCBsYXN0U2FtcGxlKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciBjdXJyVHJhY2sgPSBzZWxmLl90cmFja3NbdHJhY2tdXG5cblx0dmFyIGVudHJpZXMgPSBbXVxuXHRmb3IgKHZhciBqID0gZmlyc3RTYW1wbGU7IGogPCBsYXN0U2FtcGxlOyBqKyspIHtcblx0XHR2YXIgY3VyclNhbXBsZSA9IGN1cnJUcmFjay5zYW1wbGVzW2pdXG5cdFx0ZW50cmllcy5wdXNoKHtcblx0XHRcdHNhbXBsZUR1cmF0aW9uOiBjdXJyU2FtcGxlLmR1cmF0aW9uLFxuXHRcdFx0c2FtcGxlU2l6ZTogY3VyclNhbXBsZS5zaXplLFxuXHRcdFx0c2FtcGxlRmxhZ3M6IGN1cnJTYW1wbGUuc3luYyA/IDB4MjAwMDAwMCA6IDB4MTAxMDAwMCxcblx0XHRcdHNhbXBsZUNvbXBvc2l0aW9uVGltZU9mZnNldDogY3VyclNhbXBsZS5wcmVzZW50YXRpb25PZmZzZXRcblx0XHR9KVxuXHR9XG5cblx0dmFyIG1vb2YgPSB7XG5cdFx0dHlwZTogJ21vb2YnLFxuXHRcdG1maGQ6IHtcblx0XHRcdHNlcXVlbmNlTnVtYmVyOiBzZWxmLl9mcmFnbWVudFNlcXVlbmNlKytcblx0XHR9LFxuXHRcdHRyYWZzOiBbe1xuXHRcdFx0dGZoZDoge1xuXHRcdFx0XHRmbGFnczogMHgyMDAwMCwgLy8gZGVmYXVsdC1iYXNlLWlzLW1vb2Zcblx0XHRcdFx0dHJhY2tJZDogY3VyclRyYWNrLnRyYWNrSWRcblx0XHRcdH0sXG5cdFx0XHR0ZmR0OiB7XG5cdFx0XHRcdGJhc2VNZWRpYURlY29kZVRpbWU6IGN1cnJUcmFjay5zYW1wbGVzW2ZpcnN0U2FtcGxlXS5kdHNcblx0XHRcdH0sXG5cdFx0XHR0cnVuOiB7XG5cdFx0XHRcdGZsYWdzOiAweGYwMSxcblx0XHRcdFx0ZGF0YU9mZnNldDogOCwgLy8gVGhlIG1vb2Ygc2l6ZSBoYXMgdG8gYmUgYWRkZWQgdG8gdGhpcyBsYXRlciBhcyB3ZWxsXG5cdFx0XHRcdGVudHJpZXM6IGVudHJpZXNcblx0XHRcdH1cblx0XHR9XVxuXHR9XG5cblx0Ly8gVXBkYXRlIHRoZSBvZmZzZXRcblx0bW9vZi50cmFmc1swXS50cnVuLmRhdGFPZmZzZXQgKz0gQm94LmVuY29kaW5nTGVuZ3RoKG1vb2YpXG5cblx0cmV0dXJuIG1vb2Zcbn1cbiIsInZhciBNZWRpYUVsZW1lbnRXcmFwcGVyID0gcmVxdWlyZSgnbWVkaWFzb3VyY2UnKVxudmFyIHB1bXAgPSByZXF1aXJlKCdwdW1wJylcblxudmFyIE1QNFJlbXV4ZXIgPSByZXF1aXJlKCcuL21wNC1yZW11eGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBWaWRlb1N0cmVhbVxuXG5mdW5jdGlvbiBWaWRlb1N0cmVhbSAoZmlsZSwgbWVkaWFFbGVtLCBvcHRzKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgVmlkZW9TdHJlYW0pKSByZXR1cm4gbmV3IFZpZGVvU3RyZWFtKGZpbGUsIG1lZGlhRWxlbSwgb3B0cylcblx0b3B0cyA9IG9wdHMgfHwge31cblxuXHRzZWxmLl9lbGVtID0gbWVkaWFFbGVtXG5cdHNlbGYuX2VsZW1XcmFwcGVyID0gbmV3IE1lZGlhRWxlbWVudFdyYXBwZXIobWVkaWFFbGVtKVxuXHRzZWxmLl93YWl0aW5nRmlyZWQgPSBmYWxzZVxuXHRzZWxmLl90cmFja01ldGEgPSBudWxsXG5cdHNlbGYuX2ZpbGUgPSBmaWxlXG5cdHNlbGYuX3RyYWNrcyA9IG51bGxcblx0aWYgKHNlbGYuX2VsZW0ucHJlbG9hZCAhPT0gJ25vbmUnKSB7XG5cdFx0c2VsZi5fY3JlYXRlTXV4ZXIoKVxuXHR9XG5cblx0c2VsZi5fb25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRzZWxmLmRlc3Ryb3koKSAvLyBkb24ndCBwYXNzIGVyciB0aG91Z2ggc28gdGhlIHVzZXIgZG9lc24ndCBuZWVkIHRvIGxpc3RlbiBmb3IgZXJyb3JzXG5cdH1cblx0c2VsZi5fb25XYWl0aW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuX3dhaXRpbmdGaXJlZCA9IHRydWVcblx0XHRpZiAoIXNlbGYuX211eGVyKSB7XG5cdFx0XHRzZWxmLl9jcmVhdGVNdXhlcigpXG5cdFx0fSBlbHNlIGlmIChzZWxmLl90cmFja3MpIHtcblx0XHRcdHNlbGYuX3B1bXAoKVxuXHRcdH1cblx0fVxuXHRzZWxmLl9lbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCBzZWxmLl9vbldhaXRpbmcpXG5cdHNlbGYuX2VsZW0uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9vbkVycm9yKVxufVxuXG5WaWRlb1N0cmVhbS5wcm90b3R5cGUuX2NyZWF0ZU11eGVyID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fbXV4ZXIgPSBuZXcgTVA0UmVtdXhlcihzZWxmLl9maWxlKVxuXHRzZWxmLl9tdXhlci5vbigncmVhZHknLCBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdHNlbGYuX3RyYWNrcyA9IGRhdGEubWFwKGZ1bmN0aW9uICh0cmFja0RhdGEpIHtcblx0XHRcdHZhciBtZWRpYVNvdXJjZSA9IHNlbGYuX2VsZW1XcmFwcGVyLmNyZWF0ZVdyaXRlU3RyZWFtKHRyYWNrRGF0YS5taW1lKVxuXHRcdFx0bWVkaWFTb3VyY2Uub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRzZWxmLl9lbGVtV3JhcHBlci5lcnJvcihlcnIpXG5cdFx0XHR9KVxuXHRcdFx0bWVkaWFTb3VyY2Uud3JpdGUodHJhY2tEYXRhLmluaXQpXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtdXhlZDogbnVsbCxcblx0XHRcdFx0bWVkaWFTb3VyY2U6IG1lZGlhU291cmNlXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdGlmIChzZWxmLl93YWl0aW5nRmlyZWQgfHwgc2VsZi5fZWxlbS5wcmVsb2FkID09PSAnYXV0bycpIHtcblx0XHRcdHNlbGYuX3B1bXAoKVxuXHRcdH1cblx0fSlcblxuXHRzZWxmLl9tdXhlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0c2VsZi5fZWxlbVdyYXBwZXIuZXJyb3IoZXJyKVxuXHR9KVxufVxuXG5WaWRlb1N0cmVhbS5wcm90b3R5cGUuX3B1bXAgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciBtdXhlZCA9IHNlbGYuX211eGVyLnNlZWsoc2VsZi5fZWxlbS5jdXJyZW50VGltZSwgIXNlbGYuX3RyYWNrcylcblxuXHRzZWxmLl90cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2ssIGkpIHtcblx0XHRpZiAodHJhY2subXV4ZWQpIHtcblx0XHRcdHRyYWNrLm11eGVkLmRlc3Ryb3koKVxuXHRcdFx0dHJhY2subWVkaWFTb3VyY2UgPSBzZWxmLl9lbGVtV3JhcHBlci5jcmVhdGVXcml0ZVN0cmVhbSh0cmFjay5tZWRpYVNvdXJjZSlcblx0XHRcdHRyYWNrLm1lZGlhU291cmNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0c2VsZi5fZWxlbVdyYXBwZXIuZXJyb3IoZXJyKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0dHJhY2subXV4ZWQgPSBtdXhlZFtpXVxuXHRcdHB1bXAodHJhY2subXV4ZWQsIHRyYWNrLm1lZGlhU291cmNlKVxuXHR9KVxufVxuXG5WaWRlb1N0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmIChzZWxmLmRlc3Ryb3llZCkge1xuXHRcdHJldHVyblxuXHR9XG5cdHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuXG5cdHNlbGYuX2VsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHNlbGYuX29uV2FpdGluZylcblx0c2VsZi5fZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHNlbGYuX29uRXJyb3IpXG5cblx0aWYgKHNlbGYuX3RyYWNrcykge1xuXHRcdHNlbGYuX3RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuXHRcdFx0dHJhY2subXV4ZWQuZGVzdHJveSgpXG5cdFx0fSlcblx0fVxuXG5cdHNlbGYuX2VsZW0uc3JjID0gJydcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gV2ViVG9ycmVudFxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjb25jYXQgPSByZXF1aXJlKCdzaW1wbGUtY29uY2F0JylcbnZhciBjcmVhdGVUb3JyZW50ID0gcmVxdWlyZSgnY3JlYXRlLXRvcnJlbnQnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2VidG9ycmVudCcpXG52YXIgREhUID0gcmVxdWlyZSgnYml0dG9ycmVudC1kaHQvY2xpZW50JykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGhhdCA9IHJlcXVpcmUoJ2hhdCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbG9hZElQU2V0ID0gcmVxdWlyZSgnbG9hZC1pcC1zZXQnKSAvLyBicm93c2VyIGV4Y2x1ZGVcbnZhciBwYXJhbGxlbCA9IHJlcXVpcmUoJ3J1bi1wYXJhbGxlbCcpXG52YXIgcGFyc2VUb3JyZW50ID0gcmVxdWlyZSgncGFyc2UtdG9ycmVudCcpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG52YXIgc3BlZWRvbWV0ZXIgPSByZXF1aXJlKCdzcGVlZG9tZXRlcicpXG52YXIgemVyb0ZpbGwgPSByZXF1aXJlKCd6ZXJvLWZpbGwnKVxuXG52YXIgVENQUG9vbCA9IHJlcXVpcmUoJy4vbGliL3RjcC1wb29sJykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgVG9ycmVudCA9IHJlcXVpcmUoJy4vbGliL3RvcnJlbnQnKVxuXG4vKipcbiAqIFdlYlRvcnJlbnQgdmVyc2lvbi5cbiAqL1xudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuLyoqXG4gKiBWZXJzaW9uIG51bWJlciBpbiBBenVyZXVzLXN0eWxlLiBHZW5lcmF0ZWQgZnJvbSBtYWpvciBhbmQgbWlub3Igc2VtdmVyIHZlcnNpb24uXG4gKiBGb3IgZXhhbXBsZTpcbiAqICAgJzAuMTYuMScgLT4gJzAwMTYnXG4gKiAgICcxLjIuNScgLT4gJzAxMDInXG4gKi9cbnZhciBWRVJTSU9OX1NUUiA9IFZFUlNJT04ubWF0Y2goLyhbMC05XSspL2cpLnNsaWNlKDAsIDIpLm1hcCh6ZXJvRmlsbCgyKSkuam9pbignJylcblxuLyoqXG4gKiBWZXJzaW9uIHByZWZpeCBzdHJpbmcgKHVzZWQgaW4gcGVlciBJRCkuIFdlYlRvcnJlbnQgdXNlcyB0aGUgQXp1cmV1cy1zdHlsZVxuICogZW5jb2Rpbmc6ICctJywgdHdvIGNoYXJhY3RlcnMgZm9yIGNsaWVudCBpZCAoJ1dXJyksIGZvdXIgYXNjaWkgZGlnaXRzIGZvciB2ZXJzaW9uXG4gKiBudW1iZXIsICctJywgZm9sbG93ZWQgYnkgcmFuZG9tIG51bWJlcnMuXG4gKiBGb3IgZXhhbXBsZTpcbiAqICAgJy1XVzAxMDItJy4uLlxuICovXG52YXIgVkVSU0lPTl9QUkVGSVggPSAnLVdXJyArIFZFUlNJT05fU1RSICsgJy0nXG5cbmluaGVyaXRzKFdlYlRvcnJlbnQsIEV2ZW50RW1pdHRlcilcblxuLyoqXG4gKiBXZWJUb3JyZW50IENsaWVudFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFdlYlRvcnJlbnQgKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBXZWJUb3JyZW50KSkgcmV0dXJuIG5ldyBXZWJUb3JyZW50KG9wdHMpXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG5cbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBpZiAodHlwZW9mIG9wdHMucGVlcklkID09PSAnc3RyaW5nJykge1xuICAgIHNlbGYucGVlcklkID0gb3B0cy5wZWVySWRcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0cy5wZWVySWQpKSB7XG4gICAgc2VsZi5wZWVySWQgPSBvcHRzLnBlZXJJZC50b1N0cmluZygnaGV4JylcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnBlZXJJZCA9IEJ1ZmZlci5mcm9tKFZFUlNJT05fUFJFRklYICsgaGF0KDQ4KSlcbiAgfVxuICBzZWxmLnBlZXJJZEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlbGYucGVlcklkLCAnaGV4JylcblxuICBpZiAodHlwZW9mIG9wdHMubm9kZUlkID09PSAnc3RyaW5nJykge1xuICAgIHNlbGYubm9kZUlkID0gb3B0cy5ub2RlSWRcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0cy5ub2RlSWQpKSB7XG4gICAgc2VsZi5ub2RlSWQgPSBvcHRzLm5vZGVJZC50b1N0cmluZygnaGV4JylcbiAgfSBlbHNlIHtcbiAgICBzZWxmLm5vZGVJZCA9IGhhdCgxNjApXG4gIH1cbiAgc2VsZi5ub2RlSWRCdWZmZXIgPSBCdWZmZXIuZnJvbShzZWxmLm5vZGVJZCwgJ2hleCcpXG5cbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuICBzZWxmLmxpc3RlbmluZyA9IGZhbHNlXG4gIHNlbGYudG9ycmVudFBvcnQgPSBvcHRzLnRvcnJlbnRQb3J0IHx8IDBcbiAgc2VsZi5kaHRQb3J0ID0gb3B0cy5kaHRQb3J0IHx8IDBcbiAgc2VsZi50cmFja2VyID0gb3B0cy50cmFja2VyICE9PSB1bmRlZmluZWQgPyBvcHRzLnRyYWNrZXIgOiB7fVxuICBzZWxmLnRvcnJlbnRzID0gW11cbiAgc2VsZi5tYXhDb25ucyA9IE51bWJlcihvcHRzLm1heENvbm5zKSB8fCA1NVxuXG4gIGlmIChzZWxmLnRyYWNrZXIpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYudHJhY2tlciAhPT0gJ29iamVjdCcpIHNlbGYudHJhY2tlciA9IHt9XG4gICAgaWYgKG9wdHMucnRjQ29uZmlnKSB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdjFcbiAgICAgIGNvbnNvbGUud2FybignV2ViVG9ycmVudDogb3B0cy5ydGNDb25maWcgaXMgZGVwcmVjYXRlZC4gVXNlIG9wdHMudHJhY2tlci5ydGNDb25maWcgaW5zdGVhZCcpXG4gICAgICBzZWxmLnRyYWNrZXIucnRjQ29uZmlnID0gb3B0cy5ydGNDb25maWdcbiAgICB9XG4gICAgaWYgKG9wdHMud3J0Yykge1xuICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHYxXG4gICAgICBjb25zb2xlLndhcm4oJ1dlYlRvcnJlbnQ6IG9wdHMud3J0YyBpcyBkZXByZWNhdGVkLiBVc2Ugb3B0cy50cmFja2VyLndydGMgaW5zdGVhZCcpXG4gICAgICBzZWxmLnRyYWNrZXIud3J0YyA9IG9wdHMud3J0YyAvLyB0byBzdXBwb3J0IGB3ZWJ0b3JyZW50LWh5YnJpZGAgcGFja2FnZVxuICAgIH1cbiAgICBpZiAoZ2xvYmFsLldSVEMgJiYgIXNlbGYudHJhY2tlci53cnRjKSBzZWxmLnRyYWNrZXIud3J0YyA9IGdsb2JhbC5XUlRDXG4gIH1cblxuICBpZiAodHlwZW9mIFRDUFBvb2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLl90Y3BQb29sID0gbmV3IFRDUFBvb2woc2VsZilcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX29uTGlzdGVuaW5nKClcbiAgICB9KVxuICB9XG5cbiAgLy8gc3RhdHNcbiAgc2VsZi5fZG93bmxvYWRTcGVlZCA9IHNwZWVkb21ldGVyKClcbiAgc2VsZi5fdXBsb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG5cbiAgaWYgKG9wdHMuZGh0ICE9PSBmYWxzZSAmJiB0eXBlb2YgREhUID09PSAnZnVuY3Rpb24nIC8qIGJyb3dzZXIgZXhjbHVkZSAqLykge1xuICAgIC8vIHVzZSBhIHNpbmdsZSBESFQgaW5zdGFuY2UgZm9yIGFsbCB0b3JyZW50cywgc28gdGhlIHJvdXRpbmcgdGFibGUgY2FuIGJlIHJldXNlZFxuICAgIHNlbGYuZGh0ID0gbmV3IERIVChleHRlbmQoeyBub2RlSWQ6IHNlbGYubm9kZUlkIH0sIG9wdHMuZGh0KSlcblxuICAgIHNlbGYuZGh0Lm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgc2VsZi5fZGVzdHJveShlcnIpXG4gICAgfSlcblxuICAgIHNlbGYuZGh0Lm9uY2UoJ2xpc3RlbmluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhZGRyZXNzID0gc2VsZi5kaHQuYWRkcmVzcygpXG4gICAgICBpZiAoYWRkcmVzcykgc2VsZi5kaHRQb3J0ID0gYWRkcmVzcy5wb3J0XG4gICAgfSlcblxuICAgIC8vIElnbm9yZSB3YXJuaW5nIHdoZW4gdGhlcmUgYXJlID4gMTAgdG9ycmVudHMgaW4gdGhlIGNsaWVudFxuICAgIHNlbGYuZGh0LnNldE1heExpc3RlbmVycygwKVxuXG4gICAgc2VsZi5kaHQubGlzdGVuKHNlbGYuZGh0UG9ydClcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRodCA9IGZhbHNlXG4gIH1cblxuICBkZWJ1ZygnbmV3IHdlYnRvcnJlbnQgKHBlZXJJZCAlcywgbm9kZUlkICVzKScsIHNlbGYucGVlcklkLCBzZWxmLm5vZGVJZClcblxuICBpZiAodHlwZW9mIGxvYWRJUFNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxvYWRJUFNldChvcHRzLmJsb2NrbGlzdCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAndXNlci1hZ2VudCc6ICdXZWJUb3JyZW50LycgKyBWRVJTSU9OICsgJyAoaHR0cHM6Ly93ZWJ0b3JyZW50LmlvKSdcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyLCBpcFNldCkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGJsb2NrbGlzdDogJyArIGVyci5tZXNzYWdlKVxuICAgICAgc2VsZi5ibG9ja2VkID0gaXBTZXRcbiAgICAgIHJlYWR5KClcbiAgICB9KVxuICB9IGVsc2UgcHJvY2Vzcy5uZXh0VGljayhyZWFkeSlcblxuICBmdW5jdGlvbiByZWFkeSAoKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzZWxmLnJlYWR5ID0gdHJ1ZVxuICAgIHNlbGYuZW1pdCgncmVhZHknKVxuICB9XG59XG5cbldlYlRvcnJlbnQuV0VCUlRDX1NVUFBPUlQgPSBQZWVyLldFQlJUQ19TVVBQT1JUXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJUb3JyZW50LnByb3RvdHlwZSwgJ2Rvd25sb2FkU3BlZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG93bmxvYWRTcGVlZCgpIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJUb3JyZW50LnByb3RvdHlwZSwgJ3VwbG9hZFNwZWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3VwbG9hZFNwZWVkKCkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlRvcnJlbnQucHJvdG90eXBlLCAncHJvZ3Jlc3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b3JyZW50cyA9IHRoaXMudG9ycmVudHMuZmlsdGVyKGZ1bmN0aW9uICh0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG9ycmVudC5wcm9ncmVzcyAhPT0gMVxuICAgIH0pXG4gICAgdmFyIGRvd25sb2FkZWQgPSB0b3JyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyB0b3JyZW50LmRvd25sb2FkZWRcbiAgICB9LCAwKVxuICAgIHZhciBsZW5ndGggPSB0b3JyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyAodG9ycmVudC5sZW5ndGggfHwgMClcbiAgICB9LCAwKSB8fCAxXG4gICAgcmV0dXJuIGRvd25sb2FkZWQgLyBsZW5ndGhcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlRvcnJlbnQucHJvdG90eXBlLCAncmF0aW8nLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB1cGxvYWRlZCA9IHRoaXMudG9ycmVudHMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgdG9ycmVudCkge1xuICAgICAgcmV0dXJuIHRvdGFsICsgdG9ycmVudC51cGxvYWRlZFxuICAgIH0sIDApXG4gICAgdmFyIHJlY2VpdmVkID0gdGhpcy50b3JyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB0b3JyZW50KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyB0b3JyZW50LnJlY2VpdmVkXG4gICAgfSwgMCkgfHwgMVxuICAgIHJldHVybiB1cGxvYWRlZCAvIHJlY2VpdmVkXG4gIH1cbn0pXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG9ycmVudCB3aXRoIHRoZSBnaXZlbiBgdG9ycmVudElkYC4gQ29udmVuaWVuY2UgbWV0aG9kLiBFYXNpZXIgdGhhblxuICogc2VhcmNoaW5nIHRocm91Z2ggdGhlIGBjbGllbnQudG9ycmVudHNgIGFycmF5LiBSZXR1cm5zIGBudWxsYCBpZiBubyBtYXRjaGluZyB0b3JyZW50XG4gKiBmb3VuZC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfE9iamVjdHxUb3JyZW50fSB0b3JyZW50SWRcbiAqIEByZXR1cm4ge1RvcnJlbnR8bnVsbH1cbiAqL1xuV2ViVG9ycmVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRvcnJlbnRJZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGksIHRvcnJlbnRcbiAgdmFyIGxlbiA9IHNlbGYudG9ycmVudHMubGVuZ3RoXG5cbiAgaWYgKHRvcnJlbnRJZCBpbnN0YW5jZW9mIFRvcnJlbnQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRvcnJlbnQgPSBzZWxmLnRvcnJlbnRzW2ldXG4gICAgICBpZiAodG9ycmVudCA9PT0gdG9ycmVudElkKSByZXR1cm4gdG9ycmVudFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkXG4gICAgdHJ5IHsgcGFyc2VkID0gcGFyc2VUb3JyZW50KHRvcnJlbnRJZCkgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsXG4gICAgaWYgKCFwYXJzZWQuaW5mb0hhc2gpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3JyZW50IGlkZW50aWZpZXInKVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0b3JyZW50ID0gc2VsZi50b3JyZW50c1tpXVxuICAgICAgaWYgKHRvcnJlbnQuaW5mb0hhc2ggPT09IHBhcnNlZC5pbmZvSGFzaCkgcmV0dXJuIHRvcnJlbnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gVE9ETzogcmVtb3ZlIGluIHYxXG5XZWJUb3JyZW50LnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uICh0b3JyZW50SWQsIG9wdHMsIG9udG9ycmVudCkge1xuICBjb25zb2xlLndhcm4oJ1dlYlRvcnJlbnQ6IGNsaWVudC5kb3dubG9hZCgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBjbGllbnQuYWRkKCkgaW5zdGVhZCcpXG4gIHJldHVybiB0aGlzLmFkZCh0b3JyZW50SWQsIG9wdHMsIG9udG9ycmVudClcbn1cblxuLyoqXG4gKiBTdGFydCBkb3dubG9hZGluZyBhIG5ldyB0b3JyZW50LiBBbGlhc2VkIGFzIGBjbGllbnQuZG93bmxvYWRgLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfE9iamVjdH0gdG9ycmVudElkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyB0b3JyZW50LXNwZWNpZmljIG9wdGlvbnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvbnRvcnJlbnQgY2FsbGVkIHdoZW4gdGhlIHRvcnJlbnQgaXMgcmVhZHkgKGhhcyBtZXRhZGF0YSlcbiAqL1xuV2ViVG9ycmVudC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRvcnJlbnRJZCwgb3B0cywgb250b3JyZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignY2xpZW50IGlzIGRlc3Ryb3llZCcpXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGYuYWRkKHRvcnJlbnRJZCwgbnVsbCwgb3B0cylcblxuICBkZWJ1ZygnYWRkJylcbiAgb3B0cyA9IG9wdHMgPyBleHRlbmQob3B0cykgOiB7fVxuXG4gIHZhciB0b3JyZW50ID0gbmV3IFRvcnJlbnQodG9ycmVudElkLCBzZWxmLCBvcHRzKVxuICBzZWxmLnRvcnJlbnRzLnB1c2godG9ycmVudClcblxuICB0b3JyZW50Lm9uY2UoJ19pbmZvSGFzaCcsIG9uSW5mb0hhc2gpXG4gIHRvcnJlbnQub25jZSgncmVhZHknLCBvblJlYWR5KVxuICB0b3JyZW50Lm9uY2UoJ2Nsb3NlJywgb25DbG9zZSlcblxuICBmdW5jdGlvbiBvbkluZm9IYXNoICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLnRvcnJlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHNlbGYudG9ycmVudHNbaV1cbiAgICAgIGlmICh0LmluZm9IYXNoID09PSB0b3JyZW50LmluZm9IYXNoICYmIHQgIT09IHRvcnJlbnQpIHtcbiAgICAgICAgdG9ycmVudC5fZGVzdHJveShuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgZHVwbGljYXRlIHRvcnJlbnQgJyArIHRvcnJlbnQuaW5mb0hhc2gpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlYWR5ICgpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0eXBlb2Ygb250b3JyZW50ID09PSAnZnVuY3Rpb24nKSBvbnRvcnJlbnQodG9ycmVudClcbiAgICBzZWxmLmVtaXQoJ3RvcnJlbnQnLCB0b3JyZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gb25DbG9zZSAoKSB7XG4gICAgdG9ycmVudC5yZW1vdmVMaXN0ZW5lcignX2luZm9IYXNoJywgb25JbmZvSGFzaClcbiAgICB0b3JyZW50LnJlbW92ZUxpc3RlbmVyKCdyZWFkeScsIG9uUmVhZHkpXG4gICAgdG9ycmVudC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKVxuICB9XG5cbiAgcmV0dXJuIHRvcnJlbnRcbn1cblxuLyoqXG4gKiBTdGFydCBzZWVkaW5nIGEgbmV3IGZpbGUvZm9sZGVyLlxuICogQHBhcmFtICB7c3RyaW5nfEZpbGV8RmlsZUxpc3R8QnVmZmVyfEFycmF5LjxzdHJpbmd8RmlsZXxCdWZmZXI+fSBpbnB1dFxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0c1xuICogQHBhcmFtICB7ZnVuY3Rpb249fSBvbnNlZWQgY2FsbGVkIHdoZW4gdG9ycmVudCBpcyBzZWVkaW5nXG4gKi9cbldlYlRvcnJlbnQucHJvdG90eXBlLnNlZWQgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdHMsIG9uc2VlZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ2NsaWVudCBpcyBkZXN0cm95ZWQnKVxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmLnNlZWQoaW5wdXQsIG51bGwsIG9wdHMpXG5cbiAgZGVidWcoJ3NlZWQnKVxuICBvcHRzID0gb3B0cyA/IGV4dGVuZChvcHRzKSA6IHt9XG5cbiAgLy8gV2hlbiBzZWVkaW5nIGZyb20gZnMgcGF0aCwgaW5pdGlhbGl6ZSBzdG9yZSBmcm9tIHRoYXQgcGF0aCB0byBhdm9pZCBhIGNvcHlcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIG9wdHMucGF0aCA9IHBhdGguZGlybmFtZShpbnB1dClcbiAgaWYgKCFvcHRzLmNyZWF0ZWRCeSkgb3B0cy5jcmVhdGVkQnkgPSAnV2ViVG9ycmVudC8nICsgVkVSU0lPTl9TVFJcbiAgaWYgKCFzZWxmLnRyYWNrZXIpIG9wdHMuYW5ub3VuY2UgPSBbXVxuXG4gIHZhciB0b3JyZW50ID0gc2VsZi5hZGQobnVsbCwgb3B0cywgb25Ub3JyZW50KVxuICB2YXIgc3RyZWFtc1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIGlucHV0ID0gWyBpbnB1dCBdXG4gIHBhcmFsbGVsKGlucHV0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGlmIChpc1JlYWRhYmxlKGl0ZW0pKSBjb25jYXQoaXRlbSwgY2IpXG4gICAgICBlbHNlIGNiKG51bGwsIGl0ZW0pXG4gICAgfVxuICB9KSwgZnVuY3Rpb24gKGVyciwgaW5wdXQpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmIChlcnIpIHJldHVybiB0b3JyZW50Ll9kZXN0cm95KGVycilcblxuICAgIGNyZWF0ZVRvcnJlbnQucGFyc2VJbnB1dChpbnB1dCwgb3B0cywgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoZXJyKSByZXR1cm4gdG9ycmVudC5fZGVzdHJveShlcnIpXG5cbiAgICAgIHN0cmVhbXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUuZ2V0U3RyZWFtXG4gICAgICB9KVxuXG4gICAgICBjcmVhdGVUb3JyZW50KGlucHV0LCBvcHRzLCBmdW5jdGlvbiAoZXJyLCB0b3JyZW50QnVmKSB7XG4gICAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgIGlmIChlcnIpIHJldHVybiB0b3JyZW50Ll9kZXN0cm95KGVycilcblxuICAgICAgICB2YXIgZXhpc3RpbmdUb3JyZW50ID0gc2VsZi5nZXQodG9ycmVudEJ1ZilcbiAgICAgICAgaWYgKGV4aXN0aW5nVG9ycmVudCkge1xuICAgICAgICAgIHRvcnJlbnQuX2Rlc3Ryb3kobmV3IEVycm9yKCdDYW5ub3QgYWRkIGR1cGxpY2F0ZSB0b3JyZW50ICcgKyBleGlzdGluZ1RvcnJlbnQuaW5mb0hhc2gpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcnJlbnQuX29uVG9ycmVudElkKHRvcnJlbnRCdWYpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBmdW5jdGlvbiBvblRvcnJlbnQgKHRvcnJlbnQpIHtcbiAgICB2YXIgdGFza3MgPSBbXG4gICAgICBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdG9ycmVudC5sb2FkKHN0cmVhbXMsIGNiKVxuICAgICAgfVxuICAgIF1cbiAgICBpZiAoc2VsZi5kaHQpIHtcbiAgICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHRvcnJlbnQub25jZSgnZGh0QW5ub3VuY2UnLCBjYilcbiAgICAgIH0pXG4gICAgfVxuICAgIHBhcmFsbGVsKHRhc2tzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgaWYgKGVycikgcmV0dXJuIHRvcnJlbnQuX2Rlc3Ryb3koZXJyKVxuICAgICAgX29uc2VlZCh0b3JyZW50KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBfb25zZWVkICh0b3JyZW50KSB7XG4gICAgZGVidWcoJ29uIHNlZWQnKVxuICAgIGlmICh0eXBlb2Ygb25zZWVkID09PSAnZnVuY3Rpb24nKSBvbnNlZWQodG9ycmVudClcbiAgICBzZWxmLmVtaXQoJ3NlZWQnLCB0b3JyZW50KVxuICB9XG5cbiAgcmV0dXJuIHRvcnJlbnRcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSB0b3JyZW50IGZyb20gdGhlIGNsaWVudC5cbiAqIEBwYXJhbSAge3N0cmluZ3xCdWZmZXJ8VG9ycmVudH0gICB0b3JyZW50SWRcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5XZWJUb3JyZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodG9ycmVudElkLCBjYikge1xuICBkZWJ1ZygncmVtb3ZlJylcbiAgdmFyIHRvcnJlbnQgPSB0aGlzLmdldCh0b3JyZW50SWQpXG4gIGlmICghdG9ycmVudCkgdGhyb3cgbmV3IEVycm9yKCdObyB0b3JyZW50IHdpdGggaWQgJyArIHRvcnJlbnRJZClcbiAgdGhpcy5fcmVtb3ZlKHRvcnJlbnRJZCwgY2IpXG59XG5cbldlYlRvcnJlbnQucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAodG9ycmVudElkLCBjYikge1xuICB2YXIgdG9ycmVudCA9IHRoaXMuZ2V0KHRvcnJlbnRJZClcbiAgaWYgKCF0b3JyZW50KSByZXR1cm5cbiAgdGhpcy50b3JyZW50cy5zcGxpY2UodGhpcy50b3JyZW50cy5pbmRleE9mKHRvcnJlbnQpLCAxKVxuICB0b3JyZW50LmRlc3Ryb3koY2IpXG59XG5cbldlYlRvcnJlbnQucHJvdG90eXBlLmFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5saXN0ZW5pbmcpIHJldHVybiBudWxsXG4gIHJldHVybiB0aGlzLl90Y3BQb29sXG4gICAgPyB0aGlzLl90Y3BQb29sLnNlcnZlci5hZGRyZXNzKClcbiAgICA6IHsgYWRkcmVzczogJzAuMC4wLjAnLCBmYW1pbHk6ICdJUHY0JywgcG9ydDogMCB9XG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgY2xpZW50LCBpbmNsdWRpbmcgYWxsIHRvcnJlbnRzIGFuZCBjb25uZWN0aW9ucyB0byBwZWVycy5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYlxuICovXG5XZWJUb3JyZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdjbGllbnQgYWxyZWFkeSBkZXN0cm95ZWQnKVxuICB0aGlzLl9kZXN0cm95KG51bGwsIGNiKVxufVxuXG5XZWJUb3JyZW50LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1ZygnY2xpZW50IGRlc3Ryb3knKVxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcblxuICB2YXIgdGFza3MgPSBzZWxmLnRvcnJlbnRzLm1hcChmdW5jdGlvbiAodG9ycmVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHRvcnJlbnQuZGVzdHJveShjYilcbiAgICB9XG4gIH0pXG5cbiAgaWYgKHNlbGYuX3RjcFBvb2wpIHtcbiAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VsZi5fdGNwUG9vbC5kZXN0cm95KGNiKVxuICAgIH0pXG4gIH1cblxuICBpZiAoc2VsZi5kaHQpIHtcbiAgICB0YXNrcy5wdXNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgc2VsZi5kaHQuZGVzdHJveShjYilcbiAgICB9KVxuICB9XG5cbiAgcGFyYWxsZWwodGFza3MsIGNiKVxuXG4gIGlmIChlcnIpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cbiAgc2VsZi50b3JyZW50cyA9IFtdXG4gIHNlbGYuX3RjcFBvb2wgPSBudWxsXG4gIHNlbGYuZGh0ID0gbnVsbFxufVxuXG5XZWJUb3JyZW50LnByb3RvdHlwZS5fb25MaXN0ZW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGlzdGVuaW5nID0gdHJ1ZVxuXG4gIGlmICh0aGlzLl90Y3BQb29sKSB7XG4gICAgLy8gU29tZXRpbWVzIHNlcnZlci5hZGRyZXNzKCkgcmV0dXJucyBgbnVsbGAgaW4gRG9ja2VyLlxuICAgIC8vIFdlYlRvcnJlbnQgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYml0dG9ycmVudC1zd2FybS9wdWxsLzE4XG4gICAgdmFyIGFkZHJlc3MgPSB0aGlzLl90Y3BQb29sLnNlcnZlci5hZGRyZXNzKClcbiAgICBpZiAoYWRkcmVzcykgdGhpcy50b3JyZW50UG9ydCA9IGFkZHJlc3MucG9ydFxuICB9XG5cbiAgdGhpcy5lbWl0KCdsaXN0ZW5pbmcnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgbm9kZSBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgeyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZWFkYWJsZSAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqLnBpcGUgPT09ICdmdW5jdGlvbidcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gRmlsZVN0cmVhbVxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJ0b3JyZW50OmZpbGUtc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG5pbmhlcml0cyhGaWxlU3RyZWFtLCBzdHJlYW0uUmVhZGFibGUpXG5cbi8qKlxuICogUmVhZGFibGUgc3RyZWFtIG9mIGEgdG9ycmVudCBmaWxlXG4gKlxuICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc3RhcnQgc3RyZWFtIHNsaWNlIG9mIGZpbGUsIHN0YXJ0aW5nIGZyb20gdGhpcyBieXRlIChpbmNsdXNpdmUpXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy5lbmQgc3RyZWFtIHNsaWNlIG9mIGZpbGUsIGVuZGluZyB3aXRoIHRoaXMgYnl0ZSAoaW5jbHVzaXZlKVxuICovXG5mdW5jdGlvbiBGaWxlU3RyZWFtIChmaWxlLCBvcHRzKSB7XG4gIHN0cmVhbS5SZWFkYWJsZS5jYWxsKHRoaXMsIG9wdHMpXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICB0aGlzLl90b3JyZW50ID0gZmlsZS5fdG9ycmVudFxuXG4gIHZhciBzdGFydCA9IChvcHRzICYmIG9wdHMuc3RhcnQpIHx8IDBcbiAgdmFyIGVuZCA9IChvcHRzICYmIG9wdHMuZW5kICYmIG9wdHMuZW5kIDwgZmlsZS5sZW5ndGgpXG4gICAgPyBvcHRzLmVuZFxuICAgIDogZmlsZS5sZW5ndGggLSAxXG5cbiAgdmFyIHBpZWNlTGVuZ3RoID0gZmlsZS5fdG9ycmVudC5waWVjZUxlbmd0aFxuXG4gIHRoaXMuX3N0YXJ0UGllY2UgPSAoc3RhcnQgKyBmaWxlLm9mZnNldCkgLyBwaWVjZUxlbmd0aCB8IDBcbiAgdGhpcy5fZW5kUGllY2UgPSAoZW5kICsgZmlsZS5vZmZzZXQpIC8gcGllY2VMZW5ndGggfCAwXG5cbiAgdGhpcy5fcGllY2UgPSB0aGlzLl9zdGFydFBpZWNlXG4gIHRoaXMuX29mZnNldCA9IChzdGFydCArIGZpbGUub2Zmc2V0KSAtICh0aGlzLl9zdGFydFBpZWNlICogcGllY2VMZW5ndGgpXG5cbiAgdGhpcy5fbWlzc2luZyA9IGVuZCAtIHN0YXJ0ICsgMVxuICB0aGlzLl9yZWFkaW5nID0gZmFsc2VcbiAgdGhpcy5fbm90aWZ5aW5nID0gZmFsc2VcbiAgdGhpcy5fY3JpdGljYWxMZW5ndGggPSBNYXRoLm1pbigoMTAyNCAqIDEwMjQgLyBwaWVjZUxlbmd0aCkgfCAwLCAyKVxufVxuXG5GaWxlU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3JlYWRpbmcpIHJldHVyblxuICB0aGlzLl9yZWFkaW5nID0gdHJ1ZVxuICB0aGlzLl9ub3RpZnkoKVxufVxuXG5GaWxlU3RyZWFtLnByb3RvdHlwZS5fbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoIXNlbGYuX3JlYWRpbmcgfHwgc2VsZi5fbWlzc2luZyA9PT0gMCkgcmV0dXJuXG4gIGlmICghc2VsZi5fdG9ycmVudC5iaXRmaWVsZC5nZXQoc2VsZi5fcGllY2UpKSB7XG4gICAgcmV0dXJuIHNlbGYuX3RvcnJlbnQuY3JpdGljYWwoc2VsZi5fcGllY2UsIHNlbGYuX3BpZWNlICsgc2VsZi5fY3JpdGljYWxMZW5ndGgpXG4gIH1cblxuICBpZiAoc2VsZi5fbm90aWZ5aW5nKSByZXR1cm5cbiAgc2VsZi5fbm90aWZ5aW5nID0gdHJ1ZVxuXG4gIHZhciBwID0gc2VsZi5fcGllY2VcbiAgc2VsZi5fdG9ycmVudC5zdG9yZS5nZXQocCwgZnVuY3Rpb24gKGVyciwgYnVmZmVyKSB7XG4gICAgc2VsZi5fbm90aWZ5aW5nID0gZmFsc2VcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmIChlcnIpIHJldHVybiBzZWxmLl9kZXN0cm95KGVycilcbiAgICBkZWJ1ZygncmVhZCAlcyAobGVuZ3RoICVzKSAoZXJyICVzKScsIHAsIGJ1ZmZlci5sZW5ndGgsIGVyciAmJiBlcnIubWVzc2FnZSlcblxuICAgIGlmIChzZWxmLl9vZmZzZXQpIHtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShzZWxmLl9vZmZzZXQpXG4gICAgICBzZWxmLl9vZmZzZXQgPSAwXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX21pc3NpbmcgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgc2VsZi5fbWlzc2luZylcbiAgICB9XG4gICAgc2VsZi5fbWlzc2luZyAtPSBidWZmZXIubGVuZ3RoXG5cbiAgICBkZWJ1ZygncHVzaGluZyBidWZmZXIgb2YgbGVuZ3RoICVzJywgYnVmZmVyLmxlbmd0aClcbiAgICBzZWxmLl9yZWFkaW5nID0gZmFsc2VcbiAgICBzZWxmLnB1c2goYnVmZmVyKVxuXG4gICAgaWYgKHNlbGYuX21pc3NpbmcgPT09IDApIHNlbGYucHVzaChudWxsKVxuICB9KVxuICBzZWxmLl9waWVjZSArPSAxXG59XG5cbkZpbGVTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob25jbG9zZSkge1xuICB0aGlzLl9kZXN0cm95KG51bGwsIG9uY2xvc2UpXG59XG5cbkZpbGVTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgb25jbG9zZSkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcblxuICBpZiAoIXRoaXMuX3RvcnJlbnQuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fdG9ycmVudC5kZXNlbGVjdCh0aGlzLl9zdGFydFBpZWNlLCB0aGlzLl9lbmRQaWVjZSwgdHJ1ZSlcbiAgfVxuXG4gIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxuICBpZiAob25jbG9zZSkgb25jbG9zZSgpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEZpbGVcblxudmFyIGVvcyA9IHJlcXVpcmUoJ2VuZC1vZi1zdHJlYW0nKVxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIEZpbGVTdHJlYW0gPSByZXF1aXJlKCcuL2ZpbGUtc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgcmVuZGVyID0gcmVxdWlyZSgncmVuZGVyLW1lZGlhJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIHN0cmVhbVRvQmxvYlVSTCA9IHJlcXVpcmUoJ3N0cmVhbS10by1ibG9iLXVybCcpXG52YXIgc3RyZWFtVG9CdWZmZXIgPSByZXF1aXJlKCdzdHJlYW0td2l0aC1rbm93bi1sZW5ndGgtdG8tYnVmZmVyJylcblxuaW5oZXJpdHMoRmlsZSwgRXZlbnRFbWl0dGVyKVxuXG5mdW5jdGlvbiBGaWxlICh0b3JyZW50LCBmaWxlKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fdG9ycmVudCA9IHRvcnJlbnRcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2VcblxuICB0aGlzLm5hbWUgPSBmaWxlLm5hbWVcbiAgdGhpcy5wYXRoID0gZmlsZS5wYXRoXG4gIHRoaXMubGVuZ3RoID0gZmlsZS5sZW5ndGhcbiAgdGhpcy5vZmZzZXQgPSBmaWxlLm9mZnNldFxuXG4gIHRoaXMuZG9uZSA9IGZhbHNlXG5cbiAgdmFyIHN0YXJ0ID0gZmlsZS5vZmZzZXRcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgZmlsZS5sZW5ndGggLSAxXG5cbiAgdGhpcy5fc3RhcnRQaWVjZSA9IHN0YXJ0IC8gdGhpcy5fdG9ycmVudC5waWVjZUxlbmd0aCB8IDBcbiAgdGhpcy5fZW5kUGllY2UgPSBlbmQgLyB0aGlzLl90b3JyZW50LnBpZWNlTGVuZ3RoIHwgMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuZG9uZSA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ2RvbmUnKVxuICB9XG59XG5cbkZpbGUucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuICB0aGlzLl90b3JyZW50LnNlbGVjdCh0aGlzLl9zdGFydFBpZWNlLCB0aGlzLl9lbmRQaWVjZSwgcHJpb3JpdHkpXG59XG5cbkZpbGUucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuICB0aGlzLl90b3JyZW50LmRlc2VsZWN0KHRoaXMuX3N0YXJ0UGllY2UsIHRoaXMuX2VuZFBpZWNlLCBmYWxzZSlcbn1cblxuRmlsZS5wcm90b3R5cGUuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgZW1wdHkgPSBuZXcgc3RyZWFtLlBhc3NUaHJvdWdoKClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVtcHR5LmVuZCgpXG4gICAgfSlcbiAgICByZXR1cm4gZW1wdHlcbiAgfVxuXG4gIHZhciBmaWxlU3RyZWFtID0gbmV3IEZpbGVTdHJlYW0oc2VsZiwgb3B0cylcbiAgc2VsZi5fdG9ycmVudC5zZWxlY3QoZmlsZVN0cmVhbS5fc3RhcnRQaWVjZSwgZmlsZVN0cmVhbS5fZW5kUGllY2UsIHRydWUsIGZ1bmN0aW9uICgpIHtcbiAgICBmaWxlU3RyZWFtLl9ub3RpZnkoKVxuICB9KVxuICBlb3MoZmlsZVN0cmVhbSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICghc2VsZi5fdG9ycmVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHNlbGYuX3RvcnJlbnQuZGVzZWxlY3QoZmlsZVN0cmVhbS5fc3RhcnRQaWVjZSwgZmlsZVN0cmVhbS5fZW5kUGllY2UsIHRydWUpXG4gICAgfVxuICB9KVxuICByZXR1cm4gZmlsZVN0cmVhbVxufVxuXG5GaWxlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgc3RyZWFtVG9CdWZmZXIodGhpcy5jcmVhdGVSZWFkU3RyZWFtKCksIHRoaXMubGVuZ3RoLCBjYilcbn1cblxuRmlsZS5wcm90b3R5cGUuZ2V0QmxvYlVSTCA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYnJvd3Nlci1vbmx5IG1ldGhvZCcpXG4gIHZhciBtaW1lID0gcmVuZGVyLm1pbWVbcGF0aC5leHRuYW1lKHRoaXMubmFtZSkudG9Mb3dlckNhc2UoKV1cbiAgc3RyZWFtVG9CbG9iVVJMKHRoaXMuY3JlYXRlUmVhZFN0cmVhbSgpLCBtaW1lLCBjYilcbn1cblxuRmlsZS5wcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbiAoZWxlbSwgY2IpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2Jyb3dzZXItb25seSBtZXRob2QnKVxuICByZW5kZXIuYXBwZW5kKHRoaXMsIGVsZW0sIGNiKVxufVxuXG5GaWxlLnByb3RvdHlwZS5yZW5kZXJUbyA9IGZ1bmN0aW9uIChlbGVtLCBjYikge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYnJvd3Nlci1vbmx5IG1ldGhvZCcpXG4gIHJlbmRlci5yZW5kZXIodGhpcywgZWxlbSwgY2IpXG59XG5cbkZpbGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIHRoaXMuX3RvcnJlbnQgPSBudWxsXG59XG4iLCJ2YXIgYXJyYXlSZW1vdmUgPSByZXF1aXJlKCd1bm9yZGVyZWQtYXJyYXktcmVtb3ZlJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnRvcnJlbnQ6cGVlcicpXG52YXIgV2lyZSA9IHJlcXVpcmUoJ2JpdHRvcnJlbnQtcHJvdG9jb2wnKVxuXG52YXIgV2ViQ29ubiA9IHJlcXVpcmUoJy4vd2ViY29ubicpXG5cbnZhciBDT05ORUNUX1RJTUVPVVRfVENQID0gNTAwMFxudmFyIENPTk5FQ1RfVElNRU9VVF9XRUJSVEMgPSAyNTAwMFxudmFyIEhBTkRTSEFLRV9USU1FT1VUID0gMjUwMDBcblxuLyoqXG4gKiBXZWJSVEMgcGVlciBjb25uZWN0aW9ucyBzdGFydCBvdXQgY29ubmVjdGVkLCBiZWNhdXNlIFdlYlJUQyBwZWVycyByZXF1aXJlIGFuXG4gKiBcImludHJvZHVjdGlvblwiIChpLmUuIFdlYlJUQyBzaWduYWxpbmcpLCBhbmQgdGhlcmUncyBubyBlcXVpdmFsZW50IHRvIGFuIElQIGFkZHJlc3NcbiAqIHRoYXQgbGV0cyB5b3UgcmVmZXIgdG8gYSBXZWJSVEMgZW5kcG9pbnQuXG4gKi9cbmV4cG9ydHMuY3JlYXRlV2ViUlRDUGVlciA9IGZ1bmN0aW9uIChjb25uLCBzd2FybSkge1xuICB2YXIgcGVlciA9IG5ldyBQZWVyKGNvbm4uaWQsICd3ZWJydGMnKVxuICBwZWVyLmNvbm4gPSBjb25uXG4gIHBlZXIuc3dhcm0gPSBzd2FybVxuXG4gIGlmIChwZWVyLmNvbm4uY29ubmVjdGVkKSB7XG4gICAgcGVlci5vbkNvbm5lY3QoKVxuICB9IGVsc2Uge1xuICAgIHBlZXIuY29ubi5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkgeyBwZWVyLm9uQ29ubmVjdCgpIH0pXG4gICAgcGVlci5jb25uLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyBwZWVyLmRlc3Ryb3koZXJyKSB9KVxuICAgIHBlZXIuc3RhcnRDb25uZWN0VGltZW91dCgpXG4gIH1cblxuICByZXR1cm4gcGVlclxufVxuXG4vKipcbiAqIEluY29taW5nIFRDUCBwZWVycyBzdGFydCBvdXQgY29ubmVjdGVkLCBiZWNhdXNlIHRoZSByZW1vdGUgcGVlciBjb25uZWN0ZWQgdG8gdGhlXG4gKiBsaXN0ZW5pbmcgcG9ydCBvZiB0aGUgVENQIHNlcnZlci4gVW50aWwgdGhlIHJlbW90ZSBwZWVyIHNlbmRzIGEgaGFuZHNoYWtlLCB3ZSBkb24ndFxuICoga25vdyB3aGF0IHN3YXJtIHRoZSBjb25uZWN0aW9uIGlzIGludGVuZGVkIGZvci5cbiAqL1xuZXhwb3J0cy5jcmVhdGVUQ1BJbmNvbWluZ1BlZXIgPSBmdW5jdGlvbiAoY29ubikge1xuICB2YXIgYWRkciA9IGNvbm4ucmVtb3RlQWRkcmVzcyArICc6JyArIGNvbm4ucmVtb3RlUG9ydFxuICB2YXIgcGVlciA9IG5ldyBQZWVyKGFkZHIsICd0Y3BJbmNvbWluZycpXG4gIHBlZXIuY29ubiA9IGNvbm5cbiAgcGVlci5hZGRyID0gYWRkclxuXG4gIHBlZXIub25Db25uZWN0KClcblxuICByZXR1cm4gcGVlclxufVxuXG4vKipcbiAqIE91dGdvaW5nIFRDUCBwZWVycyBzdGFydCBvdXQgd2l0aCBqdXN0IGFuIElQIGFkZHJlc3MuIEF0IHNvbWUgcG9pbnQgKHdoZW4gdGhlcmUgaXMgYW5cbiAqIGF2YWlsYWJsZSBjb25uZWN0aW9uKSwgdGhlIGNsaWVudCBjYW4gYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBhZGRyZXNzLlxuICovXG5leHBvcnRzLmNyZWF0ZVRDUE91dGdvaW5nUGVlciA9IGZ1bmN0aW9uIChhZGRyLCBzd2FybSkge1xuICB2YXIgcGVlciA9IG5ldyBQZWVyKGFkZHIsICd0Y3BPdXRnb2luZycpXG4gIHBlZXIuYWRkciA9IGFkZHJcbiAgcGVlci5zd2FybSA9IHN3YXJtXG5cbiAgcmV0dXJuIHBlZXJcbn1cblxuLyoqXG4gKiBQZWVyIHRoYXQgcmVwcmVzZW50cyBhIFdlYiBTZWVkIChCRVAxNyAvIEJFUDE5KS5cbiAqL1xuZXhwb3J0cy5jcmVhdGVXZWJTZWVkUGVlciA9IGZ1bmN0aW9uICh1cmwsIHN3YXJtKSB7XG4gIHZhciBwZWVyID0gbmV3IFBlZXIodXJsLCAnd2ViU2VlZCcpXG4gIHBlZXIuc3dhcm0gPSBzd2FybVxuICBwZWVyLmNvbm4gPSBuZXcgV2ViQ29ubih1cmwsIHN3YXJtKVxuXG4gIHBlZXIub25Db25uZWN0KClcblxuICByZXR1cm4gcGVlclxufVxuXG4vKipcbiAqIFBlZXIuIFJlcHJlc2VudHMgYSBwZWVyIGluIHRoZSB0b3JyZW50IHN3YXJtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBcImlwOnBvcnRcIiBzdHJpbmcsIHBlZXIgaWQgKGZvciBXZWJSVEMgcGVlcnMpLCBvciB1cmwgKGZvciBXZWIgU2VlZHMpXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgcGVlclxuICovXG5mdW5jdGlvbiBQZWVyIChpZCwgdHlwZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5pZCA9IGlkXG4gIHNlbGYudHlwZSA9IHR5cGVcblxuICBkZWJ1ZygnbmV3IFBlZXIgJXMnLCBpZClcblxuICBzZWxmLmFkZHIgPSBudWxsXG4gIHNlbGYuY29ubiA9IG51bGxcbiAgc2VsZi5zd2FybSA9IG51bGxcbiAgc2VsZi53aXJlID0gbnVsbFxuXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuICBzZWxmLnRpbWVvdXQgPSBudWxsIC8vIGhhbmRzaGFrZSB0aW1lb3V0XG4gIHNlbGYucmV0cmllcyA9IDAgLy8gb3V0Z29pbmcgVENQIGNvbm5lY3Rpb24gcmV0cnkgY291bnRcblxuICBzZWxmLnNlbnRIYW5kc2hha2UgPSBmYWxzZVxufVxuXG4vKipcbiAqIENhbGxlZCBvbmNlIHRoZSBwZWVyIGlzIGNvbm5lY3RlZCAoaS5lLiBmaXJlZCAnY29ubmVjdCcgZXZlbnQpXG4gKiBAcGFyYW0ge1NvY2tldH0gY29ublxuICovXG5QZWVyLnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmNvbm5lY3RlZCA9IHRydWVcblxuICBkZWJ1ZygnUGVlciAlcyBjb25uZWN0ZWQnLCBzZWxmLmlkKVxuXG4gIGNsZWFyVGltZW91dChzZWxmLmNvbm5lY3RUaW1lb3V0KVxuXG4gIHZhciBjb25uID0gc2VsZi5jb25uXG4gIGNvbm4ub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveSgpXG4gIH0pXG4gIGNvbm4ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgY29ubi5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgY29ubi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLmRlc3Ryb3koZXJyKVxuICB9KVxuXG4gIHZhciB3aXJlID0gc2VsZi53aXJlID0gbmV3IFdpcmUoKVxuICB3aXJlLnR5cGUgPSBzZWxmLnR5cGVcbiAgd2lyZS5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KClcbiAgfSlcbiAgd2lyZS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICB3aXJlLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmRlc3Ryb3koKVxuICB9KVxuICB3aXJlLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuZGVzdHJveShlcnIpXG4gIH0pXG5cbiAgd2lyZS5vbmNlKCdoYW5kc2hha2UnLCBmdW5jdGlvbiAoaW5mb0hhc2gsIHBlZXJJZCkge1xuICAgIHNlbGYub25IYW5kc2hha2UoaW5mb0hhc2gsIHBlZXJJZClcbiAgfSlcbiAgc2VsZi5zdGFydEhhbmRzaGFrZVRpbWVvdXQoKVxuXG4gIGNvbm4ucGlwZSh3aXJlKS5waXBlKGNvbm4pXG4gIGlmIChzZWxmLnN3YXJtICYmICFzZWxmLnNlbnRIYW5kc2hha2UpIHNlbGYuaGFuZHNoYWtlKClcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBoYW5kc2hha2UgaXMgcmVjZWl2ZWQgZnJvbSByZW1vdGUgcGVlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmZvSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHBlZXJJZFxuICovXG5QZWVyLnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChpbmZvSGFzaCwgcGVlcklkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuc3dhcm0pIHJldHVybiAvLyBgc2VsZi5zd2FybWAgbm90IHNldCB5ZXQsIHNvIGRvIG5vdGhpbmdcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBpZiAoc2VsZi5zd2FybS5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXN0cm95KG5ldyBFcnJvcignc3dhcm0gYWxyZWFkeSBkZXN0cm95ZWQnKSlcbiAgfVxuICBpZiAoaW5mb0hhc2ggIT09IHNlbGYuc3dhcm0uaW5mb0hhc2gpIHtcbiAgICByZXR1cm4gc2VsZi5kZXN0cm95KG5ldyBFcnJvcigndW5leHBlY3RlZCBoYW5kc2hha2UgaW5mbyBoYXNoIGZvciB0aGlzIHN3YXJtJykpXG4gIH1cbiAgaWYgKHBlZXJJZCA9PT0gc2VsZi5zd2FybS5wZWVySWQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXN0cm95KG5ldyBFcnJvcigncmVmdXNpbmcgdG8gY29ubmVjdCB0byBvdXJzZWx2ZXMnKSlcbiAgfVxuXG4gIGRlYnVnKCdQZWVyICVzIGdvdCBoYW5kc2hha2UgJXMnLCBzZWxmLmlkLCBpbmZvSGFzaClcblxuICBjbGVhclRpbWVvdXQoc2VsZi5oYW5kc2hha2VUaW1lb3V0KVxuXG4gIHNlbGYucmV0cmllcyA9IDBcblxuICB2YXIgYWRkciA9IHNlbGYuYWRkclxuICBpZiAoIWFkZHIgJiYgc2VsZi5jb25uLnJlbW90ZUFkZHJlc3MpIHtcbiAgICBhZGRyID0gc2VsZi5jb25uLnJlbW90ZUFkZHJlc3MgKyAnOicgKyBzZWxmLmNvbm4ucmVtb3RlUG9ydFxuICB9XG4gIHNlbGYuc3dhcm0uX29uV2lyZShzZWxmLndpcmUsIGFkZHIpXG5cbiAgLy8gc3dhcm0gY291bGQgYmUgZGVzdHJveWVkIGluIHVzZXIncyAnd2lyZScgZXZlbnQgaGFuZGxlclxuICBpZiAoIXNlbGYuc3dhcm0gfHwgc2VsZi5zd2FybS5kZXN0cm95ZWQpIHJldHVyblxuXG4gIGlmICghc2VsZi5zZW50SGFuZHNoYWtlKSBzZWxmLmhhbmRzaGFrZSgpXG59XG5cblBlZXIucHJvdG90eXBlLmhhbmRzaGFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBvcHRzID0ge1xuICAgIGRodDogc2VsZi5zd2FybS5wcml2YXRlID8gZmFsc2UgOiAhIXNlbGYuc3dhcm0uY2xpZW50LmRodFxuICB9XG4gIHNlbGYud2lyZS5oYW5kc2hha2Uoc2VsZi5zd2FybS5pbmZvSGFzaCwgc2VsZi5zd2FybS5jbGllbnQucGVlcklkLCBvcHRzKVxuICBzZWxmLnNlbnRIYW5kc2hha2UgPSB0cnVlXG59XG5cblBlZXIucHJvdG90eXBlLnN0YXJ0Q29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBjbGVhclRpbWVvdXQoc2VsZi5jb25uZWN0VGltZW91dClcbiAgc2VsZi5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZGVzdHJveShuZXcgRXJyb3IoJ2Nvbm5lY3QgdGltZW91dCcpKVxuICB9LCBzZWxmLnR5cGUgPT09ICd3ZWJydGMnID8gQ09OTkVDVF9USU1FT1VUX1dFQlJUQyA6IENPTk5FQ1RfVElNRU9VVF9UQ1ApXG4gIGlmIChzZWxmLmNvbm5lY3RUaW1lb3V0LnVucmVmKSBzZWxmLmNvbm5lY3RUaW1lb3V0LnVucmVmKClcbn1cblxuUGVlci5wcm90b3R5cGUuc3RhcnRIYW5kc2hha2VUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgY2xlYXJUaW1lb3V0KHNlbGYuaGFuZHNoYWtlVGltZW91dClcbiAgc2VsZi5oYW5kc2hha2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kZXN0cm95KG5ldyBFcnJvcignaGFuZHNoYWtlIHRpbWVvdXQnKSlcbiAgfSwgSEFORFNIQUtFX1RJTUVPVVQpXG4gIGlmIChzZWxmLmhhbmRzaGFrZVRpbWVvdXQudW5yZWYpIHNlbGYuaGFuZHNoYWtlVGltZW91dC51bnJlZigpXG59XG5cblBlZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZVxuXG4gIGRlYnVnKCdkZXN0cm95ICVzIChlcnJvcjogJXMpJywgc2VsZi5pZCwgZXJyICYmIChlcnIubWVzc2FnZSB8fCBlcnIpKVxuXG4gIGNsZWFyVGltZW91dChzZWxmLmNvbm5lY3RUaW1lb3V0KVxuICBjbGVhclRpbWVvdXQoc2VsZi5oYW5kc2hha2VUaW1lb3V0KVxuXG4gIHZhciBzd2FybSA9IHNlbGYuc3dhcm1cbiAgdmFyIGNvbm4gPSBzZWxmLmNvbm5cbiAgdmFyIHdpcmUgPSBzZWxmLndpcmVcblxuICBzZWxmLnN3YXJtID0gbnVsbFxuICBzZWxmLmNvbm4gPSBudWxsXG4gIHNlbGYud2lyZSA9IG51bGxcblxuICBpZiAoc3dhcm0gJiYgd2lyZSkge1xuICAgIGFycmF5UmVtb3ZlKHN3YXJtLndpcmVzLCBzd2FybS53aXJlcy5pbmRleE9mKHdpcmUpKVxuICB9XG4gIGlmIChjb25uKSB7XG4gICAgY29ubi5vbignZXJyb3InLCBub29wKVxuICAgIGNvbm4uZGVzdHJveSgpXG4gIH1cbiAgaWYgKHdpcmUpIHdpcmUuZGVzdHJveSgpXG4gIGlmIChzd2FybSkgc3dhcm0ucmVtb3ZlUGVlcihzZWxmLmlkKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFJhcml0eU1hcFxuXG4vKipcbiAqIE1hcHBpbmcgb2YgdG9ycmVudCBwaWVjZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBhdmFpbGFiaWxpdHkgaW4gdGhlIHRvcnJlbnQgc3dhcm0uIFVzZWRcbiAqIGJ5IHRoZSB0b3JyZW50IG1hbmFnZXIgZm9yIGltcGxlbWVudGluZyB0aGUgcmFyZXN0IHBpZWNlIGZpcnN0IHNlbGVjdGlvbiBzdHJhdGVneS5cbiAqL1xuZnVuY3Rpb24gUmFyaXR5TWFwICh0b3JyZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuX3RvcnJlbnQgPSB0b3JyZW50XG4gIHNlbGYuX251bVBpZWNlcyA9IHRvcnJlbnQucGllY2VzLmxlbmd0aFxuICBzZWxmLl9waWVjZXMgPSBbXVxuXG4gIHNlbGYuX29uV2lyZSA9IGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgc2VsZi5yZWNhbGN1bGF0ZSgpXG4gICAgc2VsZi5faW5pdFdpcmUod2lyZSlcbiAgfVxuICBzZWxmLl9vbldpcmVIYXZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgc2VsZi5fcGllY2VzW2luZGV4XSArPSAxXG4gIH1cbiAgc2VsZi5fb25XaXJlQml0ZmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5yZWNhbGN1bGF0ZSgpXG4gIH1cblxuICBzZWxmLl90b3JyZW50LndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICBzZWxmLl9pbml0V2lyZSh3aXJlKVxuICB9KVxuICBzZWxmLl90b3JyZW50Lm9uKCd3aXJlJywgc2VsZi5fb25XaXJlKVxuICBzZWxmLnJlY2FsY3VsYXRlKClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIHRoZSByYXJlc3QgcGllY2UuIE9wdGlvbmFsbHksIHBhc3MgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gZXhjbHVkZVxuICogY2VydGFpbiBwaWVjZXMgKGZvciBpbnN0YW5jZSwgdGhvc2UgdGhhdCB3ZSBhbHJlYWR5IGhhdmUpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHBpZWNlRmlsdGVyRnVuY1xuICogQHJldHVybiB7bnVtYmVyfSBpbmRleCBvZiByYXJlc3QgcGllY2UsIG9yIC0xXG4gKi9cblJhcml0eU1hcC5wcm90b3R5cGUuZ2V0UmFyZXN0UGllY2UgPSBmdW5jdGlvbiAocGllY2VGaWx0ZXJGdW5jKSB7XG4gIGlmICghcGllY2VGaWx0ZXJGdW5jKSBwaWVjZUZpbHRlckZ1bmMgPSB0cnVlRm5cblxuICB2YXIgY2FuZGlkYXRlcyA9IFtdXG4gIHZhciBtaW4gPSBJbmZpbml0eVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbnVtUGllY2VzOyArK2kpIHtcbiAgICBpZiAoIXBpZWNlRmlsdGVyRnVuYyhpKSkgY29udGludWVcblxuICAgIHZhciBhdmFpbGFiaWxpdHkgPSB0aGlzLl9waWVjZXNbaV1cbiAgICBpZiAoYXZhaWxhYmlsaXR5ID09PSBtaW4pIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaChpKVxuICAgIH0gZWxzZSBpZiAoYXZhaWxhYmlsaXR5IDwgbWluKSB7XG4gICAgICBjYW5kaWRhdGVzID0gWyBpIF1cbiAgICAgIG1pbiA9IGF2YWlsYWJpbGl0eVxuICAgIH1cbiAgfVxuXG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgcGllY2VzIHdpdGggdGhlIHNhbWUgYXZhaWxhYmlsaXR5LCBjaG9vc2Ugb25lIHJhbmRvbWx5XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbTWF0aC5yYW5kb20oKSAqIGNhbmRpZGF0ZXMubGVuZ3RoIHwgMF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTFcbiAgfVxufVxuXG5SYXJpdHlNYXAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl90b3JyZW50LnJlbW92ZUxpc3RlbmVyKCd3aXJlJywgc2VsZi5fb25XaXJlKVxuICBzZWxmLl90b3JyZW50LndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICBzZWxmLl9jbGVhbnVwV2lyZUV2ZW50cyh3aXJlKVxuICB9KVxuICBzZWxmLl90b3JyZW50ID0gbnVsbFxuICBzZWxmLl9waWVjZXMgPSBudWxsXG5cbiAgc2VsZi5fb25XaXJlID0gbnVsbFxuICBzZWxmLl9vbldpcmVIYXZlID0gbnVsbFxuICBzZWxmLl9vbldpcmVCaXRmaWVsZCA9IG51bGxcbn1cblxuUmFyaXR5TWFwLnByb3RvdHlwZS5faW5pdFdpcmUgPSBmdW5jdGlvbiAod2lyZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB3aXJlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2NsZWFudXBXaXJlRXZlbnRzKHdpcmUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9udW1QaWVjZXM7ICsraSkge1xuICAgICAgc2VsZi5fcGllY2VzW2ldIC09IHdpcmUucGVlclBpZWNlcy5nZXQoaSlcbiAgICB9XG4gIH1cblxuICB3aXJlLm9uKCdoYXZlJywgc2VsZi5fb25XaXJlSGF2ZSlcbiAgd2lyZS5vbignYml0ZmllbGQnLCBzZWxmLl9vbldpcmVCaXRmaWVsZClcbiAgd2lyZS5vbmNlKCdjbG9zZScsIHdpcmUuX29uQ2xvc2UpXG59XG5cbi8qKlxuICogUmVjYWxjdWxhdGVzIHBpZWNlIGF2YWlsYWJpbGl0eSBhY3Jvc3MgYWxsIHBlZXJzIGluIHRoZSB0b3JyZW50LlxuICovXG5SYXJpdHlNYXAucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbnVtUGllY2VzOyArK2kpIHtcbiAgICB0aGlzLl9waWVjZXNbaV0gPSAwXG4gIH1cblxuICB2YXIgbnVtV2lyZXMgPSB0aGlzLl90b3JyZW50LndpcmVzLmxlbmd0aFxuICBmb3IgKGkgPSAwOyBpIDwgbnVtV2lyZXM7ICsraSkge1xuICAgIHZhciB3aXJlID0gdGhpcy5fdG9ycmVudC53aXJlc1tpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fbnVtUGllY2VzOyArK2opIHtcbiAgICAgIHRoaXMuX3BpZWNlc1tqXSArPSB3aXJlLnBlZXJQaWVjZXMuZ2V0KGopXG4gICAgfVxuICB9XG59XG5cblJhcml0eU1hcC5wcm90b3R5cGUuX2NsZWFudXBXaXJlRXZlbnRzID0gZnVuY3Rpb24gKHdpcmUpIHtcbiAgd2lyZS5yZW1vdmVMaXN0ZW5lcignaGF2ZScsIHRoaXMuX29uV2lyZUhhdmUpXG4gIHdpcmUucmVtb3ZlTGlzdGVuZXIoJ2JpdGZpZWxkJywgdGhpcy5fb25XaXJlQml0ZmllbGQpXG4gIGlmICh3aXJlLl9vbkNsb3NlKSB3aXJlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHdpcmUuX29uQ2xvc2UpXG4gIHdpcmUuX29uQ2xvc2UgPSBudWxsXG59XG5cbmZ1bmN0aW9uIHRydWVGbiAoKSB7XG4gIHJldHVybiB0cnVlXG59XG4iLCIvKiBnbG9iYWwgVVJMLCBCbG9iICovXG5cbm1vZHVsZS5leHBvcnRzID0gVG9ycmVudFxuXG52YXIgYWRkclRvSVBQb3J0ID0gcmVxdWlyZSgnYWRkci10by1pcC1wb3J0JylcbnZhciBCaXRGaWVsZCA9IHJlcXVpcmUoJ2JpdGZpZWxkJylcbnZhciBDaHVua1N0b3JlV3JpdGVTdHJlYW0gPSByZXF1aXJlKCdjaHVuay1zdG9yZS1zdHJlYW0vd3JpdGUnKVxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnd2VidG9ycmVudDp0b3JyZW50JylcbnZhciBEaXNjb3ZlcnkgPSByZXF1aXJlKCd0b3JyZW50LWRpc2NvdmVyeScpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGV4dGVuZE11dGFibGUgPSByZXF1aXJlKCd4dGVuZC9tdXRhYmxlJylcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBGU0NodW5rU3RvcmUgPSByZXF1aXJlKCdmcy1jaHVuay1zdG9yZScpIC8vIGJyb3dzZXI6IGBtZW1vcnktY2h1bmstc3RvcmVgXG52YXIgZ2V0ID0gcmVxdWlyZSgnc2ltcGxlLWdldCcpXG52YXIgSW1tZWRpYXRlQ2h1bmtTdG9yZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZS1jaHVuay1zdG9yZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTXVsdGlTdHJlYW0gPSByZXF1aXJlKCdtdWx0aXN0cmVhbScpXG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0JykgLy8gYnJvd3NlciBleGNsdWRlXG52YXIgb3MgPSByZXF1aXJlKCdvcycpIC8vIGJyb3dzZXIgZXhjbHVkZVxudmFyIHBhcmFsbGVsID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsJylcbnZhciBwYXJhbGxlbExpbWl0ID0gcmVxdWlyZSgncnVuLXBhcmFsbGVsLWxpbWl0JylcbnZhciBwYXJzZVRvcnJlbnQgPSByZXF1aXJlKCdwYXJzZS10b3JyZW50JylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgUGllY2UgPSByZXF1aXJlKCd0b3JyZW50LXBpZWNlJylcbnZhciBwdW1wID0gcmVxdWlyZSgncHVtcCcpXG52YXIgcmFuZG9tSXRlcmF0ZSA9IHJlcXVpcmUoJ3JhbmRvbS1pdGVyYXRlJylcbnZhciBzaGExID0gcmVxdWlyZSgnc2ltcGxlLXNoYTEnKVxudmFyIHNwZWVkb21ldGVyID0gcmVxdWlyZSgnc3BlZWRvbWV0ZXInKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcbnZhciB1dE1ldGFkYXRhID0gcmVxdWlyZSgndXRfbWV0YWRhdGEnKVxudmFyIHV0UGV4ID0gcmVxdWlyZSgndXRfcGV4JykgLy8gYnJvd3NlciBleGNsdWRlXG5cbnZhciBGaWxlID0gcmVxdWlyZSgnLi9maWxlJylcbnZhciBQZWVyID0gcmVxdWlyZSgnLi9wZWVyJylcbnZhciBSYXJpdHlNYXAgPSByZXF1aXJlKCcuL3Jhcml0eS1tYXAnKVxudmFyIFNlcnZlciA9IHJlcXVpcmUoJy4vc2VydmVyJykgLy8gYnJvd3NlciBleGNsdWRlXG5cbnZhciBNQVhfQkxPQ0tfTEVOR1RIID0gMTI4ICogMTAyNFxudmFyIFBJRUNFX1RJTUVPVVQgPSAzMDAwMFxudmFyIENIT0tFX1RJTUVPVVQgPSA1MDAwXG52YXIgU1BFRURfVEhSRVNIT0xEID0gMyAqIFBpZWNlLkJMT0NLX0xFTkdUSFxuXG52YXIgUElQRUxJTkVfTUlOX0RVUkFUSU9OID0gMC41XG52YXIgUElQRUxJTkVfTUFYX0RVUkFUSU9OID0gMVxuXG52YXIgUkVDSE9LRV9JTlRFUlZBTCA9IDEwMDAwIC8vIDEwIHNlY29uZHNcbnZhciBSRUNIT0tFX09QVElNSVNUSUNfRFVSQVRJT04gPSAyIC8vIDMwIHNlY29uZHNcblxudmFyIEZJTEVTWVNURU1fQ09OQ1VSUkVOQ1kgPSAyXG5cbnZhciBSRUNPTk5FQ1RfV0FJVCA9IFsgMTAwMCwgNTAwMCwgMTUwMDAgXVxuXG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxudmFyIFRNUFxudHJ5IHtcbiAgVE1QID0gcGF0aC5qb2luKGZzLnN0YXRTeW5jKCcvdG1wJykgJiYgJy90bXAnLCAnd2VidG9ycmVudCcpXG59IGNhdGNoIChlcnIpIHtcbiAgVE1QID0gcGF0aC5qb2luKHR5cGVvZiBvcy50bXBEaXIgPT09ICdmdW5jdGlvbicgPyBvcy50bXBEaXIoKSA6ICcvJywgJ3dlYnRvcnJlbnQnKVxufVxuXG5pbmhlcml0cyhUb3JyZW50LCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIFRvcnJlbnQgKHRvcnJlbnRJZCwgY2xpZW50LCBvcHRzKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgdGhpcy5fZGVidWdJZCA9IHRoaXMuY2xpZW50LnBlZXJJZC5zbGljZSgzMilcblxuICB0aGlzLl9kZWJ1ZygnbmV3IHRvcnJlbnQnKVxuXG4gIHRoaXMuYW5ub3VuY2UgPSBvcHRzLmFubm91bmNlXG4gIHRoaXMudXJsTGlzdCA9IG9wdHMudXJsTGlzdFxuXG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aFxuICB0aGlzLl9zdG9yZSA9IG9wdHMuc3RvcmUgfHwgRlNDaHVua1N0b3JlXG4gIHRoaXMuX2dldEFubm91bmNlT3B0cyA9IG9wdHMuZ2V0QW5ub3VuY2VPcHRzXG5cbiAgdGhpcy5zdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3kgfHwgJ3NlcXVlbnRpYWwnXG5cbiAgdGhpcy5tYXhXZWJDb25ucyA9IG9wdHMubWF4V2ViQ29ubnMgfHwgNFxuXG4gIHRoaXMuX3JlY2hva2VOdW1TbG90cyA9IChvcHRzLnVwbG9hZHMgPT09IGZhbHNlIHx8IG9wdHMudXBsb2FkcyA9PT0gMClcbiAgICA/IDBcbiAgICA6ICgrb3B0cy51cGxvYWRzIHx8IDEwKVxuICB0aGlzLl9yZWNob2tlT3B0aW1pc3RpY1dpcmUgPSBudWxsXG4gIHRoaXMuX3JlY2hva2VPcHRpbWlzdGljVGltZSA9IDBcbiAgdGhpcy5fcmVjaG9rZUludGVydmFsSWQgPSBudWxsXG5cbiAgdGhpcy5yZWFkeSA9IGZhbHNlXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICB0aGlzLmRvbmUgPSBmYWxzZVxuXG4gIHRoaXMubWV0YWRhdGEgPSBudWxsXG4gIHRoaXMuc3RvcmUgPSBudWxsXG4gIHRoaXMuZmlsZXMgPSBbXVxuICB0aGlzLnBpZWNlcyA9IFtdXG5cbiAgdGhpcy5fYW1JbnRlcmVzdGVkID0gZmFsc2VcbiAgdGhpcy5fc2VsZWN0aW9ucyA9IFtdXG4gIHRoaXMuX2NyaXRpY2FsID0gW11cblxuICB0aGlzLndpcmVzID0gW10gLy8gb3BlbiB3aXJlcyAoYWRkZWQgKmFmdGVyKiBoYW5kc2hha2UpXG5cbiAgdGhpcy5fcXVldWUgPSBbXSAvLyBxdWV1ZSBvZiBvdXRnb2luZyB0Y3AgcGVlcnMgdG8gY29ubmVjdCB0b1xuICB0aGlzLl9wZWVycyA9IHt9IC8vIGNvbm5lY3RlZCBwZWVycyAoYWRkci9wZWVySWQgLT4gUGVlcilcbiAgdGhpcy5fcGVlcnNMZW5ndGggPSAwIC8vIG51bWJlciBvZiBlbGVtZW50cyBpbiBgdGhpcy5fcGVlcnNgIChjYWNoZSwgZm9yIHBlcmYpXG5cbiAgLy8gc3RhdHNcbiAgdGhpcy5yZWNlaXZlZCA9IDBcbiAgdGhpcy51cGxvYWRlZCA9IDBcbiAgdGhpcy5fZG93bmxvYWRTcGVlZCA9IHNwZWVkb21ldGVyKClcbiAgdGhpcy5fdXBsb2FkU3BlZWQgPSBzcGVlZG9tZXRlcigpXG5cbiAgLy8gZm9yIGNsZWFudXBcbiAgdGhpcy5fc2VydmVycyA9IFtdXG4gIHRoaXMuX3hzUmVxdWVzdHMgPSBbXVxuXG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIGFuZCBleHBvc2UgYSBob29rIGluc3RlYWRcbiAgLy8gb3B0aW1pemF0aW9uOiBkb24ndCByZWNoZWNrIGV2ZXJ5IGZpbGUgaWYgaXQgaGFzbid0IGNoYW5nZWRcbiAgdGhpcy5fZmlsZU1vZHRpbWVzID0gb3B0cy5maWxlTW9kdGltZXNcblxuICBpZiAodG9ycmVudElkICE9PSBudWxsKSB0aGlzLl9vblRvcnJlbnRJZCh0b3JyZW50SWQpXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb3JyZW50LnByb3RvdHlwZSwgJ3RpbWVSZW1haW5pbmcnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRvbmUpIHJldHVybiAwXG4gICAgaWYgKHRoaXMuZG93bmxvYWRTcGVlZCA9PT0gMCkgcmV0dXJuIEluZmluaXR5XG4gICAgcmV0dXJuICgodGhpcy5sZW5ndGggLSB0aGlzLmRvd25sb2FkZWQpIC8gdGhpcy5kb3dubG9hZFNwZWVkKSAqIDEwMDBcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnZG93bmxvYWRlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmJpdGZpZWxkKSByZXR1cm4gMFxuICAgIHZhciBkb3dubG9hZGVkID0gMFxuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuID0gdGhpcy5waWVjZXMubGVuZ3RoOyBpbmRleCA8IGxlbjsgKytpbmRleCkge1xuICAgICAgaWYgKHRoaXMuYml0ZmllbGQuZ2V0KGluZGV4KSkgeyAvLyB2ZXJpZmllZCBkYXRhXG4gICAgICAgIGRvd25sb2FkZWQgKz0gKGluZGV4ID09PSBsZW4gLSAxKSA/IHRoaXMubGFzdFBpZWNlTGVuZ3RoIDogdGhpcy5waWVjZUxlbmd0aFxuICAgICAgfSBlbHNlIHsgLy8gXCJpbiBwcm9ncmVzc1wiIGRhdGFcbiAgICAgICAgdmFyIHBpZWNlID0gdGhpcy5waWVjZXNbaW5kZXhdXG4gICAgICAgIGRvd25sb2FkZWQgKz0gKHBpZWNlLmxlbmd0aCAtIHBpZWNlLm1pc3NpbmcpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb3dubG9hZGVkXG4gIH1cbn0pXG5cbi8vIFRPRE86IHJlLWVuYWJsZSB0aGlzLiBUaGUgbnVtYmVyIG9mIG1pc3NpbmcgcGllY2VzLiBVc2VkIHRvIGltcGxlbWVudCAnZW5kIGdhbWUnIG1vZGUuXG4vLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmFnZS5wcm90b3R5cGUsICdudW1NaXNzaW5nJywge1xuLy8gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbi8vICAgICB2YXIgc2VsZiA9IHRoaXNcbi8vICAgICB2YXIgbnVtTWlzc2luZyA9IHNlbGYucGllY2VzLmxlbmd0aFxuLy8gICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuID0gc2VsZi5waWVjZXMubGVuZ3RoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuLy8gICAgICAgbnVtTWlzc2luZyAtPSBzZWxmLmJpdGZpZWxkLmdldChpbmRleClcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIG51bU1pc3Npbmdcbi8vICAgfVxuLy8gfSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnZG93bmxvYWRTcGVlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb3dubG9hZFNwZWVkKCkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAndXBsb2FkU3BlZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdXBsb2FkU3BlZWQoKSB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxlbmd0aCA/IHRoaXMuZG93bmxvYWRlZCAvIHRoaXMubGVuZ3RoIDogMCB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdyYXRpbycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVwbG9hZGVkIC8gKHRoaXMucmVjZWl2ZWQgfHwgMSkgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnbnVtUGVlcnMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53aXJlcy5sZW5ndGggfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAndG9ycmVudEZpbGVCbG9iVVJMJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignYnJvd3Nlci1vbmx5IHByb3BlcnR5JylcbiAgICBpZiAoIXRoaXMudG9ycmVudEZpbGUpIHJldHVybiBudWxsXG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICBuZXcgQmxvYihbIHRoaXMudG9ycmVudEZpbGUgXSwgeyB0eXBlOiAnYXBwbGljYXRpb24veC1iaXR0b3JyZW50JyB9KVxuICAgIClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnX251bVF1ZXVlZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aCArICh0aGlzLl9wZWVyc0xlbmd0aCAtIHRoaXMuX251bUNvbm5zKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVG9ycmVudC5wcm90b3R5cGUsICdfbnVtQ29ubnMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBudW1Db25ucyA9IDBcbiAgICBmb3IgKHZhciBpZCBpbiBzZWxmLl9wZWVycykge1xuICAgICAgaWYgKHNlbGYuX3BlZXJzW2lkXS5jb25uZWN0ZWQpIG51bUNvbm5zICs9IDFcbiAgICB9XG4gICAgcmV0dXJuIG51bUNvbm5zXG4gIH1cbn0pXG5cbi8vIFRPRE86IHJlbW92ZSBpbiB2MVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvcnJlbnQucHJvdG90eXBlLCAnc3dhcm0nLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUud2FybignV2ViVG9ycmVudDogYHRvcnJlbnQuc3dhcm1gIGlzIGRlcHJlY2F0ZWQuIFVzZSBgdG9ycmVudGAgZGlyZWN0bHkgaW5zdGVhZC4nKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0pXG5cblRvcnJlbnQucHJvdG90eXBlLl9vblRvcnJlbnRJZCA9IGZ1bmN0aW9uICh0b3JyZW50SWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgdmFyIHBhcnNlZFRvcnJlbnRcbiAgdHJ5IHsgcGFyc2VkVG9ycmVudCA9IHBhcnNlVG9ycmVudCh0b3JyZW50SWQpIH0gY2F0Y2ggKGVycikge31cbiAgaWYgKHBhcnNlZFRvcnJlbnQpIHtcbiAgICAvLyBBdHRlbXB0IHRvIHNldCBpbmZvSGFzaCBwcm9wZXJ0eSBzeW5jaHJvbm91c2x5XG4gICAgc2VsZi5pbmZvSGFzaCA9IHBhcnNlZFRvcnJlbnQuaW5mb0hhc2hcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBzZWxmLl9vblBhcnNlZFRvcnJlbnQocGFyc2VkVG9ycmVudClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRvcnJlbnRJZCBmYWlsZWQgdG8gcGFyc2UsIGl0IGNvdWxkIGJlIGluIGEgZm9ybSB0aGF0IHJlcXVpcmVzIGFuIGFzeW5jXG4gICAgLy8gb3BlcmF0aW9uLCBpLmUuIGh0dHAvaHR0cHMgbGluaywgZmlsZXN5c3RlbSBwYXRoLCBvciBCbG9iLlxuICAgIHBhcnNlVG9ycmVudC5yZW1vdGUodG9ycmVudElkLCBmdW5jdGlvbiAoZXJyLCBwYXJzZWRUb3JyZW50KSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICAgICAgc2VsZi5fb25QYXJzZWRUb3JyZW50KHBhcnNlZFRvcnJlbnQpXG4gICAgfSlcbiAgfVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fb25QYXJzZWRUb3JyZW50ID0gZnVuY3Rpb24gKHBhcnNlZFRvcnJlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcHJvY2Vzc1BhcnNlZFRvcnJlbnQocGFyc2VkVG9ycmVudClcblxuICBpZiAoIXNlbGYuaW5mb0hhc2gpIHtcbiAgICByZXR1cm4gc2VsZi5fZGVzdHJveShuZXcgRXJyb3IoJ01hbGZvcm1lZCB0b3JyZW50IGRhdGE6IE5vIGluZm8gaGFzaCcpKVxuICB9XG5cbiAgaWYgKCFzZWxmLnBhdGgpIHNlbGYucGF0aCA9IHBhdGguam9pbihUTVAsIHNlbGYuaW5mb0hhc2gpXG5cbiAgc2VsZi5fcmVjaG9rZUludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fcmVjaG9rZSgpXG4gIH0sIFJFQ0hPS0VfSU5URVJWQUwpXG4gIGlmIChzZWxmLl9yZWNob2tlSW50ZXJ2YWxJZC51bnJlZikgc2VsZi5fcmVjaG9rZUludGVydmFsSWQudW5yZWYoKVxuXG4gIC8vIFByaXZhdGUgJ2luZm9IYXNoJyBldmVudCBhbGxvd3MgY2xpZW50LmFkZCB0byBjaGVjayBmb3IgZHVwbGljYXRlIHRvcnJlbnRzIGFuZFxuICAvLyBkZXN0cm95IHRoZW0gYmVmb3JlIHRoZSBub3JtYWwgJ2luZm9IYXNoJyBldmVudCBpcyBlbWl0dGVkLiBQcmV2ZW50cyB1c2VyXG4gIC8vIGFwcGxpY2F0aW9ucyBmcm9tIG5lZWRpbmcgdG8gZGVhbCB3aXRoIGR1cGxpY2F0ZSAnaW5mb0hhc2gnIGV2ZW50cy5cbiAgc2VsZi5lbWl0KCdfaW5mb0hhc2gnLCBzZWxmLmluZm9IYXNoKVxuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuZW1pdCgnaW5mb0hhc2gnLCBzZWxmLmluZm9IYXNoKVxuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiAvLyB1c2VyIG1pZ2h0IGRlc3Ryb3kgdG9ycmVudCBpbiBldmVudCBoYW5kbGVyXG5cbiAgaWYgKHNlbGYuY2xpZW50Lmxpc3RlbmluZykge1xuICAgIHNlbGYuX29uTGlzdGVuaW5nKClcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmNsaWVudC5vbmNlKCdsaXN0ZW5pbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9vbkxpc3RlbmluZygpXG4gICAgfSlcbiAgfVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fcHJvY2Vzc1BhcnNlZFRvcnJlbnQgPSBmdW5jdGlvbiAocGFyc2VkVG9ycmVudCkge1xuICBpZiAodGhpcy5hbm5vdW5jZSkge1xuICAgIC8vIEFsbG93IHNwZWNpZnlpbmcgdHJhY2tlcnMgdmlhIGBvcHRzYCBwYXJhbWV0ZXJcbiAgICBwYXJzZWRUb3JyZW50LmFubm91bmNlID0gcGFyc2VkVG9ycmVudC5hbm5vdW5jZS5jb25jYXQodGhpcy5hbm5vdW5jZSlcbiAgfVxuXG4gIGlmICh0aGlzLmNsaWVudC50cmFja2VyICYmIGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFICYmICF0aGlzLnByaXZhdGUpIHtcbiAgICAvLyBTbyBgd2VidG9ycmVudC1oeWJyaWRgIGNhbiBmb3JjZSBzcGVjaWZpYyB0cmFja2VycyB0byBiZSB1c2VkXG4gICAgcGFyc2VkVG9ycmVudC5hbm5vdW5jZSA9IHBhcnNlZFRvcnJlbnQuYW5ub3VuY2UuY29uY2F0KGdsb2JhbC5XRUJUT1JSRU5UX0FOTk9VTkNFKVxuICB9XG5cbiAgaWYgKHRoaXMudXJsTGlzdCkge1xuICAgIC8vIEFsbG93IHNwZWNpZnlpbmcgd2ViIHNlZWRzIHZpYSBgb3B0c2AgcGFyYW1ldGVyXG4gICAgcGFyc2VkVG9ycmVudC51cmxMaXN0ID0gcGFyc2VkVG9ycmVudC51cmxMaXN0LmNvbmNhdCh0aGlzLnVybExpc3QpXG4gIH1cblxuICB1bmlxKHBhcnNlZFRvcnJlbnQuYW5ub3VuY2UpXG4gIHVuaXEocGFyc2VkVG9ycmVudC51cmxMaXN0KVxuXG4gIGV4dGVuZE11dGFibGUodGhpcywgcGFyc2VkVG9ycmVudClcblxuICB0aGlzLm1hZ25ldFVSSSA9IHBhcnNlVG9ycmVudC50b01hZ25ldFVSSShwYXJzZWRUb3JyZW50KVxuICB0aGlzLnRvcnJlbnRGaWxlID0gcGFyc2VUb3JyZW50LnRvVG9ycmVudEZpbGUocGFyc2VkVG9ycmVudClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX29uTGlzdGVuaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGlzY292ZXJ5IHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICB2YXIgdHJhY2tlck9wdHMgPSBzZWxmLmNsaWVudC50cmFja2VyXG4gIGlmICh0cmFja2VyT3B0cykge1xuICAgIHRyYWNrZXJPcHRzID0gZXh0ZW5kKHNlbGYuY2xpZW50LnRyYWNrZXIsIHtcbiAgICAgIGdldEFubm91bmNlT3B0czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICB1cGxvYWRlZDogc2VsZi51cGxvYWRlZCxcbiAgICAgICAgICBkb3dubG9hZGVkOiBzZWxmLmRvd25sb2FkZWQsXG4gICAgICAgICAgbGVmdDogTWF0aC5tYXgoc2VsZi5sZW5ndGggLSBzZWxmLmRvd25sb2FkZWQsIDApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuY2xpZW50LnRyYWNrZXIuZ2V0QW5ub3VuY2VPcHRzKSB7XG4gICAgICAgICAgZXh0ZW5kTXV0YWJsZShvcHRzLCBzZWxmLmNsaWVudC50cmFja2VyLmdldEFubm91bmNlT3B0cygpKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLl9nZXRBbm5vdW5jZU9wdHMpIHtcbiAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBkZXByZWNhdGluZyB0aGlzLCBhcyBpdCdzIHJlZHVuZGFudCB3aXRoIHRoZSBmb3JtZXIgY2FzZVxuICAgICAgICAgIGV4dGVuZE11dGFibGUob3B0cywgc2VsZi5fZ2V0QW5ub3VuY2VPcHRzKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHNcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gYmVnaW4gZGlzY292ZXJpbmcgcGVlcnMgdmlhIERIVCBhbmQgdHJhY2tlcnNcbiAgc2VsZi5kaXNjb3ZlcnkgPSBuZXcgRGlzY292ZXJ5KHtcbiAgICBpbmZvSGFzaDogc2VsZi5pbmZvSGFzaCxcbiAgICBhbm5vdW5jZTogc2VsZi5hbm5vdW5jZSxcbiAgICBwZWVySWQ6IHNlbGYuY2xpZW50LnBlZXJJZCxcbiAgICBkaHQ6ICFzZWxmLnByaXZhdGUgJiYgc2VsZi5jbGllbnQuZGh0LFxuICAgIHRyYWNrZXI6IHRyYWNrZXJPcHRzLFxuICAgIHBvcnQ6IHNlbGYuY2xpZW50LnRvcnJlbnRQb3J0XG4gIH0pXG5cbiAgc2VsZi5kaXNjb3Zlcnkub24oJ2Vycm9yJywgb25FcnJvcilcbiAgc2VsZi5kaXNjb3Zlcnkub24oJ3BlZXInLCBvblBlZXIpXG4gIHNlbGYuZGlzY292ZXJ5Lm9uKCd0cmFja2VyQW5ub3VuY2UnLCBvblRyYWNrZXJBbm5vdW5jZSlcbiAgc2VsZi5kaXNjb3Zlcnkub24oJ2RodEFubm91bmNlJywgb25ESFRBbm5vdW5jZSlcbiAgc2VsZi5kaXNjb3Zlcnkub24oJ3dhcm5pbmcnLCBvbldhcm5pbmcpXG5cbiAgZnVuY3Rpb24gb25FcnJvciAoZXJyKSB7XG4gICAgc2VsZi5fZGVzdHJveShlcnIpXG4gIH1cblxuICBmdW5jdGlvbiBvblBlZXIgKHBlZXIpIHtcbiAgICAvLyBEb24ndCBjcmVhdGUgbmV3IG91dGdvaW5nIFRDUCBjb25uZWN0aW9ucyB3aGVuIHRvcnJlbnQgaXMgZG9uZVxuICAgIGlmICh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycgJiYgc2VsZi5kb25lKSByZXR1cm5cbiAgICBzZWxmLmFkZFBlZXIocGVlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhY2tlckFubm91bmNlICgpIHtcbiAgICBzZWxmLmVtaXQoJ3RyYWNrZXJBbm5vdW5jZScpXG4gICAgaWYgKHNlbGYubnVtUGVlcnMgPT09IDApIHNlbGYuZW1pdCgnbm9QZWVycycsICd0cmFja2VyJylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uREhUQW5ub3VuY2UgKCkge1xuICAgIHNlbGYuZW1pdCgnZGh0QW5ub3VuY2UnKVxuICAgIGlmIChzZWxmLm51bVBlZXJzID09PSAwKSBzZWxmLmVtaXQoJ25vUGVlcnMnLCAnZGh0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uV2FybmluZyAoZXJyKSB7XG4gICAgc2VsZi5lbWl0KCd3YXJuaW5nJywgZXJyKVxuICB9XG5cbiAgaWYgKHNlbGYuaW5mbykge1xuICAgIC8vIGlmIGZ1bGwgbWV0YWRhdGEgd2FzIGluY2x1ZGVkIGluIGluaXRpYWwgdG9ycmVudCBpZCwgdXNlIGl0IGltbWVkaWF0ZWx5LiBPdGhlcndpc2UsXG4gICAgLy8gd2FpdCBmb3IgdG9ycmVudC1kaXNjb3ZlcnkgdG8gZmluZCBwZWVycyBhbmQgdXRfbWV0YWRhdGEgdG8gZ2V0IHRoZSBtZXRhZGF0YS5cbiAgICBzZWxmLl9vbk1ldGFkYXRhKHNlbGYpXG4gIH0gZWxzZSBpZiAoc2VsZi54cykge1xuICAgIHNlbGYuX2dldE1ldGFkYXRhRnJvbVNlcnZlcigpXG4gIH1cbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX2dldE1ldGFkYXRhRnJvbVNlcnZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB1cmxzID0gQXJyYXkuaXNBcnJheShzZWxmLnhzKSA/IHNlbGYueHMgOiBbIHNlbGYueHMgXVxuXG4gIHZhciB0YXNrcyA9IHVybHMubWFwKGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBnZXRNZXRhZGF0YUZyb21VUkwodXJsLCBjYilcbiAgICB9XG4gIH0pXG4gIHBhcmFsbGVsKHRhc2tzKVxuXG4gIGZ1bmN0aW9uIGdldE1ldGFkYXRhRnJvbVVSTCAodXJsLCBjYikge1xuICAgIGlmICh1cmwuaW5kZXhPZignaHR0cDovLycpICE9PSAwICYmIHVybC5pbmRleE9mKCdodHRwczovLycpICE9PSAwKSB7XG4gICAgICBzZWxmLl9kZWJ1Zygnc2tpcHBpbmcgbm9uLWh0dHAgeHMgcGFyYW06ICVzJywgdXJsKVxuICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgfVxuXG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICd1c2VyLWFnZW50JzogJ1dlYlRvcnJlbnQvJyArIFZFUlNJT04gKyAnIChodHRwczovL3dlYnRvcnJlbnQuaW8pJ1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVxXG4gICAgdHJ5IHtcbiAgICAgIHJlcSA9IGdldC5jb25jYXQob3B0cywgb25SZXNwb25zZSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdza2lwcGluZyBpbnZhbGlkIHVybCB4cyBwYXJhbTogJXMnLCB1cmwpXG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICBzZWxmLl94c1JlcXVlc3RzLnB1c2gocmVxKVxuXG4gICAgZnVuY3Rpb24gb25SZXNwb25zZSAoZXJyLCByZXMsIHRvcnJlbnQpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKG51bGwpXG4gICAgICBpZiAoc2VsZi5tZXRhZGF0YSkgcmV0dXJuIGNiKG51bGwpXG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ2h0dHAgZXJyb3IgZnJvbSB4cyBwYXJhbTogJXMnLCB1cmwpXG4gICAgICAgIHJldHVybiBjYihudWxsKVxuICAgICAgfVxuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ25vbi0yMDAgc3RhdHVzIGNvZGUgJXMgZnJvbSB4cyBwYXJhbTogJXMnLCByZXMuc3RhdHVzQ29kZSwgdXJsKVxuICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZFRvcnJlbnRcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZFRvcnJlbnQgPSBwYXJzZVRvcnJlbnQodG9ycmVudClcbiAgICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgICAgaWYgKCFwYXJzZWRUb3JyZW50KSB7XG4gICAgICAgIHNlbGYuX2RlYnVnKCdnb3QgaW52YWxpZCB0b3JyZW50IGZpbGUgZnJvbSB4cyBwYXJhbTogJXMnLCB1cmwpXG4gICAgICAgIHJldHVybiBjYihudWxsKVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VkVG9ycmVudC5pbmZvSGFzaCAhPT0gc2VsZi5pbmZvSGFzaCkge1xuICAgICAgICBzZWxmLl9kZWJ1ZygnZ290IHRvcnJlbnQgZmlsZSB3aXRoIGluY29ycmVjdCBpbmZvIGhhc2ggZnJvbSB4cyBwYXJhbTogJXMnLCB1cmwpXG4gICAgICAgIHJldHVybiBjYihudWxsKVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9vbk1ldGFkYXRhKHBhcnNlZFRvcnJlbnQpXG4gICAgICBjYihudWxsKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBmdWxsIHRvcnJlbnQgbWV0YWRhdGEgaXMgcmVjZWl2ZWQuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9vbk1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5tZXRhZGF0YSB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdnb3QgbWV0YWRhdGEnKVxuXG4gIHNlbGYuX3hzUmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxKSB7XG4gICAgcmVxLmFib3J0KClcbiAgfSlcbiAgc2VsZi5feHNSZXF1ZXN0cyA9IFtdXG5cbiAgdmFyIHBhcnNlZFRvcnJlbnRcbiAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmluZm9IYXNoKSB7XG4gICAgLy8gYG1ldGFkYXRhYCBpcyBhIHBhcnNlZCB0b3JyZW50IChmcm9tIHBhcnNlLXRvcnJlbnQgbW9kdWxlKVxuICAgIHBhcnNlZFRvcnJlbnQgPSBtZXRhZGF0YVxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRUb3JyZW50ID0gcGFyc2VUb3JyZW50KG1ldGFkYXRhKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxuXG4gIHNlbGYuX3Byb2Nlc3NQYXJzZWRUb3JyZW50KHBhcnNlZFRvcnJlbnQpXG4gIHNlbGYubWV0YWRhdGEgPSBzZWxmLnRvcnJlbnRGaWxlXG5cbiAgLy8gYWRkIHdlYiBzZWVkIHVybHMgKEJFUDE5KVxuICBzZWxmLnVybExpc3QuZm9yRWFjaChmdW5jdGlvbiAodXJsKSB7XG4gICAgc2VsZi5hZGRXZWJTZWVkKHVybClcbiAgfSlcblxuICBzZWxmLl9yYXJpdHlNYXAgPSBuZXcgUmFyaXR5TWFwKHNlbGYpXG5cbiAgc2VsZi5zdG9yZSA9IG5ldyBJbW1lZGlhdGVDaHVua1N0b3JlKFxuICAgIG5ldyBzZWxmLl9zdG9yZShzZWxmLnBpZWNlTGVuZ3RoLCB7XG4gICAgICB0b3JyZW50OiB7XG4gICAgICAgIGluZm9IYXNoOiBzZWxmLmluZm9IYXNoXG4gICAgICB9LFxuICAgICAgZmlsZXM6IHNlbGYuZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aDogcGF0aC5qb2luKHNlbGYucGF0aCwgZmlsZS5wYXRoKSxcbiAgICAgICAgICBsZW5ndGg6IGZpbGUubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldDogZmlsZS5vZmZzZXRcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBsZW5ndGg6IHNlbGYubGVuZ3RoXG4gICAgfSlcbiAgKVxuXG4gIHNlbGYuZmlsZXMgPSBzZWxmLmZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgIHJldHVybiBuZXcgRmlsZShzZWxmLCBmaWxlKVxuICB9KVxuXG4gIHNlbGYuX2hhc2hlcyA9IHNlbGYucGllY2VzXG5cbiAgc2VsZi5waWVjZXMgPSBzZWxmLnBpZWNlcy5tYXAoZnVuY3Rpb24gKGhhc2gsIGkpIHtcbiAgICB2YXIgcGllY2VMZW5ndGggPSAoaSA9PT0gc2VsZi5waWVjZXMubGVuZ3RoIC0gMSlcbiAgICAgID8gc2VsZi5sYXN0UGllY2VMZW5ndGhcbiAgICAgIDogc2VsZi5waWVjZUxlbmd0aFxuICAgIHJldHVybiBuZXcgUGllY2UocGllY2VMZW5ndGgpXG4gIH0pXG5cbiAgc2VsZi5fcmVzZXJ2YXRpb25zID0gc2VsZi5waWVjZXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW11cbiAgfSlcblxuICBzZWxmLmJpdGZpZWxkID0gbmV3IEJpdEZpZWxkKHNlbGYucGllY2VzLmxlbmd0aClcblxuICBzZWxmLndpcmVzLmZvckVhY2goZnVuY3Rpb24gKHdpcmUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgaGF2ZSB0aGUgbWV0YWRhdGEgYXQgdGhlIHRpbWUgdXRfbWV0YWRhdGEgd2FzIGluaXRpYWxpemVkIGZvciB0aGlzXG4gICAgLy8gd2lyZSwgd2Ugc3RpbGwgd2FudCB0byBtYWtlIGl0IGF2YWlsYWJsZSB0byB0aGUgcGVlciBpbiBjYXNlIHRoZXkgcmVxdWVzdCBpdC5cbiAgICBpZiAod2lyZS51dF9tZXRhZGF0YSkgd2lyZS51dF9tZXRhZGF0YS5zZXRNZXRhZGF0YShzZWxmLm1ldGFkYXRhKVxuXG4gICAgc2VsZi5fb25XaXJlV2l0aE1ldGFkYXRhKHdpcmUpXG4gIH0pXG5cbiAgc2VsZi5fZGVidWcoJ3ZlcmlmeWluZyBleGlzdGluZyB0b3JyZW50IGRhdGEnKVxuICBpZiAoc2VsZi5fZmlsZU1vZHRpbWVzICYmIHNlbGYuX3N0b3JlID09PSBGU0NodW5rU3RvcmUpIHtcbiAgICAvLyBkb24ndCB2ZXJpZnkgaWYgdGhlIGZpbGVzIGhhdmVuJ3QgYmVlbiBtb2RpZmllZCBzaW5jZSB3ZSBsYXN0IGNoZWNrZWRcbiAgICBzZWxmLmdldEZpbGVNb2R0aW1lcyhmdW5jdGlvbiAoZXJyLCBmaWxlTW9kdGltZXMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBzZWxmLl9kZXN0cm95KGVycilcblxuICAgICAgdmFyIHVuY2hhbmdlZCA9IHNlbGYuZmlsZXMubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmlsZU1vZHRpbWVzW2luZGV4XSA9PT0gc2VsZi5fZmlsZU1vZHRpbWVzW2luZGV4XVxuICAgICAgfSkuZXZlcnkoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHhcbiAgICAgIH0pXG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHNlbGYucGllY2VzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHNlbGYuX21hcmtWZXJpZmllZChpbmRleClcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9vblN0b3JlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3ZlcmlmeVBpZWNlcygpXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLl92ZXJpZnlQaWVjZXMoKVxuICB9XG5cbiAgc2VsZi5lbWl0KCdtZXRhZGF0YScpXG59XG5cbi8qXG4gKiBUT0RPOiByZW1vdmUgdGhpc1xuICogR2V0cyB0aGUgbGFzdCBtb2RpZmllZCB0aW1lIG9mIGV2ZXJ5IGZpbGUgb24gZGlzayBmb3IgdGhpcyB0b3JyZW50LlxuICogT25seSB2YWxpZCBpbiBOb2RlLCBub3QgaW4gdGhlIGJyb3dzZXIuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLmdldEZpbGVNb2R0aW1lcyA9IGZ1bmN0aW9uIChjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJldCA9IFtdXG4gIHBhcmFsbGVsTGltaXQoc2VsZi5maWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYikge1xuICAgICAgZnMuc3RhdChwYXRoLmpvaW4oc2VsZi5wYXRoLCBmaWxlLnBhdGgpLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFTk9FTlQnKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICByZXRbaW5kZXhdID0gc3RhdCAmJiBzdGF0Lm10aW1lLmdldFRpbWUoKVxuICAgICAgICBjYihudWxsKVxuICAgICAgfSlcbiAgICB9XG4gIH0pLCBGSUxFU1lTVEVNX0NPTkNVUlJFTkNZLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5fZGVidWcoJ2RvbmUgZ2V0dGluZyBmaWxlIG1vZHRpbWVzJylcbiAgICBjYihlcnIsIHJldClcbiAgfSlcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX3ZlcmlmeVBpZWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHBhcmFsbGVsTGltaXQoc2VsZi5waWVjZXMubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKSlcbiAgICAgIHNlbGYuc3RvcmUuZ2V0KGluZGV4LCBmdW5jdGlvbiAoZXJyLCBidWYpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKG51bGwpIC8vIGlnbm9yZSBlcnJvclxuICAgICAgICBzaGExKGJ1ZiwgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICBpZiAoaGFzaCA9PT0gc2VsZi5faGFzaGVzW2luZGV4XSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnBpZWNlc1tpbmRleF0pIHJldHVyblxuICAgICAgICAgICAgc2VsZi5fZGVidWcoJ3BpZWNlIHZlcmlmaWVkICVzJywgaW5kZXgpXG4gICAgICAgICAgICBzZWxmLl9tYXJrVmVyaWZpZWQoaW5kZXgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuX2RlYnVnKCdwaWVjZSBpbnZhbGlkICVzJywgaW5kZXgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKG51bGwpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSksIEZJTEVTWVNURU1fQ09OQ1VSUkVOQ1ksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5fZGVzdHJveShlcnIpXG4gICAgc2VsZi5fZGVidWcoJ2RvbmUgdmVyaWZ5aW5nJylcbiAgICBzZWxmLl9vblN0b3JlKClcbiAgfSlcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX21hcmtWZXJpZmllZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB0aGlzLnBpZWNlc1tpbmRleF0gPSBudWxsXG4gIHRoaXMuX3Jlc2VydmF0aW9uc1tpbmRleF0gPSBudWxsXG4gIHRoaXMuYml0ZmllbGQuc2V0KGluZGV4LCB0cnVlKVxufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBtZXRhZGF0YSwgbGlzdGVuaW5nIHNlcnZlciwgYW5kIHVuZGVybHlpbmcgY2h1bmsgc3RvcmUgaXMgaW5pdGlhbGl6ZWQuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9vblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIHN0b3JlJylcblxuICAvLyBzdGFydCBvZmYgc2VsZWN0aW5nIHRoZSBlbnRpcmUgdG9ycmVudCB3aXRoIGxvdyBwcmlvcml0eVxuICBpZiAoc2VsZi5waWVjZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgc2VsZi5zZWxlY3QoMCwgc2VsZi5waWVjZXMubGVuZ3RoIC0gMSwgZmFsc2UpXG4gIH1cblxuICBzZWxmLnJlYWR5ID0gdHJ1ZVxuICBzZWxmLmVtaXQoJ3JlYWR5JylcblxuICAvLyBGaWxlcyBtYXkgc3RhcnQgb3V0IGRvbmUgaWYgdGhlIGZpbGUgd2FzIGFscmVhZHkgaW4gdGhlIHN0b3JlXG4gIHNlbGYuX2NoZWNrRG9uZSgpXG5cbiAgLy8gSW4gY2FzZSBhbnkgc2VsZWN0aW9ucyB3ZXJlIG1hZGUgYmVmb3JlIHRvcnJlbnQgd2FzIHJlYWR5XG4gIHNlbGYuX3VwZGF0ZVNlbGVjdGlvbnMoKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZXN0cm95KG51bGwsIGNiKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLmRlc3Ryb3llZCA9IHRydWVcbiAgc2VsZi5fZGVidWcoJ2Rlc3Ryb3knKVxuXG4gIHNlbGYuY2xpZW50Ll9yZW1vdmUoc2VsZilcblxuICBjbGVhckludGVydmFsKHNlbGYuX3JlY2hva2VJbnRlcnZhbElkKVxuXG4gIHNlbGYuX3hzUmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxKSB7XG4gICAgcmVxLmFib3J0KClcbiAgfSlcblxuICBpZiAoc2VsZi5fcmFyaXR5TWFwKSB7XG4gICAgc2VsZi5fcmFyaXR5TWFwLmRlc3Ryb3koKVxuICB9XG5cbiAgZm9yICh2YXIgaWQgaW4gc2VsZi5fcGVlcnMpIHtcbiAgICBzZWxmLnJlbW92ZVBlZXIoaWQpXG4gIH1cblxuICBzZWxmLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIGZpbGUuX2Rlc3Ryb3koKVxuICB9KVxuXG4gIHZhciB0YXNrcyA9IHNlbGYuX3NlcnZlcnMubWFwKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG4gICAgICBzZXJ2ZXIuZGVzdHJveShjYilcbiAgICB9XG4gIH0pXG5cbiAgaWYgKHNlbGYuZGlzY292ZXJ5KSB7XG4gICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHNlbGYuZGlzY292ZXJ5LmRlc3Ryb3koY2IpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzZWxmLnN0b3JlKSB7XG4gICAgdGFza3MucHVzaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHNlbGYuc3RvcmUuY2xvc2UoY2IpXG4gICAgfSlcbiAgfVxuXG4gIHBhcmFsbGVsKHRhc2tzLCBjYilcblxuICBpZiAoZXJyKSB7XG4gICAgLy8gVG9ycmVudCBlcnJvcnMgYXJlIGVtaXR0ZWQgYXQgYHRvcnJlbnQub24oJ2Vycm9yJylgLiBJZiB0aGVyZSBhcmUgbm8gJ2Vycm9yJyBldmVudFxuICAgIC8vIGhhbmRsZXJzIG9uIHRoZSB0b3JyZW50IGluc3RhbmNlLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIGF0XG4gICAgLy8gYGNsaWVudC5vbignZXJyb3InKWAuIFRoaXMgcHJldmVudHMgY3Jhc2hpbmcgdGhlIHVzZXIncyBwcm9ncmFtLCBidXQgaXQgbWFrZXMgaXRcbiAgICAvLyBpbXBvc3NpYmxlIHRvIGRldGVybWluZSBhIGNsaWVudCBlcnJvciB2ZXJzdXMgYSB0b3JyZW50IGVycm9yICh3aGVyZSB0aGUgY2xpZW50XG4gICAgLy8gaXMgc3RpbGwgdXNhYmxlIGFmdGVyd2FyZHMpLiBVc2VycyBhcmUgcmVjb21tZW5kZWQgZm9yIGVycm9ycyBpbiBib3RoIHBsYWNlc1xuICAgIC8vIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIGVycm9yIHR5cGVzLlxuICAgIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHNlbGYuY2xpZW50LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cbiAgfVxuXG4gIHNlbGYuZW1pdCgnY2xvc2UnKVxuXG4gIHNlbGYuY2xpZW50ID0gbnVsbFxuICBzZWxmLmZpbGVzID0gW11cbiAgc2VsZi5kaXNjb3ZlcnkgPSBudWxsXG4gIHNlbGYuc3RvcmUgPSBudWxsXG4gIHNlbGYuX3Jhcml0eU1hcCA9IG51bGxcbiAgc2VsZi5fcGVlcnMgPSBudWxsXG4gIHNlbGYuX3NlcnZlcnMgPSBudWxsXG4gIHNlbGYuX3hzUmVxdWVzdHMgPSBudWxsXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmFkZFBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcbiAgaWYgKCFzZWxmLmluZm9IYXNoKSB0aHJvdyBuZXcgRXJyb3IoJ2FkZFBlZXIoKSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBgaW5mb0hhc2hgIGV2ZW50JylcblxuICBpZiAoc2VsZi5jbGllbnQuYmxvY2tlZCkge1xuICAgIHZhciBob3N0XG4gICAgaWYgKHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhcnRzXG4gICAgICB0cnkge1xuICAgICAgICBwYXJ0cyA9IGFkZHJUb0lQUG9ydChwZWVyKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgcGVlcjogaW52YWxpZCAlcycsIHBlZXIpXG4gICAgICAgIHNlbGYuZW1pdCgnaW52YWxpZFBlZXInLCBwZWVyKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGhvc3QgPSBwYXJ0c1swXVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBlZXIucmVtb3RlQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhvc3QgPSBwZWVyLnJlbW90ZUFkZHJlc3NcbiAgICB9XG5cbiAgICBpZiAoaG9zdCAmJiBzZWxmLmNsaWVudC5ibG9ja2VkLmNvbnRhaW5zKGhvc3QpKSB7XG4gICAgICBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgcGVlcjogYmxvY2tlZCAlcycsIHBlZXIpXG4gICAgICBpZiAodHlwZW9mIHBlZXIgIT09ICdzdHJpbmcnKSBwZWVyLmRlc3Ryb3koKVxuICAgICAgc2VsZi5lbWl0KCdibG9ja2VkUGVlcicsIHBlZXIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICB2YXIgd2FzQWRkZWQgPSAhIXNlbGYuX2FkZFBlZXIocGVlcilcbiAgaWYgKHdhc0FkZGVkKSB7XG4gICAgc2VsZi5lbWl0KCdwZWVyJywgcGVlcilcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmVtaXQoJ2ludmFsaWRQZWVyJywgcGVlcilcbiAgfVxuICByZXR1cm4gd2FzQWRkZWRcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX2FkZFBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB7XG4gICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IHRvcnJlbnQgaXMgZGVzdHJveWVkJylcbiAgICBpZiAodHlwZW9mIHBlZXIgIT09ICdzdHJpbmcnKSBwZWVyLmRlc3Ryb3koKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJyAmJiAhc2VsZi5fdmFsaWRBZGRyKHBlZXIpKSB7XG4gICAgc2VsZi5fZGVidWcoJ2lnbm9yaW5nIHBlZXI6IGludmFsaWQgJXMnLCBwZWVyKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgaWQgPSAocGVlciAmJiBwZWVyLmlkKSB8fCBwZWVyXG4gIGlmIChzZWxmLl9wZWVyc1tpZF0pIHtcbiAgICBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgcGVlcjogZHVwbGljYXRlICglcyknLCBpZClcbiAgICBpZiAodHlwZW9mIHBlZXIgIT09ICdzdHJpbmcnKSBwZWVyLmRlc3Ryb3koKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAoc2VsZi5wYXVzZWQpIHtcbiAgICBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgcGVlcjogdG9ycmVudCBpcyBwYXVzZWQnKVxuICAgIGlmICh0eXBlb2YgcGVlciAhPT0gJ3N0cmluZycpIHBlZXIuZGVzdHJveSgpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHNlbGYuX2RlYnVnKCdhZGQgcGVlciAlcycsIGlkKVxuXG4gIHZhciBuZXdQZWVyXG4gIGlmICh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBgcGVlcmAgaXMgYW4gYWRkciAoXCJpcDpwb3J0XCIgc3RyaW5nKVxuICAgIG5ld1BlZXIgPSBQZWVyLmNyZWF0ZVRDUE91dGdvaW5nUGVlcihwZWVyLCBzZWxmKVxuICB9IGVsc2Uge1xuICAgIC8vIGBwZWVyYCBpcyBhIFdlYlJUQyBjb25uZWN0aW9uIChzaW1wbGUtcGVlcilcbiAgICBuZXdQZWVyID0gUGVlci5jcmVhdGVXZWJSVENQZWVyKHBlZXIsIHNlbGYpXG4gIH1cblxuICBzZWxmLl9wZWVyc1tuZXdQZWVyLmlkXSA9IG5ld1BlZXJcbiAgc2VsZi5fcGVlcnNMZW5ndGggKz0gMVxuXG4gIGlmICh0eXBlb2YgcGVlciA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBgcGVlcmAgaXMgYW4gYWRkciAoXCJpcDpwb3J0XCIgc3RyaW5nKVxuICAgIHNlbGYuX3F1ZXVlLnB1c2gobmV3UGVlcilcbiAgICBzZWxmLl9kcmFpbigpXG4gIH1cblxuICByZXR1cm4gbmV3UGVlclxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5hZGRXZWJTZWVkID0gZnVuY3Rpb24gKHVybCkge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuXG4gIGlmICghL15odHRwcz86XFwvXFwvLisvLnRlc3QodXJsKSkge1xuICAgIHRoaXMuX2RlYnVnKCdpZ25vcmluZyBpbnZhbGlkIHdlYiBzZWVkICVzJywgdXJsKVxuICAgIHRoaXMuZW1pdCgnaW52YWxpZFBlZXInLCB1cmwpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodGhpcy5fcGVlcnNbdXJsXSkge1xuICAgIHRoaXMuX2RlYnVnKCdpZ25vcmluZyBkdXBsaWNhdGUgd2ViIHNlZWQgJXMnLCB1cmwpXG4gICAgdGhpcy5lbWl0KCdpbnZhbGlkUGVlcicsIHVybClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuX2RlYnVnKCdhZGQgd2ViIHNlZWQgJXMnLCB1cmwpXG5cbiAgdmFyIG5ld1BlZXIgPSBQZWVyLmNyZWF0ZVdlYlNlZWRQZWVyKHVybCwgdGhpcylcbiAgdGhpcy5fcGVlcnNbbmV3UGVlci5pZF0gPSBuZXdQZWVyXG4gIHRoaXMuX3BlZXJzTGVuZ3RoICs9IDFcblxuICB0aGlzLmVtaXQoJ3BlZXInLCB1cmwpXG59XG5cbi8qKlxuICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluY29taW5nIFRDUCBwZWVyIGNvbm5lY3RzIHRvIHRoaXMgdG9ycmVudCBzd2FybS4gQ2FsbGVkIHdpdGggYVxuICogcGVlciB0aGF0IGhhcyBhbHJlYWR5IHNlbnQgYSBoYW5kc2hha2UuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9hZGRJbmNvbWluZ1BlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm4gcGVlci5kZXN0cm95KG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKSlcbiAgaWYgKHNlbGYucGF1c2VkKSByZXR1cm4gcGVlci5kZXN0cm95KG5ldyBFcnJvcigndG9ycmVudCBpcyBwYXVzZWQnKSlcblxuICB0aGlzLl9kZWJ1ZygnYWRkIGluY29taW5nIHBlZXIgJXMnLCBwZWVyLmlkKVxuXG4gIHNlbGYuX3BlZXJzW3BlZXIuaWRdID0gcGVlclxuICBzZWxmLl9wZWVyc0xlbmd0aCArPSAxXG59XG5cblRvcnJlbnQucHJvdG90eXBlLnJlbW92ZVBlZXIgPSBmdW5jdGlvbiAocGVlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGlkID0gKHBlZXIgJiYgcGVlci5pZCkgfHwgcGVlclxuICBwZWVyID0gc2VsZi5fcGVlcnNbaWRdXG5cbiAgaWYgKCFwZWVyKSByZXR1cm5cblxuICB0aGlzLl9kZWJ1ZygncmVtb3ZlUGVlciAlcycsIGlkKVxuXG4gIGRlbGV0ZSBzZWxmLl9wZWVyc1tpZF1cbiAgc2VsZi5fcGVlcnNMZW5ndGggLT0gMVxuXG4gIHBlZXIuZGVzdHJveSgpXG5cbiAgLy8gSWYgdG9ycmVudCBzd2FybSB3YXMgYXQgY2FwYWNpdHkgYmVmb3JlLCB0cnkgdG8gb3BlbiBhIG5ldyBjb25uZWN0aW9uIG5vd1xuICBzZWxmLl9kcmFpbigpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcmlvcml0eSwgbm90aWZ5KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcigndG9ycmVudCBpcyBkZXN0cm95ZWQnKVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kIDwgc3RhcnQgfHwgc2VsZi5waWVjZXMubGVuZ3RoIDw9IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZWxlY3Rpb24gJywgc3RhcnQsICc6JywgZW5kKVxuICB9XG4gIHByaW9yaXR5ID0gTnVtYmVyKHByaW9yaXR5KSB8fCAwXG5cbiAgc2VsZi5fZGVidWcoJ3NlbGVjdCAlcy0lcyAocHJpb3JpdHkgJXMpJywgc3RhcnQsIGVuZCwgcHJpb3JpdHkpXG5cbiAgc2VsZi5fc2VsZWN0aW9ucy5wdXNoKHtcbiAgICBmcm9tOiBzdGFydCxcbiAgICB0bzogZW5kLFxuICAgIG9mZnNldDogMCxcbiAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgbm90aWZ5OiBub3RpZnkgfHwgbm9vcFxuICB9KVxuXG4gIHNlbGYuX3NlbGVjdGlvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eVxuICB9KVxuXG4gIHNlbGYuX3VwZGF0ZVNlbGVjdGlvbnMoKVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcmlvcml0eSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcblxuICBwcmlvcml0eSA9IE51bWJlcihwcmlvcml0eSkgfHwgMFxuICBzZWxmLl9kZWJ1ZygnZGVzZWxlY3QgJXMtJXMgKHByaW9yaXR5ICVzKScsIHN0YXJ0LCBlbmQsIHByaW9yaXR5KVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBzID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuICAgIGlmIChzLmZyb20gPT09IHN0YXJ0ICYmIHMudG8gPT09IGVuZCAmJiBzLnByaW9yaXR5ID09PSBwcmlvcml0eSkge1xuICAgICAgc2VsZi5fc2VsZWN0aW9ucy5zcGxpY2UoaS0tLCAxKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBzZWxmLl91cGRhdGVTZWxlY3Rpb25zKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuY3JpdGljYWwgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ3RvcnJlbnQgaXMgZGVzdHJveWVkJylcblxuICBzZWxmLl9kZWJ1ZygnY3JpdGljYWwgJXMtJXMnLCBzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHNlbGYuX2NyaXRpY2FsW2ldID0gdHJ1ZVxuICB9XG5cbiAgc2VsZi5fdXBkYXRlU2VsZWN0aW9ucygpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9vbldpcmUgPSBmdW5jdGlvbiAod2lyZSwgYWRkcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVidWcoJ2dvdCB3aXJlICVzICglcyknLCB3aXJlLl9kZWJ1Z0lkLCBhZGRyIHx8ICdVbmtub3duJylcblxuICB3aXJlLm9uKCdkb3dubG9hZCcsIGZ1bmN0aW9uIChkb3dubG9hZGVkKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzZWxmLnJlY2VpdmVkICs9IGRvd25sb2FkZWRcbiAgICBzZWxmLl9kb3dubG9hZFNwZWVkKGRvd25sb2FkZWQpXG4gICAgc2VsZi5jbGllbnQuX2Rvd25sb2FkU3BlZWQoZG93bmxvYWRlZClcbiAgICBzZWxmLmVtaXQoJ2Rvd25sb2FkJywgZG93bmxvYWRlZClcbiAgICBzZWxmLmNsaWVudC5lbWl0KCdkb3dubG9hZCcsIGRvd25sb2FkZWQpXG4gIH0pXG5cbiAgd2lyZS5vbigndXBsb2FkJywgZnVuY3Rpb24gKHVwbG9hZGVkKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzZWxmLnVwbG9hZGVkICs9IHVwbG9hZGVkXG4gICAgc2VsZi5fdXBsb2FkU3BlZWQodXBsb2FkZWQpXG4gICAgc2VsZi5jbGllbnQuX3VwbG9hZFNwZWVkKHVwbG9hZGVkKVxuICAgIHNlbGYuZW1pdCgndXBsb2FkJywgdXBsb2FkZWQpXG4gICAgc2VsZi5jbGllbnQuZW1pdCgndXBsb2FkJywgdXBsb2FkZWQpXG4gIH0pXG5cbiAgc2VsZi53aXJlcy5wdXNoKHdpcmUpXG5cbiAgaWYgKGFkZHIpIHtcbiAgICAvLyBTb21ldGltZXMgUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMoKSBkb2Vzbid0IHJldHVybiBhbiBpcDpwb3J0IGZvciBwZWVyc1xuICAgIHZhciBwYXJ0cyA9IGFkZHJUb0lQUG9ydChhZGRyKVxuICAgIHdpcmUucmVtb3RlQWRkcmVzcyA9IHBhcnRzWzBdXG4gICAgd2lyZS5yZW1vdGVQb3J0ID0gcGFydHNbMV1cbiAgfVxuXG4gIC8vIFdoZW4gcGVlciBzZW5kcyBQT1JUIG1lc3NhZ2UsIGFkZCB0aGF0IERIVCBub2RlIHRvIHJvdXRpbmcgdGFibGVcbiAgaWYgKHNlbGYuY2xpZW50LmRodCAmJiBzZWxmLmNsaWVudC5kaHQubGlzdGVuaW5nKSB7XG4gICAgd2lyZS5vbigncG9ydCcsIGZ1bmN0aW9uIChwb3J0KSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cm95ZWQgfHwgc2VsZi5jbGllbnQuZGh0LmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghd2lyZS5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9kZWJ1ZygnaWdub3JpbmcgUE9SVCBmcm9tIHBlZXIgd2l0aCBubyBhZGRyZXNzJylcbiAgICAgIH1cbiAgICAgIGlmIChwb3J0ID09PSAwIHx8IHBvcnQgPiA2NTUzNikge1xuICAgICAgICByZXR1cm4gc2VsZi5fZGVidWcoJ2lnbm9yaW5nIGludmFsaWQgUE9SVCBmcm9tIHBlZXInKVxuICAgICAgfVxuXG4gICAgICBzZWxmLl9kZWJ1ZygncG9ydDogJXMgKGZyb20gJXMpJywgcG9ydCwgYWRkcilcbiAgICAgIHNlbGYuY2xpZW50LmRodC5hZGROb2RlKHsgaG9zdDogd2lyZS5yZW1vdGVBZGRyZXNzLCBwb3J0OiBwb3J0IH0pXG4gICAgfSlcbiAgfVxuXG4gIHdpcmUub24oJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fZGVidWcoJ3dpcmUgdGltZW91dCAoJXMpJywgYWRkcilcbiAgICAvLyBUT0RPOiB0aGlzIG1pZ2h0IGJlIGRlc3Ryb3lpbmcgd2lyZXMgdG9vIGVhZ2VybHlcbiAgICB3aXJlLmRlc3Ryb3koKVxuICB9KVxuXG4gIC8vIFRpbWVvdXQgZm9yIHBpZWNlIHJlcXVlc3RzIHRvIHRoaXMgcGVlclxuICB3aXJlLnNldFRpbWVvdXQoUElFQ0VfVElNRU9VVCwgdHJ1ZSlcblxuICAvLyBTZW5kIEtFRVAtQUxJVkUgKGV2ZXJ5IDYwcykgc28gcGVlcnMgd2lsbCBub3QgZGlzY29ubmVjdCB0aGUgd2lyZVxuICB3aXJlLnNldEtlZXBBbGl2ZSh0cnVlKVxuXG4gIC8vIHVzZSB1dF9tZXRhZGF0YSBleHRlbnNpb25cbiAgd2lyZS51c2UodXRNZXRhZGF0YShzZWxmLm1ldGFkYXRhKSlcblxuICB3aXJlLnV0X21ldGFkYXRhLm9uKCd3YXJuaW5nJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYuX2RlYnVnKCd1dF9tZXRhZGF0YSB3YXJuaW5nOiAlcycsIGVyci5tZXNzYWdlKVxuICB9KVxuXG4gIGlmICghc2VsZi5tZXRhZGF0YSkge1xuICAgIHdpcmUudXRfbWV0YWRhdGEub24oJ21ldGFkYXRhJywgZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICBzZWxmLl9kZWJ1ZygnZ290IG1ldGFkYXRhIHZpYSB1dF9tZXRhZGF0YScpXG4gICAgICBzZWxmLl9vbk1ldGFkYXRhKG1ldGFkYXRhKVxuICAgIH0pXG4gICAgd2lyZS51dF9tZXRhZGF0YS5mZXRjaCgpXG4gIH1cblxuICAvLyB1c2UgdXRfcGV4IGV4dGVuc2lvbiBpZiB0aGUgdG9ycmVudCBpcyBub3QgZmxhZ2dlZCBhcyBwcml2YXRlXG4gIGlmICh0eXBlb2YgdXRQZXggPT09ICdmdW5jdGlvbicgJiYgIXNlbGYucHJpdmF0ZSkge1xuICAgIHdpcmUudXNlKHV0UGV4KCkpXG5cbiAgICB3aXJlLnV0X3BleC5vbigncGVlcicsIGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgICAvLyBPbmx5IGFkZCBwb3RlbnRpYWwgbmV3IHBlZXJzIHdoZW4gd2UncmUgbm90IHNlZWRpbmdcbiAgICAgIGlmIChzZWxmLmRvbmUpIHJldHVyblxuICAgICAgc2VsZi5fZGVidWcoJ3V0X3BleDogZ290IHBlZXI6ICVzIChmcm9tICVzKScsIHBlZXIsIGFkZHIpXG4gICAgICBzZWxmLmFkZFBlZXIocGVlcilcbiAgICB9KVxuXG4gICAgd2lyZS51dF9wZXgub24oJ2Ryb3BwZWQnLCBmdW5jdGlvbiAocGVlcikge1xuICAgICAgLy8gdGhlIHJlbW90ZSBwZWVyIGJlbGlldmVzIGEgZ2l2ZW4gcGVlciBoYXMgYmVlbiBkcm9wcGVkIGZyb20gdGhlIHRvcnJlbnQgc3dhcm0uXG4gICAgICAvLyBpZiB3ZSdyZSBub3QgY3VycmVudGx5IGNvbm5lY3RlZCB0byBpdCwgdGhlbiByZW1vdmUgaXQgZnJvbSB0aGUgcXVldWUuXG4gICAgICB2YXIgcGVlck9iaiA9IHNlbGYuX3BlZXJzW3BlZXJdXG4gICAgICBpZiAocGVlck9iaiAmJiAhcGVlck9iai5jb25uZWN0ZWQpIHtcbiAgICAgICAgc2VsZi5fZGVidWcoJ3V0X3BleDogZHJvcHBlZCBwZWVyOiAlcyAoZnJvbSAlcyknLCBwZWVyLCBhZGRyKVxuICAgICAgICBzZWxmLnJlbW92ZVBlZXIocGVlcilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgd2lyZS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFN0b3Agc2VuZGluZyB1cGRhdGVzIHRvIHJlbW90ZSBwZWVyXG4gICAgICB3aXJlLnV0X3BleC5yZXNldCgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIEhvb2sgdG8gYWxsb3cgdXNlci1kZWZpbmVkIGBiaXR0b3JyZW50LXByb3RvY29sYCBleHRlbnNpb25zXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9iaXR0b3JyZW50LXByb3RvY29sI2V4dGVuc2lvbi1hcGlcbiAgc2VsZi5lbWl0KCd3aXJlJywgd2lyZSwgYWRkcilcblxuICBpZiAoc2VsZi5tZXRhZGF0YSkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVGhpcyBhbGxvd3Mgd2lyZS5oYW5kc2hha2UoKSB0byBiZSBjYWxsZWQgKGJ5IFBlZXIub25IYW5kc2hha2UpIGJlZm9yZSBhbnlcbiAgICAgIC8vIG1lc3NhZ2VzIGdldCBzZW50IG9uIHRoZSB3aXJlXG4gICAgICBzZWxmLl9vbldpcmVXaXRoTWV0YWRhdGEod2lyZSlcbiAgICB9KVxuICB9XG59XG5cblRvcnJlbnQucHJvdG90eXBlLl9vbldpcmVXaXRoTWV0YWRhdGEgPSBmdW5jdGlvbiAod2lyZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHRpbWVvdXRJZCA9IG51bGxcblxuICBmdW5jdGlvbiBvbkNob2tlVGltZW91dCAoKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkIHx8IHdpcmUuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIGlmIChzZWxmLl9udW1RdWV1ZWQgPiAyICogKHNlbGYuX251bUNvbm5zIC0gc2VsZi5udW1QZWVycykgJiZcbiAgICAgIHdpcmUuYW1JbnRlcmVzdGVkKSB7XG4gICAgICB3aXJlLmRlc3Ryb3koKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KG9uQ2hva2VUaW1lb3V0LCBDSE9LRV9USU1FT1VUKVxuICAgICAgaWYgKHRpbWVvdXRJZC51bnJlZikgdGltZW91dElkLnVucmVmKClcbiAgICB9XG4gIH1cblxuICB2YXIgaSA9IDBcbiAgZnVuY3Rpb24gdXBkYXRlU2VlZFN0YXR1cyAoKSB7XG4gICAgaWYgKHdpcmUucGVlclBpZWNlcy5sZW5ndGggIT09IHNlbGYucGllY2VzLmxlbmd0aCkgcmV0dXJuXG4gICAgZm9yICg7IGkgPCBzZWxmLnBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCF3aXJlLnBlZXJQaWVjZXMuZ2V0KGkpKSByZXR1cm5cbiAgICB9XG4gICAgd2lyZS5pc1NlZWRlciA9IHRydWVcbiAgICB3aXJlLmNob2tlKCkgLy8gYWx3YXlzIGNob2tlIHNlZWRlcnNcbiAgfVxuXG4gIHdpcmUub24oJ2JpdGZpZWxkJywgZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZVNlZWRTdGF0dXMoKVxuICAgIHNlbGYuX3VwZGF0ZSgpXG4gIH0pXG5cbiAgd2lyZS5vbignaGF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVTZWVkU3RhdHVzKClcbiAgICBzZWxmLl91cGRhdGUoKVxuICB9KVxuXG4gIHdpcmUub25jZSgnaW50ZXJlc3RlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB3aXJlLnVuY2hva2UoKVxuICB9KVxuXG4gIHdpcmUub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgfSlcblxuICB3aXJlLm9uKCdjaG9rZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQob25DaG9rZVRpbWVvdXQsIENIT0tFX1RJTUVPVVQpXG4gICAgaWYgKHRpbWVvdXRJZC51bnJlZikgdGltZW91dElkLnVucmVmKClcbiAgfSlcblxuICB3aXJlLm9uKCd1bmNob2tlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgc2VsZi5fdXBkYXRlKClcbiAgfSlcblxuICB3aXJlLm9uKCdyZXF1ZXN0JywgZnVuY3Rpb24gKGluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2IpIHtcbiAgICBpZiAobGVuZ3RoID4gTUFYX0JMT0NLX0xFTkdUSCkge1xuICAgICAgLy8gUGVyIHNwZWMsIGRpc2Nvbm5lY3QgZnJvbSBwZWVycyB0aGF0IHJlcXVlc3QgPjEyOEtCXG4gICAgICByZXR1cm4gd2lyZS5kZXN0cm95KClcbiAgICB9XG4gICAgaWYgKHNlbGYucGllY2VzW2luZGV4XSkgcmV0dXJuXG4gICAgc2VsZi5zdG9yZS5nZXQoaW5kZXgsIHsgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoIH0sIGNiKVxuICB9KVxuXG4gIHdpcmUuYml0ZmllbGQoc2VsZi5iaXRmaWVsZCkgLy8gYWx3YXlzIHNlbmQgYml0ZmllbGQgKHJlcXVpcmVkKVxuICB3aXJlLmludGVyZXN0ZWQoKSAvLyBhbHdheXMgc3RhcnQgb3V0IGludGVyZXN0ZWRcblxuICAvLyBTZW5kIFBPUlQgbWVzc2FnZSB0byBwZWVycyB0aGF0IHN1cHBvcnQgREhUXG4gIGlmICh3aXJlLnBlZXJFeHRlbnNpb25zLmRodCAmJiBzZWxmLmNsaWVudC5kaHQgJiYgc2VsZi5jbGllbnQuZGh0Lmxpc3RlbmluZykge1xuICAgIHdpcmUucG9ydChzZWxmLmNsaWVudC5kaHQuYWRkcmVzcygpLnBvcnQpXG4gIH1cblxuICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KG9uQ2hva2VUaW1lb3V0LCBDSE9LRV9USU1FT1VUKVxuICBpZiAodGltZW91dElkLnVucmVmKSB0aW1lb3V0SWQudW5yZWYoKVxuXG4gIHdpcmUuaXNTZWVkZXIgPSBmYWxzZVxuICB1cGRhdGVTZWVkU3RhdHVzKClcbn1cblxuLyoqXG4gKiBDYWxsZWQgb24gc2VsZWN0aW9uIGNoYW5nZXMuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl91cGRhdGVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLnJlYWR5IHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9nY1NlbGVjdGlvbnMoKVxuICB9KVxuICBzZWxmLl91cGRhdGVJbnRlcmVzdCgpXG4gIHNlbGYuX3VwZGF0ZSgpXG59XG5cbi8qKlxuICogR2FyYmFnZSBjb2xsZWN0IHNlbGVjdGlvbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBzdG9yZSdzIGN1cnJlbnQgc3RhdGUuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9nY1NlbGVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuICAgIHZhciBvbGRPZmZzZXQgPSBzLm9mZnNldFxuXG4gICAgLy8gY2hlY2sgZm9yIG5ld2x5IGRvd25sb2FkZWQgcGllY2VzIGluIHNlbGVjdGlvblxuICAgIHdoaWxlIChzZWxmLmJpdGZpZWxkLmdldChzLmZyb20gKyBzLm9mZnNldCkgJiYgcy5mcm9tICsgcy5vZmZzZXQgPCBzLnRvKSB7XG4gICAgICBzLm9mZnNldCsrXG4gICAgfVxuXG4gICAgaWYgKG9sZE9mZnNldCAhPT0gcy5vZmZzZXQpIHMubm90aWZ5KClcbiAgICBpZiAocy50byAhPT0gcy5mcm9tICsgcy5vZmZzZXQpIGNvbnRpbnVlXG4gICAgaWYgKCFzZWxmLmJpdGZpZWxkLmdldChzLmZyb20gKyBzLm9mZnNldCkpIGNvbnRpbnVlXG5cbiAgICAvLyByZW1vdmUgZnVsbHkgZG93bmxvYWRlZCBzZWxlY3Rpb25cbiAgICBzZWxmLl9zZWxlY3Rpb25zLnNwbGljZShpLS0sIDEpIC8vIGRlY3JlbWVudCBpIHRvIG9mZnNldCBzcGxpY2VcbiAgICBzLm5vdGlmeSgpIC8vIFRPRE86IHRoaXMgbWF5IG5vdGlmeSB0d2ljZSBpbiBhIHJvdy4gaXMgdGhpcyBhIHByb2JsZW0/XG4gICAgc2VsZi5fdXBkYXRlSW50ZXJlc3QoKVxuICB9XG5cbiAgaWYgKCFzZWxmLl9zZWxlY3Rpb25zLmxlbmd0aCkgc2VsZi5lbWl0KCdpZGxlJylcbn1cblxuLyoqXG4gKiBVcGRhdGUgaW50ZXJlc3RlZCBzdGF0dXMgZm9yIGFsbCBwZWVycy5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3VwZGF0ZUludGVyZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgcHJldiA9IHNlbGYuX2FtSW50ZXJlc3RlZFxuICBzZWxmLl9hbUludGVyZXN0ZWQgPSAhIXNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoXG5cbiAgc2VsZi53aXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgLy8gVE9ETzogb25seSBjYWxsIHdpcmUuaW50ZXJlc3RlZCBpZiB0aGUgd2lyZSBoYXMgYXQgbGVhc3Qgb25lIHBpZWNlIHdlIG5lZWRcbiAgICBpZiAoc2VsZi5fYW1JbnRlcmVzdGVkKSB3aXJlLmludGVyZXN0ZWQoKVxuICAgIGVsc2Ugd2lyZS51bmludGVyZXN0ZWQoKVxuICB9KVxuXG4gIGlmIChwcmV2ID09PSBzZWxmLl9hbUludGVyZXN0ZWQpIHJldHVyblxuICBpZiAoc2VsZi5fYW1JbnRlcmVzdGVkKSBzZWxmLmVtaXQoJ2ludGVyZXN0ZWQnKVxuICBlbHNlIHNlbGYuZW1pdCgndW5pbnRlcmVzdGVkJylcbn1cblxuLyoqXG4gKiBIZWFydGJlYXQgdG8gdXBkYXRlIGFsbCBwZWVycyBhbmQgdGhlaXIgcmVxdWVzdHMuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIC8vIHVwZGF0ZSB3aXJlcyBpbiByYW5kb20gb3JkZXIgZm9yIGJldHRlciByZXF1ZXN0IGRpc3RyaWJ1dGlvblxuICB2YXIgaXRlID0gcmFuZG9tSXRlcmF0ZShzZWxmLndpcmVzKVxuICB2YXIgd2lyZVxuICB3aGlsZSAoKHdpcmUgPSBpdGUoKSkpIHtcbiAgICBzZWxmLl91cGRhdGVXaXJlKHdpcmUpXG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byB1cGRhdGUgYSBwZWVyJ3MgcmVxdWVzdHNcbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3VwZGF0ZVdpcmUgPSBmdW5jdGlvbiAod2lyZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAod2lyZS5wZWVyQ2hva2luZykgcmV0dXJuXG4gIGlmICghd2lyZS5kb3dubG9hZGVkKSByZXR1cm4gdmFsaWRhdGVXaXJlKClcblxuICB2YXIgbWluT3V0c3RhbmRpbmdSZXF1ZXN0cyA9IGdldEJsb2NrUGlwZWxpbmVMZW5ndGgod2lyZSwgUElQRUxJTkVfTUlOX0RVUkFUSU9OKVxuICBpZiAod2lyZS5yZXF1ZXN0cy5sZW5ndGggPj0gbWluT3V0c3RhbmRpbmdSZXF1ZXN0cykgcmV0dXJuXG4gIHZhciBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzID0gZ2V0QmxvY2tQaXBlbGluZUxlbmd0aCh3aXJlLCBQSVBFTElORV9NQVhfRFVSQVRJT04pXG5cbiAgdHJ5U2VsZWN0V2lyZShmYWxzZSkgfHwgdHJ5U2VsZWN0V2lyZSh0cnVlKVxuXG4gIGZ1bmN0aW9uIGdlblBpZWNlRmlsdGVyRnVuYyAoc3RhcnQsIGVuZCwgdHJpZWQsIHJhbmspIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpID49IHN0YXJ0ICYmIGkgPD0gZW5kICYmICEoaSBpbiB0cmllZCkgJiYgd2lyZS5wZWVyUGllY2VzLmdldChpKSAmJiAoIXJhbmsgfHwgcmFuayhpKSlcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBEbyB3ZSBuZWVkIGJvdGggdmFsaWRhdGVXaXJlIGFuZCB0cnlTZWxlY3RXaXJlP1xuICBmdW5jdGlvbiB2YWxpZGF0ZVdpcmUgKCkge1xuICAgIGlmICh3aXJlLnJlcXVlc3RzLmxlbmd0aCkgcmV0dXJuXG5cbiAgICB2YXIgaSA9IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIG5leHQgPSBzZWxmLl9zZWxlY3Rpb25zW2ldXG4gICAgICB2YXIgcGllY2VcbiAgICAgIGlmIChzZWxmLnN0cmF0ZWd5ID09PSAncmFyZXN0Jykge1xuICAgICAgICB2YXIgc3RhcnQgPSBuZXh0LmZyb20gKyBuZXh0Lm9mZnNldFxuICAgICAgICB2YXIgZW5kID0gbmV4dC50b1xuICAgICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQgKyAxXG4gICAgICAgIHZhciB0cmllZCA9IHt9XG4gICAgICAgIHZhciB0cmllcyA9IDBcbiAgICAgICAgdmFyIGZpbHRlciA9IGdlblBpZWNlRmlsdGVyRnVuYyhzdGFydCwgZW5kLCB0cmllZClcblxuICAgICAgICB3aGlsZSAodHJpZXMgPCBsZW4pIHtcbiAgICAgICAgICBwaWVjZSA9IHNlbGYuX3Jhcml0eU1hcC5nZXRSYXJlc3RQaWVjZShmaWx0ZXIpXG4gICAgICAgICAgaWYgKHBpZWNlIDwgMCkgYnJlYWtcbiAgICAgICAgICBpZiAoc2VsZi5fcmVxdWVzdCh3aXJlLCBwaWVjZSwgZmFsc2UpKSByZXR1cm5cbiAgICAgICAgICB0cmllZFtwaWVjZV0gPSB0cnVlXG4gICAgICAgICAgdHJpZXMgKz0gMVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHBpZWNlID0gbmV4dC50bzsgcGllY2UgPj0gbmV4dC5mcm9tICsgbmV4dC5vZmZzZXQ7IC0tcGllY2UpIHtcbiAgICAgICAgICBpZiAoIXdpcmUucGVlclBpZWNlcy5nZXQocGllY2UpKSBjb250aW51ZVxuICAgICAgICAgIGlmIChzZWxmLl9yZXF1ZXN0KHdpcmUsIHBpZWNlLCBmYWxzZSkpIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogd2lyZSBmYWlsZWQgdG8gdmFsaWRhdGUgYXMgdXNlZnVsOyBzaG91bGQgd2UgY2xvc2UgaXQ/XG4gICAgLy8gcHJvYmFibHkgbm90LCBzaW5jZSAnaGF2ZScgYW5kICdiaXRmaWVsZCcgbWVzc2FnZXMgbWlnaHQgYmUgY29taW5nXG4gIH1cblxuICBmdW5jdGlvbiBzcGVlZFJhbmtlciAoKSB7XG4gICAgdmFyIHNwZWVkID0gd2lyZS5kb3dubG9hZFNwZWVkKCkgfHwgMVxuICAgIGlmIChzcGVlZCA+IFNQRUVEX1RIUkVTSE9MRCkgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfVxuXG4gICAgdmFyIHNlY3MgPSBNYXRoLm1heCgxLCB3aXJlLnJlcXVlc3RzLmxlbmd0aCkgKiBQaWVjZS5CTE9DS19MRU5HVEggLyBzcGVlZFxuICAgIHZhciB0cmllcyA9IDEwXG4gICAgdmFyIHB0ciA9IDBcblxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIGlmICghdHJpZXMgfHwgc2VsZi5iaXRmaWVsZC5nZXQoaW5kZXgpKSByZXR1cm4gdHJ1ZVxuXG4gICAgICB2YXIgbWlzc2luZyA9IHNlbGYucGllY2VzW2luZGV4XS5taXNzaW5nXG5cbiAgICAgIGZvciAoOyBwdHIgPCBzZWxmLndpcmVzLmxlbmd0aDsgcHRyKyspIHtcbiAgICAgICAgdmFyIG90aGVyV2lyZSA9IHNlbGYud2lyZXNbcHRyXVxuICAgICAgICB2YXIgb3RoZXJTcGVlZCA9IG90aGVyV2lyZS5kb3dubG9hZFNwZWVkKClcblxuICAgICAgICBpZiAob3RoZXJTcGVlZCA8IFNQRUVEX1RIUkVTSE9MRCkgY29udGludWVcbiAgICAgICAgaWYgKG90aGVyU3BlZWQgPD0gc3BlZWQpIGNvbnRpbnVlXG4gICAgICAgIGlmICghb3RoZXJXaXJlLnBlZXJQaWVjZXMuZ2V0KGluZGV4KSkgY29udGludWVcbiAgICAgICAgaWYgKChtaXNzaW5nIC09IG90aGVyU3BlZWQgKiBzZWNzKSA+IDApIGNvbnRpbnVlXG5cbiAgICAgICAgdHJpZXMtLVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaHVmZmxlUHJpb3JpdHkgKGkpIHtcbiAgICB2YXIgbGFzdCA9IGlcbiAgICBmb3IgKHZhciBqID0gaTsgaiA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoICYmIHNlbGYuX3NlbGVjdGlvbnNbal0ucHJpb3JpdHk7IGorKykge1xuICAgICAgbGFzdCA9IGpcbiAgICB9XG4gICAgdmFyIHRtcCA9IHNlbGYuX3NlbGVjdGlvbnNbaV1cbiAgICBzZWxmLl9zZWxlY3Rpb25zW2ldID0gc2VsZi5fc2VsZWN0aW9uc1tsYXN0XVxuICAgIHNlbGYuX3NlbGVjdGlvbnNbbGFzdF0gPSB0bXBcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVNlbGVjdFdpcmUgKGhvdHN3YXApIHtcbiAgICBpZiAod2lyZS5yZXF1ZXN0cy5sZW5ndGggPj0gbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cykgcmV0dXJuIHRydWVcbiAgICB2YXIgcmFuayA9IHNwZWVkUmFua2VyKClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fc2VsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBzZWxmLl9zZWxlY3Rpb25zW2ldXG5cbiAgICAgIHZhciBwaWVjZVxuICAgICAgaWYgKHNlbGYuc3RyYXRlZ3kgPT09ICdyYXJlc3QnKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG5leHQuZnJvbSArIG5leHQub2Zmc2V0XG4gICAgICAgIHZhciBlbmQgPSBuZXh0LnRvXG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydCArIDFcbiAgICAgICAgdmFyIHRyaWVkID0ge31cbiAgICAgICAgdmFyIHRyaWVzID0gMFxuICAgICAgICB2YXIgZmlsdGVyID0gZ2VuUGllY2VGaWx0ZXJGdW5jKHN0YXJ0LCBlbmQsIHRyaWVkLCByYW5rKVxuXG4gICAgICAgIHdoaWxlICh0cmllcyA8IGxlbikge1xuICAgICAgICAgIHBpZWNlID0gc2VsZi5fcmFyaXR5TWFwLmdldFJhcmVzdFBpZWNlKGZpbHRlcilcbiAgICAgICAgICBpZiAocGllY2UgPCAwKSBicmVha1xuXG4gICAgICAgICAgLy8gcmVxdWVzdCBhbGwgbm9uLXJlc2VydmVkIGJsb2NrcyBpbiB0aGlzIHBpZWNlXG4gICAgICAgICAgd2hpbGUgKHNlbGYuX3JlcXVlc3Qod2lyZSwgcGllY2UsIHNlbGYuX2NyaXRpY2FsW3BpZWNlXSB8fCBob3Rzd2FwKSkge31cblxuICAgICAgICAgIGlmICh3aXJlLnJlcXVlc3RzLmxlbmd0aCA8IG1heE91dHN0YW5kaW5nUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHRyaWVkW3BpZWNlXSA9IHRydWVcbiAgICAgICAgICAgIHRyaWVzKytcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQucHJpb3JpdHkpIHNodWZmbGVQcmlvcml0eShpKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAocGllY2UgPSBuZXh0LmZyb20gKyBuZXh0Lm9mZnNldDsgcGllY2UgPD0gbmV4dC50bzsgcGllY2UrKykge1xuICAgICAgICAgIGlmICghd2lyZS5wZWVyUGllY2VzLmdldChwaWVjZSkgfHwgIXJhbmsocGllY2UpKSBjb250aW51ZVxuXG4gICAgICAgICAgLy8gcmVxdWVzdCBhbGwgbm9uLXJlc2VydmVkIGJsb2NrcyBpbiBwaWVjZVxuICAgICAgICAgIHdoaWxlIChzZWxmLl9yZXF1ZXN0KHdpcmUsIHBpZWNlLCBzZWxmLl9jcml0aWNhbFtwaWVjZV0gfHwgaG90c3dhcCkpIHt9XG5cbiAgICAgICAgICBpZiAod2lyZS5yZXF1ZXN0cy5sZW5ndGggPCBtYXhPdXRzdGFuZGluZ1JlcXVlc3RzKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG5leHQucHJpb3JpdHkpIHNodWZmbGVQcmlvcml0eShpKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIENhbGxlZCBwZXJpb2RpY2FsbHkgdG8gdXBkYXRlIHRoZSBjaG9rZWQgc3RhdHVzIG9mIGFsbCBwZWVycywgaGFuZGxpbmcgb3B0aW1pc3RpY1xuICogdW5jaG9raW5nIGFzIGRlc2NyaWJlZCBpbiBCRVAzLlxuICovXG5Ub3JyZW50LnByb3RvdHlwZS5fcmVjaG9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5yZWFkeSkgcmV0dXJuXG5cbiAgaWYgKHNlbGYuX3JlY2hva2VPcHRpbWlzdGljVGltZSA+IDApIHNlbGYuX3JlY2hva2VPcHRpbWlzdGljVGltZSAtPSAxXG4gIGVsc2Ugc2VsZi5fcmVjaG9rZU9wdGltaXN0aWNXaXJlID0gbnVsbFxuXG4gIHZhciBwZWVycyA9IFtdXG5cbiAgc2VsZi53aXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgaWYgKCF3aXJlLmlzU2VlZGVyICYmIHdpcmUgIT09IHNlbGYuX3JlY2hva2VPcHRpbWlzdGljV2lyZSkge1xuICAgICAgcGVlcnMucHVzaCh7XG4gICAgICAgIHdpcmU6IHdpcmUsXG4gICAgICAgIGRvd25sb2FkU3BlZWQ6IHdpcmUuZG93bmxvYWRTcGVlZCgpLFxuICAgICAgICB1cGxvYWRTcGVlZDogd2lyZS51cGxvYWRTcGVlZCgpLFxuICAgICAgICBzYWx0OiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICBpc0Nob2tlZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcGVlcnMuc29ydChyZWNob2tlU29ydClcblxuICB2YXIgdW5jaG9rZUludGVyZXN0ZWQgPSAwXG4gIHZhciBpID0gMFxuICBmb3IgKDsgaSA8IHBlZXJzLmxlbmd0aCAmJiB1bmNob2tlSW50ZXJlc3RlZCA8IHNlbGYuX3JlY2hva2VOdW1TbG90czsgKytpKSB7XG4gICAgcGVlcnNbaV0uaXNDaG9rZWQgPSBmYWxzZVxuICAgIGlmIChwZWVyc1tpXS53aXJlLnBlZXJJbnRlcmVzdGVkKSB1bmNob2tlSW50ZXJlc3RlZCArPSAxXG4gIH1cblxuICAvLyBPcHRpbWlzdGljYWxseSB1bmNob2tlIGEgcGVlclxuICBpZiAoIXNlbGYuX3JlY2hva2VPcHRpbWlzdGljV2lyZSAmJiBpIDwgcGVlcnMubGVuZ3RoICYmIHNlbGYuX3JlY2hva2VOdW1TbG90cykge1xuICAgIHZhciBjYW5kaWRhdGVzID0gcGVlcnMuc2xpY2UoaSkuZmlsdGVyKGZ1bmN0aW9uIChwZWVyKSB7IHJldHVybiBwZWVyLndpcmUucGVlckludGVyZXN0ZWQgfSlcbiAgICB2YXIgb3B0aW1pc3RpYyA9IGNhbmRpZGF0ZXNbcmFuZG9tSW50KGNhbmRpZGF0ZXMubGVuZ3RoKV1cblxuICAgIGlmIChvcHRpbWlzdGljKSB7XG4gICAgICBvcHRpbWlzdGljLmlzQ2hva2VkID0gZmFsc2VcbiAgICAgIHNlbGYuX3JlY2hva2VPcHRpbWlzdGljV2lyZSA9IG9wdGltaXN0aWMud2lyZVxuICAgICAgc2VsZi5fcmVjaG9rZU9wdGltaXN0aWNUaW1lID0gUkVDSE9LRV9PUFRJTUlTVElDX0RVUkFUSU9OXG4gICAgfVxuICB9XG5cbiAgLy8gVW5jaG9rZSBiZXN0IHBlZXJzXG4gIHBlZXJzLmZvckVhY2goZnVuY3Rpb24gKHBlZXIpIHtcbiAgICBpZiAocGVlci53aXJlLmFtQ2hva2luZyAhPT0gcGVlci5pc0Nob2tlZCkge1xuICAgICAgaWYgKHBlZXIuaXNDaG9rZWQpIHBlZXIud2lyZS5jaG9rZSgpXG4gICAgICBlbHNlIHBlZXIud2lyZS51bmNob2tlKClcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gcmVjaG9rZVNvcnQgKHBlZXJBLCBwZWVyQikge1xuICAgIC8vIFByZWZlciBoaWdoZXIgZG93bmxvYWQgc3BlZWRcbiAgICBpZiAocGVlckEuZG93bmxvYWRTcGVlZCAhPT0gcGVlckIuZG93bmxvYWRTcGVlZCkge1xuICAgICAgcmV0dXJuIHBlZXJCLmRvd25sb2FkU3BlZWQgLSBwZWVyQS5kb3dubG9hZFNwZWVkXG4gICAgfVxuXG4gICAgLy8gUHJlZmVyIGhpZ2hlciB1cGxvYWQgc3BlZWRcbiAgICBpZiAocGVlckEudXBsb2FkU3BlZWQgIT09IHBlZXJCLnVwbG9hZFNwZWVkKSB7XG4gICAgICByZXR1cm4gcGVlckIudXBsb2FkU3BlZWQgLSBwZWVyQS51cGxvYWRTcGVlZFxuICAgIH1cblxuICAgIC8vIFByZWZlciB1bmNob2tlZFxuICAgIGlmIChwZWVyQS53aXJlLmFtQ2hva2luZyAhPT0gcGVlckIud2lyZS5hbUNob2tpbmcpIHtcbiAgICAgIHJldHVybiBwZWVyQS53aXJlLmFtQ2hva2luZyA/IDEgOiAtMVxuICAgIH1cblxuICAgIC8vIFJhbmRvbSBvcmRlclxuICAgIHJldHVybiBwZWVyQS5zYWx0IC0gcGVlckIuc2FsdFxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY2FuY2VsIGEgc2xvdyBibG9jayByZXF1ZXN0IGZyb20gYW5vdGhlciB3aXJlIHN1Y2ggdGhhdCB0aGVcbiAqIGdpdmVuIHdpcmUgbWF5IGVmZmVjdGl2ZWx5IHN3YXAgb3V0IHRoZSByZXF1ZXN0IGZvciBvbmUgb2YgaXRzIG93bi5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX2hvdHN3YXAgPSBmdW5jdGlvbiAod2lyZSwgaW5kZXgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIHNwZWVkID0gd2lyZS5kb3dubG9hZFNwZWVkKClcbiAgaWYgKHNwZWVkIDwgUGllY2UuQkxPQ0tfTEVOR1RIKSByZXR1cm4gZmFsc2VcbiAgaWYgKCFzZWxmLl9yZXNlcnZhdGlvbnNbaW5kZXhdKSByZXR1cm4gZmFsc2VcblxuICB2YXIgciA9IHNlbGYuX3Jlc2VydmF0aW9uc1tpbmRleF1cbiAgaWYgKCFyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgbWluU3BlZWQgPSBJbmZpbml0eVxuICB2YXIgbWluV2lyZVxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyV2lyZSA9IHJbaV1cbiAgICBpZiAoIW90aGVyV2lyZSB8fCBvdGhlcldpcmUgPT09IHdpcmUpIGNvbnRpbnVlXG5cbiAgICB2YXIgb3RoZXJTcGVlZCA9IG90aGVyV2lyZS5kb3dubG9hZFNwZWVkKClcbiAgICBpZiAob3RoZXJTcGVlZCA+PSBTUEVFRF9USFJFU0hPTEQpIGNvbnRpbnVlXG4gICAgaWYgKDIgKiBvdGhlclNwZWVkID4gc3BlZWQgfHwgb3RoZXJTcGVlZCA+IG1pblNwZWVkKSBjb250aW51ZVxuXG4gICAgbWluV2lyZSA9IG90aGVyV2lyZVxuICAgIG1pblNwZWVkID0gb3RoZXJTcGVlZFxuICB9XG5cbiAgaWYgKCFtaW5XaXJlKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyW2ldID09PSBtaW5XaXJlKSByW2ldID0gbnVsbFxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG1pbldpcmUucmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVxID0gbWluV2lyZS5yZXF1ZXN0c1tpXVxuICAgIGlmIChyZXEucGllY2UgIT09IGluZGV4KSBjb250aW51ZVxuXG4gICAgc2VsZi5waWVjZXNbaW5kZXhdLmNhbmNlbCgocmVxLm9mZnNldCAvIFBpZWNlLkJMT0NLX0xFTkdUSCkgfCAwKVxuICB9XG5cbiAgc2VsZi5lbWl0KCdob3Rzd2FwJywgbWluV2lyZSwgd2lyZSwgaW5kZXgpXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVxdWVzdCBhIGJsb2NrIGZyb20gdGhlIGdpdmVuIHdpcmUuXG4gKi9cblRvcnJlbnQucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24gKHdpcmUsIGluZGV4LCBob3Rzd2FwKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbnVtUmVxdWVzdHMgPSB3aXJlLnJlcXVlc3RzLmxlbmd0aFxuICB2YXIgaXNXZWJTZWVkID0gd2lyZS50eXBlID09PSAnd2ViU2VlZCdcblxuICBpZiAoc2VsZi5iaXRmaWVsZC5nZXQoaW5kZXgpKSByZXR1cm4gZmFsc2VcblxuICB2YXIgbWF4T3V0c3RhbmRpbmdSZXF1ZXN0cyA9IGlzV2ViU2VlZFxuICAgID8gTWF0aC5taW4oXG4gICAgICAgIGdldFBpZWNlUGlwZWxpbmVMZW5ndGgod2lyZSwgUElQRUxJTkVfTUFYX0RVUkFUSU9OLCBzZWxmLnBpZWNlTGVuZ3RoKSxcbiAgICAgICAgc2VsZi5tYXhXZWJDb25uc1xuICAgICAgKVxuICAgIDogZ2V0QmxvY2tQaXBlbGluZUxlbmd0aCh3aXJlLCBQSVBFTElORV9NQVhfRFVSQVRJT04pXG5cbiAgaWYgKG51bVJlcXVlc3RzID49IG1heE91dHN0YW5kaW5nUmVxdWVzdHMpIHJldHVybiBmYWxzZVxuICAvLyB2YXIgZW5kR2FtZSA9ICh3aXJlLnJlcXVlc3RzLmxlbmd0aCA9PT0gMCAmJiBzZWxmLnN0b3JlLm51bU1pc3NpbmcgPCAzMClcblxuICB2YXIgcGllY2UgPSBzZWxmLnBpZWNlc1tpbmRleF1cbiAgdmFyIHJlc2VydmF0aW9uID0gaXNXZWJTZWVkID8gcGllY2UucmVzZXJ2ZVJlbWFpbmluZygpIDogcGllY2UucmVzZXJ2ZSgpXG5cbiAgaWYgKHJlc2VydmF0aW9uID09PSAtMSAmJiBob3Rzd2FwICYmIHNlbGYuX2hvdHN3YXAod2lyZSwgaW5kZXgpKSB7XG4gICAgcmVzZXJ2YXRpb24gPSBpc1dlYlNlZWQgPyBwaWVjZS5yZXNlcnZlUmVtYWluaW5nKCkgOiBwaWVjZS5yZXNlcnZlKClcbiAgfVxuICBpZiAocmVzZXJ2YXRpb24gPT09IC0xKSByZXR1cm4gZmFsc2VcblxuICB2YXIgciA9IHNlbGYuX3Jlc2VydmF0aW9uc1tpbmRleF1cbiAgaWYgKCFyKSByID0gc2VsZi5fcmVzZXJ2YXRpb25zW2luZGV4XSA9IFtdXG4gIHZhciBpID0gci5pbmRleE9mKG51bGwpXG4gIGlmIChpID09PSAtMSkgaSA9IHIubGVuZ3RoXG4gIHJbaV0gPSB3aXJlXG5cbiAgdmFyIGNodW5rT2Zmc2V0ID0gcGllY2UuY2h1bmtPZmZzZXQocmVzZXJ2YXRpb24pXG4gIHZhciBjaHVua0xlbmd0aCA9IGlzV2ViU2VlZCA/IHBpZWNlLmNodW5rTGVuZ3RoUmVtYWluaW5nKHJlc2VydmF0aW9uKSA6IHBpZWNlLmNodW5rTGVuZ3RoKHJlc2VydmF0aW9uKVxuXG4gIHdpcmUucmVxdWVzdChpbmRleCwgY2h1bmtPZmZzZXQsIGNodW5rTGVuZ3RoLCBmdW5jdGlvbiBvbkNodW5rIChlcnIsIGNodW5rKSB7XG4gICAgLy8gVE9ETzogd2hhdCBpcyB0aGlzIGZvcj9cbiAgICBpZiAoIXNlbGYucmVhZHkpIHJldHVybiBzZWxmLm9uY2UoJ3JlYWR5JywgZnVuY3Rpb24gKCkgeyBvbkNodW5rKGVyciwgY2h1bmspIH0pXG5cbiAgICBpZiAocltpXSA9PT0gd2lyZSkgcltpXSA9IG51bGxcblxuICAgIGlmIChwaWVjZSAhPT0gc2VsZi5waWVjZXNbaW5kZXhdKSByZXR1cm4gb25VcGRhdGVUaWNrKClcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHNlbGYuX2RlYnVnKFxuICAgICAgICAnZXJyb3IgZ2V0dGluZyBwaWVjZSAlcyAob2Zmc2V0OiAlcyBsZW5ndGg6ICVzKSBmcm9tICVzOiAlcycsXG4gICAgICAgIGluZGV4LCBjaHVua09mZnNldCwgY2h1bmtMZW5ndGgsIHdpcmUucmVtb3RlQWRkcmVzcyArICc6JyArIHdpcmUucmVtb3RlUG9ydCxcbiAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgIClcbiAgICAgIGlzV2ViU2VlZCA/IHBpZWNlLmNhbmNlbFJlbWFpbmluZyhyZXNlcnZhdGlvbikgOiBwaWVjZS5jYW5jZWwocmVzZXJ2YXRpb24pXG4gICAgICBvblVwZGF0ZVRpY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2VsZi5fZGVidWcoXG4gICAgICAnZ290IHBpZWNlICVzIChvZmZzZXQ6ICVzIGxlbmd0aDogJXMpIGZyb20gJXMnLFxuICAgICAgaW5kZXgsIGNodW5rT2Zmc2V0LCBjaHVua0xlbmd0aCwgd2lyZS5yZW1vdGVBZGRyZXNzICsgJzonICsgd2lyZS5yZW1vdGVQb3J0XG4gICAgKVxuXG4gICAgaWYgKCFwaWVjZS5zZXQocmVzZXJ2YXRpb24sIGNodW5rLCB3aXJlKSkgcmV0dXJuIG9uVXBkYXRlVGljaygpXG5cbiAgICB2YXIgYnVmID0gcGllY2UuZmx1c2goKVxuXG4gICAgLy8gVE9ETzogbWlnaHQgbmVlZCB0byBzZXQgc2VsZi5waWVjZXNbaW5kZXhdID0gbnVsbCBoZXJlIHNpbmNlIHNoYTEgaXMgYXN5bmNcblxuICAgIHNoYTEoYnVmLCBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgaWYgKGhhc2ggPT09IHNlbGYuX2hhc2hlc1tpbmRleF0pIHtcbiAgICAgICAgaWYgKCFzZWxmLnBpZWNlc1tpbmRleF0pIHJldHVyblxuICAgICAgICBzZWxmLl9kZWJ1ZygncGllY2UgdmVyaWZpZWQgJXMnLCBpbmRleClcblxuICAgICAgICBzZWxmLnBpZWNlc1tpbmRleF0gPSBudWxsXG4gICAgICAgIHNlbGYuX3Jlc2VydmF0aW9uc1tpbmRleF0gPSBudWxsXG4gICAgICAgIHNlbGYuYml0ZmllbGQuc2V0KGluZGV4LCB0cnVlKVxuXG4gICAgICAgIHNlbGYuc3RvcmUucHV0KGluZGV4LCBidWYpXG5cbiAgICAgICAgc2VsZi53aXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh3aXJlKSB7XG4gICAgICAgICAgd2lyZS5oYXZlKGluZGV4KVxuICAgICAgICB9KVxuXG4gICAgICAgIHNlbGYuX2NoZWNrRG9uZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnBpZWNlc1tpbmRleF0gPSBuZXcgUGllY2UocGllY2UubGVuZ3RoKVxuICAgICAgICBzZWxmLmVtaXQoJ3dhcm5pbmcnLCBuZXcgRXJyb3IoJ1BpZWNlICcgKyBpbmRleCArICcgZmFpbGVkIHZlcmlmaWNhdGlvbicpKVxuICAgICAgfVxuICAgICAgb25VcGRhdGVUaWNrKClcbiAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIG9uVXBkYXRlVGljayAoKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHNlbGYuX3VwZGF0ZSgpIH0pXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5fY2hlY2tEb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICAvLyBhcmUgYW55IG5ldyBmaWxlcyBkb25lP1xuICBzZWxmLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBpZiAoZmlsZS5kb25lKSByZXR1cm5cbiAgICBmb3IgKHZhciBpID0gZmlsZS5fc3RhcnRQaWVjZTsgaSA8PSBmaWxlLl9lbmRQaWVjZTsgKytpKSB7XG4gICAgICBpZiAoIXNlbGYuYml0ZmllbGQuZ2V0KGkpKSByZXR1cm5cbiAgICB9XG4gICAgZmlsZS5kb25lID0gdHJ1ZVxuICAgIGZpbGUuZW1pdCgnZG9uZScpXG4gICAgc2VsZi5fZGVidWcoJ2ZpbGUgZG9uZTogJyArIGZpbGUubmFtZSlcbiAgfSlcblxuICAvLyBpcyB0aGUgdG9ycmVudCBkb25lPyAoaWYgYWxsIGN1cnJlbnQgc2VsZWN0aW9ucyBhcmUgc2F0aXNmaWVkLCBvciB0aGVyZSBhcmVcbiAgLy8gbm8gc2VsZWN0aW9ucywgdGhlbiB0b3JyZW50IGlzIGRvbmUpXG4gIHZhciBkb25lID0gdHJ1ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX3NlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gc2VsZi5fc2VsZWN0aW9uc1tpXVxuICAgIGZvciAodmFyIHBpZWNlID0gc2VsZWN0aW9uLmZyb207IHBpZWNlIDw9IHNlbGVjdGlvbi50bzsgcGllY2UrKykge1xuICAgICAgaWYgKCFzZWxmLmJpdGZpZWxkLmdldChwaWVjZSkpIHtcbiAgICAgICAgZG9uZSA9IGZhbHNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZG9uZSkgYnJlYWtcbiAgfVxuICBpZiAoIXNlbGYuZG9uZSAmJiBkb25lKSB7XG4gICAgc2VsZi5kb25lID0gdHJ1ZVxuICAgIHNlbGYuX2RlYnVnKCd0b3JyZW50IGRvbmU6ICcgKyBzZWxmLmluZm9IYXNoKVxuICAgIGlmIChzZWxmLmRpc2NvdmVyeS50cmFja2VyKSB7XG4gICAgICBzZWxmLmRpc2NvdmVyeS50cmFja2VyLmNvbXBsZXRlKClcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdkb25lJylcbiAgfVxuXG4gIHNlbGYuX2djU2VsZWN0aW9ucygpXG59XG5cblRvcnJlbnQucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoc3RyZWFtcywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG4gIGlmICghc2VsZi5yZWFkeSkgcmV0dXJuIHNlbGYub25jZSgncmVhZHknLCBmdW5jdGlvbiAoKSB7IHNlbGYubG9hZChzdHJlYW1zLCBjYikgfSlcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RyZWFtcykpIHN0cmVhbXMgPSBbIHN0cmVhbXMgXVxuICBpZiAoIWNiKSBjYiA9IG5vb3BcblxuICB2YXIgcmVhZGFibGUgPSBuZXcgTXVsdGlTdHJlYW0oc3RyZWFtcylcbiAgdmFyIHdyaXRhYmxlID0gbmV3IENodW5rU3RvcmVXcml0ZVN0cmVhbShzZWxmLnN0b3JlLCBzZWxmLnBpZWNlTGVuZ3RoKVxuXG4gIHB1bXAocmVhZGFibGUsIHdyaXRhYmxlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBzZWxmLnBpZWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaWVjZSwgaW5kZXgpIHtcbiAgICAgIHNlbGYucGllY2VzW2luZGV4XSA9IG51bGxcbiAgICAgIHNlbGYuX3Jlc2VydmF0aW9uc1tpbmRleF0gPSBudWxsXG4gICAgICBzZWxmLmJpdGZpZWxkLnNldChpbmRleCwgdHJ1ZSlcbiAgICB9KVxuICAgIHNlbGYuX2NoZWNrRG9uZSgpXG4gICAgY2IobnVsbClcbiAgfSlcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuY3JlYXRlU2VydmVyID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBTZXJ2ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignbm9kZS5qcy1vbmx5IG1ldGhvZCcpXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCd0b3JyZW50IGlzIGRlc3Ryb3llZCcpXG4gIHZhciBzZXJ2ZXIgPSBuZXcgU2VydmVyKHRoaXMsIG9wdHMpXG4gIHRoaXMuX3NlcnZlcnMucHVzaChzZXJ2ZXIpXG4gIHJldHVybiBzZXJ2ZXJcbn1cblxuVG9ycmVudC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2RlYnVnKCdwYXVzZScpXG4gIHRoaXMucGF1c2VkID0gdHJ1ZVxufVxuXG5Ub3JyZW50LnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2RlYnVnKCdyZXN1bWUnKVxuICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gIHRoaXMuX2RyYWluKClcbn1cblxuVG9ycmVudC5wcm90b3R5cGUuX2RlYnVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICBhcmdzWzBdID0gJ1snICsgdGhpcy5fZGVidWdJZCArICddICcgKyBhcmdzWzBdXG4gIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3MpXG59XG5cbi8qKlxuICogUG9wIGEgcGVlciBvZmYgdGhlIEZJRk8gcXVldWUgYW5kIGNvbm5lY3QgdG8gaXQuIFdoZW4gX2RyYWluKCkgZ2V0cyBjYWxsZWQsXG4gKiB0aGUgcXVldWUgd2lsbCB1c3VhbGx5IGhhdmUgb25seSBvbmUgcGVlciBpbiBpdCwgZXhjZXB0IHdoZW4gdGhlcmUgYXJlIHRvb1xuICogbWFueSBwZWVycyAob3ZlciBgdGhpcy5tYXhDb25uc2ApIGluIHdoaWNoIGNhc2UgdGhleSB3aWxsIGp1c3Qgc2l0IGluIHRoZVxuICogcXVldWUgdW50aWwgYW5vdGhlciBjb25uZWN0aW9uIGNsb3Nlcy5cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX2RyYWluID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fZGVidWcoJ19kcmFpbiBudW1Db25ucyAlcyBtYXhDb25ucyAlcycsIHNlbGYuX251bUNvbm5zLCBzZWxmLmNsaWVudC5tYXhDb25ucylcbiAgaWYgKHR5cGVvZiBuZXQuY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyB8fCBzZWxmLmRlc3Ryb3llZCB8fCBzZWxmLnBhdXNlZCB8fFxuICAgICAgc2VsZi5fbnVtQ29ubnMgPj0gc2VsZi5jbGllbnQubWF4Q29ubnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl9kZWJ1ZygnZHJhaW4gKCVzIHF1ZXVlZCwgJXMvJXMgcGVlcnMpJywgc2VsZi5fbnVtUXVldWVkLCBzZWxmLm51bVBlZXJzLCBzZWxmLmNsaWVudC5tYXhDb25ucylcblxuICB2YXIgcGVlciA9IHNlbGYuX3F1ZXVlLnNoaWZ0KClcbiAgaWYgKCFwZWVyKSByZXR1cm4gLy8gcXVldWUgY291bGQgYmUgZW1wdHlcblxuICB0aGlzLl9kZWJ1ZygndGNwIGNvbm5lY3QgYXR0ZW1wdCB0byAlcycsIHBlZXIuYWRkcilcblxuICB2YXIgcGFydHMgPSBhZGRyVG9JUFBvcnQocGVlci5hZGRyKVxuICB2YXIgb3B0cyA9IHtcbiAgICBob3N0OiBwYXJ0c1swXSxcbiAgICBwb3J0OiBwYXJ0c1sxXVxuICB9XG5cbiAgdmFyIGNvbm4gPSBwZWVyLmNvbm4gPSBuZXQuY29ubmVjdChvcHRzKVxuXG4gIGNvbm4ub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHsgcGVlci5vbkNvbm5lY3QoKSB9KVxuICBjb25uLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyBwZWVyLmRlc3Ryb3koZXJyKSB9KVxuICBwZWVyLnN0YXJ0Q29ubmVjdFRpbWVvdXQoKVxuXG4gIC8vIFdoZW4gY29ubmVjdGlvbiBjbG9zZXMsIGF0dGVtcHQgcmVjb25uZWN0IGFmdGVyIHRpbWVvdXQgKHdpdGggZXhwb25lbnRpYWwgYmFja29mZilcbiAgY29ubi5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIC8vIFRPRE86IElmIHRvcnJlbnQgaXMgZG9uZSwgZG8gbm90IHRyeSB0byByZWNvbm5lY3QgYWZ0ZXIgYSB0aW1lb3V0XG5cbiAgICBpZiAocGVlci5yZXRyaWVzID49IFJFQ09OTkVDVF9XQUlULmxlbmd0aCkge1xuICAgICAgc2VsZi5fZGVidWcoXG4gICAgICAgICdjb25uICVzIGNsb3NlZDogd2lsbCBub3QgcmUtYWRkIChtYXggJXMgYXR0ZW1wdHMpJyxcbiAgICAgICAgcGVlci5hZGRyLCBSRUNPTk5FQ1RfV0FJVC5sZW5ndGhcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBtcyA9IFJFQ09OTkVDVF9XQUlUW3BlZXIucmV0cmllc11cbiAgICBzZWxmLl9kZWJ1ZyhcbiAgICAgICdjb25uICVzIGNsb3NlZDogd2lsbCByZS1hZGQgdG8gcXVldWUgaW4gJXNtcyAoYXR0ZW1wdCAlcyknLFxuICAgICAgcGVlci5hZGRyLCBtcywgcGVlci5yZXRyaWVzICsgMVxuICAgIClcblxuICAgIHZhciByZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiByZWNvbm5lY3RUaW1lb3V0ICgpIHtcbiAgICAgIHZhciBuZXdQZWVyID0gc2VsZi5fYWRkUGVlcihwZWVyLmFkZHIpXG4gICAgICBpZiAobmV3UGVlcikgbmV3UGVlci5yZXRyaWVzID0gcGVlci5yZXRyaWVzICsgMVxuICAgIH0sIG1zKVxuICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0LnVucmVmKSByZWNvbm5lY3RUaW1lb3V0LnVucmVmKClcbiAgfSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBzdHJpbmcgaXMgdmFsaWQgSVB2NC82IGFkZHJlc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVG9ycmVudC5wcm90b3R5cGUuX3ZhbGlkQWRkciA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHZhciBwYXJ0c1xuICB0cnkge1xuICAgIHBhcnRzID0gYWRkclRvSVBQb3J0KGFkZHIpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaG9zdCA9IHBhcnRzWzBdXG4gIHZhciBwb3J0ID0gcGFydHNbMV1cbiAgcmV0dXJuIHBvcnQgPiAwICYmIHBvcnQgPCA2NTUzNSAmJlxuICAgICEoaG9zdCA9PT0gJzEyNy4wLjAuMScgJiYgcG9ydCA9PT0gdGhpcy5jbGllbnQudG9ycmVudFBvcnQpXG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrUGlwZWxpbmVMZW5ndGggKHdpcmUsIGR1cmF0aW9uKSB7XG4gIHJldHVybiAyICsgTWF0aC5jZWlsKGR1cmF0aW9uICogd2lyZS5kb3dubG9hZFNwZWVkKCkgLyBQaWVjZS5CTE9DS19MRU5HVEgpXG59XG5cbmZ1bmN0aW9uIGdldFBpZWNlUGlwZWxpbmVMZW5ndGggKHdpcmUsIGR1cmF0aW9uLCBwaWVjZUxlbmd0aCkge1xuICByZXR1cm4gMSArIE1hdGguY2VpbChkdXJhdGlvbiAqIHdpcmUuZG93bmxvYWRTcGVlZCgpIC8gcGllY2VMZW5ndGgpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGluIFswLGhpZ2gpXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludCAoaGlnaCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIGhpZ2ggfCAwXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsIm1vZHVsZS5leHBvcnRzID0gV2ViQ29ublxuXG52YXIgQml0RmllbGQgPSByZXF1aXJlKCdiaXRmaWVsZCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnRvcnJlbnQ6d2ViY29ubicpXG52YXIgZ2V0ID0gcmVxdWlyZSgnc2ltcGxlLWdldCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2hhMSA9IHJlcXVpcmUoJ3NpbXBsZS1zaGExJylcbnZhciBXaXJlID0gcmVxdWlyZSgnYml0dG9ycmVudC1wcm90b2NvbCcpXG5cbnZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG5pbmhlcml0cyhXZWJDb25uLCBXaXJlKVxuXG4vKipcbiAqIENvbnZlcnRzIHJlcXVlc3RzIGZvciB0b3JyZW50IGJsb2NrcyBpbnRvIGh0dHAgcmFuZ2UgcmVxdWVzdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHdlYiBzZWVkIHVybFxuICogQHBhcmFtIHtPYmplY3R9IHRvcnJlbnRcbiAqL1xuZnVuY3Rpb24gV2ViQ29ubiAodXJsLCB0b3JyZW50KSB7XG4gIFdpcmUuY2FsbCh0aGlzKVxuXG4gIHRoaXMudXJsID0gdXJsXG4gIHRoaXMud2ViUGVlcklkID0gc2hhMS5zeW5jKHVybClcbiAgdGhpcy5fdG9ycmVudCA9IHRvcnJlbnRcblxuICB0aGlzLl9pbml0KClcbn1cblxuV2ViQ29ubi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLnNldEtlZXBBbGl2ZSh0cnVlKVxuXG4gIHNlbGYub25jZSgnaGFuZHNoYWtlJywgZnVuY3Rpb24gKGluZm9IYXNoLCBwZWVySWQpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNlbGYuaGFuZHNoYWtlKGluZm9IYXNoLCBzZWxmLndlYlBlZXJJZClcbiAgICB2YXIgbnVtUGllY2VzID0gc2VsZi5fdG9ycmVudC5waWVjZXMubGVuZ3RoXG4gICAgdmFyIGJpdGZpZWxkID0gbmV3IEJpdEZpZWxkKG51bVBpZWNlcylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBudW1QaWVjZXM7IGkrKykge1xuICAgICAgYml0ZmllbGQuc2V0KGksIHRydWUpXG4gICAgfVxuICAgIHNlbGYuYml0ZmllbGQoYml0ZmllbGQpXG4gIH0pXG5cbiAgc2VsZi5vbmNlKCdpbnRlcmVzdGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdpbnRlcmVzdGVkJylcbiAgICBzZWxmLnVuY2hva2UoKVxuICB9KVxuXG4gIHNlbGYub24oJ3VuaW50ZXJlc3RlZCcsIGZ1bmN0aW9uICgpIHsgZGVidWcoJ3VuaW50ZXJlc3RlZCcpIH0pXG4gIHNlbGYub24oJ2Nob2tlJywgZnVuY3Rpb24gKCkgeyBkZWJ1ZygnY2hva2UnKSB9KVxuICBzZWxmLm9uKCd1bmNob2tlJywgZnVuY3Rpb24gKCkgeyBkZWJ1ZygndW5jaG9rZScpIH0pXG4gIHNlbGYub24oJ2JpdGZpZWxkJywgZnVuY3Rpb24gKCkgeyBkZWJ1ZygnYml0ZmllbGQnKSB9KVxuXG4gIHNlbGYub24oJ3JlcXVlc3QnLCBmdW5jdGlvbiAocGllY2VJbmRleCwgb2Zmc2V0LCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ3JlcXVlc3QgcGllY2VJbmRleD0lZCBvZmZzZXQ9JWQgbGVuZ3RoPSVkJywgcGllY2VJbmRleCwgb2Zmc2V0LCBsZW5ndGgpXG4gICAgc2VsZi5odHRwUmVxdWVzdChwaWVjZUluZGV4LCBvZmZzZXQsIGxlbmd0aCwgY2FsbGJhY2spXG4gIH0pXG59XG5cbldlYkNvbm4ucHJvdG90eXBlLmh0dHBSZXF1ZXN0ID0gZnVuY3Rpb24gKHBpZWNlSW5kZXgsIG9mZnNldCwgbGVuZ3RoLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHBpZWNlT2Zmc2V0ID0gcGllY2VJbmRleCAqIHNlbGYuX3RvcnJlbnQucGllY2VMZW5ndGhcbiAgdmFyIHJhbmdlU3RhcnQgPSBwaWVjZU9mZnNldCArIG9mZnNldCAvKiBvZmZzZXQgd2l0aGluIHdob2xlIHRvcnJlbnQgKi9cbiAgdmFyIHJhbmdlRW5kID0gcmFuZ2VTdGFydCArIGxlbmd0aCAtIDFcblxuICAvLyBXZWIgc2VlZCBVUkwgZm9ybWF0OlxuICAvLyBGb3Igc2luZ2xlLWZpbGUgdG9ycmVudHMsIG1ha2UgSFRUUCByYW5nZSByZXF1ZXN0cyBkaXJlY3RseSB0byB0aGUgd2ViIHNlZWQgVVJMXG4gIC8vIEZvciBtdWx0aS1maWxlIHRvcnJlbnRzLCBhZGQgdGhlIHRvcnJlbnQgZm9sZGVyIGFuZCBmaWxlIG5hbWUgdG8gdGhlIFVSTFxuICB2YXIgZmlsZXMgPSBzZWxmLl90b3JyZW50LmZpbGVzXG4gIHZhciByZXF1ZXN0c1xuICBpZiAoZmlsZXMubGVuZ3RoIDw9IDEpIHtcbiAgICByZXF1ZXN0cyA9IFt7XG4gICAgICB1cmw6IHNlbGYudXJsLFxuICAgICAgc3RhcnQ6IHJhbmdlU3RhcnQsXG4gICAgICBlbmQ6IHJhbmdlRW5kXG4gICAgfV1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVxdWVzdGVkRmlsZXMgPSBmaWxlcy5maWx0ZXIoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIHJldHVybiBmaWxlLm9mZnNldCA8PSByYW5nZUVuZCAmJiAoZmlsZS5vZmZzZXQgKyBmaWxlLmxlbmd0aCkgPiByYW5nZVN0YXJ0XG4gICAgfSlcbiAgICBpZiAocmVxdWVzdGVkRmlsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgZmlsZSBjb3JyZXNwb25uZGluZyB0byB3ZWIgc2VlZCByYW5nZSByZXF1ZXN0JykpXG4gICAgfVxuXG4gICAgcmVxdWVzdHMgPSByZXF1ZXN0ZWRGaWxlcy5tYXAoZnVuY3Rpb24gKHJlcXVlc3RlZEZpbGUpIHtcbiAgICAgIHZhciBmaWxlRW5kID0gcmVxdWVzdGVkRmlsZS5vZmZzZXQgKyByZXF1ZXN0ZWRGaWxlLmxlbmd0aCAtIDFcbiAgICAgIHZhciB1cmwgPSBzZWxmLnVybCArXG4gICAgICAgIChzZWxmLnVybFtzZWxmLnVybC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJycgOiAnLycpICtcbiAgICAgICAgcmVxdWVzdGVkRmlsZS5wYXRoXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZmlsZU9mZnNldEluUmFuZ2U6IE1hdGgubWF4KHJlcXVlc3RlZEZpbGUub2Zmc2V0IC0gcmFuZ2VTdGFydCwgMCksXG4gICAgICAgIHN0YXJ0OiBNYXRoLm1heChyYW5nZVN0YXJ0IC0gcmVxdWVzdGVkRmlsZS5vZmZzZXQsIDApLFxuICAgICAgICBlbmQ6IE1hdGgubWluKGZpbGVFbmQsIHJhbmdlRW5kIC0gcmVxdWVzdGVkRmlsZS5vZmZzZXQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGFsbCB0aGUgSFRUUCByZXF1ZXN0cyB3ZSBuZWVkIGluIG9yZGVyIHRvIGxvYWQgdGhpcyBwaWVjZVxuICAvLyBVc3VhbGx5IHRoYXQncyBvbmUgcmVxdWVzdHMsIGJ1dCBzb21ldGltZXMgaXQgd2lsbCBiZSBtdWx0aXBsZVxuICAvLyBTZW5kIHJlcXVlc3RzIGluIHBhcmFsbGVsIGFuZCB3YWl0IGZvciB0aGVtIGFsbCB0byBjb21lIGJhY2tcbiAgdmFyIG51bVJlcXVlc3RzU3VjY2VlZGVkID0gMFxuICB2YXIgaGFzRXJyb3IgPSBmYWxzZVxuXG4gIHZhciByZXRcbiAgaWYgKHJlcXVlc3RzLmxlbmd0aCA+IDEpIHtcbiAgICByZXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKVxuICB9XG5cbiAgcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHZhciB1cmwgPSByZXF1ZXN0LnVybFxuICAgIHZhciBzdGFydCA9IHJlcXVlc3Quc3RhcnRcbiAgICB2YXIgZW5kID0gcmVxdWVzdC5lbmRcbiAgICBkZWJ1ZyhcbiAgICAgICdSZXF1ZXN0aW5nIHVybD0lcyBwaWVjZUluZGV4PSVkIG9mZnNldD0lZCBsZW5ndGg9JWQgc3RhcnQ9JWQgZW5kPSVkJyxcbiAgICAgIHVybCwgcGllY2VJbmRleCwgb2Zmc2V0LCBsZW5ndGgsIHN0YXJ0LCBlbmRcbiAgICApXG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICd1c2VyLWFnZW50JzogJ1dlYlRvcnJlbnQvJyArIFZFUlNJT04gKyAnIChodHRwczovL3dlYnRvcnJlbnQuaW8pJyxcbiAgICAgICAgcmFuZ2U6ICdieXRlcz0nICsgc3RhcnQgKyAnLScgKyBlbmRcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0LmNvbmNhdChvcHRzLCBmdW5jdGlvbiAoZXJyLCByZXMsIGRhdGEpIHtcbiAgICAgIGlmIChoYXNFcnJvcikgcmV0dXJuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZVxuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlcy5zdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgICBoYXNFcnJvciA9IHRydWVcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignVW5leHBlY3RlZCBIVFRQIHN0YXR1cyBjb2RlICcgKyByZXMuc3RhdHVzQ29kZSkpXG4gICAgICB9XG4gICAgICBkZWJ1ZygnR290IGRhdGEgb2YgbGVuZ3RoICVkJywgZGF0YS5sZW5ndGgpXG5cbiAgICAgIGlmIChyZXF1ZXN0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gQ29tbW9uIGNhc2U6IGZldGNoIHBpZWNlIGluIGEgc2luZ2xlIEhUVFAgcmVxdWVzdCwgcmV0dXJuIGRpcmVjdGx5XG4gICAgICAgIGNiKG51bGwsIGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSYXJlIGNhc2U6IHJlY29uc3RydWN0IG11bHRpcGxlIEhUVFAgcmVxdWVzdHMgYWNyb3NzIDIrIGZpbGVzIGludG8gb25lXG4gICAgICAgIC8vIHBpZWNlIGJ1ZmZlclxuICAgICAgICBkYXRhLmNvcHkocmV0LCByZXF1ZXN0LmZpbGVPZmZzZXRJblJhbmdlKVxuICAgICAgICBpZiAoKytudW1SZXF1ZXN0c1N1Y2NlZWRlZCA9PT0gcmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2IobnVsbCwgcmV0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuV2ViQ29ubi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgV2lyZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpXG4gIHRoaXMuX3RvcnJlbnQgPSBudWxsXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJ2ZXJzaW9uXCI6XCIwLjk0LjRcIn0iLCIvLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXG4vLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdFxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweVxuZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHtcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXG5cbiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cbiAgfSlcblxuICByZXR1cm4gd3JhcHBlclxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXVxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldFtrXSA9IGNiW2tdXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIi8qIGdsb2JhbCBZICovXG4ndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gZXh0ZW5kIChZKSB7XG4gIGNsYXNzIFlBcnJheSB7XG4gICAgY29uc3RydWN0b3IgKG9zLCBfbW9kZWwsIF9jb250ZW50KSB7XG4gICAgICB0aGlzLm9zID0gb3NcbiAgICAgIHRoaXMuX21vZGVsID0gX21vZGVsXG4gICAgICAvLyBBcnJheSBvZiBhbGwgdGhlIG5lY2Nlc3NhcnkgY29udGVudFxuICAgICAgdGhpcy5fY29udGVudCA9IF9jb250ZW50XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlciA9IG5ldyBZLnV0aWxzLkV2ZW50SGFuZGxlcigob3ApID0+IHtcbiAgICAgICAgaWYgKG9wLnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICBsZXQgcG9zXG4gICAgICAgICAgLy8gd2UgY2hlY2sgb3AubGVmdCBvbmx5ISxcbiAgICAgICAgICAvLyBiZWNhdXNlIG9wLnJpZ2h0IG1pZ2h0IG5vdCBiZSBkZWZpbmVkIHdoZW4gdGhpcyBpcyBjYWxsZWRcbiAgICAgICAgICBpZiAob3AubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSAxICsgdGhpcy5fY29udGVudC5maW5kSW5kZXgoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFkudXRpbHMuY29tcGFyZUlkcyhjLmlkLCBvcC5sZWZ0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGlmIChwb3MgPD0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb3BlcmF0aW9uIScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWx1ZXNcbiAgICAgICAgICB2YXIgbGVuZ3RoXG4gICAgICAgICAgaWYgKG9wLmhhc093blByb3BlcnR5KCdvcENvbnRlbnQnKSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5zcGxpY2UocG9zLCAwLCB7XG4gICAgICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICAgICAgdHlwZTogb3Aub3BDb250ZW50XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgbGV0IG9wQ29udGVudCA9IG9wLm9wQ29udGVudFxuICAgICAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgICAgICAgdmFsdWVzID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB5aWVsZCogdGhpcy5nZXRUeXBlKG9wQ29udGVudClcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoW3R5cGVdKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50cyA9IG9wLmNvbnRlbnQubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IFtvcC5pZFswXSwgb3AuaWRbMV0gKyBpXSxcbiAgICAgICAgICAgICAgICB2YWw6IGNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIGluc2VydCB2YWx1ZSBpbiBfY29udGVudFxuICAgICAgICAgICAgdGhpcy5fY29udGVudC5zcGxpY2UuYXBwbHkodGhpcy5fY29udGVudCwgW3BvcywgMF0uY29uY2F0KGNvbnRlbnRzKSlcbiAgICAgICAgICAgIHZhbHVlcyA9IG9wLmNvbnRlbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IG9wLmNvbnRlbnQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmNhbGxFdmVudExpc3RlbmVycyh7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0JyxcbiAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgIGluZGV4OiBwb3MsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgIC8vIHZhbHVlSWQ6IHZhbHVlSWQsIC8vIFRPRE86IGRvZXMgdGhpcyBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkP1xuICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKG9wLnN0cnVjdCA9PT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgICB2YXIgaSA9IDAgLy8gY3VycmVudCBwb3NpdGlvbiBpbiBfY29udGVudFxuICAgICAgICAgIGZvciAoOyBpIDwgdGhpcy5fY29udGVudC5sZW5ndGggJiYgb3AubGVuZ3RoID4gMDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2NvbnRlbnRbaV1cbiAgICAgICAgICAgIGlmIChZLnV0aWxzLmluRGVsZXRpb25SYW5nZShvcCwgYy5pZCkpIHtcbiAgICAgICAgICAgICAgLy8gaXMgaW4gZGVsZXRpb24gcmFuZ2UhXG4gICAgICAgICAgICAgIHZhciBkZWxMZW5ndGhcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaG93IG1hbnkgY2hhcmFjdGVyIHRvIGRlbGV0ZSBpbiBvbmUgZmx1c2hcbiAgICAgICAgICAgICAgZm9yIChkZWxMZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBkZWxMZW5ndGggPCBvcC5sZW5ndGggJiYgaSArIGRlbExlbmd0aCA8IHRoaXMuX2NvbnRlbnQubGVuZ3RoICYmIFkudXRpbHMuaW5EZWxldGlvblJhbmdlKG9wLCB0aGlzLl9jb250ZW50W2kgKyBkZWxMZW5ndGhdLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsTGVuZ3RoKyspIHt9XG4gICAgICAgICAgICAgIC8vIGxhc3Qgb3BlcmF0aW9uIHRoYXMgd2lsbCBiZSBkZWxldGVkXG4gICAgICAgICAgICAgIGMgPSB0aGlzLl9jb250ZW50W2kgKyBkZWxMZW5ndGggLSAxXVxuICAgICAgICAgICAgICAvLyB1cGRhdGUgZGVsZXRlIG9wZXJhdGlvblxuICAgICAgICAgICAgICBvcC5sZW5ndGggLT0gYy5pZFsxXSAtIG9wLnRhcmdldFsxXSArIDFcbiAgICAgICAgICAgICAgb3AudGFyZ2V0ID0gW2MuaWRbMF0sIGMuaWRbMV0gKyAxXVxuICAgICAgICAgICAgICAvLyBhcHBseSBkZWxldGlvbiAmIGZpbmQgc2VuZCBldmVudFxuICAgICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMuX2NvbnRlbnQuc3BsaWNlKGksIGRlbExlbmd0aClcbiAgICAgICAgICAgICAgLy8gVE9ETzogaG93IGFib3V0IHJldHVybiB0eXBlc1xuICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gY29udGVudC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmFsIH0pXG4gICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmNhbGxFdmVudExpc3RlbmVycyh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgICAgICAgIF9jb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZGVsTGVuZ3RoXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC8vIHdpdGggdGhlIGZyZXNoIGRlbGV0ZSBvcCwgd2UgY2FuIGNvbnRpbnVlXG4gICAgICAgICAgICAgIC8vIG5vdGU6IHdlIGRvbid0IGhhdmUgdG8gaW5jcmVtZW50IGksIGJlY2F1c2UgdGhlIGktdGggY29udGVudCB3YXMgZGVsZXRlZFxuICAgICAgICAgICAgICAvLyBidXQgb24gdGhlIG90aGVyIGhhZCwgdGhlIChpK2RlbExlbmd0aCktdGggd2FzIG5vdCBpbiBkZWxldGlvbiByYW5nZVxuICAgICAgICAgICAgICAvLyBTbyB3ZSBkb24ndCBkbyBpLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHN0cnVjdCEnKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBfZGVzdHJveSAoKSB7XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlci5kZXN0cm95KClcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gbnVsbFxuICAgICAgdGhpcy5fY29udGVudCA9IG51bGxcbiAgICAgIHRoaXMuX21vZGVsID0gbnVsbFxuICAgICAgdGhpcy5vcyA9IG51bGxcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGhcbiAgICB9XG4gICAgZ2V0IChwb3MpIHtcbiAgICAgIGlmIChwb3MgPT0gbnVsbCB8fCB0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcyBtdXN0IGJlIGEgbnVtYmVyIScpXG4gICAgICB9XG4gICAgICBpZiAocG9zID49IHRoaXMuX2NvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb250ZW50W3Bvc10udHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50W3Bvc10udmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2lkID0gdGhpcy5fY29udGVudFtwb3NdLnR5cGVcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgdGhpcy5vcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0geWllbGQqIHRoaXMuZ2V0VHlwZShvaWQpXG4gICAgICAgICAgICByZXNvbHZlKHR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb25seSByZXR1cm5zIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICB0b0FycmF5ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lm1hcChmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICByZXR1cm4geC52YWxcbiAgICAgIH0pXG4gICAgfVxuICAgIHB1c2ggKGNvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnQodGhpcy5fY29udGVudC5sZW5ndGgsIGNvbnRlbnRzKVxuICAgIH1cbiAgICBpbnNlcnQgKHBvcywgY29udGVudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcyBtdXN0IGJlIGEgbnVtYmVyIScpXG4gICAgICB9XG4gICAgICBpZiAoIShjb250ZW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRlbnRzIG11c3QgYmUgYW4gQXJyYXkgb2Ygb2JqZWN0cyEnKVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPiB0aGlzLl9jb250ZW50Lmxlbmd0aCB8fCBwb3MgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwb3NpdGlvbiBleGNlZWRzIHRoZSByYW5nZSBvZiB0aGUgYXJyYXkhJylcbiAgICAgIH1cbiAgICAgIHZhciBtb3N0TGVmdCA9IHBvcyA9PT0gMCA/IG51bGwgOiB0aGlzLl9jb250ZW50W3BvcyAtIDFdLmlkXG5cbiAgICAgIHZhciBvcHMgPSBbXVxuICAgICAgdmFyIG5ld1R5cGVzID0gW11cbiAgICAgIHZhciBwcmV2SWQgPSBtb3N0TGVmdFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50cy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgICBsZWZ0OiBwcmV2SWQsXG4gICAgICAgICAgb3JpZ2luOiBwcmV2SWQsXG4gICAgICAgICAgLy8gcmlnaHQ6IG1vc3RSaWdodCxcbiAgICAgICAgICAvLyBOT1RFOiBJIGludGVudGlvbmFsbHkgZG8gbm90IGRlZmluZSByaWdodCBoZXJlLCBiZWNhdXNlIGl0IGNvdWxkIGJlIGRlbGV0ZWRcbiAgICAgICAgICAvLyBhdCB0aGUgdGltZSBvZiBpbnNlcnRpbmcgdGhpcyBvcGVyYXRpb24gKHdoZW4gd2UgZ2V0IHRoZSB0cmFuc2FjdGlvbiksXG4gICAgICAgICAgLy8gYW5kIHdvdWxkIHRoZXJlZm9yZSBub3QgZGVmaW5lZCBpbiB0aGlzLl9jb250ZW50XG4gICAgICAgICAgcGFyZW50OiB0aGlzLl9tb2RlbCxcbiAgICAgICAgICBzdHJ1Y3Q6ICdJbnNlcnQnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jb250ZW50ID0gW11cbiAgICAgICAgdmFyIHR5cGVEZWZpbml0aW9uXG4gICAgICAgIHdoaWxlIChpIDwgY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGNvbnRlbnRzW2krK11cbiAgICAgICAgICB0eXBlRGVmaW5pdGlvbiA9IFkudXRpbHMuaXNUeXBlRGVmaW5pdGlvbih2YWwpXG4gICAgICAgICAgaWYgKCF0eXBlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgX2NvbnRlbnQucHVzaCh2YWwpXG4gICAgICAgICAgfSBlbHNlIGlmIChfY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpLS0gLy8gY29tZSBiYWNrIGFnYWluIGxhdGVyXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGNvbnRlbnQgaXMgZGVmaW5lZFxuICAgICAgICAgIG9wLmNvbnRlbnQgPSBfY29udGVudFxuICAgICAgICAgIG9wLmlkID0gdGhpcy5vcy5nZXROZXh0T3BJZChfY29udGVudC5sZW5ndGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0cyBhIHR5cGVcbiAgICAgICAgICB2YXIgdHlwZWlkID0gdGhpcy5vcy5nZXROZXh0T3BJZCgxKVxuICAgICAgICAgIG5ld1R5cGVzLnB1c2goW3R5cGVEZWZpbml0aW9uLCB0eXBlaWRdKVxuICAgICAgICAgIG9wLm9wQ29udGVudCA9IHR5cGVpZFxuICAgICAgICAgIG9wLmlkID0gdGhpcy5vcy5nZXROZXh0T3BJZCgxKVxuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKG9wKVxuICAgICAgICBwcmV2SWQgPSBvcC5pZFxuICAgICAgfVxuICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVyXG4gICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICAvLyBub3cgd2UgY2FuIHNldCB0aGUgcmlnaHQgcmVmZXJlbmNlLlxuICAgICAgICB2YXIgbW9zdFJpZ2h0XG4gICAgICAgIGlmIChtb3N0TGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG1sID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5FbmQobW9zdExlZnQpXG4gICAgICAgICAgbW9zdFJpZ2h0ID0gbWwucmlnaHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3N0UmlnaHQgPSAoeWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKG9wc1swXS5wYXJlbnQpKS5zdGFydFxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB5aWVsZCogdGhpcy5jcmVhdGVUeXBlLmFwcGx5KHRoaXMsIG5ld1R5cGVzW2ldKVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG9wID0gb3BzW2pdXG4gICAgICAgICAgb3AucmlnaHQgPSBtb3N0UmlnaHRcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogZXZlbnRIYW5kbGVyLmF3YWl0T3BzKHRoaXMsIHRoaXMuYXBwbHlDcmVhdGVkT3BlcmF0aW9ucywgW29wc10pXG4gICAgICB9KVxuICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKG9wcylcbiAgICB9XG4gICAgZGVsZXRlIChwb3MsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7IGxlbmd0aCA9IDEgfVxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIhJylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvcyBtdXN0IGJlIGEgbnVtYmVyIScpXG4gICAgICB9XG4gICAgICBpZiAocG9zICsgbGVuZ3RoID4gdGhpcy5fY29udGVudC5sZW5ndGggfHwgcG9zIDwgMCB8fCBsZW5ndGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlbGV0aW9uIHJhbmdlIGV4Y2VlZHMgdGhlIHJhbmdlIG9mIHRoZSBhcnJheSEnKVxuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLmV2ZW50SGFuZGxlclxuICAgICAgdmFyIGRlbHMgPSBbXVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgPSBpICsgZGVsTGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9IHRoaXMuX2NvbnRlbnRbcG9zICsgaV0uaWRcbiAgICAgICAgdmFyIGRlbExlbmd0aFxuICAgICAgICAvLyBob3cgbWFueSBpbnNlcnRpb25zIGNhbiB3ZSBkZWxldGUgaW4gb25lIGRlbGV0aW9uP1xuICAgICAgICBmb3IgKGRlbExlbmd0aCA9IDE7IGkgKyBkZWxMZW5ndGggPCBsZW5ndGg7IGRlbExlbmd0aCsrKSB7XG4gICAgICAgICAgaWYgKCFZLnV0aWxzLmNvbXBhcmVJZHModGhpcy5fY29udGVudFtwb3MgKyBpICsgZGVsTGVuZ3RoXS5pZCwgW3RhcmdldElkWzBdLCB0YXJnZXRJZFsxXSArIGRlbExlbmd0aF0pKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxzLnB1c2goe1xuICAgICAgICAgIHRhcmdldDogdGFyZ2V0SWQsXG4gICAgICAgICAgc3RydWN0OiAnRGVsZXRlJyxcbiAgICAgICAgICBsZW5ndGg6IGRlbExlbmd0aFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKGRlbHMpXG4gICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICB5aWVsZCogZXZlbnRIYW5kbGVyLmF3YWl0T3BzKHRoaXMsIHRoaXMuYXBwbHlDcmVhdGVkT3BlcmF0aW9ucywgW2RlbHNdKVxuICAgICAgfSlcbiAgICB9XG4gICAgb2JzZXJ2ZSAoZikge1xuICAgICAgdGhpcy5ldmVudEhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcihmKVxuICAgIH1cbiAgICB1bm9ic2VydmUgKGYpIHtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZilcbiAgICB9XG4gICAgKiBfY2hhbmdlZCAodHJhbnNhY3Rpb24sIG9wKSB7XG4gICAgICBpZiAoIW9wLmRlbGV0ZWQpIHtcbiAgICAgICAgaWYgKG9wLnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICB2YXIgbCA9IG9wLmxlZnRcbiAgICAgICAgICB2YXIgbGVmdFxuICAgICAgICAgIHdoaWxlIChsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxlZnQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0SW5zZXJ0aW9uKGwpXG4gICAgICAgICAgICBpZiAoIWxlZnQuZGVsZXRlZCkge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbCA9IGxlZnQubGVmdFxuICAgICAgICAgIH1cbiAgICAgICAgICBvcC5sZWZ0ID0gbFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLnJlY2VpdmVkT3Aob3ApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgWS5leHRlbmQoJ0FycmF5JywgbmV3IFkudXRpbHMuQ3VzdG9tVHlwZSh7XG4gICAgbmFtZTogJ0FycmF5JyxcbiAgICBjbGFzczogWUFycmF5LFxuICAgIHN0cnVjdDogJ0xpc3QnLFxuICAgIGluaXRUeXBlOiBmdW5jdGlvbiAqIFlBcnJheUluaXRpYWxpemVyIChvcywgbW9kZWwpIHtcbiAgICAgIHZhciBfY29udGVudCA9IFtdXG4gICAgICB5aWVsZCogWS5TdHJ1Y3QuTGlzdC5tYXAuY2FsbCh0aGlzLCBtb2RlbCwgZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIGlmIChvcC5oYXNPd25Qcm9wZXJ0eSgnb3BDb250ZW50JykpIHtcbiAgICAgICAgICBfY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICAgIHR5cGU6IG9wLm9wQ29udGVudFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3AuY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICBfY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IFtvcC5pZFswXSwgb3AuaWRbMV0gKyBpXSxcbiAgICAgICAgICAgICAgdmFsOiBvcC5jb250ZW50W2ldXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbmV3IFlBcnJheShvcywgbW9kZWwuaWQsIF9jb250ZW50KVxuICAgIH1cbiAgfSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5pZiAodHlwZW9mIFkgIT09ICd1bmRlZmluZWQnKSB7XG4gIGV4dGVuZChZKVxufVxuIiwiLyogZ2xvYmFsIFkgKi9cbid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBleHRlbmQgKFkgLyogOmFueSAqLykge1xuICBjbGFzcyBZTWFwIHtcbiAgICAvKiA6OlxuICAgIF9tb2RlbDogSWQ7XG4gICAgb3M6IFkuQWJzdHJhY3REYXRhYmFzZTtcbiAgICBtYXA6IE9iamVjdDtcbiAgICBjb250ZW50czogYW55O1xuICAgIG9wQ29udGVudHM6IE9iamVjdDtcbiAgICBldmVudEhhbmRsZXI6IEZ1bmN0aW9uO1xuICAgICovXG4gICAgY29uc3RydWN0b3IgKG9zLCBtb2RlbCwgY29udGVudHMsIG9wQ29udGVudHMpIHtcbiAgICAgIHRoaXMuX21vZGVsID0gbW9kZWwuaWRcbiAgICAgIHRoaXMub3MgPSBvc1xuICAgICAgdGhpcy5tYXAgPSBZLnV0aWxzLmNvcHlPYmplY3QobW9kZWwubWFwKVxuICAgICAgdGhpcy5jb250ZW50cyA9IGNvbnRlbnRzXG4gICAgICB0aGlzLm9wQ29udGVudHMgPSBvcENvbnRlbnRzXG4gICAgICB0aGlzLmV2ZW50SGFuZGxlciA9IG5ldyBZLnV0aWxzLkV2ZW50SGFuZGxlcihvcCA9PiB7XG4gICAgICAgIHZhciBvbGRWYWx1ZVxuICAgICAgICAvLyBrZXkgaXMgdGhlIG5hbWUgdG8gdXNlIHRvIGFjY2VzcyAob3ApY29udGVudFxuICAgICAgICB2YXIga2V5ID0gb3Auc3RydWN0ID09PSAnRGVsZXRlJyA/IG9wLmtleSA6IG9wLnBhcmVudFN1YlxuXG4gICAgICAgIC8vIGNvbXB1dGUgb2xkVmFsdWVcbiAgICAgICAgaWYgKHRoaXMub3BDb250ZW50c1trZXldICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgcHJldlR5cGUgPSB0aGlzLm9wQ29udGVudHNba2V5XVxuICAgICAgICAgIG9sZFZhbHVlID0gKCkgPT4gey8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkgey8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHlpZWxkKiB0aGlzLmdldFR5cGUocHJldlR5cGUpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0eXBlKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkVmFsdWUgPSB0aGlzLmNvbnRlbnRzW2tleV1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIG9wIGV2ZW50XG4gICAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdJbnNlcnQnKSB7XG4gICAgICAgICAgaWYgKG9wLmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVxuICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBpZiBvcC5kZWxldGVkPz8/IEkgcGFydGlhbGx5IGhhbmRsZXMgdGhpcyBjYXNlIGhlcmUuLiAobWF5YmUgZnJvbSB0aGUgcHJldmlvdXMgdmVyc2lvbilcbiAgICAgICAgICAgIGlmIChvcC5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICgpID0+IHsvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkgey8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB5aWVsZCogdGhpcy5nZXRUeXBlKG9wLm9wQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eXBlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnRzW2tleV1cbiAgICAgICAgICAgICAgaWYgKG9wLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vcENvbnRlbnRzW2tleV1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wQ29udGVudHNba2V5XSA9IG9wLm9wQ29udGVudFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG9wLmNvbnRlbnRbMF1cbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3BDb250ZW50c1trZXldXG4gICAgICAgICAgICAgIGlmIChvcC5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGVudHNba2V5XVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudHNba2V5XSA9IG9wLmNvbnRlbnRbMF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXBba2V5XSA9IG9wLmlkXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlci5jYWxsRXZlbnRMaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlci5jYWxsRXZlbnRMaXN0ZW5lcnMoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyh0aGlzLm1hcFtrZXldLCBvcC50YXJnZXQpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcENvbnRlbnRzW2tleV1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRlbnRzW2tleV1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmNhbGxFdmVudExpc3RlbmVycyh7XG4gICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgT3BlcmF0aW9uIScpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9kZXN0cm95ICgpIHtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmRlc3Ryb3koKVxuICAgICAgdGhpcy5ldmVudEhhbmRsZXIgPSBudWxsXG4gICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbFxuICAgICAgdGhpcy5vcENvbnRlbnRzID0gbnVsbFxuICAgICAgdGhpcy5fbW9kZWwgPSBudWxsXG4gICAgICB0aGlzLm9zID0gbnVsbFxuICAgICAgdGhpcy5tYXAgPSBudWxsXG4gICAgfVxuICAgIGdldCAoa2V5KSB7XG4gICAgICAvLyByZXR1cm4gcHJvcGVydHkuXG4gICAgICAvLyBpZiBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCwgcmV0dXJuIG51bGxcbiAgICAgIC8vIGlmIHByb3BlcnR5IGlzIGEgdHlwZSwgcmV0dXJuIGEgcHJvbWlzZVxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGtleSAoYXMgc3RyaW5nKSEnKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3BDb250ZW50c1trZXldID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHNba2V5XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgdmFyIG9pZCA9IHRoaXMub3BDb250ZW50c1trZXldXG4gICAgICAgICAgdGhpcy5vcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0geWllbGQqIHRoaXMuZ2V0VHlwZShvaWQpXG4gICAgICAgICAgICByZXNvbHZlKHR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAga2V5cyAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb250ZW50cykuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMub3BDb250ZW50cykpXG4gICAgfVxuICAgIGtleXNQcmltaXRpdmVzICgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbnRlbnRzKVxuICAgIH1cbiAgICBrZXlzVHlwZXMgKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMub3BDb250ZW50cylcbiAgICB9XG4gICAgLypcbiAgICAgIElmIHRoZXJlIGlzIGEgcHJpbWl0aXZlIChub3QgYSBjdXN0b20gdHlwZSksIHRoZW4gcmV0dXJuIGl0LlxuICAgICAgUmV0dXJucyBhbGwgcHJpbWl0aXZlIHZhbHVlcywgaWYgcHJvcGVydHlOYW1lIGlzIHNwZWNpZmllZCFcbiAgICAgIE5vdGU6IG1vZGlmeWluZyB0aGUgcmV0dXJuIHZhbHVlIGNvdWxkIHJlc3VsdCBpbiBpbmNvbnNpc3RlbmNpZXMhXG4gICAgICAgIC0tIHNvIG1ha2Ugc3VyZSB0byBjb3B5IGl0IGZpcnN0IVxuICAgICovXG4gICAgZ2V0UHJpbWl0aXZlIChrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gWS51dGlscy5jb3B5T2JqZWN0KHRoaXMuY29udGVudHMpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5IGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nIScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50c1trZXldXG4gICAgICB9XG4gICAgfVxuICAgIGdldFR5cGUgKGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGtleSAoYXMgc3RyaW5nKSEnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wQ29udGVudHNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHZhciBvaWQgPSB0aGlzLm9wQ29udGVudHNba2V5XVxuICAgICAgICAgIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICooKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHlpZWxkKiB0aGlzLmdldFR5cGUob2lkKVxuICAgICAgICAgICAgcmVzb2x2ZSh0eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHByb3BlcnR5IHNwZWNpZmllZCBmb3IgdGhpcyBrZXkhJylcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIChrZXkpIHtcbiAgICAgIHZhciByaWdodCA9IHRoaXMubWFwW2tleV1cbiAgICAgIGlmIChyaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWwgPSB7XG4gICAgICAgICAgdGFyZ2V0OiByaWdodCxcbiAgICAgICAgICBzdHJ1Y3Q6ICdEZWxldGUnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVyXG4gICAgICAgIHZhciBtb2REZWwgPSBZLnV0aWxzLmNvcHlPYmplY3QoZGVsKVxuICAgICAgICBtb2REZWwua2V5ID0ga2V5XG4gICAgICAgIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICooKSB7XG4gICAgICAgICAgeWllbGQqIGV2ZW50SGFuZGxlci5hd2FpdE9wcyh0aGlzLCB0aGlzLmFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMsIFtbZGVsXV0pXG4gICAgICAgIH0pXG4gICAgICAgIC8vIGFsd2F5cyByZW1lbWJlciB0byBkbyB0aGF0IGFmdGVyIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uXG4gICAgICAgIC8vIChvdGhlcndpc2UgdmFsdWVzIG1pZ2h0IGNvbnRhaW4gYSB1bmRlZmluZWQgcmVmZXJlbmNlIHRvIHR5cGUpXG4gICAgICAgIGV2ZW50SGFuZGxlci5hd2FpdEFuZFByZW1hdHVyZWx5Q2FsbChbbW9kRGVsXSlcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgICAvLyBzZXQgcHJvcGVydHkuXG4gICAgICAvLyBpZiBwcm9wZXJ0eSBpcyBhIHR5cGUsIHJldHVybiBhIHByb21pc2VcbiAgICAgIC8vIGlmIG5vdCwgYXBwbHkgaW1tZWRpYXRlbHkgb24gdGhpcyB0eXBlIGFuIGNhbGwgZXZlbnRcblxuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5tYXBba2V5XSB8fCBudWxsXG4gICAgICB2YXIgaW5zZXJ0IC8qIDphbnkgKi8gPSB7XG4gICAgICAgIGlkOiB0aGlzLm9zLmdldE5leHRPcElkKDEpLFxuICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIG9yaWdpbjogbnVsbCxcbiAgICAgICAgcGFyZW50OiB0aGlzLl9tb2RlbCxcbiAgICAgICAgcGFyZW50U3ViOiBrZXksXG4gICAgICAgIHN0cnVjdDogJ0luc2VydCdcbiAgICAgIH1cbiAgICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLmV2ZW50SGFuZGxlclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHZhciB0eXBlRGVmaW5pdGlvbiA9IFkudXRpbHMuaXNUeXBlRGVmaW5pdGlvbih2YWx1ZSlcbiAgICAgICAgaWYgKHR5cGVEZWZpbml0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZhciB0eXBlaWQgPSB0aGlzLm9zLmdldE5leHRPcElkKDEpXG4gICAgICAgICAgaW5zZXJ0Lm9wQ29udGVudCA9IHR5cGVpZFxuICAgICAgICAgIC8vIGNvbnN0cnVjdCBhIG5ldyB0eXBlXG4gICAgICAgICAgdGhpcy5vcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0geWllbGQqIHRoaXMuY3JlYXRlVHlwZSh0eXBlRGVmaW5pdGlvbiwgdHlwZWlkKVxuICAgICAgICAgICAgeWllbGQqIGV2ZW50SGFuZGxlci5hd2FpdE9wcyh0aGlzLCB0aGlzLmFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMsIFtbaW5zZXJ0XV0pXG4gICAgICAgICAgICByZXNvbHZlKHR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBhbHdheXMgcmVtZW1iZXIgdG8gZG8gdGhhdCBhZnRlciB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvblxuICAgICAgICAgIC8vIChvdGhlcndpc2UgdmFsdWVzIG1pZ2h0IGNvbnRhaW4gYSB1bmRlZmluZWQgcmVmZXJlbmNlIHRvIHR5cGUpXG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKFtpbnNlcnRdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydC5jb250ZW50ID0gW3ZhbHVlXVxuICAgICAgICAgIHRoaXMub3MucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogKCkge1xuICAgICAgICAgICAgeWllbGQqIGV2ZW50SGFuZGxlci5hd2FpdE9wcyh0aGlzLCB0aGlzLmFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMsIFtbaW5zZXJ0XV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBhbHdheXMgcmVtZW1iZXIgdG8gZG8gdGhhdCBhZnRlciB0aGlzLm9zLnJlcXVlc3RUcmFuc2FjdGlvblxuICAgICAgICAgIC8vIChvdGhlcndpc2UgdmFsdWVzIG1pZ2h0IGNvbnRhaW4gYSB1bmRlZmluZWQgcmVmZXJlbmNlIHRvIHR5cGUpXG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmF3YWl0QW5kUHJlbWF0dXJlbHlDYWxsKFtpbnNlcnRdKVxuICAgICAgICAgIHJlc29sdmUodmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIG9ic2VydmUgKGYpIHtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoZilcbiAgICB9XG4gICAgdW5vYnNlcnZlIChmKSB7XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlci5yZW1vdmVFdmVudExpc3RlbmVyKGYpXG4gICAgfVxuICAgIC8qXG4gICAgICBPYnNlcnZlIGEgcGF0aC5cblxuICAgICAgRS5nLlxuICAgICAgYGBgXG4gICAgICBvLnNldCgndGV4dGFyZWEnLCBZLlRleHRCaW5kKVxuICAgICAgby5vYnNlcnZlUGF0aChbJ3RleHRhcmVhJ10sIGZ1bmN0aW9uKHQpe1xuICAgICAgICAvLyBpcyBjYWxsZWQgd2hlbmV2ZXIgdGV4dGFyZWEgaXMgcmVwbGFjZWRcbiAgICAgICAgdC5iaW5kKHRleHRhcmVhKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJucyBhIFByb21pc2UgdGhhdCBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgb2JzZXJ2ZXIgZnJvbSB0aGUgcGF0aC5cbiAgICAqL1xuICAgIG9ic2VydmVQYXRoIChwYXRoLCBmKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIGZ1bmN0aW9uIG9ic2VydmVQcm9wZXJ0eSAoZXZlbnQpIHtcbiAgICAgICAgLy8gY2FsbCBmIHdoZW5ldmVyIHBhdGggY2hhbmdlc1xuICAgICAgICBpZiAoZXZlbnQubmFtZSA9PT0gcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgLy8gY2FsbCB0aGlzIGFsc28gZm9yIGRlbGV0ZSBldmVudHMhXG4gICAgICAgICAgdmFyIHByb3BlcnR5ID0gc2VsZi5nZXQocHJvcGVydHlOYW1lKVxuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHByb3BlcnR5LnRoZW4oZilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZihwcm9wZXJ0eSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGgubGVuZ3RoIDwgMSkge1xuICAgICAgICBmKHRoaXMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24gKCkge30pXG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwYXRoWzBdXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHNlbGYuZ2V0KHByb3BlcnR5TmFtZSlcbiAgICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHByb3BlcnR5LnRoZW4oZilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmKHByb3BlcnR5KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZShvYnNlcnZlUHJvcGVydHkpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudW5vYnNlcnZlKGYpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVsZXRlQ2hpbGRPYnNlcnZlcnNcbiAgICAgICAgdmFyIHJlc2V0T2JzZXJ2ZXJQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5nZXQocGF0aFswXSlcbiAgICAgICAgICBpZiAoIXByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBpdHMgZWl0aGVyIG5vdCBkZWZpbmVkIG9yIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgICAgICBwcm9taXNlID0gc2VsZi5zZXQocGF0aFswXSwgWS5NYXApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcC5vYnNlcnZlUGF0aChwYXRoLnNsaWNlKDEpLCBmKVxuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF9kZWxldGVDaGlsZE9ic2VydmVycykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGRlbGV0ZUNoaWxkT2JzZXJ2ZXJzXG4gICAgICAgICAgICBkZWxldGVDaGlsZE9ic2VydmVycyA9IF9kZWxldGVDaGlsZE9ic2VydmVyc1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpIC8vIFByb21pc2UgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQubmFtZSA9PT0gcGF0aFswXSkge1xuICAgICAgICAgICAgaWYgKGRlbGV0ZUNoaWxkT2JzZXJ2ZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZGVsZXRlQ2hpbGRPYnNlcnZlcnMoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdhZGQnIHx8IGV2ZW50LnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICAgIHJlc2V0T2JzZXJ2ZXJQYXRoKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgdGhlIGRlbGV0ZSBldmVudHM/XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYub2JzZXJ2ZShvYnNlcnZlcilcbiAgICAgICAgcmV0dXJuIHJlc2V0T2JzZXJ2ZXJQYXRoKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gdGhpcyBwcm9taXNlIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBkZWxldGVzIGFsbCB0aGUgY2hpbGQgb2JzZXJ2ZXJzXG4gICAgICAgICAgLy8gYW5kIGhvdyB0byB1bm9ic2VydmUgdGhlIG9ic2VydmUgZnJvbSB0aGlzIG9iamVjdFxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICBpZiAoZGVsZXRlQ2hpbGRPYnNlcnZlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWxldGVDaGlsZE9ic2VydmVycygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnVub2JzZXJ2ZShvYnNlcnZlcilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICAqIF9jaGFuZ2VkICh0cmFuc2FjdGlvbiwgb3ApIHtcbiAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0T3BlcmF0aW9uKG9wLnRhcmdldClcbiAgICAgICAgb3Aua2V5ID0gdGFyZ2V0LnBhcmVudFN1YlxuICAgICAgfVxuICAgICAgdGhpcy5ldmVudEhhbmRsZXIucmVjZWl2ZWRPcChvcClcbiAgICB9XG4gIH1cbiAgWS5leHRlbmQoJ01hcCcsIG5ldyBZLnV0aWxzLkN1c3RvbVR5cGUoe1xuICAgIG5hbWU6ICdNYXAnLFxuICAgIGNsYXNzOiBZTWFwLFxuICAgIHN0cnVjdDogJ01hcCcsXG4gICAgaW5pdFR5cGU6IGZ1bmN0aW9uICogWU1hcEluaXRpYWxpemVyIChvcywgbW9kZWwpIHtcbiAgICAgIHZhciBjb250ZW50cyA9IHt9XG4gICAgICB2YXIgb3BDb250ZW50cyA9IHt9XG4gICAgICB2YXIgbWFwID0gbW9kZWwubWFwXG4gICAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICB2YXIgb3AgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24obWFwW25hbWVdKVxuICAgICAgICBpZiAob3Aub3BDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBvcENvbnRlbnRzW25hbWVdID0gb3Aub3BDb250ZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudHNbbmFtZV0gPSBvcC5jb250ZW50WzBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgWU1hcChvcywgbW9kZWwsIGNvbnRlbnRzLCBvcENvbnRlbnRzKVxuICAgIH1cbiAgfSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5pZiAodHlwZW9mIFkgIT09ICd1bmRlZmluZWQnKSB7XG4gIGV4dGVuZChZKVxufVxuIiwiLyogZ2xvYmFsIFkgKi9cclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5mdW5jdGlvbiBleHRlbmQgKFkpIHtcclxuICByZXF1aXJlKCcuL1JlZEJsYWNrVHJlZS5qcycpKFkpXHJcbiAgY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBZLlRyYW5zYWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yIChzdG9yZSkge1xyXG4gICAgICBzdXBlcihzdG9yZSlcclxuICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlXHJcbiAgICAgIHRoaXMuc3MgPSBzdG9yZS5zc1xyXG4gICAgICB0aGlzLm9zID0gc3RvcmUub3NcclxuICAgICAgdGhpcy5kcyA9IHN0b3JlLmRzXHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBTdG9yZSA9IFkudXRpbHMuUkJUcmVlXHJcbiAgdmFyIEJ1ZmZlcmVkU3RvcmUgPSBZLnV0aWxzLmNyZWF0ZVNtYWxsTG9va3VwQnVmZmVyKFN0b3JlKVxyXG5cclxuICBjbGFzcyBEYXRhYmFzZSBleHRlbmRzIFkuQWJzdHJhY3REYXRhYmFzZSB7XHJcbiAgICBjb25zdHJ1Y3RvciAoeSwgb3B0cykge1xyXG4gICAgICBzdXBlcih5LCBvcHRzKVxyXG4gICAgICB0aGlzLm9zID0gbmV3IEJ1ZmZlcmVkU3RvcmUoKVxyXG4gICAgICB0aGlzLmRzID0gbmV3IFN0b3JlKClcclxuICAgICAgdGhpcy5zcyA9IG5ldyBCdWZmZXJlZFN0b3JlKClcclxuICAgIH1cclxuICAgIGxvZ1RhYmxlICgpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgIHNlbGYucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2VyOiAnLCB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLnVzZXJJZCwgXCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIikgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3RhdGUgU2V0IChTUyk6XCIsIHlpZWxkKiB0aGlzLmdldFN0YXRlU2V0KCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk9wZXJhdGlvbiBTdG9yZSAoT1MpOlwiKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgeWllbGQqIHRoaXMub3MubG9nVGFibGUoKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJEZWxldGlvbiBTdG9yZSAoRFMpOlwiKSAvL2VzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICB5aWVsZCogdGhpcy5kcy5sb2dUYWJsZSgpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICBpZiAodGhpcy5zdG9yZS5nYzEubGVuZ3RoID4gMCB8fCB0aGlzLnN0b3JlLmdjMi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0dDMXwyIG5vdCBlbXB0eSEnLCB0aGlzLnN0b3JlLmdjMSwgdGhpcy5zdG9yZS5nYzIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnN0b3JlLmxpc3RlbmVyc0J5SWQpICE9PSAne30nKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2xpc3RlbmVyc0J5SWQgbm90IGVtcHR5IScpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnN0b3JlLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93KSAhPT0gJ1tdJykge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lcnNCeUlkRXhlY3V0ZU5vdyBub3QgZW1wdHkhJylcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RvcmUudHJhbnNhY3Rpb25JblByb2dyZXNzKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHN0aWxsIGluIHByb2dyZXNzIScpXHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0cnVlKVxyXG4gICAgfVxyXG4gICAgdHJhbnNhY3QgKG1ha2VHZW4pIHtcclxuICAgICAgdmFyIHQgPSBuZXcgVHJhbnNhY3Rpb24odGhpcylcclxuICAgICAgd2hpbGUgKG1ha2VHZW4gIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgZ2VuID0gbWFrZUdlbi5jYWxsKHQpXHJcbiAgICAgICAgdmFyIHJlcyA9IGdlbi5uZXh0KClcclxuICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XHJcbiAgICAgICAgICByZXMgPSBnZW4ubmV4dChyZXMudmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ha2VHZW4gPSB0aGlzLmdldE5leHRSZXF1ZXN0KClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKiBkZXN0cm95ICgpIHtcclxuICAgICAgeWllbGQqIHN1cGVyLmRlc3Ryb3koKVxyXG4gICAgICBkZWxldGUgdGhpcy5vc1xyXG4gICAgICBkZWxldGUgdGhpcy5zc1xyXG4gICAgICBkZWxldGUgdGhpcy5kc1xyXG4gICAgfVxyXG4gIH1cclxuICBZLmV4dGVuZCgnbWVtb3J5JywgRGF0YWJhc2UpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXHJcbmlmICh0eXBlb2YgWSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBleHRlbmQoWSlcclxufVxyXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbi8qXHJcbiAgVGhpcyBmaWxlIGNvbnRhaW5zIGEgbm90IHNvIGZhbmN5IGltcGxlbWFudGlvbiBvZiBhIFJlZCBCbGFjayBUcmVlLlxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZKSB7XHJcbiAgY2xhc3MgTiB7XHJcbiAgICAvLyBBIGNyZWF0ZWQgbm9kZSBpcyBhbHdheXMgcmVkIVxyXG4gICAgY29uc3RydWN0b3IgKHZhbCkge1xyXG4gICAgICB0aGlzLnZhbCA9IHZhbFxyXG4gICAgICB0aGlzLmNvbG9yID0gdHJ1ZVxyXG4gICAgICB0aGlzLl9sZWZ0ID0gbnVsbFxyXG4gICAgICB0aGlzLl9yaWdodCA9IG51bGxcclxuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbFxyXG4gICAgICBpZiAodmFsLmlkID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgaWQhJylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNSZWQgKCkgeyByZXR1cm4gdGhpcy5jb2xvciB9XHJcbiAgICBpc0JsYWNrICgpIHsgcmV0dXJuICF0aGlzLmNvbG9yIH1cclxuICAgIHJlZGRlbiAoKSB7IHRoaXMuY29sb3IgPSB0cnVlOyByZXR1cm4gdGhpcyB9XHJcbiAgICBibGFja2VuICgpIHsgdGhpcy5jb2xvciA9IGZhbHNlOyByZXR1cm4gdGhpcyB9XHJcbiAgICBnZXQgZ3JhbmRwYXJlbnQgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQucGFyZW50XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFxyXG4gICAgfVxyXG4gICAgZ2V0IHNpYmxpbmcgKCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMgPT09IHRoaXMucGFyZW50LmxlZnQpXHJcbiAgICAgICAgPyB0aGlzLnBhcmVudC5yaWdodCA6IHRoaXMucGFyZW50LmxlZnRcclxuICAgIH1cclxuICAgIGdldCBsZWZ0ICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2xlZnRcclxuICAgIH1cclxuICAgIGdldCByaWdodCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yaWdodFxyXG4gICAgfVxyXG4gICAgc2V0IGxlZnQgKG4pIHtcclxuICAgICAgaWYgKG4gIT09IG51bGwpIHtcclxuICAgICAgICBuLl9wYXJlbnQgPSB0aGlzXHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fbGVmdCA9IG5cclxuICAgIH1cclxuICAgIHNldCByaWdodCAobikge1xyXG4gICAgICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgICAgIG4uX3BhcmVudCA9IHRoaXNcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9yaWdodCA9IG5cclxuICAgIH1cclxuICAgIHJvdGF0ZUxlZnQgKHRyZWUpIHtcclxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50XHJcbiAgICAgIHZhciBuZXdQYXJlbnQgPSB0aGlzLnJpZ2h0XHJcbiAgICAgIHZhciBuZXdSaWdodCA9IHRoaXMucmlnaHQubGVmdFxyXG4gICAgICBuZXdQYXJlbnQubGVmdCA9IHRoaXNcclxuICAgICAgdGhpcy5yaWdodCA9IG5ld1JpZ2h0XHJcbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICB0cmVlLnJvb3QgPSBuZXdQYXJlbnRcclxuICAgICAgICBuZXdQYXJlbnQuX3BhcmVudCA9IG51bGxcclxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgIHBhcmVudC5sZWZ0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgcGFyZW50LnJpZ2h0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWxlbWVudHMgYXJlIHdyb25nbHkgY29ubmVjdGVkIScpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHQgKCkge1xyXG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHNlYXJjaCB0aGUgbW9zdCBsZWZ0IG5vZGUgaW4gdGhlIHJpZ2h0IHRyZWVcclxuICAgICAgICB2YXIgbyA9IHRoaXMucmlnaHRcclxuICAgICAgICB3aGlsZSAoby5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBvID0gby5sZWZ0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzXHJcbiAgICAgICAgd2hpbGUgKHAucGFyZW50ICE9PSBudWxsICYmIHAgIT09IHAucGFyZW50LmxlZnQpIHtcclxuICAgICAgICAgIHAgPSBwLnBhcmVudFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcC5wYXJlbnRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJldiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBzZWFyY2ggdGhlIG1vc3QgcmlnaHQgbm9kZSBpbiB0aGUgbGVmdCB0cmVlXHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLmxlZnRcclxuICAgICAgICB3aGlsZSAoby5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgbyA9IG8ucmlnaHRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgcCA9IHRoaXNcclxuICAgICAgICB3aGlsZSAocC5wYXJlbnQgIT09IG51bGwgJiYgcCAhPT0gcC5wYXJlbnQucmlnaHQpIHtcclxuICAgICAgICAgIHAgPSBwLnBhcmVudFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcC5wYXJlbnRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcm90YXRlUmlnaHQgKHRyZWUpIHtcclxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50XHJcbiAgICAgIHZhciBuZXdQYXJlbnQgPSB0aGlzLmxlZnRcclxuICAgICAgdmFyIG5ld0xlZnQgPSB0aGlzLmxlZnQucmlnaHRcclxuICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gdGhpc1xyXG4gICAgICB0aGlzLmxlZnQgPSBuZXdMZWZ0XHJcbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICB0cmVlLnJvb3QgPSBuZXdQYXJlbnRcclxuICAgICAgICBuZXdQYXJlbnQuX3BhcmVudCA9IG51bGxcclxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgIHBhcmVudC5sZWZ0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgcGFyZW50LnJpZ2h0ID0gbmV3UGFyZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWxlbWVudHMgYXJlIHdyb25nbHkgY29ubmVjdGVkIScpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGdldFVuY2xlICgpIHtcclxuICAgICAgLy8gd2UgY2FuIGFzc3VtZSB0aGF0IGdyYW5kcGFyZW50IGV4aXN0cyB3aGVuIHRoaXMgaXMgY2FsbGVkIVxyXG4gICAgICBpZiAodGhpcy5wYXJlbnQgPT09IHRoaXMucGFyZW50LnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnBhcmVudC5yaWdodFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQubGVmdFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGFzcyBSQlRyZWUge1xyXG4gICAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgICB0aGlzLnJvb3QgPSBudWxsXHJcbiAgICAgIHRoaXMubGVuZ3RoID0gMFxyXG4gICAgfVxyXG4gICAgKiBmaW5kTmV4dCAoaWQpIHtcclxuICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZpbmRXaXRoTG93ZXJCb3VuZChbaWRbMF0sIGlkWzFdICsgMV0pXHJcbiAgICB9XHJcbiAgICAqIGZpbmRQcmV2IChpZCkge1xyXG4gICAgICByZXR1cm4geWllbGQqIHRoaXMuZmluZFdpdGhVcHBlckJvdW5kKFtpZFswXSwgaWRbMV0gLSAxXSlcclxuICAgIH1cclxuICAgIGZpbmROb2RlV2l0aExvd2VyQm91bmQgKGZyb20pIHtcclxuICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZGVmaW5lIGZyb20hJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbyA9IHRoaXMucm9vdFxyXG4gICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIGlmICgoZnJvbSA9PT0gbnVsbCB8fCBZLnV0aWxzLnNtYWxsZXIoZnJvbSwgby52YWwuaWQpKSAmJiBvLmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBpbmNsdWRlZCBpbiB0aGUgYm91bmRcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCB0aGF0IGlzIGNsb3NlciB0byB0aGUgYm91bmRcclxuICAgICAgICAgICAgbyA9IG8ubGVmdFxyXG4gICAgICAgICAgfSBlbHNlIGlmIChmcm9tICE9PSBudWxsICYmIFkudXRpbHMuc21hbGxlcihvLnZhbC5pZCwgZnJvbSkpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBub3Qgd2l0aGluIHRoZSBib3VuZCwgbWF5YmUgb25lIG9mIHRoZSByaWdodCBlbGVtZW50cyBpcy4uXHJcbiAgICAgICAgICAgIGlmIChvLnJpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgbyA9IG8ucmlnaHRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyByaWdodCBlbGVtZW50LiBTZWFyY2ggZm9yIHRoZSBuZXh0IGJpZ2dlciBlbGVtZW50LFxyXG4gICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgICAgICAgcmV0dXJuIG8ubmV4dCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kTm9kZVdpdGhVcHBlckJvdW5kICh0bykge1xyXG4gICAgICBpZiAodG8gPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZGVmaW5lIGZyb20hJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbyA9IHRoaXMucm9vdFxyXG4gICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIGlmICgodG8gPT09IG51bGwgfHwgWS51dGlscy5zbWFsbGVyKG8udmFsLmlkLCB0bykpICYmIG8ucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBpbmNsdWRlZCBpbiB0aGUgYm91bmRcclxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCB0aGF0IGlzIGNsb3NlciB0byB0aGUgYm91bmRcclxuICAgICAgICAgICAgbyA9IG8ucmlnaHRcclxuICAgICAgICAgIH0gZWxzZSBpZiAodG8gIT09IG51bGwgJiYgWS51dGlscy5zbWFsbGVyKHRvLCBvLnZhbC5pZCkpIHtcclxuICAgICAgICAgICAgLy8gbyBpcyBub3Qgd2l0aGluIHRoZSBib3VuZCwgbWF5YmUgb25lIG9mIHRoZSBsZWZ0IGVsZW1lbnRzIGlzLi5cclxuICAgICAgICAgICAgaWYgKG8ubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIG8gPSBvLmxlZnRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBsZWZ0IGVsZW1lbnQuIFNlYXJjaCBmb3IgdGhlIHByZXYgc21hbGxlciBlbGVtZW50LFxyXG4gICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgICAgICAgcmV0dXJuIG8ucHJldigpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kU21hbGxlc3ROb2RlICgpIHtcclxuICAgICAgdmFyIG8gPSB0aGlzLnJvb3RcclxuICAgICAgd2hpbGUgKG8gIT0gbnVsbCAmJiBvLmxlZnQgIT0gbnVsbCkge1xyXG4gICAgICAgIG8gPSBvLmxlZnRcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb1xyXG4gICAgfVxyXG4gICAgKiBmaW5kV2l0aExvd2VyQm91bmQgKGZyb20pIHtcclxuICAgICAgdmFyIG4gPSB0aGlzLmZpbmROb2RlV2l0aExvd2VyQm91bmQoZnJvbSlcclxuICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IG51bGwgOiBuLnZhbFxyXG4gICAgfVxyXG4gICAgKiBmaW5kV2l0aFVwcGVyQm91bmQgKHRvKSB7XHJcbiAgICAgIHZhciBuID0gdGhpcy5maW5kTm9kZVdpdGhVcHBlckJvdW5kKHRvKVxyXG4gICAgICByZXR1cm4gbiA9PSBudWxsID8gbnVsbCA6IG4udmFsXHJcbiAgICB9XHJcbiAgICAqIGl0ZXJhdGUgKHQsIGZyb20sIHRvLCBmKSB7XHJcbiAgICAgIHZhciBvXHJcbiAgICAgIGlmIChmcm9tID09PSBudWxsKSB7XHJcbiAgICAgICAgbyA9IHRoaXMuZmluZFNtYWxsZXN0Tm9kZSgpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbyA9IHRoaXMuZmluZE5vZGVXaXRoTG93ZXJCb3VuZChmcm9tKVxyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChvICE9PSBudWxsICYmICh0byA9PT0gbnVsbCB8fCBZLnV0aWxzLnNtYWxsZXIoby52YWwuaWQsIHRvKSB8fCBZLnV0aWxzLmNvbXBhcmVJZHMoby52YWwuaWQsIHRvKSkpIHtcclxuICAgICAgICB5aWVsZCogZi5jYWxsKHQsIG8udmFsKVxyXG4gICAgICAgIG8gPSBvLm5leHQoKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICAqIGxvZ1RhYmxlIChmcm9tLCB0bywgZmlsdGVyKSB7XHJcbiAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChmcm9tID09IG51bGwpIHsgZnJvbSA9IG51bGwgfVxyXG4gICAgICBpZiAodG8gPT0gbnVsbCkgeyB0byA9IG51bGwgfVxyXG4gICAgICB2YXIgb3MgPSBbXVxyXG4gICAgICB5aWVsZCogdGhpcy5pdGVyYXRlKHRoaXMsIGZyb20sIHRvLCBmdW5jdGlvbiAqIChvKSB7XHJcbiAgICAgICAgaWYgKGZpbHRlcihvKSkge1xyXG4gICAgICAgICAgdmFyIG9fID0ge31cclxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb1trZXldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgIG9fW2tleV0gPSBKU09OLnN0cmluZ2lmeShvW2tleV0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgb19ba2V5XSA9IG9ba2V5XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvcy5wdXNoKG9fKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgaWYgKGNvbnNvbGUudGFibGUgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnNvbGUudGFibGUob3MpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICogZmluZCAoaWQpIHtcclxuICAgICAgdmFyIG5cclxuICAgICAgcmV0dXJuIChuID0gdGhpcy5maW5kTm9kZShpZCkpID8gbi52YWwgOiBudWxsXHJcbiAgICB9XHJcbiAgICBmaW5kTm9kZSAoaWQpIHtcclxuICAgICAgaWYgKGlkID09IG51bGwgfHwgaWQuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgaWQgdG8gYmUgYW4gYXJyYXkhJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbyA9IHRoaXMucm9vdFxyXG4gICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBpZiAobyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChZLnV0aWxzLnNtYWxsZXIoaWQsIG8udmFsLmlkKSkge1xyXG4gICAgICAgICAgICBvID0gby5sZWZ0XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFkudXRpbHMuc21hbGxlcihvLnZhbC5pZCwgaWQpKSB7XHJcbiAgICAgICAgICAgIG8gPSBvLnJpZ2h0XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKiBkZWxldGUgKGlkKSB7XHJcbiAgICAgIGlmIChpZCA9PSBudWxsIHx8IGlkLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gQXJyYXkhJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgZCA9IHRoaXMuZmluZE5vZGUoaWQpXHJcbiAgICAgIGlmIChkID09IG51bGwpIHtcclxuICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgZG9lcyBub3QgZXhpc3QhJylcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxlbmd0aC0tXHJcbiAgICAgIGlmIChkLmxlZnQgIT09IG51bGwgJiYgZC5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHN3aXRjaCBkIHdpdGggdGhlIGdyZWF0ZXMgZWxlbWVudCBpbiB0aGUgbGVmdCBzdWJ0cmVlLlxyXG4gICAgICAgIC8vIG8gc2hvdWxkIGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXHJcbiAgICAgICAgdmFyIG8gPSBkLmxlZnRcclxuICAgICAgICAvLyBmaW5kXHJcbiAgICAgICAgd2hpbGUgKG8ucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgIG8gPSBvLnJpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN3aXRjaFxyXG4gICAgICAgIGQudmFsID0gby52YWxcclxuICAgICAgICBkID0gb1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGQgaGFzIGF0IG1vc3Qgb25lIGNoaWxkXHJcbiAgICAgIC8vIGxldCBuIGJlIHRoZSBub2RlIHRoYXQgcmVwbGFjZXMgZFxyXG4gICAgICB2YXIgaXNGYWtlQ2hpbGRcclxuICAgICAgdmFyIGNoaWxkID0gZC5sZWZ0IHx8IGQucmlnaHRcclxuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XHJcbiAgICAgICAgaXNGYWtlQ2hpbGQgPSB0cnVlXHJcbiAgICAgICAgY2hpbGQgPSBuZXcgTih7aWQ6IDB9KVxyXG4gICAgICAgIGNoaWxkLmJsYWNrZW4oKVxyXG4gICAgICAgIGQucmlnaHQgPSBjaGlsZFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlzRmFrZUNoaWxkID0gZmFsc2VcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGQucGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKCFpc0Zha2VDaGlsZCkge1xyXG4gICAgICAgICAgdGhpcy5yb290ID0gY2hpbGRcclxuICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKVxyXG4gICAgICAgICAgY2hpbGQuX3BhcmVudCA9IG51bGxcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5yb290ID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm5cclxuICAgICAgfSBlbHNlIGlmIChkLnBhcmVudC5sZWZ0ID09PSBkKSB7XHJcbiAgICAgICAgZC5wYXJlbnQubGVmdCA9IGNoaWxkXHJcbiAgICAgIH0gZWxzZSBpZiAoZC5wYXJlbnQucmlnaHQgPT09IGQpIHtcclxuICAgICAgICBkLnBhcmVudC5yaWdodCA9IGNoaWxkXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlIScpXHJcbiAgICAgIH1cclxuICAgICAgaWYgKGQuaXNCbGFjaygpKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLmlzUmVkKCkpIHtcclxuICAgICAgICAgIGNoaWxkLmJsYWNrZW4oKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9maXhEZWxldGUoY2hpbGQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucm9vdC5ibGFja2VuKClcclxuICAgICAgaWYgKGlzRmFrZUNoaWxkKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudC5sZWZ0ID09PSBjaGlsZCkge1xyXG4gICAgICAgICAgY2hpbGQucGFyZW50LmxlZnQgPSBudWxsXHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5wYXJlbnQucmlnaHQgPT09IGNoaWxkKSB7XHJcbiAgICAgICAgICBjaGlsZC5wYXJlbnQucmlnaHQgPSBudWxsXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1wb3NzaWJsZSAjMycpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZml4RGVsZXRlIChuKSB7XHJcbiAgICAgIGZ1bmN0aW9uIGlzQmxhY2sgKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZSAhPT0gbnVsbCA/IG5vZGUuaXNCbGFjaygpIDogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGlzUmVkIChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUgIT09IG51bGwgPyBub2RlLmlzUmVkKCkgOiBmYWxzZVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChuLnBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBmaXJzdCBpdGVyYXRpb24gb2YgZml4RGVsZXRlLlxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIC8vIGQgd2FzIGFscmVhZHkgcmVwbGFjZWQgYnkgdGhlIGNoaWxkXHJcbiAgICAgIC8vIGQgaXMgbm90IHRoZSByb290XHJcbiAgICAgIC8vIGQgYW5kIGNoaWxkIGFyZSBibGFja1xyXG4gICAgICB2YXIgc2libGluZyA9IG4uc2libGluZ1xyXG4gICAgICBpZiAoaXNSZWQoc2libGluZykpIHtcclxuICAgICAgICAvLyBtYWtlIHNpYmxpbmcgdGhlIGdyYW5kZmF0aGVyXHJcbiAgICAgICAgbi5wYXJlbnQucmVkZGVuKClcclxuICAgICAgICBzaWJsaW5nLmJsYWNrZW4oKVxyXG4gICAgICAgIGlmIChuID09PSBuLnBhcmVudC5sZWZ0KSB7XHJcbiAgICAgICAgICBuLnBhcmVudC5yb3RhdGVMZWZ0KHRoaXMpXHJcbiAgICAgICAgfSBlbHNlIGlmIChuID09PSBuLnBhcmVudC5yaWdodCkge1xyXG4gICAgICAgICAgbi5wYXJlbnQucm90YXRlUmlnaHQodGhpcylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvc3NpYmxlICMyJylcclxuICAgICAgICB9XHJcbiAgICAgICAgc2libGluZyA9IG4uc2libGluZ1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHBhcmVudCwgc2libGluZywgYW5kIGNoaWxkcmVuIG9mIG4gYXJlIGJsYWNrXHJcbiAgICAgIGlmIChuLnBhcmVudC5pc0JsYWNrKCkgJiZcclxuICAgICAgICBzaWJsaW5nLmlzQmxhY2soKSAmJlxyXG4gICAgICAgIGlzQmxhY2soc2libGluZy5sZWZ0KSAmJlxyXG4gICAgICAgIGlzQmxhY2soc2libGluZy5yaWdodClcclxuICAgICAgKSB7XHJcbiAgICAgICAgc2libGluZy5yZWRkZW4oKVxyXG4gICAgICAgIHRoaXMuX2ZpeERlbGV0ZShuLnBhcmVudClcclxuICAgICAgfSBlbHNlIGlmIChuLnBhcmVudC5pc1JlZCgpICYmXHJcbiAgICAgICAgc2libGluZy5pc0JsYWNrKCkgJiZcclxuICAgICAgICBpc0JsYWNrKHNpYmxpbmcubGVmdCkgJiZcclxuICAgICAgICBpc0JsYWNrKHNpYmxpbmcucmlnaHQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHNpYmxpbmcucmVkZGVuKClcclxuICAgICAgICBuLnBhcmVudC5ibGFja2VuKClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQubGVmdCAmJlxyXG4gICAgICAgICAgc2libGluZy5pc0JsYWNrKCkgJiZcclxuICAgICAgICAgIGlzUmVkKHNpYmxpbmcubGVmdCkgJiZcclxuICAgICAgICAgIGlzQmxhY2soc2libGluZy5yaWdodClcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHNpYmxpbmcucmVkZGVuKClcclxuICAgICAgICAgIHNpYmxpbmcubGVmdC5ibGFja2VuKClcclxuICAgICAgICAgIHNpYmxpbmcucm90YXRlUmlnaHQodGhpcylcclxuICAgICAgICAgIHNpYmxpbmcgPSBuLnNpYmxpbmdcclxuICAgICAgICB9IGVsc2UgaWYgKG4gPT09IG4ucGFyZW50LnJpZ2h0ICYmXHJcbiAgICAgICAgICBzaWJsaW5nLmlzQmxhY2soKSAmJlxyXG4gICAgICAgICAgaXNSZWQoc2libGluZy5yaWdodCkgJiZcclxuICAgICAgICAgIGlzQmxhY2soc2libGluZy5sZWZ0KVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgc2libGluZy5yZWRkZW4oKVxyXG4gICAgICAgICAgc2libGluZy5yaWdodC5ibGFja2VuKClcclxuICAgICAgICAgIHNpYmxpbmcucm90YXRlTGVmdCh0aGlzKVxyXG4gICAgICAgICAgc2libGluZyA9IG4uc2libGluZ1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaWJsaW5nLmNvbG9yID0gbi5wYXJlbnQuY29sb3JcclxuICAgICAgICBuLnBhcmVudC5ibGFja2VuKClcclxuICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQubGVmdCkge1xyXG4gICAgICAgICAgc2libGluZy5yaWdodC5ibGFja2VuKClcclxuICAgICAgICAgIG4ucGFyZW50LnJvdGF0ZUxlZnQodGhpcylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2libGluZy5sZWZ0LmJsYWNrZW4oKVxyXG4gICAgICAgICAgbi5wYXJlbnQucm90YXRlUmlnaHQodGhpcylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICogcHV0ICh2KSB7XHJcbiAgICAgIGlmICh2ID09IG51bGwgfHwgdi5pZCA9PSBudWxsIHx8IHYuaWQuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2IGlzIGV4cGVjdGVkIHRvIGhhdmUgYW4gaWQgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkhJylcclxuICAgICAgfVxyXG4gICAgICB2YXIgbm9kZSA9IG5ldyBOKHYpXHJcbiAgICAgIGlmICh0aGlzLnJvb3QgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgcCA9IHRoaXMucm9vdCAvLyBwIGFiYnJldi4gcGFyZW50XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgIGlmIChZLnV0aWxzLnNtYWxsZXIobm9kZS52YWwuaWQsIHAudmFsLmlkKSkge1xyXG4gICAgICAgICAgICBpZiAocC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcC5sZWZ0ID0gbm9kZVxyXG4gICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcCA9IHAubGVmdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFkudXRpbHMuc21hbGxlcihwLnZhbC5pZCwgbm9kZS52YWwuaWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChwLnJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcC5yaWdodCA9IG5vZGVcclxuICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHAgPSBwLnJpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHAudmFsID0gbm9kZS52YWxcclxuICAgICAgICAgICAgcmV0dXJuIHBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZml4SW5zZXJ0KG5vZGUpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbm9kZVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGVuZ3RoKytcclxuICAgICAgdGhpcy5yb290LmJsYWNrZW4oKVxyXG4gICAgICByZXR1cm4gbm9kZVxyXG4gICAgfVxyXG4gICAgX2ZpeEluc2VydCAobikge1xyXG4gICAgICBpZiAobi5wYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICBuLmJsYWNrZW4oKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9IGVsc2UgaWYgKG4ucGFyZW50LmlzQmxhY2soKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIHZhciB1bmNsZSA9IG4uZ2V0VW5jbGUoKVxyXG4gICAgICBpZiAodW5jbGUgIT09IG51bGwgJiYgdW5jbGUuaXNSZWQoKSkge1xyXG4gICAgICAgIC8vIE5vdGU6IHBhcmVudDogcmVkLCB1bmNsZTogcmVkXHJcbiAgICAgICAgbi5wYXJlbnQuYmxhY2tlbigpXHJcbiAgICAgICAgdW5jbGUuYmxhY2tlbigpXHJcbiAgICAgICAgbi5ncmFuZHBhcmVudC5yZWRkZW4oKVxyXG4gICAgICAgIHRoaXMuX2ZpeEluc2VydChuLmdyYW5kcGFyZW50KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vdGU6IHBhcmVudDogcmVkLCB1bmNsZTogYmxhY2sgb3IgbnVsbFxyXG4gICAgICAgIC8vIE5vdyB3ZSB0cmFuc2Zvcm0gdGhlIHRyZWUgaW4gc3VjaCBhIHdheSB0aGF0XHJcbiAgICAgICAgLy8gZWl0aGVyIG9mIHRoZXNlIGhvbGRzOlxyXG4gICAgICAgIC8vICAgMSkgZ3JhbmRwYXJlbnQubGVmdC5pc1JlZFxyXG4gICAgICAgIC8vICAgICBhbmQgZ3JhbmRwYXJlbnQubGVmdC5sZWZ0LmlzUmVkXHJcbiAgICAgICAgLy8gICAyKSBncmFuZHBhcmVudC5yaWdodC5pc1JlZFxyXG4gICAgICAgIC8vICAgICBhbmQgZ3JhbmRwYXJlbnQucmlnaHQucmlnaHQuaXNSZWRcclxuICAgICAgICBpZiAobiA9PT0gbi5wYXJlbnQucmlnaHQgJiYgbi5wYXJlbnQgPT09IG4uZ3JhbmRwYXJlbnQubGVmdCkge1xyXG4gICAgICAgICAgbi5wYXJlbnQucm90YXRlTGVmdCh0aGlzKVxyXG4gICAgICAgICAgLy8gU2luY2Ugd2Ugcm90YXRlZCBhbmQgd2FudCB0byB1c2UgdGhlIHByZXZpb3VzXHJcbiAgICAgICAgICAvLyBjYXNlcywgd2UgbmVlZCB0byBzZXQgbiBpbiBzdWNoIGEgd2F5IHRoYXRcclxuICAgICAgICAgIC8vIG4ucGFyZW50LmlzUmVkIGFnYWluXHJcbiAgICAgICAgICBuID0gbi5sZWZ0XHJcbiAgICAgICAgfSBlbHNlIGlmIChuID09PSBuLnBhcmVudC5sZWZ0ICYmIG4ucGFyZW50ID09PSBuLmdyYW5kcGFyZW50LnJpZ2h0KSB7XHJcbiAgICAgICAgICBuLnBhcmVudC5yb3RhdGVSaWdodCh0aGlzKVxyXG4gICAgICAgICAgLy8gc2VlIGFib3ZlXHJcbiAgICAgICAgICBuID0gbi5yaWdodFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYXNlIDEpIG9yIDIpIGhvbGQgZnJvbSBoZXJlIG9uLlxyXG4gICAgICAgIC8vIE5vdyB0cmF2ZXJzZSBncmFuZHBhcmVudCwgbWFrZSBwYXJlbnQgYSBibGFjayBub2RlXHJcbiAgICAgICAgLy8gb24gdGhlIGhpZ2hlc3QgbGV2ZWwgd2hpY2ggaG9sZHMgdHdvIHJlZCBub2Rlcy5cclxuICAgICAgICBuLnBhcmVudC5ibGFja2VuKClcclxuICAgICAgICBuLmdyYW5kcGFyZW50LnJlZGRlbigpXHJcbiAgICAgICAgaWYgKG4gPT09IG4ucGFyZW50LmxlZnQpIHtcclxuICAgICAgICAgIC8vIENhc2UgMVxyXG4gICAgICAgICAgbi5ncmFuZHBhcmVudC5yb3RhdGVSaWdodCh0aGlzKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBDYXNlIDJcclxuICAgICAgICAgIG4uZ3JhbmRwYXJlbnQucm90YXRlTGVmdCh0aGlzKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgKiBmbHVzaCAoKSB7fVxyXG4gIH1cclxuXHJcbiAgWS51dGlscy5SQlRyZWUgPSBSQlRyZWVcclxufVxyXG4iLCIvKiBnbG9iYWwgWSwgZ2xvYmFsICovXG4ndXNlIHN0cmljdCdcblxuLy8gc29ja2V0LmlvIHJlcXVpcmVzIHV0ZjguIFRoaXMgcGFja2FnZSBjaGVja3MgaWYgaXQgaXMgcmVxdWlyZWQgYnkgcmVxdWlyZWpzLlxuLy8gSWYgd2luZG93LnJlcXVpcmUgaXMgc2V0LCB0aGVuIGl0IHdpbGwgZGVmaW5lIGl0c2VsZiBhcyBhIG1vZHVsZS4gVGhpcyBpcyBlcnJhdGljIGJlaGF2aW9yIGFuZFxuLy8gcmVzdWx0cyBpbiBzb2NrZXQuaW8gaGF2aW5nIGEgXCJiYWQgcmVxdWVzdFwiLlxuLy8gVGhpcyBpcyB3aHkgd2UgdW5kZWZpbmUgZ2xvYmFsLmRlZmluZSAoaXQgaXMgc2V0IGJ5IHJlcXVpcmVqcykgYmVmb3JlIHdlIHJlcXVpcmUgc29ja2V0LmlvLWNsaWVudC5cbnZhciBkZWZpbmUgPSBnbG9iYWwuZGVmaW5lXG5nbG9iYWwuZGVmaW5lID0gbnVsbFxudmFyIGlvID0gcmVxdWlyZSgnc29ja2V0LmlvLWNsaWVudCcpXG4vLyByZWRlZmluZSBnbG9iYWwuZGVmaW5lXG5nbG9iYWwuZGVmaW5lID0gZGVmaW5lXG5cbmZ1bmN0aW9uIGV4dGVuZCAoWSkge1xuICBjbGFzcyBDb25uZWN0b3IgZXh0ZW5kcyBZLkFic3RyYWN0Q29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvciAoeSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgbXVzdCBub3QgYmUgdW5kZWZpbmVkIScpXG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yb29tID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgYSByb29tIG5hbWUhJylcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucm9sZSA9ICdzbGF2ZSdcbiAgICAgIHN1cGVyKHksIG9wdGlvbnMpXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsIHx8ICdodHRwczovL3lqcy5kYmlzLnJ3dGgtYWFjaGVuLmRlOjUwNzInXG4gICAgICB2YXIgc29ja2V0ID0gb3B0aW9ucy5zb2NrZXQgfHwgaW8ob3B0aW9ucy51cmwpXG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICAgIHRoaXMuX29uQ29ubmVjdCA9IGZ1bmN0aW9uIGpvaW5Sb29tICgpIHtcbiAgICAgICAgc29ja2V0LmVtaXQoJ2pvaW5Sb29tJywgb3B0aW9ucy5yb29tKVxuICAgICAgICBzZWxmLnVzZXJKb2luZWQoJ3NlcnZlcicsICdtYXN0ZXInKVxuICAgICAgfVxuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCB0aGlzLl9vbkNvbm5lY3QpXG4gICAgICBpZiAoc29ja2V0LmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9vbkNvbm5lY3QoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vbllqc0V2ZW50ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3N5bmMgZG9uZScpIHtcbiAgICAgICAgICAgIHZhciB1c2VySWQgPSBzb2NrZXQuaWRcbiAgICAgICAgICAgIGlmIChzb2NrZXQuX3lqc19jb25uZWN0aW9uX2NvdW50ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzb2NrZXQuX3lqc19jb25uZWN0aW9uX2NvdW50ZXIgPSAxXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1c2VySWQgKz0gc29ja2V0Ll95anNfY29ubmVjdGlvbl9jb3VudGVyKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuc2V0VXNlcklkKHVzZXJJZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uucm9vbSA9PT0gb3B0aW9ucy5yb29tKSB7XG4gICAgICAgICAgICBzZWxmLnJlY2VpdmVNZXNzYWdlKCdzZXJ2ZXInLCBtZXNzYWdlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc29ja2V0Lm9uKCd5anNFdmVudCcsIHRoaXMuX29uWWpzRXZlbnQpXG5cbiAgICAgIHRoaXMuX29uRGlzY29ubmVjdCA9IGZ1bmN0aW9uIChwZWVyKSB7XG4gICAgICAgIHNlbGYudXNlckxlZnQoJ3NlcnZlcicpXG4gICAgICB9XG4gICAgICBzb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzLl9vbkRpc2Nvbm5lY3QpXG4gICAgfVxuICAgIGRpc2Nvbm5lY3QgKCkge1xuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgnbGVhdmVSb29tJywgdGhpcy5vcHRpb25zLnJvb20pXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgICB9XG4gICAgICBzdXBlci5kaXNjb25uZWN0KClcbiAgICB9XG4gICAgZGVzdHJveSAoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5zb2NrZXQub2ZmKCdkaXNjb25uZWN0JywgdGhpcy5fb25EaXNjb25uZWN0KVxuICAgICAgdGhpcy5zb2NrZXQub2ZmKCd5anNFdmVudCcsIHRoaXMuX29uWWpzRXZlbnQpXG4gICAgICB0aGlzLnNvY2tldC5vZmYoJ2Nvbm5lY3QnLCB0aGlzLl9vbkNvbm5lY3QpXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpXG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldCA9IG51bGxcbiAgICB9XG4gICAgcmVjb25uZWN0ICgpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgc3VwZXIucmVjb25uZWN0KClcbiAgICB9XG4gICAgc2VuZCAodWlkLCBtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlLnJvb20gPSB0aGlzLm9wdGlvbnMucm9vbVxuICAgICAgdGhpcy5zb2NrZXQuZW1pdCgneWpzRXZlbnQnLCBtZXNzYWdlKVxuICAgIH1cbiAgICBicm9hZGNhc3QgKG1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2Uucm9vbSA9IHRoaXMub3B0aW9ucy5yb29tXG4gICAgICB0aGlzLnNvY2tldC5lbWl0KCd5anNFdmVudCcsIG1lc3NhZ2UpXG4gICAgfVxuICAgIGlzRGlzY29ubmVjdGVkICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5kaXNjb25uZWN0ZWRcbiAgICB9XG4gIH1cbiAgQ29ubmVjdG9yLmlvID0gaW9cbiAgWS5leHRlbmQoJ3dlYnNvY2tldHMtY2xpZW50JywgQ29ubmVjdG9yKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuaWYgKHR5cGVvZiBZICE9PSAndW5kZWZpbmVkJykge1xuICBleHRlbmQoWSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iLCIvKiBAZmxvdyAqL1xuJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkvKiA6YW55ICovKSB7XG4gIGNsYXNzIEFic3RyYWN0Q29ubmVjdG9yIHtcbiAgICAvKiA6OlxuICAgIHk6IFlDb25maWc7XG4gICAgcm9sZTogU3luY1JvbGU7XG4gICAgY29ubmVjdGlvbnM6IE9iamVjdDtcbiAgICBpc1N5bmNlZDogYm9vbGVhbjtcbiAgICB1c2VyRXZlbnRMaXN0ZW5lcnM6IEFycmF5PEZ1bmN0aW9uPjtcbiAgICB3aGVuU3luY2VkTGlzdGVuZXJzOiBBcnJheTxGdW5jdGlvbj47XG4gICAgY3VycmVudFN5bmNUYXJnZXQ6ID9Vc2VySWQ7XG4gICAgc3luY2luZ0NsaWVudHM6IEFycmF5PFVzZXJJZD47XG4gICAgZm9yd2FyZFRvU3luY2luZ0NsaWVudHM6IGJvb2xlYW47XG4gICAgZGVidWc6IGJvb2xlYW47XG4gICAgYnJvYWRjYXN0ZWRIQjogYm9vbGVhbjtcbiAgICBzeW5jU3RlcDI6IFByb21pc2U7XG4gICAgdXNlcklkOiBVc2VySWQ7XG4gICAgc2VuZDogRnVuY3Rpb247XG4gICAgYnJvYWRjYXN0OiBGdW5jdGlvbjtcbiAgICBicm9hZGNhc3RPcEJ1ZmZlcjogQXJyYXk8T3BlcmF0aW9uPjtcbiAgICBwcm90b2NvbFZlcnNpb246IG51bWJlcjtcbiAgICAqL1xuICAgIC8qXG4gICAgICBvcHRzIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG4gICAgICAgcm9sZSA6IFN0cmluZyBSb2xlIG9mIHRoaXMgY2xpZW50IChcIm1hc3RlclwiIG9yIFwic2xhdmVcIilcbiAgICAgICB1c2VySWQgOiBTdHJpbmcgVW5pcXVlbHkgZGVmaW5lcyB0aGUgdXNlci5cbiAgICAgICBkZWJ1ZzogQm9vbGVhbiBXaGV0aGVyIHRvIHByaW50IGRlYnVnIG1lc3NhZ2VzIChvcHRpb25hbClcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yICh5LCBvcHRzKSB7XG4gICAgICB0aGlzLnkgPSB5XG4gICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fVxuICAgICAgfVxuICAgICAgaWYgKG9wdHMucm9sZSA9PSBudWxsIHx8IG9wdHMucm9sZSA9PT0gJ21hc3RlcicpIHtcbiAgICAgICAgdGhpcy5yb2xlID0gJ21hc3RlcidcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5yb2xlID09PSAnc2xhdmUnKSB7XG4gICAgICAgIHRoaXMucm9sZSA9ICdzbGF2ZSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvbGUgbXVzdCBiZSBlaXRoZXIgJ21hc3Rlcicgb3IgJ3NsYXZlJyFcIilcbiAgICAgIH1cbiAgICAgIHRoaXMueS5kYi5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgPSBvcHRzLmZvcndhcmRBcHBsaWVkT3BlcmF0aW9ucyB8fCBmYWxzZVxuICAgICAgdGhpcy5yb2xlID0gb3B0cy5yb2xlXG4gICAgICB0aGlzLmNvbm5lY3Rpb25zID0ge31cbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZVxuICAgICAgdGhpcy51c2VyRXZlbnRMaXN0ZW5lcnMgPSBbXVxuICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzID0gW11cbiAgICAgIHRoaXMuY3VycmVudFN5bmNUYXJnZXQgPSBudWxsXG4gICAgICB0aGlzLnN5bmNpbmdDbGllbnRzID0gW11cbiAgICAgIHRoaXMuZm9yd2FyZFRvU3luY2luZ0NsaWVudHMgPSBvcHRzLmZvcndhcmRUb1N5bmNpbmdDbGllbnRzICE9PSBmYWxzZVxuICAgICAgdGhpcy5kZWJ1ZyA9IG9wdHMuZGVidWcgPT09IHRydWVcbiAgICAgIHRoaXMuYnJvYWRjYXN0ZWRIQiA9IGZhbHNlXG4gICAgICB0aGlzLnN5bmNTdGVwMiA9IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB0aGlzLmJyb2FkY2FzdE9wQnVmZmVyID0gW11cbiAgICAgIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gMTFcbiAgICB9XG4gICAgcmVjb25uZWN0ICgpIHtcbiAgICB9XG4gICAgZGlzY29ubmVjdCAoKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zID0ge31cbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZVxuICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IG51bGxcbiAgICAgIHRoaXMuYnJvYWRjYXN0ZWRIQiA9IGZhbHNlXG4gICAgICB0aGlzLnN5bmNpbmdDbGllbnRzID0gW11cbiAgICAgIHRoaXMud2hlblN5bmNlZExpc3RlbmVycyA9IFtdXG4gICAgICByZXR1cm4gdGhpcy55LmRiLnN0b3BHYXJiYWdlQ29sbGVjdG9yKClcbiAgICB9XG4gICAgc2V0VXNlcklkICh1c2VySWQpIHtcbiAgICAgIGlmICh0aGlzLnVzZXJJZCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudXNlcklkID0gdXNlcklkXG4gICAgICAgIHJldHVybiB0aGlzLnkuZGIuc2V0VXNlcklkKHVzZXJJZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIG9uVXNlckV2ZW50IChmKSB7XG4gICAgICB0aGlzLnVzZXJFdmVudExpc3RlbmVycy5wdXNoKGYpXG4gICAgfVxuICAgIHVzZXJMZWZ0ICh1c2VyKSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uc1t1c2VyXSAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW3VzZXJdXG4gICAgICAgIGlmICh1c2VyID09PSB0aGlzLmN1cnJlbnRTeW5jVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IG51bGxcbiAgICAgICAgICB0aGlzLmZpbmROZXh0U3luY1RhcmdldCgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jaW5nQ2xpZW50cyA9IHRoaXMuc3luY2luZ0NsaWVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGkpIHtcbiAgICAgICAgICByZXR1cm4gY2xpICE9PSB1c2VyXG4gICAgICAgIH0pXG4gICAgICAgIGZvciAodmFyIGYgb2YgdGhpcy51c2VyRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3VzZXJMZWZ0JyxcbiAgICAgICAgICAgIHVzZXI6IHVzZXJcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVzZXJKb2luZWQgKHVzZXIsIHJvbGUpIHtcbiAgICAgIGlmIChyb2xlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IHRoZSByb2xlIG9mIHRoZSBqb2luZWQgdXNlciEnKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbdXNlcl0gIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdXNlciBhbHJlYWR5IGpvaW5lZCEnKVxuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0aW9uc1t1c2VyXSA9IHtcbiAgICAgICAgaXNTeW5jZWQ6IGZhbHNlLFxuICAgICAgICByb2xlOiByb2xlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBmIG9mIHRoaXMudXNlckV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIGYoe1xuICAgICAgICAgIGFjdGlvbjogJ3VzZXJKb2luZWQnLFxuICAgICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgICAgcm9sZTogcm9sZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY3VycmVudFN5bmNUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZpbmROZXh0U3luY1RhcmdldCgpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgYSBmdW5jdGlvbiBfd2hlbl8gd2UgYXJlIGNvbm5lY3RlZC5cbiAgICAvLyBJZiBub3QgY29ubmVjdGVkLCB3YWl0IHVudGlsIGNvbm5lY3RlZFxuICAgIHdoZW5TeW5jZWQgKGYpIHtcbiAgICAgIGlmICh0aGlzLmlzU3luY2VkKSB7XG4gICAgICAgIGYoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53aGVuU3luY2VkTGlzdGVuZXJzLnB1c2goZilcbiAgICAgIH1cbiAgICB9XG4gICAgLypcblxuICAgICByZXR1cm5zIGZhbHNlLCBpZiB0aGVyZSBpcyBubyBzeW5jIHRhcmdldFxuICAgICB0cnVlIG90aGVyd2lzZVxuICAgICovXG4gICAgZmluZE5leHRTeW5jVGFyZ2V0ICgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRTeW5jVGFyZ2V0ICE9IG51bGwgfHwgdGhpcy5pc1N5bmNlZCkge1xuICAgICAgICByZXR1cm4gLy8gXCJUaGUgY3VycmVudCBzeW5jIGhhcyBub3QgZmluaXNoZWQhXCJcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNVc2VyID0gbnVsbFxuICAgICAgZm9yICh2YXIgdWlkIGluIHRoaXMuY29ubmVjdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW3VpZF0uaXNTeW5jZWQpIHtcbiAgICAgICAgICBzeW5jVXNlciA9IHVpZFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjb25uID0gdGhpc1xuICAgICAgaWYgKHN5bmNVc2VyICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IHN5bmNVc2VyXG4gICAgICAgIHRoaXMueS5kYi5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICB2YXIgc3RhdGVTZXQgPSB5aWVsZCogdGhpcy5nZXRTdGF0ZVNldCgpXG4gICAgICAgICAgdmFyIGRlbGV0ZVNldCA9IHlpZWxkKiB0aGlzLmdldERlbGV0ZVNldCgpXG4gICAgICAgICAgY29ubi5zZW5kKHN5bmNVc2VyLCB7XG4gICAgICAgICAgICB0eXBlOiAnc3luYyBzdGVwIDEnLFxuICAgICAgICAgICAgc3RhdGVTZXQ6IHN0YXRlU2V0LFxuICAgICAgICAgICAgZGVsZXRlU2V0OiBkZWxldGVTZXQsXG4gICAgICAgICAgICBwcm90b2NvbFZlcnNpb246IGNvbm4ucHJvdG9jb2xWZXJzaW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueS5kYi5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKigpIHtcbiAgICAgICAgICAvLyBpdCBpcyBjcnVjaWFsIHRoYXQgaXNTeW5jZWQgaXMgc2V0IGF0IHRoZSB0aW1lIGdhcmJhZ2VDb2xsZWN0QWZ0ZXJTeW5jIGlzIGNhbGxlZFxuICAgICAgICAgIGNvbm4uaXNTeW5jZWQgPSB0cnVlXG4gICAgICAgICAgeWllbGQqIHRoaXMuZ2FyYmFnZUNvbGxlY3RBZnRlclN5bmMoKVxuICAgICAgICAgIC8vIGNhbGwgd2hlbnN5bmNlZCBsaXN0ZW5lcnNcbiAgICAgICAgICBmb3IgKHZhciBmIG9mIGNvbm4ud2hlblN5bmNlZExpc3RlbmVycykge1xuICAgICAgICAgICAgZigpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbm4ud2hlblN5bmNlZExpc3RlbmVycyA9IFtdXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHNlbmQgKHVpZCwgbWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYHNlbmQgJHt0aGlzLnVzZXJJZH0gLT4gJHt1aWR9OiAke21lc3NhZ2UudHlwZX1gLCBtZXNzYWdlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBCdWZmZXIgb3BlcmF0aW9ucywgYW5kIGJyb2FkY2FzdCB0aGVtIHdoZW4gcmVhZHkuXG4gICAgKi9cbiAgICBicm9hZGNhc3RPcHMgKG9wcykge1xuICAgICAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIFkuU3RydWN0W29wLnN0cnVjdF0uZW5jb2RlKG9wKVxuICAgICAgfSlcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgZnVuY3Rpb24gYnJvYWRjYXN0T3BlcmF0aW9ucyAoKSB7XG4gICAgICAgIGlmIChzZWxmLmJyb2FkY2FzdE9wQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZWxmLmJyb2FkY2FzdCh7XG4gICAgICAgICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgICAgICAgIG9wczogc2VsZi5icm9hZGNhc3RPcEJ1ZmZlclxuICAgICAgICAgIH0pXG4gICAgICAgICAgc2VsZi5icm9hZGNhc3RPcEJ1ZmZlciA9IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJyb2FkY2FzdE9wQnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdE9wQnVmZmVyID0gb3BzXG4gICAgICAgIGlmICh0aGlzLnkuZGIudHJhbnNhY3Rpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgdGhpcy55LmRiLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpLnRoZW4oYnJvYWRjYXN0T3BlcmF0aW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGJyb2FkY2FzdE9wZXJhdGlvbnMsIDApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0T3BCdWZmZXIgPSB0aGlzLmJyb2FkY2FzdE9wQnVmZmVyLmNvbmNhdChvcHMpXG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBZb3UgcmVjZWl2ZWQgYSByYXcgbWVzc2FnZSwgYW5kIHlvdSBrbm93IHRoYXQgaXQgaXMgaW50ZW5kZWQgZm9yIFlqcy4gVGhlbiBjYWxsIHRoaXMgZnVuY3Rpb24uXG4gICAgKi9cbiAgICByZWNlaXZlTWVzc2FnZSAoc2VuZGVyLyogOlVzZXJJZCAqLywgbWVzc2FnZS8qIDpNZXNzYWdlICovKSB7XG4gICAgICBpZiAoc2VuZGVyID09PSB0aGlzLnVzZXJJZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGByZWNlaXZlICR7c2VuZGVyfSAtPiAke3RoaXMudXNlcklkfTogJHttZXNzYWdlLnR5cGV9YCwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXNzYWdlKSkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLnByb3RvY29sVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UucHJvdG9jb2xWZXJzaW9uICE9PSB0aGlzLnByb3RvY29sVmVyc2lvbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBZb3UgdHJpZWQgdG8gc3luYyB3aXRoIGEgeWpzIGluc3RhbmNlIHRoYXQgaGFzIGEgZGlmZmVyZW50IHByb3RvY29sIHZlcnNpb25cbiAgICAgICAgICAoWW91OiAke3RoaXMucHJvdG9jb2xWZXJzaW9ufSwgQ2xpZW50OiAke21lc3NhZ2UucHJvdG9jb2xWZXJzaW9ufSkuXG4gICAgICAgICAgVGhlIHN5bmMgd2FzIHN0b3BwZWQuIFlvdSBuZWVkIHRvIHVwZ3JhZGUgeW91ciBkZXBlbmRlbmNpZXMgKGVzcGVjaWFsbHkgWWpzICYgdGhlIENvbm5lY3RvcikhXG4gICAgICAgICAgYClcbiAgICAgICAgdGhpcy5zZW5kKHNlbmRlciwge1xuICAgICAgICAgIHR5cGU6ICdzeW5jIHN0b3AnLFxuICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogdGhpcy5wcm90b2NvbFZlcnNpb25cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSAnc3luYyBzdGVwIDEnKSB7XG4gICAgICAgIGxldCBjb25uID0gdGhpc1xuICAgICAgICBsZXQgbSA9IG1lc3NhZ2VcbiAgICAgICAgdGhpcy55LmRiLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqKCkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhdGVTZXQgPSB5aWVsZCogdGhpcy5nZXRTdGF0ZVNldCgpXG4gICAgICAgICAgeWllbGQqIHRoaXMuYXBwbHlEZWxldGVTZXQobS5kZWxldGVTZXQpXG5cbiAgICAgICAgICB2YXIgZHMgPSB5aWVsZCogdGhpcy5nZXREZWxldGVTZXQoKVxuICAgICAgICAgIHZhciBvcHMgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb25zKG0uc3RhdGVTZXQpXG4gICAgICAgICAgY29ubi5zZW5kKHNlbmRlciwge1xuICAgICAgICAgICAgdHlwZTogJ3N5bmMgc3RlcCAyJyxcbiAgICAgICAgICAgIG9zOiBvcHMsXG4gICAgICAgICAgICBzdGF0ZVNldDogY3VycmVudFN0YXRlU2V0LFxuICAgICAgICAgICAgZGVsZXRlU2V0OiBkcyxcbiAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogdGhpcy5wcm90b2NvbFZlcnNpb25cbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmICh0aGlzLmZvcndhcmRUb1N5bmNpbmdDbGllbnRzKSB7XG4gICAgICAgICAgICBjb25uLnN5bmNpbmdDbGllbnRzLnB1c2goc2VuZGVyKVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbm4uc3luY2luZ0NsaWVudHMgPSBjb25uLnN5bmNpbmdDbGllbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaSAhPT0gc2VuZGVyXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGNvbm4uc2VuZChzZW5kZXIsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3luYyBkb25lJ1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSwgNTAwMCkgLy8gVE9ETzogY29ubi5zeW5jaW5nQ2xpZW50RHVyYXRpb24pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbm4uc2VuZChzZW5kZXIsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N5bmMgZG9uZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbm4uX3NldFN5bmNlZFdpdGgoc2VuZGVyKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzeW5jIHN0ZXAgMicpIHtcbiAgICAgICAgbGV0IGNvbm4gPSB0aGlzXG4gICAgICAgIHZhciBicm9hZGNhc3RIQiA9ICF0aGlzLmJyb2FkY2FzdGVkSEJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RlZEhCID0gdHJ1ZVxuICAgICAgICB2YXIgZGIgPSB0aGlzLnkuZGJcbiAgICAgICAgdmFyIGRlZmVyID0ge31cbiAgICAgICAgZGVmZXIucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgZGVmZXIucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5zeW5jU3RlcDIgPSBkZWZlci5wcm9taXNlXG4gICAgICAgIGxldCBtIC8qIDpNZXNzYWdlU3luY1N0ZXAyICovID0gbWVzc2FnZVxuICAgICAgICBkYi5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgICAgeWllbGQqIHRoaXMuYXBwbHlEZWxldGVTZXQobS5kZWxldGVTZXQpXG4gICAgICAgICAgdGhpcy5zdG9yZS5hcHBseShtLm9zKVxuICAgICAgICAgIGRiLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICAgIHZhciBvcHMgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb25zKG0uc3RhdGVTZXQpXG4gICAgICAgICAgICBpZiAob3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKCFicm9hZGNhc3RIQikgeyAvLyBUT0RPOiBjb25zaWRlciB0byBicm9hZGNhc3QgaGVyZS4uXG4gICAgICAgICAgICAgICAgY29ubi5zZW5kKHNlbmRlciwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICBvcHM6IG9wc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYnJvYWRjYXN0IG9ubHkgb25jZSFcbiAgICAgICAgICAgICAgICBjb25uLmJyb2FkY2FzdE9wcyhvcHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3N5bmMgZG9uZScpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgIHRoaXMuc3luY1N0ZXAyLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX3NldFN5bmNlZFdpdGgoc2VuZGVyKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcndhcmRUb1N5bmNpbmdDbGllbnRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgY2xpZW50IG9mIHRoaXMuc3luY2luZ0NsaWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZChjbGllbnQsIG1lc3NhZ2UpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnkuZGIuZm9yd2FyZEFwcGxpZWRPcGVyYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGRlbG9wcyA9IG1lc3NhZ2Uub3BzLmZpbHRlcihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuIG8uc3RydWN0ID09PSAnRGVsZXRlJ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKGRlbG9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE9wcyhkZWxvcHMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMueS5kYi5hcHBseShtZXNzYWdlLm9wcylcbiAgICAgIH1cbiAgICB9XG4gICAgX3NldFN5bmNlZFdpdGggKHVzZXIpIHtcbiAgICAgIHZhciBjb25uID0gdGhpcy5jb25uZWN0aW9uc1t1c2VyXVxuICAgICAgaWYgKGNvbm4gIT0gbnVsbCkge1xuICAgICAgICBjb25uLmlzU3luY2VkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHVzZXIgPT09IHRoaXMuY3VycmVudFN5bmNUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3luY1RhcmdldCA9IG51bGxcbiAgICAgICAgdGhpcy5maW5kTmV4dFN5bmNUYXJnZXQoKVxuICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgICAgQ3VycmVudGx5LCB0aGUgSEIgZW5jb2RlcyBvcGVyYXRpb25zIGFzIEpTT04uIEZvciB0aGUgbW9tZW50IEkgd2FudCB0byBrZWVwIGl0XG4gICAgICB0aGF0IHdheS4gTWF5YmUgd2Ugc3VwcG9ydCBlbmNvZGluZyBpbiB0aGUgSEIgYXMgWE1MIGluIHRoZSBmdXR1cmUsIGJ1dCBmb3Igbm93IEkgZG9uJ3Qgd2FudFxuICAgICAgdG9vIG11Y2ggb3ZlcmhlYWQuIFkgaXMgdmVyeSBsaWtlbHkgdG8gZ2V0IGNoYW5nZWQgYSBsb3QgaW4gdGhlIGZ1dHVyZVxuXG4gICAgICBCZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gZW5jb2RlIEpTT04gYXMgc3RyaW5nICh3aXRoIGNoYXJhY3RlciBlc2NhcGluZywgd2ljaCBtYWtlcyBpdCBwcmV0dHkgbXVjaCB1bnJlYWRhYmxlKVxuICAgICAgd2UgZW5jb2RlIHRoZSBKU09OIGFzIFhNTC5cblxuICAgICAgV2hlbiB0aGUgSEIgc3VwcG9ydCBlbmNvZGluZyBhcyBYTUwsIHRoZSBmb3JtYXQgc2hvdWxkIGxvb2sgcHJldHR5IG11Y2ggbGlrZSB0aGlzLlxuXG4gICAgICBkb2VzIG5vdCBzdXBwb3J0IHByaW1pdGl2ZSB2YWx1ZXMgYXMgYXJyYXkgZWxlbWVudHNcbiAgICAgIGV4cGVjdHMgYW4gbHR4IChsZXNzIHRoYW4geG1sKSBvYmplY3RcbiAgICAqL1xuICAgIHBhcnNlTWVzc2FnZUZyb21YbWwgKG0vKiA6YW55ICovKSB7XG4gICAgICBmdW5jdGlvbiBwYXJzZUFycmF5IChub2RlKSB7XG4gICAgICAgIGZvciAodmFyIG4gb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChuLmdldEF0dHJpYnV0ZSgnaXNBcnJheScpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5KG4pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdChuKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VPYmplY3QgKG5vZGUvKiA6YW55ICovKSB7XG4gICAgICAgIHZhciBqc29uID0ge31cbiAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gbm9kZS5hdHRycykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNbYXR0ck5hbWVdXG4gICAgICAgICAgdmFyIGludCA9IHBhcnNlSW50KHZhbHVlLCAxMClcbiAgICAgICAgICBpZiAoaXNOYU4oaW50KSB8fCAoJycgKyBpbnQpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAganNvblthdHRyTmFtZV0gPSB2YWx1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqc29uW2F0dHJOYW1lXSA9IGludFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBuLyogOmFueSAqLyBpbiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBuLm5hbWVcbiAgICAgICAgICBpZiAobi5nZXRBdHRyaWJ1dGUoJ2lzQXJyYXknKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICBqc29uW25hbWVdID0gcGFyc2VBcnJheShuKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqc29uW25hbWVdID0gcGFyc2VPYmplY3QobilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25cbiAgICAgIH1cbiAgICAgIHBhcnNlT2JqZWN0KG0pXG4gICAgfVxuICAgIC8qXG4gICAgICBlbmNvZGUgbWVzc2FnZSBpbiB4bWxcbiAgICAgIHdlIHVzZSBzdHJpbmcgYmVjYXVzZSBTdHJvcGhlIG9ubHkgYWNjZXB0cyBhbiBcInhtbC1zdHJpbmdcIi4uXG4gICAgICBTbyB7YTo0LGI6e2M6NX19IHdpbGwgbG9vayBsaWtlXG4gICAgICA8eSBhPVwiNFwiPlxuICAgICAgICA8YiBjPVwiNVwiPjwvYj5cbiAgICAgIDwveT5cbiAgICAgIG0gLSBsdHggZWxlbWVudFxuICAgICAganNvbiAtIE9iamVjdFxuICAgICovXG4gICAgZW5jb2RlTWVzc2FnZVRvWG1sIChtc2csIG9iaikge1xuICAgICAgLy8gYXR0cmlidXRlcyBpcyBvcHRpb25hbFxuICAgICAgZnVuY3Rpb24gZW5jb2RlT2JqZWN0IChtLCBqc29uKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ganNvbikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGpzb25bbmFtZV1cbiAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3BcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGVuY29kZU9iamVjdChtLmMobmFtZSksIHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBlbmNvZGVBcnJheShtLmMobmFtZSksIHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuY29kZUFycmF5IChtLCBhcnJheSkge1xuICAgICAgICBtLnNldEF0dHJpYnV0ZSgnaXNBcnJheScsICd0cnVlJylcbiAgICAgICAgZm9yICh2YXIgZSBvZiBhcnJheSkge1xuICAgICAgICAgIGlmIChlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGVuY29kZU9iamVjdChtLmMoJ2FycmF5LWVsZW1lbnQnKSwgZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RlQXJyYXkobS5jKCdhcnJheS1lbGVtZW50JyksIGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgZW5jb2RlT2JqZWN0KG1zZy5jKCd5JywgeyB4bWxuczogJ2h0dHA6Ly95Lm5pbmphL2Nvbm5lY3Rvci1zdGFuemEnIH0pLCBvYmopXG4gICAgICB9IGVsc2UgaWYgKG9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgZW5jb2RlQXJyYXkobXNnLmMoJ3knLCB7IHhtbG5zOiAnaHR0cDovL3kubmluamEvY29ubmVjdG9yLXN0YW56YScgfSksIG9iailcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkkgY2FuJ3QgZW5jb2RlIHRoaXMganNvbiFcIilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgWS5BYnN0cmFjdENvbm5lY3RvciA9IEFic3RyYWN0Q29ubmVjdG9yXG59XG4iLCIvKiBnbG9iYWwgZ2V0UmFuZG9tLCBhc3luYyAqL1xuJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkpIHtcbiAgdmFyIGdsb2JhbFJvb20gPSB7XG4gICAgdXNlcnM6IHt9LFxuICAgIGJ1ZmZlcnM6IHt9LCAvLyBUT0RPOiByZWltcGxlbWVudCB0aGlzIGlkZWEuIFRoaXMgZG9lcyBub3QgY292ZXIgYWxsIGNhc2VzISEgSGVyZSwgeW91IGhhdmUgYSBxdWV1ZSB3aGljaCBpcyB1bnJlYWxpc3RpYyAoaS5lLiB0aGluayBhYm91dCBtdWx0aXBsZSBpbmNvbWluZyBjb25uZWN0aW9ucylcbiAgICByZW1vdmVVc2VyOiBmdW5jdGlvbiAodXNlcikge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnVzZXJzKSB7XG4gICAgICAgIHRoaXMudXNlcnNbaV0udXNlckxlZnQodXNlcilcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLnVzZXJzW3VzZXJdXG4gICAgICBkZWxldGUgdGhpcy5idWZmZXJzW3VzZXJdXG4gICAgfSxcbiAgICBhZGRVc2VyOiBmdW5jdGlvbiAoY29ubmVjdG9yKSB7XG4gICAgICB0aGlzLnVzZXJzW2Nvbm5lY3Rvci51c2VySWRdID0gY29ubmVjdG9yXG4gICAgICB0aGlzLmJ1ZmZlcnNbY29ubmVjdG9yLnVzZXJJZF0gPSB7fVxuICAgICAgZm9yICh2YXIgdW5hbWUgaW4gdGhpcy51c2Vycykge1xuICAgICAgICBpZiAodW5hbWUgIT09IGNvbm5lY3Rvci51c2VySWQpIHtcbiAgICAgICAgICB2YXIgdSA9IHRoaXMudXNlcnNbdW5hbWVdXG4gICAgICAgICAgdS51c2VySm9pbmVkKGNvbm5lY3Rvci51c2VySWQsICdtYXN0ZXInKVxuICAgICAgICAgIGNvbm5lY3Rvci51c2VySm9pbmVkKHUudXNlcklkLCAnbWFzdGVyJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgd2hlblRyYW5zYWN0aW9uc0ZpbmlzaGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHMgPSBbXVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnVzZXJzKSB7XG4gICAgICAgIHBzLnB1c2godGhpcy51c2Vyc1tuYW1lXS55LmRiLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBzKVxuICAgIH0sXG4gICAgZmx1c2hPbmU6IGZ1bmN0aW9uIGZsdXNoT25lICgpIHtcbiAgICAgIHZhciBidWZzID0gW11cbiAgICAgIGZvciAodmFyIHJlY2VpdmVyIGluIGdsb2JhbFJvb20uYnVmZmVycykge1xuICAgICAgICBsZXQgYnVmZiA9IGdsb2JhbFJvb20uYnVmZmVyc1tyZWNlaXZlcl1cbiAgICAgICAgdmFyIHB1c2ggPSBmYWxzZVxuICAgICAgICBmb3IgKGxldCBzZW5kZXIgaW4gYnVmZikge1xuICAgICAgICAgIGlmIChidWZmW3NlbmRlcl0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcHVzaCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwdXNoKSB7XG4gICAgICAgICAgYnVmcy5wdXNoKHJlY2VpdmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB1c2VySWQgPSBnZXRSYW5kb20oYnVmcylcbiAgICAgICAgbGV0IGJ1ZmYgPSBnbG9iYWxSb29tLmJ1ZmZlcnNbdXNlcklkXVxuICAgICAgICBsZXQgc2VuZGVyID0gZ2V0UmFuZG9tKE9iamVjdC5rZXlzKGJ1ZmYpKVxuICAgICAgICB2YXIgbSA9IGJ1ZmZbc2VuZGVyXS5zaGlmdCgpXG4gICAgICAgIGlmIChidWZmW3NlbmRlcl0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIGJ1ZmZbc2VuZGVyXVxuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VyID0gZ2xvYmFsUm9vbS51c2Vyc1t1c2VySWRdXG4gICAgICAgIHVzZXIucmVjZWl2ZU1lc3NhZ2UobVswXSwgbVsxXSlcbiAgICAgICAgcmV0dXJuIHVzZXIueS5kYi53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIC8vIGZsdXNoZXMgbWF5IHJlc3VsdCBpbiBtb3JlIGNyZWF0ZWQgb3BlcmF0aW9ucyxcbiAgICAgICAgLy8gZmx1c2ggdW50aWwgdGhlcmUgaXMgbm90aGluZyBtb3JlIHRvIGZsdXNoXG4gICAgICAgIGZ1bmN0aW9uIG5leHRGbHVzaCAoKSB7XG4gICAgICAgICAgdmFyIGMgPSBnbG9iYWxSb29tLmZsdXNoT25lKClcbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgICAgICAgYyA9IGdsb2JhbFJvb20uZmx1c2hPbmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmFsUm9vbS53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKS50aGVuKG5leHRGbHVzaClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gZ2xvYmFsUm9vbS5mbHVzaE9uZSgpXG4gICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgYy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGdsb2JhbFJvb20ud2hlblRyYW5zYWN0aW9uc0ZpbmlzaGVkKCkudGhlbihuZXh0Rmx1c2gpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsUm9vbS53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKS50aGVuKG5leHRGbHVzaClcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIFkudXRpbHMuZ2xvYmFsUm9vbSA9IGdsb2JhbFJvb21cblxuICB2YXIgdXNlcklkQ291bnRlciA9IDBcblxuICBjbGFzcyBUZXN0IGV4dGVuZHMgWS5BYnN0cmFjdENvbm5lY3RvciB7XG4gICAgY29uc3RydWN0b3IgKHksIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIG11c3Qgbm90IGJlIHVuZGVmaW5lZCEnKVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5yb2xlID0gJ21hc3RlcidcbiAgICAgIG9wdGlvbnMuZm9yd2FyZFRvU3luY2luZ0NsaWVudHMgPSBmYWxzZVxuICAgICAgc3VwZXIoeSwgb3B0aW9ucylcbiAgICAgIHRoaXMuc2V0VXNlcklkKCh1c2VySWRDb3VudGVyKyspICsgJycpLnRoZW4oKCkgPT4ge1xuICAgICAgICBnbG9iYWxSb29tLmFkZFVzZXIodGhpcylcbiAgICAgIH0pXG4gICAgICB0aGlzLmdsb2JhbFJvb20gPSBnbG9iYWxSb29tXG4gICAgICB0aGlzLnN5bmNpbmdDbGllbnREdXJhdGlvbiA9IDBcbiAgICB9XG4gICAgcmVjZWl2ZU1lc3NhZ2UgKHNlbmRlciwgbSkge1xuICAgICAgc3VwZXIucmVjZWl2ZU1lc3NhZ2Uoc2VuZGVyLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG0pKSlcbiAgICB9XG4gICAgc2VuZCAodXNlcklkLCBtZXNzYWdlKSB7XG4gICAgICB2YXIgYnVmZmVyID0gZ2xvYmFsUm9vbS5idWZmZXJzW3VzZXJJZF1cbiAgICAgIGlmIChidWZmZXIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYnVmZmVyW3RoaXMudXNlcklkXSA9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVyW3RoaXMudXNlcklkXSA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyW3RoaXMudXNlcklkXS5wdXNoKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoW3RoaXMudXNlcklkLCBtZXNzYWdlXSkpKVxuICAgICAgfVxuICAgIH1cbiAgICBicm9hZGNhc3QgKG1lc3NhZ2UpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBnbG9iYWxSb29tLmJ1ZmZlcnMpIHtcbiAgICAgICAgdmFyIGJ1ZmYgPSBnbG9iYWxSb29tLmJ1ZmZlcnNba2V5XVxuICAgICAgICBpZiAoYnVmZlt0aGlzLnVzZXJJZF0gPT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZbdGhpcy51c2VySWRdID0gW11cbiAgICAgICAgfVxuICAgICAgICBidWZmW3RoaXMudXNlcklkXS5wdXNoKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoW3RoaXMudXNlcklkLCBtZXNzYWdlXSkpKVxuICAgICAgfVxuICAgIH1cbiAgICBpc0Rpc2Nvbm5lY3RlZCAoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsUm9vbS51c2Vyc1t0aGlzLnVzZXJJZF0gPT0gbnVsbFxuICAgIH1cbiAgICByZWNvbm5lY3QgKCkge1xuICAgICAgaWYgKHRoaXMuaXNEaXNjb25uZWN0ZWQoKSkge1xuICAgICAgICBnbG9iYWxSb29tLmFkZFVzZXIodGhpcylcbiAgICAgICAgc3VwZXIucmVjb25uZWN0KClcbiAgICAgIH1cbiAgICAgIHJldHVybiBZLnV0aWxzLmdsb2JhbFJvb20uZmx1c2hBbGwoKVxuICAgIH1cbiAgICBkaXNjb25uZWN0ICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0Rpc2Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIGdsb2JhbFJvb20ucmVtb3ZlVXNlcih0aGlzLnVzZXJJZClcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdCgpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy55LmRiLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpXG4gICAgfVxuICAgIGZsdXNoICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgcmV0dXJuIGFzeW5jKGZ1bmN0aW9uICogKCkge1xuICAgICAgICB2YXIgYnVmZiA9IGdsb2JhbFJvb20uYnVmZmVyc1tzZWxmLnVzZXJJZF1cbiAgICAgICAgd2hpbGUgKE9iamVjdC5rZXlzKGJ1ZmYpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgc2VuZGVyID0gZ2V0UmFuZG9tKE9iamVjdC5rZXlzKGJ1ZmYpKVxuICAgICAgICAgIHZhciBtID0gYnVmZltzZW5kZXJdLnNoaWZ0KClcbiAgICAgICAgICBpZiAoYnVmZltzZW5kZXJdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZbc2VuZGVyXVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlKG1bMF0sIG1bMV0pXG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgc2VsZi53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBZLlRlc3QgPSBUZXN0XG59XG4iLCIvKiBAZmxvdyAqL1xuJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkgLyogOmFueSAqLykge1xuICAvKlxuICAgIFBhcnRpYWwgZGVmaW5pdGlvbiBvZiBhbiBPcGVyYXRpb25TdG9yZS5cbiAgICBUT0RPOiBuYW1lIGl0IERhdGFiYXNlLCBvcGVyYXRpb24gc3RvcmUgb25seSBob2xkcyBvcGVyYXRpb25zLlxuXG4gICAgQSBkYXRhYmFzZSBkZWZpbml0aW9uIG11c3QgYWxzZSBkZWZpbmUgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgICogbG9nVGFibGUoKSAob3B0aW9uYWwpXG4gICAgICAtIHNob3cgcmVsZXZhbnQgaW5mb3JtYXRpb24gaW5mb3JtYXRpb24gaW4gYSB0YWJsZVxuICAgICogcmVxdWVzdFRyYW5zYWN0aW9uKG1ha2VHZW4pXG4gICAgICAtIHJlcXVlc3QgYSB0cmFuc2FjdGlvblxuICAgICogZGVzdHJveSgpXG4gICAgICAtIGRlc3Ryb3kgdGhlIGRhdGFiYXNlXG4gICovXG4gIGNsYXNzIEFic3RyYWN0RGF0YWJhc2Uge1xuICAgIC8qIDo6XG4gICAgeTogWUNvbmZpZztcbiAgICBmb3J3YXJkQXBwbGllZE9wZXJhdGlvbnM6IGJvb2xlYW47XG4gICAgbGlzdGVuZXJzQnlJZDogT2JqZWN0O1xuICAgIGxpc3RlbmVyc0J5SWRFeGVjdXRlTm93OiBBcnJheTxPYmplY3Q+O1xuICAgIGxpc3RlbmVyc0J5SWRSZXF1ZXN0UGVuZGluZzogYm9vbGVhbjtcbiAgICBpbml0aWFsaXplZFR5cGVzOiBPYmplY3Q7XG4gICAgd2hlblVzZXJJZFNldExpc3RlbmVyOiA/RnVuY3Rpb247XG4gICAgd2FpdGluZ1RyYW5zYWN0aW9uczogQXJyYXk8VHJhbnNhY3Rpb24+O1xuICAgIHRyYW5zYWN0aW9uSW5Qcm9ncmVzczogYm9vbGVhbjtcbiAgICBleGVjdXRlT3JkZXI6IEFycmF5PE9iamVjdD47XG4gICAgZ2MxOiBBcnJheTxTdHJ1Y3Q+O1xuICAgIGdjMjogQXJyYXk8U3RydWN0PjtcbiAgICBnY1RpbWVvdXQ6IG51bWJlcjtcbiAgICBnY0ludGVydmFsOiBhbnk7XG4gICAgZ2FyYmFnZUNvbGxlY3Q6IEZ1bmN0aW9uO1xuICAgIGV4ZWN1dGVPcmRlcjogQXJyYXk8YW55PjsgLy8gZm9yIGRlYnVnZ2luZyBvbmx5XG4gICAgdXNlcklkOiBVc2VySWQ7XG4gICAgb3BDbG9jazogbnVtYmVyO1xuICAgIHRyYW5zYWN0aW9uc0ZpbmlzaGVkOiA/e3Byb21pc2U6IFByb21pc2UsIHJlc29sdmU6IGFueX07XG4gICAgdHJhbnNhY3Q6ICh4OiA/R2VuZXJhdG9yKSA9PiBhbnk7XG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvciAoeSwgb3B0cykge1xuICAgICAgdGhpcy55ID0geVxuICAgICAgdmFyIG9zID0gdGhpc1xuICAgICAgdGhpcy51c2VySWQgPSBudWxsXG4gICAgICB2YXIgcmVzb2x2ZVxuICAgICAgdGhpcy51c2VySWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmVzb2x2ZSA9IHJcbiAgICAgIH0pXG4gICAgICB0aGlzLnVzZXJJZFByb21pc2UucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgIC8vIHdoZXRoZXIgdG8gYnJvYWRjYXN0IGFsbCBhcHBsaWVkIG9wZXJhdGlvbnMgKGluc2VydCAmIGRlbGV0ZSBob29rKVxuICAgICAgdGhpcy5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgPSBmYWxzZVxuICAgICAgLy8gRS5nLiB0aGlzLmxpc3RlbmVyc0J5SWRbaWRdIDogQXJyYXk8TGlzdGVuZXI+XG4gICAgICB0aGlzLmxpc3RlbmVyc0J5SWQgPSB7fVxuICAgICAgLy8gRXhlY3V0ZSB0aGUgbmV4dCB0aW1lIGEgdHJhbnNhY3Rpb24gaXMgcmVxdWVzdGVkXG4gICAgICB0aGlzLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93ID0gW11cbiAgICAgIC8vIEEgdHJhbnNhY3Rpb24gaXMgcmVxdWVzdGVkXG4gICAgICB0aGlzLmxpc3RlbmVyc0J5SWRSZXF1ZXN0UGVuZGluZyA9IGZhbHNlXG4gICAgICAvKiBUbyBtYWtlIHRoaW5ncyBtb3JlIGNsZWFyLCB0aGUgZm9sbG93aW5nIG5hbWluZyBjb252ZW50aW9uczpcbiAgICAgICAgICogbHMgOiB3ZSBwdXQgdGhpcy5saXN0ZW5lcnNCeUlkIG9uIGxzXG4gICAgICAgICAqIGwgOiBBcnJheTxMaXN0ZW5lcj5cbiAgICAgICAgICogaWQgOiBJZCAoY2FuJ3QgdXNlIGFzIHByb3BlcnR5IG5hbWUpXG4gICAgICAgICAqIHNpZCA6IFN0cmluZyAoY29udmVydGVkIGZyb20gaWQgdmlhIEpTT04uc3RyaW5naWZ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgc28gd2UgY2FuIHVzZSBpdCBhcyBhIHByb3BlcnR5IG5hbWUpXG5cbiAgICAgICAgQWx3YXlzIHJlbWVtYmVyIHRvIGZpcnN0IG92ZXJ3cml0ZVxuICAgICAgICBhIHByb3BlcnR5IGJlZm9yZSB5b3UgaXRlcmF0ZSBvdmVyIGl0IVxuICAgICAgKi9cbiAgICAgIC8vIFRPRE86IFVzZSBFUzcgV2VhayBNYXBzLiBUaGlzIHdheSB0eXBlcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlcixcbiAgICAgIC8vIHdvbnQgYmUga2VwdCBpbiBtZW1vcnkuXG4gICAgICB0aGlzLmluaXRpYWxpemVkVHlwZXMgPSB7fVxuICAgICAgdGhpcy53YWl0aW5nVHJhbnNhY3Rpb25zID0gW11cbiAgICAgIHRoaXMudHJhbnNhY3Rpb25JblByb2dyZXNzID0gZmFsc2VcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25Jc0ZsdXNoZWQgPSBmYWxzZVxuICAgICAgaWYgKHR5cGVvZiBZQ29uY3VycmVuY3lfVGVzdGluZ01vZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9yZGVyID0gW11cbiAgICAgIH1cbiAgICAgIHRoaXMuZ2MxID0gW10gLy8gZmlyc3Qgc3RhZ2VcbiAgICAgIHRoaXMuZ2MyID0gW10gLy8gc2Vjb25kIHN0YWdlIC0+IGFmdGVyIHRoYXQsIHJlbW92ZSB0aGUgb3BcbiAgICAgIHRoaXMuZ2NUaW1lb3V0ID0gIW9wdHMuZ2NUaW1lb3V0ID8gNTAwMDAgOiBvcHRzLmdjVGltZW91dHNcbiAgICAgIGZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0ICgpIHtcbiAgICAgICAgcmV0dXJuIG9zLndoZW5UcmFuc2FjdGlvbnNGaW5pc2hlZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvcy5nYzEubGVuZ3RoID4gMCB8fCBvcy5nYzIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFvcy55LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdnYyBzaG91bGQgYmUgZW1wdHkgd2hlbiBkaXNjb25uZWN0ZWQhJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBvcy5yZXF1ZXN0VHJhbnNhY3Rpb24oZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9zLnkuY29ubmVjdG9yICE9IG51bGwgJiYgb3MueS5jb25uZWN0b3IuaXNTeW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3MuZ2MyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvaWQgPSBvcy5nYzJbaV1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZ2FyYmFnZUNvbGxlY3RPcGVyYXRpb24ob2lkKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3MuZ2MyID0gb3MuZ2MxXG4gICAgICAgICAgICAgICAgICBvcy5nYzEgPSBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBVc2Ugc2V0SW50ZXJ2YWwgaGVyZSBpbnN0ZWFkICh3aGVuIGdhcmJhZ2VDb2xsZWN0IGlzIGNhbGxlZCBzZXZlcmFsIHRpbWVzIHRoZXJlIHdpbGwgYmUgc2V2ZXJhbCB0aW1lb3V0cy4uKVxuICAgICAgICAgICAgICAgIGlmIChvcy5nY1RpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcy5nY0ludGVydmFsID0gc2V0VGltZW91dChnYXJiYWdlQ29sbGVjdCwgb3MuZ2NUaW1lb3V0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHNlZSBhYm92ZVxuICAgICAgICAgICAgaWYgKG9zLmdjVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgb3MuZ2NJbnRlcnZhbCA9IHNldFRpbWVvdXQoZ2FyYmFnZUNvbGxlY3QsIG9zLmdjVGltZW91dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2FyYmFnZUNvbGxlY3QgPSBnYXJiYWdlQ29sbGVjdFxuICAgICAgaWYgKHRoaXMuZ2NUaW1lb3V0ID4gMCkge1xuICAgICAgICBnYXJiYWdlQ29sbGVjdCgpXG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXVlR2FyYmFnZUNvbGxlY3RvciAoaWQpIHtcbiAgICAgIGlmICh0aGlzLnkuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmdjMS5wdXNoKGlkKVxuICAgICAgfVxuICAgIH1cbiAgICBlbXB0eUdhcmJhZ2VDb2xsZWN0b3IgKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB2YXIgY2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2MxLmxlbmd0aCA+IDAgfHwgdGhpcy5nYzIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5nYXJiYWdlQ29sbGVjdCgpLnRoZW4oY2hlY2spXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KGNoZWNrLCAwKVxuICAgICAgfSlcbiAgICB9XG4gICAgYWRkVG9EZWJ1ZyAoKSB7XG4gICAgICBpZiAodHlwZW9mIFlDb25jdXJyZW5jeV9UZXN0aW5nTW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGNvbW1hbmQgLyogOnN0cmluZyAqLyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHMpXG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKCcnKS5yZXBsYWNlKC9cIi9nLCBcIidcIikucmVwbGFjZSgvLC9nLCAnLCAnKS5yZXBsYWNlKC86L2csICc6ICcpXG4gICAgICAgIHRoaXMuZXhlY3V0ZU9yZGVyLnB1c2goY29tbWFuZClcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVidWdEYXRhICgpIHtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuZXhlY3V0ZU9yZGVyLmpvaW4oJ1xcbicpKVxuICAgIH1cbiAgICBzdG9wR2FyYmFnZUNvbGxlY3RvciAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBzZWxmLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICB2YXIgdW5nYyAvKiA6QXJyYXk8U3RydWN0PiAqLyA9IHNlbGYuZ2MxLmNvbmNhdChzZWxmLmdjMilcbiAgICAgICAgICBzZWxmLmdjMSA9IFtdXG4gICAgICAgICAgc2VsZi5nYzIgPSBbXVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5nYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9wID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKHVuZ2NbaV0pXG4gICAgICAgICAgICBpZiAob3AgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWxldGUgb3AuZ2NcbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIC8qXG4gICAgICBUcnkgdG8gYWRkIHRvIEdDLlxuXG4gICAgICBUT0RPOiByZW5hbWUgdGhpcyBmdW5jdGlvblxuXG4gICAgICBSdWxlejpcbiAgICAgICogT25seSBnYyBpZiB0aGlzIHVzZXIgaXMgb25saW5lXG4gICAgICAqIFRoZSBtb3N0IGxlZnQgZWxlbWVudCBpbiBhIGxpc3QgbXVzdCBub3QgYmUgZ2MnZC5cbiAgICAgICAgPT4gVGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGxpc3RcblxuICAgICAgcmV0dXJucyB0cnVlIGlmZiBvcCB3YXMgYWRkZWQgdG8gR0NcbiAgICAqL1xuICAgICogYWRkVG9HYXJiYWdlQ29sbGVjdG9yIChvcCwgbGVmdCkge1xuICAgICAgaWYgKFxuICAgICAgICBvcC5nYyA9PSBudWxsICYmXG4gICAgICAgIG9wLmRlbGV0ZWQgPT09IHRydWVcbiAgICAgICkge1xuICAgICAgICB2YXIgZ2MgPSBmYWxzZVxuICAgICAgICBpZiAobGVmdCAhPSBudWxsICYmIGxlZnQuZGVsZXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGdjID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKG9wLmNvbnRlbnQgIT0gbnVsbCAmJiBvcC5jb250ZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBvcCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQoW29wLmlkWzBdLCBvcC5pZFsxXSArIDFdKVxuICAgICAgICAgIGdjID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChnYykge1xuICAgICAgICAgIG9wLmdjID0gdHJ1ZVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihvcClcbiAgICAgICAgICB0aGlzLnN0b3JlLnF1ZXVlR2FyYmFnZUNvbGxlY3RvcihvcC5pZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmVtb3ZlRnJvbUdhcmJhZ2VDb2xsZWN0b3IgKG9wKSB7XG4gICAgICBmdW5jdGlvbiBmaWx0ZXIgKG8pIHtcbiAgICAgICAgcmV0dXJuICFZLnV0aWxzLmNvbXBhcmVJZHMobywgb3AuaWQpXG4gICAgICB9XG4gICAgICB0aGlzLmdjMSA9IHRoaXMuZ2MxLmZpbHRlcihmaWx0ZXIpXG4gICAgICB0aGlzLmdjMiA9IHRoaXMuZ2MyLmZpbHRlcihmaWx0ZXIpXG4gICAgICBkZWxldGUgb3AuZ2NcbiAgICB9XG4gICAgKiBkZXN0cm95ICgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5nY0ludGVydmFsKVxuICAgICAgdGhpcy5nY0ludGVydmFsID0gbnVsbFxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuaW5pdGlhbGl6ZWRUeXBlcykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuaW5pdGlhbGl6ZWRUeXBlc1trZXldXG4gICAgICAgIGlmICh0eXBlLl9kZXN0cm95ICE9IG51bGwpIHtcbiAgICAgICAgICB0eXBlLl9kZXN0cm95KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgdHlwZSB5b3UgaW5jbHVkZWQgZG9lcyBub3QgcHJvdmlkZSBkZXN0cm95IGZ1bmN0aW9uYWxpdHksIGl0IHdpbGwgcmVtYWluIGluIG1lbW9yeSAodXBkYXRpbmcgeW91ciBwYWNrYWdlcyB3aWxsIGhlbHApLicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VXNlcklkICh1c2VySWQpIHtcbiAgICAgIGlmICghdGhpcy51c2VySWRQcm9taXNlLmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy51c2VySWRQcm9taXNlLmluUHJvZ3Jlc3MgPSB0cnVlXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICBzZWxmLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICBzZWxmLnVzZXJJZCA9IHVzZXJJZFxuICAgICAgICAgIHZhciBzdGF0ZSA9IHlpZWxkKiB0aGlzLmdldFN0YXRlKHVzZXJJZClcbiAgICAgICAgICBzZWxmLm9wQ2xvY2sgPSBzdGF0ZS5jbG9ja1xuICAgICAgICAgIHNlbGYudXNlcklkUHJvbWlzZS5yZXNvbHZlKHVzZXJJZClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnVzZXJJZFByb21pc2VcbiAgICB9XG4gICAgd2hlblVzZXJJZFNldCAoZikge1xuICAgICAgdGhpcy51c2VySWRQcm9taXNlLnRoZW4oZilcbiAgICB9XG4gICAgZ2V0TmV4dE9wSWQgKG51bWJlck9mSWRzKSB7XG4gICAgICBpZiAobnVtYmVyT2ZJZHMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldE5leHRPcElkIGV4cGVjdHMgdGhlIG51bWJlciBvZiBjcmVhdGVkIGlkcyB0byBjcmVhdGUhJylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VySWQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvblN0b3JlIG5vdCB5ZXQgaW5pdGlhbGl6ZWQhJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZCA9IFt0aGlzLnVzZXJJZCwgdGhpcy5vcENsb2NrXVxuICAgICAgICB0aGlzLm9wQ2xvY2sgKz0gbnVtYmVyT2ZJZHNcbiAgICAgICAgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBBcHBseSBhIGxpc3Qgb2Ygb3BlcmF0aW9ucy5cblxuICAgICAgKiBnZXQgYSB0cmFuc2FjdGlvblxuICAgICAgKiBjaGVjayB3aGV0aGVyIGFsbCBTdHJ1Y3QuKi5yZXF1aXJlZE9wcyBhcmUgaW4gdGhlIE9TXG4gICAgICAqIGNoZWNrIGlmIGl0IGlzIGFuIGV4cGVjdGVkIG9wIChvdGhlcndpc2Ugd2FpdCBmb3IgaXQpXG4gICAgICAqIGNoZWNrIGlmIHdhcyBkZWxldGVkLCBhcHBseSBhIGRlbGV0ZSBvcGVyYXRpb24gYWZ0ZXIgb3Agd2FzIGFwcGxpZWRcbiAgICAqL1xuICAgIGFwcGx5IChvcHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvID0gb3BzW2ldXG4gICAgICAgIGlmIChvLmlkID09IG51bGwgfHwgby5pZFswXSAhPT0gdGhpcy55LmNvbm5lY3Rvci51c2VySWQpIHtcbiAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBZLlN0cnVjdFtvLnN0cnVjdF0ucmVxdWlyZWRPcHMobylcbiAgICAgICAgICBpZiAoby5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXF1aXJlZCA9IHJlcXVpcmVkLmNvbmNhdChvLnJlcXVpcmVzKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndoZW5PcGVyYXRpb25zRXhpc3QocmVxdWlyZWQsIG8pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgIG9wIGlzIGV4ZWN1dGVkIGFzIHNvb24gYXMgZXZlcnkgb3BlcmF0aW9uIHJlcXVlc3RlZCBpcyBhdmFpbGFibGUuXG4gICAgICBOb3RlIHRoYXQgVHJhbnNhY3Rpb24gY2FuIChhbmQgc2hvdWxkKSBidWZmZXIgcmVxdWVzdHMuXG4gICAgKi9cbiAgICB3aGVuT3BlcmF0aW9uc0V4aXN0IChpZHMsIG9wKSB7XG4gICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0ge1xuICAgICAgICAgIG9wOiBvcCxcbiAgICAgICAgICBtaXNzaW5nOiBpZHMubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBpZCA9IGlkc1tpXVxuICAgICAgICAgIGxldCBzaWQgPSBKU09OLnN0cmluZ2lmeShpZClcbiAgICAgICAgICBsZXQgbCA9IHRoaXMubGlzdGVuZXJzQnlJZFtzaWRdXG4gICAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgbCA9IFtdXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc0J5SWRbc2lkXSA9IGxcbiAgICAgICAgICB9XG4gICAgICAgICAgbC5wdXNoKGxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93LnB1c2goe1xuICAgICAgICAgIG9wOiBvcFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnNCeUlkUmVxdWVzdFBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzQnlJZFJlcXVlc3RQZW5kaW5nID0gdHJ1ZVxuICAgICAgdmFyIHN0b3JlID0gdGhpc1xuXG4gICAgICB0aGlzLnJlcXVlc3RUcmFuc2FjdGlvbihmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgdmFyIGV4ZU5vdyA9IHN0b3JlLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93XG4gICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWRFeGVjdXRlTm93ID0gW11cblxuICAgICAgICB2YXIgbHMgPSBzdG9yZS5saXN0ZW5lcnNCeUlkXG4gICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWQgPSB7fVxuXG4gICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWRSZXF1ZXN0UGVuZGluZyA9IGZhbHNlXG5cbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgZXhlTm93Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBsZXQgbyA9IGV4ZU5vd1trZXldLm9wXG4gICAgICAgICAgeWllbGQqIHN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCBvKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgc2lkIGluIGxzKSB7XG4gICAgICAgICAgdmFyIGwgPSBsc1tzaWRdXG4gICAgICAgICAgdmFyIGlkID0gSlNPTi5wYXJzZShzaWQpXG4gICAgICAgICAgdmFyIG9wXG4gICAgICAgICAgaWYgKHR5cGVvZiBpZFsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKGlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihpZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3JlLmxpc3RlbmVyc0J5SWRbc2lkXSA9IGxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IGxbaV1cbiAgICAgICAgICAgICAgbGV0IG8gPSBsaXN0ZW5lci5vcFxuICAgICAgICAgICAgICBpZiAoLS1saXN0ZW5lci5taXNzaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCBvKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICAvKlxuICAgICAgQWN0dWFsbHkgZXhlY3V0ZSBhbiBvcGVyYXRpb24sIHdoZW4gYWxsIGV4cGVjdGVkIG9wZXJhdGlvbnMgYXJlIGF2YWlsYWJsZS5cbiAgICAqL1xuICAgIC8qIDo6IC8vIFRPRE86IHRoaXMgYmVsb25ncyBzb21laG93IHRvIHRyYW5zYWN0aW9uXG4gICAgc3RvcmU6IE9iamVjdDtcbiAgICBnZXRPcGVyYXRpb246IGFueTtcbiAgICBpc0dhcmJhZ2VDb2xsZWN0ZWQ6IGFueTtcbiAgICBhZGRPcGVyYXRpb246IGFueTtcbiAgICB3aGVuT3BlcmF0aW9uc0V4aXN0OiBhbnk7XG4gICAgKi9cbiAgICAqIHRyeUV4ZWN1dGUgKG9wKSB7XG4gICAgICB0aGlzLnN0b3JlLmFkZFRvRGVidWcoJ3lpZWxkKiB0aGlzLnN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCAnLCBKU09OLnN0cmluZ2lmeShvcCksICcpJylcbiAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgIHlpZWxkKiBZLlN0cnVjdC5EZWxldGUuZXhlY3V0ZS5jYWxsKHRoaXMsIG9wKVxuICAgICAgICAvLyB0aGlzIGlzIG5vdyBjYWxsZWQgaW4gVHJhbnNhY3Rpb24uZGVsZXRlT3BlcmF0aW9uIVxuICAgICAgICAvLyB5aWVsZCogdGhpcy5zdG9yZS5vcGVyYXRpb25BZGRlZCh0aGlzLCBvcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgb3Agd2FzIGRlZmluZWRcbiAgICAgICAgdmFyIGRlZmluZWQgPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24ob3AuaWQpXG4gICAgICAgIHdoaWxlIChkZWZpbmVkICE9IG51bGwgJiYgZGVmaW5lZC5jb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIG9wIGhhcyBhIGxvbmdlciBjb250ZW50IGluIHRoZSBjYXNlIGl0IGlzIGRlZmluZWRcbiAgICAgICAgICBpZiAoZGVmaW5lZC5pZFsxXSArIGRlZmluZWQuY29udGVudC5sZW5ndGggPCBvcC5pZFsxXSArIG9wLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcFNpemUgPSBkZWZpbmVkLmNvbnRlbnQubGVuZ3RoIC0gKG9wLmlkWzFdIC0gZGVmaW5lZC5pZFsxXSlcbiAgICAgICAgICAgIG9wLmNvbnRlbnQuc3BsaWNlKDAsIG92ZXJsYXBTaXplKVxuICAgICAgICAgICAgb3AuaWQgPSBbb3AuaWRbMF0sIG9wLmlkWzFdICsgb3ZlcmxhcFNpemVdXG4gICAgICAgICAgICBvcC5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQoZGVmaW5lZClcbiAgICAgICAgICAgIG9wLm9yaWdpbiA9IG9wLmxlZnRcbiAgICAgICAgICAgIGRlZmluZWQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24ob3AuaWQpIC8vIGdldE9wZXJhdGlvbiBzdWZmaWNlcyBoZXJlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbmVkID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaXNHYXJiYWdlQ29sbGVjdGVkID0geWllbGQqIHRoaXMuaXNHYXJiYWdlQ29sbGVjdGVkKG9wLmlkKVxuICAgICAgICAgIGlmICghaXNHYXJiYWdlQ29sbGVjdGVkKSB7XG4gICAgICAgICAgICB5aWVsZCogWS5TdHJ1Y3Rbb3Auc3RydWN0XS5leGVjdXRlLmNhbGwodGhpcywgb3ApXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5hZGRPcGVyYXRpb24ob3ApXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zdG9yZS5vcGVyYXRpb25BZGRlZCh0aGlzLCBvcClcblxuICAgICAgICAgICAgLy8gaWYgaW5zZXJ0aW9uLCB0cnkgdG8gY29tYmluZSB3aXRoIGxlZnRcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnRyeUNvbWJpbmVXaXRoTGVmdChvcClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBDYWxsZWQgYnkgYSB0cmFuc2FjdGlvbiB3aGVuIGFuIG9wZXJhdGlvbiBpcyBhZGRlZC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IGZvciB5LWluZGV4ZWRkYiwgd2hlcmUgc2V2ZXJhbCBpbnN0YW5jZXMgbWF5IHNoYXJlIGEgc2luZ2xlIGRhdGFiYXNlLlxuICAgICAqIEV2ZXJ5IHRpbWUgYW4gb3BlcmF0aW9uIGlzIGNyZWF0ZWQgYnkgb25lIGluc3RhbmNlLCBpdCBpcyBzZW5kIHRvIGFsbCBvdGhlciBpbnN0YW5jZXMgYW5kIG9wZXJhdGlvbkFkZGVkIGlzIGNhbGxlZFxuICAgICAqXG4gICAgICogSWYgaXQncyBub3QgYSBEZWxldGUgb3BlcmF0aW9uOlxuICAgICAqICAgKiBDaGVja3MgaWYgYW5vdGhlciBvcGVyYXRpb24gaXMgZXhlY3V0YWJsZSAobGlzdGVuZXJzQnlJZClcbiAgICAgKiAgICogVXBkYXRlIHN0YXRlLCBpZiBwb3NzaWJsZVxuICAgICAqXG4gICAgICogQWx3YXlzOlxuICAgICAqICAgKiBDYWxsIHR5cGVcbiAgICAgKi9cbiAgICAqIG9wZXJhdGlvbkFkZGVkICh0cmFuc2FjdGlvbiwgb3ApIHtcbiAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0SW5zZXJ0aW9uKG9wLnRhcmdldClcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmluaXRpYWxpemVkVHlwZXNbSlNPTi5zdHJpbmdpZnkodGFyZ2V0LnBhcmVudCldXG4gICAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICB5aWVsZCogdHlwZS5fY2hhbmdlZCh0cmFuc2FjdGlvbiwgb3ApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluY3JlYXNlIFNTXG4gICAgICAgIHlpZWxkKiB0cmFuc2FjdGlvbi51cGRhdGVTdGF0ZShvcC5pZFswXSlcbiAgICAgICAgdmFyIG9wTGVuID0gb3AuY29udGVudCAhPSBudWxsID8gb3AuY29udGVudC5sZW5ndGggOiAxXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BMZW47IGkrKykge1xuICAgICAgICAgIC8vIG5vdGlmeSB3aGVuT3BlcmF0aW9uIGxpc3RlbmVycyAoYnkgaWQpXG4gICAgICAgICAgdmFyIHNpZCA9IEpTT04uc3RyaW5naWZ5KFtvcC5pZFswXSwgb3AuaWRbMV0gKyBpXSlcbiAgICAgICAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzQnlJZFtzaWRdXG4gICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzQnlJZFtzaWRdXG4gICAgICAgICAgaWYgKGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGwpIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbFtrZXldXG4gICAgICAgICAgICAgIGlmICgtLWxpc3RlbmVyLm1pc3NpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndoZW5PcGVyYXRpb25zRXhpc3QoW10sIGxpc3RlbmVyLm9wKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gdGhpcy5pbml0aWFsaXplZFR5cGVzW0pTT04uc3RyaW5naWZ5KG9wLnBhcmVudCldXG5cbiAgICAgICAgLy8gaWYgcGFyZW50IGlzIGRlbGV0ZWQsIG1hcmsgYXMgZ2MnZCBhbmQgcmV0dXJuXG4gICAgICAgIGlmIChvcC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBwYXJlbnRJc0RlbGV0ZWQgPSB5aWVsZCogdHJhbnNhY3Rpb24uaXNEZWxldGVkKG9wLnBhcmVudClcbiAgICAgICAgICBpZiAocGFyZW50SXNEZWxldGVkKSB7XG4gICAgICAgICAgICB5aWVsZCogdHJhbnNhY3Rpb24uZGVsZXRlTGlzdChvcC5pZClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGlmeSBwYXJlbnQsIGlmIGl0IHdhcyBpbnN0YW5jaWF0ZWQgYXMgYSBjdXN0b20gdHlwZVxuICAgICAgICBpZiAodCAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IG8gPSBZLnV0aWxzLmNvcHlPcGVyYXRpb24ob3ApXG4gICAgICAgICAgeWllbGQqIHQuX2NoYW5nZWQodHJhbnNhY3Rpb24sIG8pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcC5kZWxldGVkKSB7XG4gICAgICAgICAgLy8gRGVsZXRlIGlmIERTIHNheXMgdGhpcyBpcyBhY3R1YWxseSBkZWxldGVkXG4gICAgICAgICAgdmFyIGxlbiA9IG9wLmNvbnRlbnQgIT0gbnVsbCA/IG9wLmNvbnRlbnQubGVuZ3RoIDogMVxuICAgICAgICAgIHZhciBzdGFydElkID0gb3AuaWQgLy8gWW91IG11c3Qgbm90IHVzZSBvcC5pZCBpbiB0aGUgZm9sbG93aW5nIGxvb3AsIGJlY2F1c2Ugb3Agd2lsbCBjaGFuZ2Ugd2hlbiBkZWxldGVkXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gW3N0YXJ0SWRbMF0sIHN0YXJ0SWRbMV0gKyBpXVxuICAgICAgICAgICAgdmFyIG9wSXNEZWxldGVkID0geWllbGQqIHRyYW5zYWN0aW9uLmlzRGVsZXRlZChpZClcbiAgICAgICAgICAgIGlmIChvcElzRGVsZXRlZCkge1xuICAgICAgICAgICAgICB2YXIgZGVsb3AgPSB7XG4gICAgICAgICAgICAgICAgc3RydWN0OiAnRGVsZXRlJyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMudHJ5RXhlY3V0ZS5jYWxsKHRyYW5zYWN0aW9uLCBkZWxvcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd2hlblRyYW5zYWN0aW9uc0ZpbmlzaGVkICgpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXNvbHZlID0gclxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCA9IHtcbiAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zRmluaXNoZWQucHJvbWlzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYW5vdGhlciB0cmFuc2FjdGlvbiByZXF1ZXN0LlxuICAgIC8vICogdGhlIGxhc3QgdHJhbnNhY3Rpb24gaXMgYWx3YXlzIGEgZmx1c2ggOilcbiAgICBnZXROZXh0UmVxdWVzdCAoKSB7XG4gICAgICBpZiAodGhpcy53YWl0aW5nVHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbklzRmx1c2hlZCkge1xuICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25JblByb2dyZXNzID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uSXNGbHVzaGVkID0gZmFsc2VcbiAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc0ZpbmlzaGVkLnJlc29sdmUoKVxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNGaW5pc2hlZCA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uSXNGbHVzaGVkID0gdHJ1ZVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25Jc0ZsdXNoZWQgPSBmYWxzZVxuICAgICAgICByZXR1cm4gdGhpcy53YWl0aW5nVHJhbnNhY3Rpb25zLnNoaWZ0KClcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFRyYW5zYWN0aW9uIChtYWtlR2VuLyogOmFueSAqLywgY2FsbEltbWVkaWF0ZWx5KSB7XG4gICAgICB0aGlzLndhaXRpbmdUcmFuc2FjdGlvbnMucHVzaChtYWtlR2VuKVxuICAgICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uSW5Qcm9ncmVzcyA9IHRydWVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc2FjdCh0aGlzLmdldE5leHRSZXF1ZXN0KCkpXG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFkuQWJzdHJhY3REYXRhYmFzZSA9IEFic3RyYWN0RGF0YWJhc2Vcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuLypcbiBBbiBvcGVyYXRpb24gYWxzbyBkZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgb2YgYSB0eXBlLiBUaGlzIGlzIHdoeSBvcGVyYXRpb24gYW5kXG4gc3RydWN0dXJlIGFyZSB1c2VkIGludGVyY2hhbmdlYWJseSBoZXJlLlxuXG4gSXQgbXVzdCBiZSBvZiB0aGUgdHlwZSBPYmplY3QuIEkgaG9wZSB0byBhY2hpZXZlIHNvbWUgcGVyZm9ybWFuY2VcbiBpbXByb3ZlbWVudHMgd2hlbiB3b3JraW5nIG9uIGRhdGFiYXNlcyB0aGF0IHN1cHBvcnQgdGhlIGpzb24gZm9ybWF0LlxuXG4gQW4gb3BlcmF0aW9uIG11c3QgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbiAqIGVuY29kZVxuICAgICAtIEVuY29kZSB0aGUgc3RydWN0dXJlIGluIGEgcmVhZGFibGUgZm9ybWF0IChwcmVmZXJhYmx5IHN0cmluZy0gdG9kbylcbiAqIGRlY29kZSAodG9kbylcbiAgICAgLSBkZWNvZGUgc3RydWN0dXJlIHRvIGpzb25cbiAqIGV4ZWN1dGVcbiAgICAgLSBFeGVjdXRlIHRoZSBzZW1hbnRpY3Mgb2YgYW4gb3BlcmF0aW9uLlxuICogcmVxdWlyZWRPcHNcbiAgICAgLSBPcGVyYXRpb25zIHRoYXQgYXJlIHJlcXVpcmVkIHRvIGV4ZWN1dGUgdGhpcyBvcGVyYXRpb24uXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWS8qIDphbnkgKi8pIHtcbiAgdmFyIFN0cnVjdCA9IHtcbiAgICAvKiBUaGlzIGlzIHRoZSBvbmx5IG9wZXJhdGlvbiB0aGF0IGlzIGFjdHVhbGx5IG5vdCBhIHN0cnVjdHVyZSwgYmVjYXVzZVxuICAgIGl0IGlzIG5vdCBzdG9yZWQgaW4gdGhlIE9TLiBUaGlzIGlzIHdoeSBpdCBfZG9lcyBub3RfIGhhdmUgYW4gaWRcblxuICAgIG9wID0ge1xuICAgICAgdGFyZ2V0OiBJZFxuICAgIH1cbiAgICAqL1xuICAgIERlbGV0ZToge1xuICAgICAgZW5jb2RlOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIG9wXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWRPcHM6IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICByZXR1cm4gW10gLy8gW29wLnRhcmdldF1cbiAgICAgIH0sXG4gICAgICBleGVjdXRlOiBmdW5jdGlvbiAqIChvcCkge1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZGVsZXRlT3BlcmF0aW9uKG9wLnRhcmdldCwgb3AubGVuZ3RoIHx8IDEpXG4gICAgICB9XG4gICAgfSxcbiAgICBJbnNlcnQ6IHtcbiAgICAgIC8qIHtcbiAgICAgICAgICBjb250ZW50OiBbYW55XSxcbiAgICAgICAgICBvcENvbnRlbnQ6IElkLFxuICAgICAgICAgIGlkOiBJZCxcbiAgICAgICAgICBsZWZ0OiBJZCxcbiAgICAgICAgICBvcmlnaW46IElkLFxuICAgICAgICAgIHJpZ2h0OiBJZCxcbiAgICAgICAgICBwYXJlbnQ6IElkLFxuICAgICAgICAgIHBhcmVudFN1Yjogc3RyaW5nIChvcHRpb25hbCksIC8vIGNoaWxkIG9mIE1hcCB0eXBlXG4gICAgICAgIH1cbiAgICAgICovXG4gICAgICBlbmNvZGU6IGZ1bmN0aW9uIChvcC8qIDpJbnNlcnRpb24gKi8pIC8qIDpJbnNlcnRpb24gKi8ge1xuICAgICAgICAvLyBUT0RPOiB5b3UgY291bGQgbm90IHNlbmQgdGhlIFwibGVmdFwiIHByb3BlcnR5LCB0aGVuIHlvdSBhbHNvIGhhdmUgdG9cbiAgICAgICAgLy8gXCJvcC5sZWZ0ID0gbnVsbFwiIGluICRleGVjdXRlIG9yICRkZWNvZGVcbiAgICAgICAgdmFyIGUvKiA6YW55ICovID0ge1xuICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICBsZWZ0OiBvcC5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBvcC5yaWdodCxcbiAgICAgICAgICBvcmlnaW46IG9wLm9yaWdpbixcbiAgICAgICAgICBwYXJlbnQ6IG9wLnBhcmVudCxcbiAgICAgICAgICBzdHJ1Y3Q6IG9wLnN0cnVjdFxuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5wYXJlbnRTdWIgIT0gbnVsbCkge1xuICAgICAgICAgIGUucGFyZW50U3ViID0gb3AucGFyZW50U3ViXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLmhhc093blByb3BlcnR5KCdvcENvbnRlbnQnKSkge1xuICAgICAgICAgIGUub3BDb250ZW50ID0gb3Aub3BDb250ZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZS5jb250ZW50ID0gb3AuY29udGVudC5zbGljZSgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkT3BzOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdmFyIGlkcyA9IFtdXG4gICAgICAgIGlmIChvcC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICBpZHMucHVzaChvcC5sZWZ0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgaWRzLnB1c2gob3AucmlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLm9yaWdpbiAhPSBudWxsICYmICFZLnV0aWxzLmNvbXBhcmVJZHMob3AubGVmdCwgb3Aub3JpZ2luKSkge1xuICAgICAgICAgIGlkcy5wdXNoKG9wLm9yaWdpbilcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAob3AucmlnaHQgPT0gbnVsbCAmJiBvcC5sZWZ0ID09IG51bGwpIHtcbiAgICAgICAgaWRzLnB1c2gob3AucGFyZW50KVxuXG4gICAgICAgIGlmIChvcC5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlkcy5wdXNoKG9wLm9wQ29udGVudClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzXG4gICAgICB9LFxuICAgICAgZ2V0RGlzdGFuY2VUb09yaWdpbjogZnVuY3Rpb24gKiAob3ApIHtcbiAgICAgICAgaWYgKG9wLmxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSAwXG4gICAgICAgICAgdmFyIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24ob3AubGVmdClcbiAgICAgICAgICB3aGlsZSAoIVkudXRpbHMubWF0Y2hlc0lkKG8sIG9wLm9yaWdpbikpIHtcbiAgICAgICAgICAgIGQrK1xuICAgICAgICAgICAgaWYgKG8ubGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG8ubGVmdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qXG4gICAgICAjICR0aGlzIGhhcyB0byBmaW5kIGEgdW5pcXVlIHBvc2l0aW9uIGJldHdlZW4gb3JpZ2luIGFuZCB0aGUgbmV4dCBrbm93biBjaGFyYWN0ZXJcbiAgICAgICMgY2FzZSAxOiAkb3JpZ2luIGVxdWFscyAkby5vcmlnaW46IHRoZSAkY3JlYXRvciBwYXJhbWV0ZXIgZGVjaWRlcyBpZiBsZWZ0IG9yIHJpZ2h0XG4gICAgICAjICAgICAgICAgbGV0ICRPTD0gW28xLG8yLG8zLG80XSwgd2hlcmVieSAkdGhpcyBpcyB0byBiZSBpbnNlcnRlZCBiZXR3ZWVuIG8xIGFuZCBvNFxuICAgICAgIyAgICAgICAgIG8yLG8zIGFuZCBvNCBvcmlnaW4gaXMgMSAodGhlIHBvc2l0aW9uIG9mIG8yKVxuICAgICAgIyAgICAgICAgIHRoZXJlIGlzIHRoZSBjYXNlIHRoYXQgJHRoaXMuY3JlYXRvciA8IG8yLmNyZWF0b3IsIGJ1dCBvMy5jcmVhdG9yIDwgJHRoaXMuY3JlYXRvclxuICAgICAgIyAgICAgICAgIHRoZW4gbzIga25vd3MgbzMuIFNpbmNlIG9uIGFub3RoZXIgY2xpZW50ICRPTCBjb3VsZCBiZSBbbzEsbzMsbzRdIHRoZSBwcm9ibGVtIGlzIGNvbXBsZXhcbiAgICAgICMgICAgICAgICB0aGVyZWZvcmUgJHRoaXMgd291bGQgYmUgYWx3YXlzIHRvIHRoZSByaWdodCBvZiBvM1xuICAgICAgIyBjYXNlIDI6ICRvcmlnaW4gPCAkby5vcmlnaW5cbiAgICAgICMgICAgICAgICBpZiBjdXJyZW50ICR0aGlzIGluc2VydF9wb3NpdGlvbiA+ICRvIG9yaWdpbjogJHRoaXMgaW5zXG4gICAgICAjICAgICAgICAgZWxzZSAkaW5zZXJ0X3Bvc2l0aW9uIHdpbGwgbm90IGNoYW5nZVxuICAgICAgIyAgICAgICAgIChtYXliZSB3ZSBlbmNvdW50ZXIgY2FzZSAxIGxhdGVyLCB0aGVuIHRoaXMgd2lsbCBiZSB0byB0aGUgcmlnaHQgb2YgJG8pXG4gICAgICAjIGNhc2UgMzogJG9yaWdpbiA+ICRvLm9yaWdpblxuICAgICAgIyAgICAgICAgICR0aGlzIGluc2VydF9wb3NpdGlvbiBpcyB0byB0aGUgbGVmdCBvZiAkbyAoZm9yZXZlciEpXG4gICAgICAqL1xuICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKiAob3ApIHtcbiAgICAgICAgdmFyIGkgLy8gbG9vcCBjb3VudGVyXG5cbiAgICAgICAgLy8gZHVyaW5nIHRoaXMgZnVuY3Rpb24gc29tZSBvcHMgbWF5IGdldCBzcGxpdCBpbnRvIHR3byBwaWVjZXMgKGUuZy4gd2l0aCBnZXRJbnNlcnRpb25DbGVhbkVuZClcbiAgICAgICAgLy8gV2UgdHJ5IHRvIG1lcmdlIHRoZW0gbGF0ZXIsIGlmIHBvc3NpYmxlXG4gICAgICAgIHZhciB0cnlUb1JlbWVyZ2VMYXRlciA9IFtdXG5cbiAgICAgICAgaWYgKG9wLm9yaWdpbiAhPSBudWxsKSB7IC8vIFRPRE86ICE9PSBpbnN0ZWFkIG9mICE9XG4gICAgICAgICAgLy8gd2Ugc2F2ZSBpbiBvcmlnaW4gdGhhdCBvcCBvcmlnaW5hdGVzIGluIGl0XG4gICAgICAgICAgLy8gd2UgbmVlZCB0aGF0IGxhdGVyIHdoZW4gd2UgZXZlbnR1YWxseSBnYXJiYWdlIGNvbGxlY3Qgb3JpZ2luIChzZWUgdHJhbnNhY3Rpb24pXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuRW5kKG9wLm9yaWdpbilcbiAgICAgICAgICBpZiAob3JpZ2luLm9yaWdpbk9mID09IG51bGwpIHtcbiAgICAgICAgICAgIG9yaWdpbi5vcmlnaW5PZiA9IFtdXG4gICAgICAgICAgfVxuICAgICAgICAgIG9yaWdpbi5vcmlnaW5PZi5wdXNoKG9wLmlkKVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihvcmlnaW4pXG4gICAgICAgICAgaWYgKG9yaWdpbi5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnlUb1JlbWVyZ2VMYXRlci5wdXNoKG9yaWdpbi5yaWdodClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3RhbmNlVG9PcmlnaW4gPSBpID0geWllbGQqIFN0cnVjdC5JbnNlcnQuZ2V0RGlzdGFuY2VUb09yaWdpbi5jYWxsKHRoaXMsIG9wKSAvLyBtb3N0IGNhc2VzOiAwIChzdGFydHMgZnJvbSAwKVxuXG4gICAgICAgIC8vIG5vdyB3ZSBiZWdpbiB0byBpbnNlcnQgb3AgaW4gdGhlIGxpc3Qgb2YgaW5zZXJ0aW9ucy4uXG4gICAgICAgIHZhciBvXG4gICAgICAgIHZhciBwYXJlbnRcbiAgICAgICAgdmFyIHN0YXJ0XG5cbiAgICAgICAgLy8gZmluZCBvLiBvIGlzIHRoZSBmaXJzdCBjb25mbGljdGluZyBvcGVyYXRpb25cbiAgICAgICAgaWYgKG9wLmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb25DbGVhbkVuZChvcC5sZWZ0KVxuICAgICAgICAgIGlmICghWS51dGlscy5jb21wYXJlSWRzKG9wLmxlZnQsIG9wLm9yaWdpbikgJiYgby5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGlmIG5vdCBhZGRlZCBwcmV2aW91c2x5XG4gICAgICAgICAgICB0cnlUb1JlbWVyZ2VMYXRlci5wdXNoKG8ucmlnaHQpXG4gICAgICAgICAgfVxuICAgICAgICAgIG8gPSAoby5yaWdodCA9PSBudWxsKSA/IG51bGwgOiB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5yaWdodClcbiAgICAgICAgfSBlbHNlIHsgLy8gbGVmdCA9PSBudWxsXG4gICAgICAgICAgcGFyZW50ID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKG9wLnBhcmVudClcbiAgICAgICAgICBsZXQgc3RhcnRJZCA9IG9wLnBhcmVudFN1YiA/IHBhcmVudC5tYXBbb3AucGFyZW50U3ViXSA6IHBhcmVudC5zdGFydFxuICAgICAgICAgIHN0YXJ0ID0gc3RhcnRJZCA9PSBudWxsID8gbnVsbCA6IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihzdGFydElkKVxuICAgICAgICAgIG8gPSBzdGFydFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHNwbGl0IG9wLnJpZ2h0IGlmIG5lY2Vzc2FyeSAoYWxzbyBhZGQgdG8gdHJ5Q29tYmluZVdpdGhMZWZ0KVxuICAgICAgICBpZiAob3AucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgIHRyeVRvUmVtZXJnZUxhdGVyLnB1c2gob3AucmlnaHQpXG4gICAgICAgICAgeWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5TdGFydChvcC5yaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBjb25mbGljdHNcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAobyAhPSBudWxsICYmICFZLnV0aWxzLmNvbXBhcmVJZHMoby5pZCwgb3AucmlnaHQpKSB7XG4gICAgICAgICAgICB2YXIgb09yaWdpbkRpc3RhbmNlID0geWllbGQqIFN0cnVjdC5JbnNlcnQuZ2V0RGlzdGFuY2VUb09yaWdpbi5jYWxsKHRoaXMsIG8pXG4gICAgICAgICAgICBpZiAob09yaWdpbkRpc3RhbmNlID09PSBpKSB7XG4gICAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgICBpZiAoby5pZFswXSA8IG9wLmlkWzBdKSB7XG4gICAgICAgICAgICAgICAgb3AubGVmdCA9IFkudXRpbHMuZ2V0TGFzdElkKG8pXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VUb09yaWdpbiA9IGkgKyAxIC8vIGp1c3QgaWdub3JlIG8uY29udGVudC5sZW5ndGgsIGRvZXNuJ3QgbWFrZSBhIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvT3JpZ2luRGlzdGFuY2UgPCBpKSB7XG4gICAgICAgICAgICAgIC8vIGNhc2UgMlxuICAgICAgICAgICAgICBpZiAoaSAtIGRpc3RhbmNlVG9PcmlnaW4gPD0gb09yaWdpbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgb3AubGVmdCA9IFkudXRpbHMuZ2V0TGFzdElkKG8pXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VUb09yaWdpbiA9IGkgKyAxIC8vIGp1c3QgaWdub3JlIG8uY29udGVudC5sZW5ndGgsIGRvZXNuJ3QgbWFrZSBhIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgaWYgKG8ucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG8ucmlnaHQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY29ubmVjdC4uXG4gICAgICAgIHZhciBsZWZ0ID0gbnVsbFxuICAgICAgICB2YXIgcmlnaHQgPSBudWxsXG4gICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHBhcmVudCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvcC5wYXJlbnQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWNvbm5lY3QgbGVmdCBhbmQgc2V0IHJpZ2h0IG9mIG9wXG4gICAgICAgIGlmIChvcC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICBsZWZ0ID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG9wLmxlZnQpXG4gICAgICAgICAgLy8gbGluayBsZWZ0XG4gICAgICAgICAgb3AucmlnaHQgPSBsZWZ0LnJpZ2h0XG4gICAgICAgICAgbGVmdC5yaWdodCA9IG9wLmlkXG5cbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24obGVmdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZXQgb3AucmlnaHQgZnJvbSBwYXJlbnQsIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIG9wLnJpZ2h0ID0gb3AucGFyZW50U3ViID8gcGFyZW50Lm1hcFtvcC5wYXJlbnRTdWJdIHx8IG51bGwgOiBwYXJlbnQuc3RhcnRcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvbm5lY3QgcmlnaHRcbiAgICAgICAgaWYgKG9wLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiB3YW5uYSBjb25uZWN0IHJpZ2h0IHRvbz9cbiAgICAgICAgICByaWdodCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvcC5yaWdodClcbiAgICAgICAgICByaWdodC5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQob3ApXG5cbiAgICAgICAgICAvLyBpZiByaWdodCBleGlzdHMsIGFuZCBpdCBpcyBzdXBwb3NlZCB0byBiZSBnYydkLiBSZW1vdmUgaXQgZnJvbSB0aGUgZ2NcbiAgICAgICAgICBpZiAocmlnaHQuZ2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJpZ2h0LmNvbnRlbnQgIT0gbnVsbCAmJiByaWdodC5jb250ZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb25DbGVhbkVuZChyaWdodC5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmUucmVtb3ZlRnJvbUdhcmJhZ2VDb2xsZWN0b3IocmlnaHQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihyaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnRzIC5tYXAvc3RhcnQvZW5kIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKG9wLnBhcmVudFN1YiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Lm1hcFtvcC5wYXJlbnRTdWJdID0gb3AuaWRcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihwYXJlbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlzIGEgY2hpbGQgb2YgYSBtYXAgc3RydWN0LlxuICAgICAgICAgIC8vIFRoZW4gYWxzbyBtYWtlIHN1cmUgdGhhdCBvbmx5IHRoZSBtb3N0IGxlZnQgZWxlbWVudCBpcyBub3QgZGVsZXRlZFxuICAgICAgICAgIC8vIFdlIGRvIG5vdCBjYWxsIHRoZSB0eXBlIGluIHRoaXMgY2FzZSAodGhpcyBpcyB3aGF0IHRoZSB0aGlyZCBwYXJhbWV0ZXIgaXMgZm9yKVxuICAgICAgICAgIGlmIChvcC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24ob3AucmlnaHQsIDEsIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmRlbGV0ZU9wZXJhdGlvbihvcC5pZCwgMSwgdHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJpZ2h0ID09IG51bGwgfHwgbGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJlbnQuZW5kID0gWS51dGlscy5nZXRMYXN0SWQob3ApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5zdGFydCA9IG9wLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ocGFyZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBtZXJnZSBvcmlnaW5hbCBvcC5sZWZ0IGFuZCBvcC5vcmlnaW5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cnlUb1JlbWVyZ2VMYXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKHRyeVRvUmVtZXJnZUxhdGVyW2ldKVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnRyeUNvbWJpbmVXaXRoTGVmdChtKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBMaXN0OiB7XG4gICAgICAvKlxuICAgICAge1xuICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICBzdHJ1Y3Q6IFwiTGlzdFwiLFxuICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICBpZDogdGhpcy5vcy5nZXROZXh0T3BJZCgxKVxuICAgICAgfVxuICAgICAgKi9cbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQ6IG51bGwsXG4gICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgIHN0cnVjdDogJ0xpc3QnLFxuICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5jb2RlOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgc3RydWN0OiAnTGlzdCcsXG4gICAgICAgICAgaWQ6IG9wLmlkLFxuICAgICAgICAgIHR5cGU6IG9wLnR5cGVcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AucmVxdWlyZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGUucmVxdWlyZXMgPSBvcC5yZXF1aXJlc1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5pbmZvICE9IG51bGwpIHtcbiAgICAgICAgICBlLmluZm8gPSBvcC5pbmZvXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZE9wczogZnVuY3Rpb24gKCkge1xuICAgICAgICAvKlxuICAgICAgICB2YXIgaWRzID0gW11cbiAgICAgICAgaWYgKG9wLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBpZHMucHVzaChvcC5zdGFydClcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AuZW5kICE9IG51bGwpe1xuICAgICAgICAgIGlkcy5wdXNoKG9wLmVuZClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfSxcbiAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uICogKG9wKSB7XG4gICAgICAgIG9wLnN0YXJ0ID0gbnVsbFxuICAgICAgICBvcC5lbmQgPSBudWxsXG4gICAgICB9LFxuICAgICAgcmVmOiBmdW5jdGlvbiAqIChvcCwgcG9zKSB7XG4gICAgICAgIGlmIChvcC5zdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gbnVsbFxuICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvcC5zdGFydClcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICghby5kZWxldGVkKSB7XG4gICAgICAgICAgICByZXMgPSBvXG4gICAgICAgICAgICBwb3MtLVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zID49IDAgJiYgby5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKG8ucmlnaHQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH0sXG4gICAgICBtYXA6IGZ1bmN0aW9uICogKG8sIGYpIHtcbiAgICAgICAgbyA9IG8uc3RhcnRcbiAgICAgICAgdmFyIHJlcyA9IFtdXG4gICAgICAgIHdoaWxlIChvICE9IG51bGwpIHsgLy8gVE9ETzogY2hhbmdlIHRvICE9IChhdCBsZWFzdCBzb21lIGNvbnZlbnRpb24pXG4gICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihvKVxuICAgICAgICAgIGlmICghb3BlcmF0aW9uLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGYob3BlcmF0aW9uKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbyA9IG9wZXJhdGlvbi5yaWdodFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH1cbiAgICB9LFxuICAgIE1hcDoge1xuICAgICAgLypcbiAgICAgICAge1xuICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgc3RydWN0OiBcIk1hcFwiLFxuICAgICAgICAgIHR5cGU6IFwiXCIsXG4gICAgICAgICAgaWQ6IHRoaXMub3MuZ2V0TmV4dE9wSWQoMSlcbiAgICAgICAgfVxuICAgICAgKi9cbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgc3RydWN0OiAnTWFwJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5jb2RlOiBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgc3RydWN0OiAnTWFwJyxcbiAgICAgICAgICB0eXBlOiBvcC50eXBlLFxuICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICBtYXA6IHt9IC8vIG92ZXJ3cml0ZSBtYXAhIVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcC5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZS5yZXF1aXJlcyA9IG9wLnJlcXVpcmVzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLmluZm8gIT0gbnVsbCkge1xuICAgICAgICAgIGUuaW5mbyA9IG9wLmluZm9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkT3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfSxcbiAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uICogKCkge30sXG4gICAgICAvKlxuICAgICAgICBHZXQgYSBwcm9wZXJ0eSBieSBuYW1lXG4gICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiAqIChvcCwgbmFtZSkge1xuICAgICAgICB2YXIgb2lkID0gb3AubWFwW25hbWVdXG4gICAgICAgIGlmIChvaWQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciByZXMgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24ob2lkKVxuICAgICAgICAgIGlmIChyZXMgPT0gbnVsbCB8fCByZXMuZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMFxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLm9wQ29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmNvbnRlbnRbMF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmdldFR5cGUocmVzLm9wQ29udGVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgWS5TdHJ1Y3QgPSBTdHJ1Y3Rcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuLypcbiAgUGFydGlhbCBkZWZpbml0aW9uIG9mIGEgdHJhbnNhY3Rpb25cblxuICBBIHRyYW5zYWN0aW9uIHByb3ZpZGVzIGFsbCB0aGUgdGhlIGFzeW5jIGZ1bmN0aW9uYWxpdHkgb24gYSBkYXRhYmFzZS5cblxuICBCeSBjb252ZW50aW9uLCBhIHRyYW5zYWN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICogc3MgZm9yIFN0YXRlU2V0XG4gICogb3MgZm9yIE9wZXJhdGlvblN0b3JlXG4gICogZHMgZm9yIERlbGV0ZVN0b3JlXG5cbiAgQSB0cmFuc2FjdGlvbiBtdXN0IGFsc28gZGVmaW5lIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgKiBjaGVja0RlbGV0ZVN0b3JlRm9yU3RhdGUoc3RhdGUpXG4gICAgLSBXaGVuIGluY3JlYXNpbmcgdGhlIHN0YXRlIG9mIGEgdXNlciwgYW4gb3BlcmF0aW9uIHdpdGggYW4gaGlnaGVyIGlkXG4gICAgICBtYXkgYWxyZWFkeSBiZSBnYXJiYWdlIGNvbGxlY3RlZCwgYW5kIHRoZXJlZm9yZSBpdCB3aWxsIG5ldmVyIGJlIHJlY2VpdmVkLlxuICAgICAgdXBkYXRlIHRoZSBzdGF0ZSB0byByZWZsZWN0IHRoaXMga25vd2xlZGdlLiBUaGlzIHdvbid0IGNhbGwgYSBtZXRob2QgdG8gc2F2ZSB0aGUgc3RhdGUhXG4gICogZ2V0RGVsZXRlU2V0KGlkKVxuICAgIC0gR2V0IHRoZSBkZWxldGUgc2V0IGluIGEgcmVhZGFibGUgZm9ybWF0OlxuICAgICAge1xuICAgICAgICBcInVzZXJYXCI6IFtcbiAgICAgICAgICBbNSwxXSwgLy8gc3RhcnRpbmcgZnJvbSBwb3NpdGlvbiA1LCBvbmUgb3BlcmF0aW9ucyBpcyBkZWxldGVkXG4gICAgICAgICAgWzksNF0gIC8vIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gOSwgZm91ciBvcGVyYXRpb25zIGFyZSBkZWxldGVkXG4gICAgICAgIF0sXG4gICAgICAgIFwidXNlcllcIjogLi4uXG4gICAgICB9XG4gICogZ2V0T3BzRnJvbURlbGV0ZVNldChkcykgLS0gVE9ETzoganVzdCBjYWxsIHRoaXMuZGVsZXRlT3BlcmF0aW9uKGlkKSBoZXJlXG4gICAgLSBnZXQgYSBzZXQgb2YgZGVsZXRpb25zIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIGluIG9yZGVyIHRvIGdldCB0b1xuICAgICAgYWNoaWV2ZSB0aGUgc3RhdGUgb2YgdGhlIHN1cHBsaWVkIGRzXG4gICogc2V0T3BlcmF0aW9uKG9wKVxuICAgIC0gd3JpdGUgYG9wYCB0byB0aGUgZGF0YWJhc2UuXG4gICAgICBOb3RlOiB0aGlzIGlzIGFsbG93ZWQgdG8gcmV0dXJuIGFuIGluLW1lbW9yeSBvYmplY3QuXG4gICAgICBFLmcuIHRoZSBNZW1vcnkgYWRhcHRlciByZXR1cm5zIHRoZSBvYmplY3QgdGhhdCBpdCBoYXMgaW4tbWVtb3J5LlxuICAgICAgQ2hhbmdpbmcgdmFsdWVzIG9uIHRoaXMgb2JqZWN0IHdpbGwgYmUgc3RvcmVkIGRpcmVjdGx5IGluIHRoZSBkYXRhYmFzZVxuICAgICAgd2l0aG91dCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uIFRoZXJlZm9yZSxcbiAgICAgIHNldE9wZXJhdGlvbiBtYXkgaGF2ZSBubyBmdW5jdGlvbmFsaXR5IGluIHNvbWUgYWRhcHRlcnMuIFRoaXMgYWxzbyBoYXNcbiAgICAgIGltcGxpY2F0aW9ucyBvbiB0aGUgd2F5IHdlIHVzZSBvcGVyYXRpb25zIHRoYXQgd2VyZSBzZXJ2ZWQgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAgICBXZSB0cnkgbm90IHRvIGNhbGwgY29weU9iamVjdCwgaWYgbm90IG5lY2Vzc2FyeS5cbiAgKiBhZGRPcGVyYXRpb24ob3ApXG4gICAgLSBhZGQgYW4gb3BlcmF0aW9uIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgIFRoaXMgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IG9wLmlkXG4gICAgICBNdXN0IHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBvcGVyYXRpb24gaW4gdGhlIGRhdGFiYXNlIChvcmRlcmVkIGJ5IGlkKVxuICAqIGdldE9wZXJhdGlvbihpZClcbiAgKiByZW1vdmVPcGVyYXRpb24oaWQpXG4gICAgLSByZW1vdmUgYW4gb3BlcmF0aW9uIGZyb20gdGhlIGRhdGFiYXNlLiBUaGlzIGlzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvblxuICAgICAgaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICogc2V0U3RhdGUoc3RhdGUpXG4gICAgLSBgc3RhdGVgIGlzIG9mIHRoZSBmb3JtXG4gICAgICB7XG4gICAgICAgIHVzZXI6IFwiMVwiLFxuICAgICAgICBjbG9jazogNFxuICAgICAgfSA8LSBtZWFuaW5nIHRoYXQgd2UgaGF2ZSBmb3VyIG9wZXJhdGlvbnMgZnJvbSB1c2VyIFwiMVwiXG4gICAgICAgICAgICh3aXRoIHRoZXNlIGlkJ3MgcmVzcGVjdGl2ZWx5OiAwLCAxLCAyLCBhbmQgMylcbiAgKiBnZXRTdGF0ZSh1c2VyKVxuICAqIGdldFN0YXRlVmVjdG9yKClcbiAgICAtIEdldCB0aGUgc3RhdGUgb2YgdGhlIE9TIGluIHRoZSBmb3JtXG4gICAgW3tcbiAgICAgIHVzZXI6IFwidXNlclhcIixcbiAgICAgIGNsb2NrOiAxMVxuICAgIH0sXG4gICAgIC4uXG4gICAgXVxuICAqIGdldFN0YXRlU2V0KClcbiAgICAtIEdldCB0aGUgc3RhdGUgb2YgdGhlIE9TIGluIHRoZSBmb3JtXG4gICAge1xuICAgICAgXCJ1c2VyWFwiOiAxMSxcbiAgICAgIFwidXNlcllcIjogMjJcbiAgICB9XG4gICAqIGdldE9wZXJhdGlvbnMoc3RhcnRTUylcbiAgICAgLSBHZXQgdGhlIGFsbCB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gYWNoaXZlIHRoZVxuICAgICAgIHN0YXRlU2V0IG9mIHRoaXMgdXNlciwgc3RhcnRpbmcgZnJvbSBhIHN0YXRlU2V0IHN1cHBsaWVkIGJ5IGFub3RoZXIgdXNlclxuICAgKiBtYWtlT3BlcmF0aW9uUmVhZHkoc3MsIG9wKVxuICAgICAtIHRoaXMgaXMgY2FsbGVkIG9ubHkgYnkgYGdldE9wZXJhdGlvbnMoc3RhcnRTUylgLiBJdCBtYWtlcyBhbiBvcGVyYXRpb25cbiAgICAgICBhcHBseWFibGUgb24gYSBnaXZlbiBTUy5cbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZLyogOmFueSAqLykge1xuICBjbGFzcyBUcmFuc2FjdGlvbkludGVyZmFjZSB7XG4gICAgLyogOjpcbiAgICBzdG9yZTogWS5BYnN0cmFjdERhdGFiYXNlO1xuICAgIGRzOiBTdG9yZTtcbiAgICBvczogU3RvcmU7XG4gICAgc3M6IFN0b3JlO1xuICAgICovXG4gICAgLypcbiAgICAgIEdldCBhIHR5cGUgYmFzZWQgb24gdGhlIGlkIG9mIGl0cyBtb2RlbC5cbiAgICAgIElmIGl0IGRvZXMgbm90IGV4aXN0IHllcywgY3JlYXRlIGl0LlxuICAgICAgVE9ETzogZGVsZXRlIHR5cGUgZnJvbSBzdG9yZS5pbml0aWFsaXplZFR5cGVzW2lkXSB3aGVuIGNvcnJlc3BvbmRpbmcgaWQgd2FzIGRlbGV0ZWQhXG4gICAgKi9cbiAgICAqIGdldFR5cGUgKGlkLCBhcmdzKSB7XG4gICAgICB2YXIgc2lkID0gSlNPTi5zdHJpbmdpZnkoaWQpXG4gICAgICB2YXIgdCA9IHRoaXMuc3RvcmUuaW5pdGlhbGl6ZWRUeXBlc1tzaWRdXG4gICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBvcC8qIDpNYXBTdHJ1Y3QgfCBMaXN0U3RydWN0ICovID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKGlkKVxuICAgICAgICBpZiAob3AgIT0gbnVsbCkge1xuICAgICAgICAgIHQgPSB5aWVsZCogWVtvcC50eXBlXS50eXBlRGVmaW5pdGlvbi5pbml0VHlwZS5jYWxsKHRoaXMsIHRoaXMuc3RvcmUsIG9wLCBhcmdzKVxuICAgICAgICAgIHRoaXMuc3RvcmUuaW5pdGlhbGl6ZWRUeXBlc1tzaWRdID0gdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdFxuICAgIH1cbiAgICAqIGNyZWF0ZVR5cGUgKHR5cGVkZWZpbml0aW9uLCBpZCkge1xuICAgICAgdmFyIHN0cnVjdG5hbWUgPSB0eXBlZGVmaW5pdGlvblswXS5zdHJ1Y3RcbiAgICAgIGlkID0gaWQgfHwgdGhpcy5zdG9yZS5nZXROZXh0T3BJZCgxKVxuICAgICAgdmFyIG9wXG4gICAgICBpZiAoaWRbMF0gPT09ICdfJykge1xuICAgICAgICBvcCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihpZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wID0gWS5TdHJ1Y3Rbc3RydWN0bmFtZV0uY3JlYXRlKGlkKVxuICAgICAgICBvcC50eXBlID0gdHlwZWRlZmluaXRpb25bMF0ubmFtZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVkZWZpbml0aW9uWzBdLmFwcGVuZEFkZGl0aW9uYWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgeWllbGQqIHR5cGVkZWZpbml0aW9uWzBdLmFwcGVuZEFkZGl0aW9uYWxJbmZvLmNhbGwodGhpcywgb3AsIHR5cGVkZWZpbml0aW9uWzFdKVxuICAgICAgfVxuICAgICAgaWYgKG9wWzBdID09PSAnXycpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYXBwbHlDcmVhdGVkT3BlcmF0aW9ucyhbb3BdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmdldFR5cGUoaWQsIHR5cGVkZWZpbml0aW9uWzFdKVxuICAgIH1cbiAgICAvKiBjcmVhdGVUeXBlICh0eXBlZGVmaW5pdGlvbiwgaWQpIHtcbiAgICAgIHZhciBzdHJ1Y3RuYW1lID0gdHlwZWRlZmluaXRpb25bMF0uc3RydWN0XG4gICAgICBpZCA9IGlkIHx8IHRoaXMuc3RvcmUuZ2V0TmV4dE9wSWQoMSlcbiAgICAgIHZhciBvcCA9IFkuU3RydWN0W3N0cnVjdG5hbWVdLmNyZWF0ZShpZClcbiAgICAgIG9wLnR5cGUgPSB0eXBlZGVmaW5pdGlvblswXS5uYW1lXG4gICAgICBpZiAodHlwZWRlZmluaXRpb25bMF0uYXBwZW5kQWRkaXRpb25hbEluZm8gIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCogdHlwZWRlZmluaXRpb25bMF0uYXBwZW5kQWRkaXRpb25hbEluZm8uY2FsbCh0aGlzLCBvcCwgdHlwZWRlZmluaXRpb25bMV0pXG4gICAgICB9XG4gICAgICAvLyB5aWVsZCogdGhpcy5hcHBseUNyZWF0ZWRPcGVyYXRpb25zKFtvcF0pXG4gICAgICB5aWVsZCogWS5TdHJ1Y3Rbb3Auc3RydWN0XS5leGVjdXRlLmNhbGwodGhpcywgb3ApXG4gICAgICB5aWVsZCogdGhpcy5hZGRPcGVyYXRpb24ob3ApXG4gICAgICB5aWVsZCogdGhpcy5zdG9yZS5vcGVyYXRpb25BZGRlZCh0aGlzLCBvcClcbiAgICAgIHJldHVybiB5aWVsZCogdGhpcy5nZXRUeXBlKGlkLCB0eXBlZGVmaW5pdGlvblsxXSlcbiAgICB9Ki9cbiAgICAvKlxuICAgICAgQXBwbHkgb3BlcmF0aW9ucyB0aGF0IHRoaXMgdXNlciBjcmVhdGVkIChubyByZW1vdGUgb25lcyEpXG4gICAgICAgICogZG9lcyBub3QgY2hlY2sgZm9yIFN0cnVjdC4qLnJlcXVpcmVkT3BzKClcbiAgICAgICAgKiBhbHNvIGJyb2FkY2FzdHMgaXQgdGhyb3VnaCB0aGUgY29ubmVjdG9yXG4gICAgKi9cbiAgICAqIGFwcGx5Q3JlYXRlZE9wZXJhdGlvbnMgKG9wcykge1xuICAgICAgdmFyIHNlbmQgPSBbXVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wID0gb3BzW2ldXG4gICAgICAgIHlpZWxkKiB0aGlzLnN0b3JlLnRyeUV4ZWN1dGUuY2FsbCh0aGlzLCBvcClcbiAgICAgICAgaWYgKG9wLmlkID09IG51bGwgfHwgdHlwZW9mIG9wLmlkWzFdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHNlbmQucHVzaChZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvcCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdG9yZS55LmNvbm5lY3Rvci5pc0Rpc2Nvbm5lY3RlZCgpICYmIHNlbmQubGVuZ3RoID4gMCkgeyAvLyBUT0RPOiAmJiAhdGhpcy5zdG9yZS5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgKGJ1dCB0aGVuIGkgZG9uJ3Qgc2VuZCBkZWxldGUgb3BzKVxuICAgICAgICAvLyBpcyBjb25uZWN0ZWQsIGFuZCB0aGlzIGlzIG5vdCBnb2luZyB0byBiZSBzZW5kIGluIGFkZE9wZXJhdGlvblxuICAgICAgICB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmJyb2FkY2FzdE9wcyhzZW5kKVxuICAgICAgfVxuICAgIH1cblxuICAgICogZGVsZXRlTGlzdCAoc3RhcnQpIHtcbiAgICAgIHdoaWxlIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHN0YXJ0ID0geWllbGQqIHRoaXMuZ2V0T3BlcmF0aW9uKHN0YXJ0KVxuICAgICAgICBpZiAoIXN0YXJ0LmdjKSB7XG4gICAgICAgICAgc3RhcnQuZ2MgPSB0cnVlXG4gICAgICAgICAgc3RhcnQuZGVsZXRlZCA9IHRydWVcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24oc3RhcnQpXG4gICAgICAgICAgdmFyIGRlbExlbmd0aCA9IHN0YXJ0LmNvbnRlbnQgIT0gbnVsbCA/IHN0YXJ0LmNvbnRlbnQubGVuZ3RoIDogMVxuICAgICAgICAgIHlpZWxkKiB0aGlzLm1hcmtEZWxldGVkKHN0YXJ0LmlkLCBkZWxMZW5ndGgpXG4gICAgICAgICAgaWYgKHN0YXJ0Lm9wQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24oc3RhcnQub3BDb250ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0b3JlLnF1ZXVlR2FyYmFnZUNvbGxlY3RvcihzdGFydC5pZClcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0YXJ0LnJpZ2h0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgIE1hcmsgYW4gb3BlcmF0aW9uIGFzIGRlbGV0ZWQsIGFuZCBhZGQgaXQgdG8gdGhlIEdDLCBpZiBwb3NzaWJsZS5cbiAgICAqL1xuICAgICogZGVsZXRlT3BlcmF0aW9uICh0YXJnZXRJZCwgbGVuZ3RoLCBwcmV2ZW50Q2FsbFR5cGUpIC8qIDpHZW5lcmF0b3I8YW55LCBhbnksIGFueT4gKi8ge1xuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIGxlbmd0aCA9IDFcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLm1hcmtEZWxldGVkKHRhcmdldElkLCBsZW5ndGgpXG4gICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgY2FsbFR5cGUgPSBmYWxzZVxuICAgICAgICB2YXIgdGFyZ2V0ID0geWllbGQqIHRoaXMub3MuZmluZFdpdGhVcHBlckJvdW5kKFt0YXJnZXRJZFswXSwgdGFyZ2V0SWRbMV0gKyBsZW5ndGggLSAxXSlcbiAgICAgICAgdmFyIHRhcmdldExlbmd0aCA9IHRhcmdldCAhPSBudWxsICYmIHRhcmdldC5jb250ZW50ICE9IG51bGwgPyB0YXJnZXQuY29udGVudC5sZW5ndGggOiAxXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCB8fCB0YXJnZXQuaWRbMF0gIT09IHRhcmdldElkWzBdIHx8IHRhcmdldC5pZFsxXSArIHRhcmdldExlbmd0aCA8PSB0YXJnZXRJZFsxXSkge1xuICAgICAgICAgIC8vIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBpbiB0aGUgcmFuZ2Ugb2YgdGhlIGRlbGV0aW9uXG4gICAgICAgICAgdGFyZ2V0ID0gbnVsbFxuICAgICAgICAgIGxlbmd0aCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkb2VzIGV4aXN0LCBjaGVjayBpZiBpdCBpcyB0b28gbG9uZ1xuICAgICAgICAgIGlmICghdGFyZ2V0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWRbMV0gPCB0YXJnZXRJZFsxXSkge1xuICAgICAgICAgICAgICAvLyBzdGFydHMgdG8gdGhlIGxlZnQgb2YgdGhlIGRlbGV0aW9uIHJhbmdlXG4gICAgICAgICAgICAgIHRhcmdldCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQodGFyZ2V0SWQpXG4gICAgICAgICAgICAgIHRhcmdldExlbmd0aCA9IHRhcmdldC5jb250ZW50Lmxlbmd0aCAvLyBtdXN0IGhhdmUgY29udGVudCBwcm9wZXJ0eSFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWRbMV0gKyB0YXJnZXRMZW5ndGggPiB0YXJnZXRJZFsxXSArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBlbmRzIHRvIHRoZSByaWdodCBvZiB0aGUgZGVsZXRpb24gcmFuZ2VcbiAgICAgICAgICAgICAgdGFyZ2V0ID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5FbmQoW3RhcmdldElkWzBdLCB0YXJnZXRJZFsxXSArIGxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgICB0YXJnZXRMZW5ndGggPSB0YXJnZXQuY29udGVudC5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gdGFyZ2V0LmlkWzFdIC0gdGFyZ2V0SWRbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICghdGFyZ2V0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGNhbGxUeXBlID0gdHJ1ZVxuICAgICAgICAgICAgLy8gc2V0IGRlbGV0ZWQgJiBub3RpZnkgdHlwZVxuICAgICAgICAgICAgdGFyZ2V0LmRlbGV0ZWQgPSB0cnVlXG4gICAgICAgICAgICAvLyBkZWxldGUgY29udGFpbmluZyBsaXN0c1xuICAgICAgICAgICAgaWYgKHRhcmdldC5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IGRvbid0IGRvIGl0IGxpa2UgdGhpcyAuLiAtLi1cbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZGVsZXRlTGlzdCh0YXJnZXQuc3RhcnQpXG4gICAgICAgICAgICAgIC8vIHlpZWxkKiB0aGlzLmRlbGV0ZUxpc3QodGFyZ2V0LmlkKSAtLSBkbyBub3QgZ2MgaXRzZWxmIGJlY2F1c2UgdGhpcyBtYXkgc3RpbGwgZ2V0IHJlZmVyZW5jZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQubWFwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQubWFwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZGVsZXRlTGlzdCh0YXJnZXQubWFwW25hbWVdKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRPRE86IGhlcmUgdG8uLiAgKHNlZSBhYm92ZSlcbiAgICAgICAgICAgICAgLy8geWllbGQqIHRoaXMuZGVsZXRlTGlzdCh0YXJnZXQuaWQpIC0tIHNlZSBhYm92ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24odGFyZ2V0Lm9wQ29udGVudClcbiAgICAgICAgICAgICAgLy8gdGFyZ2V0Lm9wQ29udGVudCA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQucmVxdWlyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5yZXF1aXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLmRlbGV0ZU9wZXJhdGlvbih0YXJnZXQucmVxdWlyZXNbaV0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlZnRcbiAgICAgICAgICBpZiAodGFyZ2V0LmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGVmdCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbih0YXJnZXQubGVmdClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzZXQgaGVyZSBiZWNhdXNlIGl0IHdhcyBkZWxldGVkIGFuZC9vciBnYydkXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKHRhcmdldClcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgICBDaGVjayBpZiBpdCBpcyBwb3NzaWJsZSB0byBhZGQgcmlnaHQgdG8gdGhlIGdjLlxuICAgICAgICAgICAgQmVjYXVzZSB0aGlzIGRlbGV0ZSBjYW4ndCBiZSByZXNwb25zaWJsZSBmb3IgbGVmdCBiZWluZyBnYydkLFxuICAgICAgICAgICAgd2UgZG9uJ3QgaGF2ZSB0byBhZGQgbGVmdCB0byB0aGUgZ2MuLlxuICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHJpZ2h0XG4gICAgICAgICAgaWYgKHRhcmdldC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICByaWdodCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbih0YXJnZXQucmlnaHQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbFR5cGUgJiYgIXByZXZlbnRDYWxsVHlwZSkge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RvcmUub3BlcmF0aW9uQWRkZWQodGhpcywge1xuICAgICAgICAgICAgICBzdHJ1Y3Q6ICdEZWxldGUnLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5pZCxcbiAgICAgICAgICAgICAgbGVuZ3RoOiB0YXJnZXRMZW5ndGhcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5lZWQgdG8gZ2MgaW4gdGhlIGVuZCFcbiAgICAgICAgICB5aWVsZCogdGhpcy5zdG9yZS5hZGRUb0dhcmJhZ2VDb2xsZWN0b3IuY2FsbCh0aGlzLCB0YXJnZXQsIGxlZnQpXG4gICAgICAgICAgaWYgKHJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0b3JlLmFkZFRvR2FyYmFnZUNvbGxlY3Rvci5jYWxsKHRoaXMsIHJpZ2h0LCB0YXJnZXQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICBNYXJrIGFuIG9wZXJhdGlvbiBhcyBkZWxldGVkJmdjJ2RcbiAgICAqL1xuICAgICogbWFya0dhcmJhZ2VDb2xsZWN0ZWQgKGlkLCBsZW4pIHtcbiAgICAgIC8vIHRoaXMubWVtLnB1c2goW1wiZ2NcIiwgaWRdKTtcbiAgICAgIHRoaXMuc3RvcmUuYWRkVG9EZWJ1ZygneWllbGQqIHRoaXMubWFya0dhcmJhZ2VDb2xsZWN0ZWQoJywgaWQsICcsICcsIGxlbiwgJyknKVxuICAgICAgdmFyIG4gPSB5aWVsZCogdGhpcy5tYXJrRGVsZXRlZChpZCwgbGVuKVxuICAgICAgaWYgKG4uaWRbMV0gPCBpZFsxXSAmJiAhbi5nYykge1xuICAgICAgICAvLyB1bi1leHRlbmQgbGVmdFxuICAgICAgICB2YXIgbmV3bGVuID0gbi5sZW4gLSAoaWRbMV0gLSBuLmlkWzFdKVxuICAgICAgICBuLmxlbiAtPSBuZXdsZW5cbiAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pXG4gICAgICAgIG4gPSB7aWQ6IGlkLCBsZW46IG5ld2xlbiwgZ2M6IGZhbHNlfVxuICAgICAgICB5aWVsZCogdGhpcy5kcy5wdXQobilcbiAgICAgIH1cbiAgICAgIC8vIGdldCBwcmV2Jm5leHQgYmVmb3JlIGFkZGluZyBhIG5ldyBvcGVyYXRpb25cbiAgICAgIHZhciBwcmV2ID0geWllbGQqIHRoaXMuZHMuZmluZFByZXYoaWQpXG4gICAgICB2YXIgbmV4dCA9IHlpZWxkKiB0aGlzLmRzLmZpbmROZXh0KGlkKVxuXG4gICAgICBpZiAoaWRbMV0gKyBsZW4gPCBuLmlkWzFdICsgbi5sZW4gJiYgIW4uZ2MpIHtcbiAgICAgICAgLy8gdW4tZXh0ZW5kIHJpZ2h0XG4gICAgICAgIHlpZWxkKiB0aGlzLmRzLnB1dCh7aWQ6IFtpZFswXSwgaWRbMV0gKyBsZW5dLCBsZW46IG4ubGVuIC0gbGVuLCBnYzogZmFsc2V9KVxuICAgICAgICBuLmxlbiA9IGxlblxuICAgICAgfVxuICAgICAgLy8gc2V0IGdjJ2RcbiAgICAgIG4uZ2MgPSB0cnVlXG4gICAgICAvLyBjYW4gZXh0ZW5kIGxlZnQ/XG4gICAgICBpZiAoXG4gICAgICAgIHByZXYgIT0gbnVsbCAmJlxuICAgICAgICBwcmV2LmdjICYmXG4gICAgICAgIFkudXRpbHMuY29tcGFyZUlkcyhbcHJldi5pZFswXSwgcHJldi5pZFsxXSArIHByZXYubGVuXSwgbi5pZClcbiAgICAgICkge1xuICAgICAgICBwcmV2LmxlbiArPSBuLmxlblxuICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobi5pZClcbiAgICAgICAgbiA9IHByZXZcbiAgICAgICAgLy8gZHMucHV0IG4gaGVyZT9cbiAgICAgIH1cbiAgICAgIC8vIGNhbiBleHRlbmQgcmlnaHQ/XG4gICAgICBpZiAoXG4gICAgICAgIG5leHQgIT0gbnVsbCAmJlxuICAgICAgICBuZXh0LmdjICYmXG4gICAgICAgIFkudXRpbHMuY29tcGFyZUlkcyhbbi5pZFswXSwgbi5pZFsxXSArIG4ubGVuXSwgbmV4dC5pZClcbiAgICAgICkge1xuICAgICAgICBuLmxlbiArPSBuZXh0LmxlblxuICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobmV4dC5pZClcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLmRzLnB1dChuKVxuICAgICAgeWllbGQqIHRoaXMudXBkYXRlU3RhdGUobi5pZFswXSlcbiAgICB9XG4gICAgLypcbiAgICAgIE1hcmsgYW4gb3BlcmF0aW9uIGFzIGRlbGV0ZWQuXG5cbiAgICAgIHJldHVybnMgdGhlIGRlbGV0ZSBub2RlXG4gICAgKi9cbiAgICAqIG1hcmtEZWxldGVkIChpZCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgfVxuICAgICAgLy8gdGhpcy5tZW0ucHVzaChbXCJkZWxcIiwgaWRdKTtcbiAgICAgIHZhciBuID0geWllbGQqIHRoaXMuZHMuZmluZFdpdGhVcHBlckJvdW5kKGlkKVxuICAgICAgaWYgKG4gIT0gbnVsbCAmJiBuLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICBpZiAobi5pZFsxXSA8PSBpZFsxXSAmJiBpZFsxXSA8PSBuLmlkWzFdICsgbi5sZW4pIHtcbiAgICAgICAgICAvLyBpZCBpcyBpbiBuJ3MgcmFuZ2VcbiAgICAgICAgICB2YXIgZGlmZiA9IGlkWzFdICsgbGVuZ3RoIC0gKG4uaWRbMV0gKyBuLmxlbikgLy8gb3ZlcmxhcHBpbmcgcmlnaHRcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIC8vIGlkK2xlbmd0aCBvdmVybGFwcyBuXG4gICAgICAgICAgICBpZiAoIW4uZ2MpIHtcbiAgICAgICAgICAgICAgbi5sZW4gKz0gZGlmZlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGlmZiA9IG4uaWRbMV0gKyBuLmxlbiAtIGlkWzFdIC8vIG92ZXJsYXBwaW5nIGxlZnQgKGlkIHRpbGwgbi5lbmQpXG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBwYXJ0aWFsIGRlbGV0aW9uXG4gICAgICAgICAgICAgICAgbiA9IHtpZDogW2lkWzBdLCBpZFsxXSArIGRpZmZdLCBsZW46IGxlbmd0aCAtIGRpZmYsIGdjOiBmYWxzZX1cbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kcy5wdXQobilcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGdjJ2RcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXBwZW4hIChpdCBkaXQgdGhvdWdoLi4gOigpJylcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIG92ZXJsYXBwaW5nLCBhbHJlYWR5IGRlbGV0ZWRcbiAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbm5vdCBleHRlbmQgbGVmdCAodGhlcmUgaXMgbm8gbGVmdCEpXG4gICAgICAgICAgbiA9IHtpZDogaWQsIGxlbjogbGVuZ3RoLCBnYzogZmFsc2V9XG4gICAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pIC8vIFRPRE86IHlvdSBkb3VibGUtcHV0ICEhXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhbm5vdCBleHRlbmQgbGVmdFxuICAgICAgICBuID0ge2lkOiBpZCwgbGVuOiBsZW5ndGgsIGdjOiBmYWxzZX1cbiAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pXG4gICAgICB9XG4gICAgICAvLyBjYW4gZXh0ZW5kIHJpZ2h0P1xuICAgICAgdmFyIG5leHQgPSB5aWVsZCogdGhpcy5kcy5maW5kTmV4dChuLmlkKVxuICAgICAgaWYgKFxuICAgICAgICBuZXh0ICE9IG51bGwgJiZcbiAgICAgICAgbi5pZFswXSA9PT0gbmV4dC5pZFswXSAmJlxuICAgICAgICBuLmlkWzFdICsgbi5sZW4gPj0gbmV4dC5pZFsxXVxuICAgICAgKSB7XG4gICAgICAgIGRpZmYgPSBuLmlkWzFdICsgbi5sZW4gLSBuZXh0LmlkWzFdIC8vIGZyb20gbmV4dC5zdGFydCB0byBuLmVuZFxuICAgICAgICB3aGlsZSAoZGlmZiA+PSAwKSB7XG4gICAgICAgICAgLy8gbiBvdmVybGFwcyB3aXRoIG5leHRcbiAgICAgICAgICBpZiAobmV4dC5nYykge1xuICAgICAgICAgICAgLy8gZ2MgaXMgc3Ryb25nZXIsIHNvIHJlZHVjZSBsZW5ndGggb2YgblxuICAgICAgICAgICAgbi5sZW4gLT0gZGlmZlxuICAgICAgICAgICAgaWYgKGRpZmYgPj0gbmV4dC5sZW4pIHtcbiAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBtaXNzaW5nIHJhbmdlIGFmdGVyIG5leHRcbiAgICAgICAgICAgICAgZGlmZiA9IGRpZmYgLSBuZXh0LmxlbiAvLyBtaXNzaW5nIHJhbmdlIGFmdGVyIG5leHRcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZHMucHV0KG4pIC8vIHVubmVjY2Vzc2FyeT8gVE9ETyFcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5tYXJrRGVsZXRlZChbbmV4dC5pZFswXSwgbmV4dC5pZFsxXSArIG5leHQubGVuXSwgZGlmZilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgY2FuIGV4dGVuZCBuIHdpdGggbmV4dFxuICAgICAgICAgICAgaWYgKGRpZmYgPiBuZXh0Lmxlbikge1xuICAgICAgICAgICAgICAvLyBuIGlzIGV2ZW4gbG9uZ2VyIHRoYW4gbmV4dFxuICAgICAgICAgICAgICAvLyBnZXQgbmV4dC5uZXh0LCBhbmQgdHJ5IHRvIGV4dGVuZCBpdFxuICAgICAgICAgICAgICB2YXIgX25leHQgPSB5aWVsZCogdGhpcy5kcy5maW5kTmV4dChuZXh0LmlkKVxuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobmV4dC5pZClcbiAgICAgICAgICAgICAgaWYgKF9uZXh0ID09IG51bGwgfHwgbi5pZFswXSAhPT0gX25leHQuaWRbMF0pIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQgPSBfbmV4dFxuICAgICAgICAgICAgICAgIGRpZmYgPSBuLmlkWzFdICsgbi5sZW4gLSBuZXh0LmlkWzFdIC8vIGZyb20gbmV4dC5zdGFydCB0byBuLmVuZFxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBuIGp1c3QgcGFydGlhbGx5IG92ZXJsYXBzIHdpdGggbmV4dC4gZXh0ZW5kIG4sIGRlbGV0ZSBuZXh0LCBhbmQgYnJlYWsgdGhpcyBsb29wXG4gICAgICAgICAgICAgIG4ubGVuICs9IG5leHQubGVuIC0gZGlmZlxuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kcy5kZWxldGUobmV4dC5pZClcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLmRzLnB1dChuKVxuICAgICAgcmV0dXJuIG5cbiAgICB9XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyBtZXRob2Qgd2hlbiB0aGUgY2xpZW50IGlzIGNvbm5lY3RlZCZzeW5jZWQgd2l0aCB0aGVcbiAgICAgIG90aGVyIGNsaWVudHMgKGUuZy4gbWFzdGVyKS4gVGhpcyB3aWxsIHF1ZXJ5IHRoZSBkYXRhYmFzZSBmb3JcbiAgICAgIG9wZXJhdGlvbnMgdGhhdCBjYW4gYmUgZ2MnZCBhbmQgYWRkIHRoZW0gdG8gdGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICAgICovXG4gICAgKiBnYXJiYWdlQ29sbGVjdEFmdGVyU3luYyAoKSB7XG4gICAgICBpZiAodGhpcy5zdG9yZS5nYzEubGVuZ3RoID4gMCB8fCB0aGlzLnN0b3JlLmdjMi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZ2Mgc2hvdWxkIGJlIGVtcHR5IGFmdGVyIHN5bmMnKVxuICAgICAgfVxuICAgICAgeWllbGQqIHRoaXMub3MuaXRlcmF0ZSh0aGlzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAqIChvcCkge1xuICAgICAgICBpZiAob3AuZ2MpIHtcbiAgICAgICAgICBkZWxldGUgb3AuZ2NcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ob3ApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBhcmVudERlbGV0ZWQgPSB5aWVsZCogdGhpcy5pc0RlbGV0ZWQob3AucGFyZW50KVxuICAgICAgICAgIGlmIChwYXJlbnREZWxldGVkKSB7XG4gICAgICAgICAgICBvcC5nYyA9IHRydWVcbiAgICAgICAgICAgIGlmICghb3AuZGVsZXRlZCkge1xuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5tYXJrRGVsZXRlZChvcC5pZCwgb3AuY29udGVudCAhPSBudWxsID8gb3AuY29udGVudC5sZW5ndGggOiAxKVxuICAgICAgICAgICAgICBvcC5kZWxldGVkID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAob3Aub3BDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24ob3Aub3BDb250ZW50KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcC5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5yZXF1aXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuZGVsZXRlT3BlcmF0aW9uKG9wLnJlcXVpcmVzW2ldKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgICAgICAgdGhpcy5zdG9yZS5nYzEucHVzaChvcC5pZCkgLy8gdGhpcyBpcyBvayBiZWNhdWVzIGl0cyBzaG9ydGx5IGJlZm9yZSBzeW5jIChvdGhlcndpc2UgdXNlIHF1ZXVlR2FyYmFnZUNvbGxlY3RvciEpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLmRlbGV0ZWQpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IG51bGxcbiAgICAgICAgICBpZiAob3AubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZWZ0ID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG9wLmxlZnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkKiB0aGlzLnN0b3JlLmFkZFRvR2FyYmFnZUNvbGxlY3Rvci5jYWxsKHRoaXMsIG9wLCBsZWZ0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICAvKlxuICAgICAgUmVhbGx5IHJlbW92ZSBhbiBvcCBhbmQgYWxsIGl0cyBlZmZlY3RzLlxuICAgICAgVGhlIGNvbXBsaWNhdGVkIGNhc2UgaGVyZSBpcyB0aGUgSW5zZXJ0IG9wZXJhdGlvbjpcbiAgICAgICogcmVzZXQgbGVmdFxuICAgICAgKiByZXNldCByaWdodFxuICAgICAgKiByZXNldCBwYXJlbnQuc3RhcnRcbiAgICAgICogcmVzZXQgcGFyZW50LmVuZFxuICAgICAgKiByZXNldCBvcmlnaW5zIG9mIGFsbCByaWdodCBvcHNcbiAgICAqL1xuICAgICogZ2FyYmFnZUNvbGxlY3RPcGVyYXRpb24gKGlkKSB7XG4gICAgICB0aGlzLnN0b3JlLmFkZFRvRGVidWcoJ3lpZWxkKiB0aGlzLmdhcmJhZ2VDb2xsZWN0T3BlcmF0aW9uKCcsIGlkLCAnKScpXG4gICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihpZClcbiAgICAgIHlpZWxkKiB0aGlzLm1hcmtHYXJiYWdlQ29sbGVjdGVkKGlkLCAobyAhPSBudWxsICYmIG8uY29udGVudCAhPSBudWxsKSA/IG8uY29udGVudC5sZW5ndGggOiAxKSAvLyBhbHdheXMgbWFyayBnYydkXG4gICAgICAvLyBpZiBvcCBleGlzdHMsIHRoZW4gY2xlYW4gdGhhdCBtZXNzIHVwLi5cbiAgICAgIGlmIChvICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlcHMgPSBbXVxuICAgICAgICBpZiAoby5vcENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGRlcHMucHVzaChvLm9wQ29udGVudClcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5yZXF1aXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZGVwcyA9IGRlcHMuY29uY2F0KG8ucmVxdWlyZXMpXG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRlcCA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihkZXBzW2ldKVxuICAgICAgICAgIGlmIChkZXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFkZXAuZGVsZXRlZCkge1xuICAgICAgICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24oZGVwLmlkKVxuICAgICAgICAgICAgICBkZXAgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oZGVwLmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVwLmdjID0gdHJ1ZVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGRlcClcbiAgICAgICAgICAgIHRoaXMuc3RvcmUucXVldWVHYXJiYWdlQ29sbGVjdG9yKGRlcC5pZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMubWFya0dhcmJhZ2VDb2xsZWN0ZWQoZGVwc1tpXSwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZ2MnZCBvcCBmcm9tIHRoZSBsZWZ0IG9wLCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKG8ubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGxlZnQgPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24oby5sZWZ0KVxuICAgICAgICAgIGxlZnQucmlnaHQgPSBvLnJpZ2h0XG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGxlZnQpXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGdjJ2Qgb3AgZnJvbSB0aGUgcmlnaHQgb3AsIGlmIGl0IGV4aXN0c1xuICAgICAgICAvLyBhbHNvIHJlc2V0IG9yaWdpbnMgb2YgcmlnaHQgb3BzXG4gICAgICAgIGlmIChvLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmlnaHQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5yaWdodClcbiAgICAgICAgICByaWdodC5sZWZ0ID0gby5sZWZ0XG5cbiAgICAgICAgICBpZiAoby5vcmlnaW5PZiAhPSBudWxsICYmIG8ub3JpZ2luT2YubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gZmluZCBuZXcgb3JpZ2luIG9mIHJpZ2h0IG9wc1xuICAgICAgICAgICAgLy8gb3JpZ2luIGlzIHRoZSBmaXJzdCBsZWZ0IGRlbGV0ZWQgb3BlcmF0aW9uXG4gICAgICAgICAgICB2YXIgbmV3b3JpZ2luID0gby5sZWZ0XG4gICAgICAgICAgICB2YXIgbmV3b3JpZ2luXyA9IG51bGxcbiAgICAgICAgICAgIHdoaWxlIChuZXdvcmlnaW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdvcmlnaW5fID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKG5ld29yaWdpbilcbiAgICAgICAgICAgICAgaWYgKG5ld29yaWdpbl8uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV3b3JpZ2luID0gbmV3b3JpZ2luXy5sZWZ0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IG9yaWdpbiBvZiBhbGwgcmlnaHQgb3BzIChleGNlcHQgZmlyc3QgcmlnaHQgLSBkdWghKSxcblxuICAgICAgICAgICAgLyogKiogVGhlIGZvbGxvd2luZyBjb2RlIGRvZXMgbm90IHJlbHkgb24gdGhlIHRoZSBvcmlnaW5PZiBwcm9wZXJ0eSAqKlxuICAgICAgICAgICAgICAgICAgSSByZWNlbnRseSBhZGRlZCBvcmlnaW5PZiB0byBhbGwgSW5zZXJ0IE9wZXJhdGlvbnMgKHNlZSBTdHJ1Y3QuSW5zZXJ0LmV4ZWN1dGUpLFxuICAgICAgICAgICAgICAgICAgd2hpY2ggc2F2ZXMgd2hpY2ggb3BlcmF0aW9ucyBvcmlnaW5hdGUgaW4gYSBJbnNlcnQgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgR2FyYmFnZSBjb2xsZWN0aW5nIHdpdGhvdXQgb3JpZ2luT2YgaXMgbW9yZSBtZW1vcnkgZWZmaWNpZW50LCBidXQgaXMgbmVhcmx5IGltcG9zc2libGUgZm9yIGxhcmdlIHRleHRzLCBvciBsaXN0cyFcbiAgICAgICAgICAgICAgICAgIEJ1dCBJIGtlZXAgdGhpcyBjb2RlIGZvciBub3dcbiAgICAgICAgICAgIGBgYFxuICAgICAgICAgICAgLy8gcmVzZXQgb3JpZ2luIG9mIHJpZ2h0XG4gICAgICAgICAgICByaWdodC5vcmlnaW4gPSBuZXdvcmlnaW5cbiAgICAgICAgICAgIC8vIHNlYXJjaCB1bnRpbCB5b3UgZmluZCBvcmlnaW4gcG9pbnRlciB0byB0aGUgbGVmdCBvZiBvXG4gICAgICAgICAgICBpZiAocmlnaHQucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihyaWdodC5yaWdodClcbiAgICAgICAgICAgICAgdmFyIGlkcyA9IFtvLmlkLCBvLnJpZ2h0XVxuICAgICAgICAgICAgICB3aGlsZSAoaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFkudXRpbHMuY29tcGFyZUlkcyhpZCwgaS5vcmlnaW4pXG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyhpLm9yaWdpbiwgby5pZCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IG9yaWdpbiBvZiBpXG4gICAgICAgICAgICAgICAgICBpLm9yaWdpbiA9IG5ld29yaWdpblxuICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldCBuZXh0IGlcbiAgICAgICAgICAgICAgICBpZiAoaS5yaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZHMucHVzaChpLmlkKVxuICAgICAgICAgICAgICAgICAgaSA9IHlpZWxkKiB0aGlzLmdldE9wZXJhdGlvbihpLnJpZ2h0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYGBgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gKiogTm93IHRoZSBuZXcgaW1wbGVtZW50YXRpb24gc3RhcnRzICoqXG4gICAgICAgICAgICAvLyByZXNldCBuZXdvcmlnaW4gb2YgYWxsIG9yaWdpbk9mWypdXG4gICAgICAgICAgICBmb3IgKHZhciBfaSBpbiBvLm9yaWdpbk9mKSB7XG4gICAgICAgICAgICAgIHZhciBvcmlnaW5zSW4gPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5vcmlnaW5PZltfaV0pXG4gICAgICAgICAgICAgIGlmIChvcmlnaW5zSW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbnNJbi5vcmlnaW4gPSBuZXdvcmlnaW5cbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ob3JpZ2luc0luKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3b3JpZ2luICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld29yaWdpbl8ub3JpZ2luT2YgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld29yaWdpbl8ub3JpZ2luT2YgPSBvLm9yaWdpbk9mXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3b3JpZ2luXy5vcmlnaW5PZiA9IG8ub3JpZ2luT2YuY29uY2F0KG5ld29yaWdpbl8ub3JpZ2luT2YpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG5ld29yaWdpbl8pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHNldCByaWdodCBoZXJlLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyByaWdodCBzaG91bGQgYmUgaW4gby5vcmlnaW5PZiA9PiBpdCBpcyBzZXQgaXQgdGhlIHByZXZpb3VzIGZvciBsb29wXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIGRpZG4ndCBuZWVkIHRvIHJlc2V0IHRoZSBvcmlnaW4gb2YgcmlnaHRcbiAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gc2V0IHJpZ2h0IGhlcmVcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihyaWdodClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbyBtYXkgb3JpZ2luYXRlIGluIGFub3RoZXIgb3BlcmF0aW9uLlxuICAgICAgICAvLyBTaW5jZSBvIGlzIGRlbGV0ZWQsIHdlIGhhdmUgdG8gcmVzZXQgby5vcmlnaW4ncyBgb3JpZ2luT2ZgIHByb3BlcnR5XG4gICAgICAgIGlmIChvLm9yaWdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihvLm9yaWdpbilcbiAgICAgICAgICBvcmlnaW4ub3JpZ2luT2YgPSBvcmlnaW4ub3JpZ2luT2YuZmlsdGVyKGZ1bmN0aW9uIChfaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAhWS51dGlscy5jb21wYXJlSWRzKGlkLCBfaWQpXG4gICAgICAgICAgfSlcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24ob3JpZ2luKVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRcbiAgICAgICAgaWYgKG8ucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBwYXJlbnQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5wYXJlbnQpXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGdjJ2Qgb3AgZnJvbSBwYXJlbnQsIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgc2V0UGFyZW50ID0gZmFsc2UgLy8gd2hldGhlciB0byBzYXZlIHBhcmVudCB0byB0aGUgb3NcbiAgICAgICAgICBpZiAoby5wYXJlbnRTdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyhwYXJlbnQubWFwW28ucGFyZW50U3ViXSwgby5pZCkpIHtcbiAgICAgICAgICAgICAgc2V0UGFyZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoby5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lm1hcFtvLnBhcmVudFN1Yl0gPSBvLnJpZ2h0XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudC5tYXBbby5wYXJlbnRTdWJdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFkudXRpbHMuY29tcGFyZUlkcyhwYXJlbnQuc3RhcnQsIG8uaWQpKSB7XG4gICAgICAgICAgICAgIC8vIGdjJ2Qgb3AgaXMgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgIHNldFBhcmVudCA9IHRydWVcbiAgICAgICAgICAgICAgcGFyZW50LnN0YXJ0ID0gby5yaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFkudXRpbHMubWF0Y2hlc0lkKG8sIHBhcmVudC5lbmQpKSB7XG4gICAgICAgICAgICAgIC8vIGdjJ2Qgb3AgaXMgdGhlIGVuZFxuICAgICAgICAgICAgICBzZXRQYXJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgIHBhcmVudC5lbmQgPSBvLmxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNldFBhcmVudCkge1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKHBhcmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluYWxseSByZW1vdmUgaXQgZnJvbSB0aGUgb3NcbiAgICAgICAgeWllbGQqIHRoaXMucmVtb3ZlT3BlcmF0aW9uKG8uaWQpXG4gICAgICB9XG4gICAgfVxuICAgICogY2hlY2tEZWxldGVTdG9yZUZvclN0YXRlIChzdGF0ZSkge1xuICAgICAgdmFyIG4gPSB5aWVsZCogdGhpcy5kcy5maW5kV2l0aFVwcGVyQm91bmQoW3N0YXRlLnVzZXIsIHN0YXRlLmNsb2NrXSlcbiAgICAgIGlmIChuICE9IG51bGwgJiYgbi5pZFswXSA9PT0gc3RhdGUudXNlciAmJiBuLmdjKSB7XG4gICAgICAgIHN0YXRlLmNsb2NrID0gTWF0aC5tYXgoc3RhdGUuY2xvY2ssIG4uaWRbMV0gKyBuLmxlbilcbiAgICAgIH1cbiAgICB9XG4gICAgKiB1cGRhdGVTdGF0ZSAodXNlcikge1xuICAgICAgdmFyIHN0YXRlID0geWllbGQqIHRoaXMuZ2V0U3RhdGUodXNlcilcbiAgICAgIHlpZWxkKiB0aGlzLmNoZWNrRGVsZXRlU3RvcmVGb3JTdGF0ZShzdGF0ZSlcbiAgICAgIHZhciBvID0geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uKFt1c2VyLCBzdGF0ZS5jbG9ja10pXG4gICAgICB2YXIgb0xlbmd0aCA9IChvICE9IG51bGwgJiYgby5jb250ZW50ICE9IG51bGwpID8gby5jb250ZW50Lmxlbmd0aCA6IDFcbiAgICAgIHdoaWxlIChvICE9IG51bGwgJiYgdXNlciA9PT0gby5pZFswXSAmJiBvLmlkWzFdIDw9IHN0YXRlLmNsb2NrICYmIG8uaWRbMV0gKyBvTGVuZ3RoID4gc3RhdGUuY2xvY2spIHtcbiAgICAgICAgLy8gZWl0aGVyIGl0cyBhIG5ldyBvcGVyYXRpb24gKDEuIGNhc2UpLCBvciBpdCBpcyBhbiBvcGVyYXRpb24gdGhhdCB3YXMgZGVsZXRlZCwgYnV0IGlzIG5vdCB5ZXQgaW4gdGhlIE9TXG4gICAgICAgIHN0YXRlLmNsb2NrICs9IG9MZW5ndGhcbiAgICAgICAgeWllbGQqIHRoaXMuY2hlY2tEZWxldGVTdG9yZUZvclN0YXRlKHN0YXRlKVxuICAgICAgICBvID0geWllbGQqIHRoaXMub3MuZmluZE5leHQoby5pZClcbiAgICAgICAgb0xlbmd0aCA9IChvICE9IG51bGwgJiYgby5jb250ZW50ICE9IG51bGwpID8gby5jb250ZW50Lmxlbmd0aCA6IDFcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLnNldFN0YXRlKHN0YXRlKVxuICAgIH1cbiAgICAvKlxuICAgICAgYXBwbHkgYSBkZWxldGUgc2V0IGluIG9yZGVyIHRvIGdldFxuICAgICAgdGhlIHN0YXRlIG9mIHRoZSBzdXBwbGllZCBkc1xuICAgICovXG4gICAgKiBhcHBseURlbGV0ZVNldCAoZHMpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBbXVxuXG4gICAgICBmb3IgKHZhciB1c2VyIGluIGRzKSB7XG4gICAgICAgIHZhciBkdiA9IGRzW3VzZXJdXG4gICAgICAgIHZhciBwb3MgPSAwXG4gICAgICAgIHZhciBkID0gZHZbcG9zXVxuICAgICAgICB5aWVsZCogdGhpcy5kcy5pdGVyYXRlKHRoaXMsIFt1c2VyLCAwXSwgW3VzZXIsIE51bWJlci5NQVhfVkFMVUVdLCBmdW5jdGlvbiAqIChuKSB7XG4gICAgICAgICAgLy8gY2FzZXM6XG4gICAgICAgICAgLy8gMS4gZCBkZWxldGVzIHNvbWV0aGluZyB0byB0aGUgcmlnaHQgb2YgblxuICAgICAgICAgIC8vICA9PiBnbyB0byBuZXh0IG4gKGJyZWFrKVxuICAgICAgICAgIC8vIDIuIGQgZGVsZXRlcyBzb21ldGhpbmcgdG8gdGhlIGxlZnQgb2YgblxuICAgICAgICAgIC8vICA9PiBjcmVhdGUgZGVsZXRpb25zXG4gICAgICAgICAgLy8gID0+IHJlc2V0IGQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmUsIGdvIHRvIG5leHQgZCAoY29udGludWUpXG4gICAgICAgICAgLy8gMy4gbm90IDIpIGFuZCBkIGRlbGV0ZXMgc29tZXRoaW5nIHRoYXQgYWxzbyBuIGRlbGV0ZXNcbiAgICAgICAgICAvLyAgPT4gcmVzZXQgZCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29udGFpbiBuJ3MgZGVsZXRpb25cbiAgICAgICAgICAvLyAgKik9PiBpZiBkIGRvZXMgbm90IGRlbGV0ZSBhbnl0aGluZyBhbnltb3JlLCBnbyB0byBuZXh0IGQgKGNvbnRpbnVlKVxuICAgICAgICAgIHdoaWxlIChkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gMCAvLyBkZXNjcmliZSB0aGUgZGlmZiBvZiBsZW5ndGggaW4gMSkgYW5kIDIpXG4gICAgICAgICAgICBpZiAobi5pZFsxXSArIG4ubGVuIDw9IGRbMF0pIHtcbiAgICAgICAgICAgICAgLy8gMSlcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZFswXSA8IG4uaWRbMV0pIHtcbiAgICAgICAgICAgICAgLy8gMilcbiAgICAgICAgICAgICAgLy8gZGVsZXRlIG1heGltdW0gdGhlIGxlbiBvZiBkXG4gICAgICAgICAgICAgIC8vIGVsc2UgZGVsZXRlIGFzIG11Y2ggYXMgcG9zc2libGVcbiAgICAgICAgICAgICAgZGlmZiA9IE1hdGgubWluKG4uaWRbMV0gLSBkWzBdLCBkWzFdKVxuICAgICAgICAgICAgICBkZWxldGlvbnMucHVzaChbdXNlciwgZFswXSwgZGlmZiwgZFsyXV0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyAzKVxuICAgICAgICAgICAgICBkaWZmID0gbi5pZFsxXSArIG4ubGVuIC0gZFswXSAvLyBuZXZlciBudWxsIChzZWUgMSlcbiAgICAgICAgICAgICAgaWYgKGRbMl0gJiYgIW4uZ2MpIHtcbiAgICAgICAgICAgICAgICAvLyBkIG1hcmtzIGFzIGdjJ2QgYnV0IG4gZG9lcyBub3RcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGRlbGV0ZSBlaXRoZXIgd2F5XG4gICAgICAgICAgICAgICAgZGVsZXRpb25zLnB1c2goW3VzZXIsIGRbMF0sIE1hdGgubWluKGRpZmYsIGRbMV0pLCBkWzJdXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbMV0gPD0gZGlmZikge1xuICAgICAgICAgICAgICAvLyBkIGRvZXNuJ3QgZGVsZXRlIGFueXRoaW5nIGFueW1vcmVcbiAgICAgICAgICAgICAgZCA9IGR2WysrcG9zXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZFswXSA9IGRbMF0gKyBkaWZmIC8vIHJlc2V0IHBvc1xuICAgICAgICAgICAgICBkWzFdID0gZFsxXSAtIGRpZmYgLy8gcmVzZXQgbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAvLyBmb3IgdGhlIHJlc3QuLiBqdXN0IGFwcGx5IGl0XG4gICAgICAgIGZvciAoOyBwb3MgPCBkdi5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgZCA9IGR2W3Bvc11cbiAgICAgICAgICBkZWxldGlvbnMucHVzaChbdXNlciwgZFswXSwgZFsxXSwgZFsyXV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZWwgPSBkZWxldGlvbnNbaV1cbiAgICAgICAgLy8gYWx3YXlzIHRyeSB0byBkZWxldGUuLlxuICAgICAgICB5aWVsZCogdGhpcy5kZWxldGVPcGVyYXRpb24oW2RlbFswXSwgZGVsWzFdXSwgZGVsWzJdKVxuICAgICAgICBpZiAoZGVsWzNdKSB7XG4gICAgICAgICAgLy8gZ2MuLlxuICAgICAgICAgIHlpZWxkKiB0aGlzLm1hcmtHYXJiYWdlQ29sbGVjdGVkKFtkZWxbMF0sIGRlbFsxXV0sIGRlbFsyXSkgLy8gYWx3YXlzIG1hcmsgZ2MnZFxuICAgICAgICAgIC8vIHJlbW92ZSBvcGVyYXRpb24uLlxuICAgICAgICAgIHZhciBjb3VudGVyID0gZGVsWzFdICsgZGVsWzJdXG4gICAgICAgICAgd2hpbGUgKGNvdW50ZXIgPj0gZGVsWzFdKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLm9zLmZpbmRXaXRoVXBwZXJCb3VuZChbZGVsWzBdLCBjb3VudGVyIC0gMV0pXG4gICAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb0xlbiA9IG8uY29udGVudCAhPSBudWxsID8gby5jb250ZW50Lmxlbmd0aCA6IDFcbiAgICAgICAgICAgIGlmIChvLmlkWzBdICE9PSBkZWxbMF0gfHwgby5pZFsxXSArIG9MZW4gPD0gZGVsWzFdKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBpbiByYW5nZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG8uaWRbMV0gKyBvTGVuID4gZGVsWzFdICsgZGVsWzJdKSB7XG4gICAgICAgICAgICAgIC8vIG92ZXJsYXBzIHJpZ2h0XG4gICAgICAgICAgICAgIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb25DbGVhbkVuZChbZGVsWzBdLCBkZWxbMV0gKyBkZWxbMl0gLSAxXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvLmlkWzFdIDwgZGVsWzFdKSB7XG4gICAgICAgICAgICAgIC8vIG92ZXJsYXBzIGxlZnRcbiAgICAgICAgICAgICAgbyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQoW2RlbFswXSwgZGVsWzFdXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIgPSBvLmlkWzFdXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5nYXJiYWdlQ29sbGVjdE9wZXJhdGlvbihvLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdG9yZS5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgb3BzID0gW11cbiAgICAgICAgICBvcHMucHVzaCh7c3RydWN0OiAnRGVsZXRlJywgdGFyZ2V0OiBbZFswXSwgZFsxXV0sIGxlbmd0aDogZGVsWzJdfSlcbiAgICAgICAgICB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmJyb2FkY2FzdE9wcyhvcHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgKiBpc0dhcmJhZ2VDb2xsZWN0ZWQgKGlkKSB7XG4gICAgICB2YXIgbiA9IHlpZWxkKiB0aGlzLmRzLmZpbmRXaXRoVXBwZXJCb3VuZChpZClcbiAgICAgIHJldHVybiBuICE9IG51bGwgJiYgbi5pZFswXSA9PT0gaWRbMF0gJiYgaWRbMV0gPCBuLmlkWzFdICsgbi5sZW4gJiYgbi5nY1xuICAgIH1cbiAgICAvKlxuICAgICAgQSBEZWxldGVTZXQgKGRzKSBkZXNjcmliZXMgYWxsIHRoZSBkZWxldGVkIG9wcyBpbiB0aGUgT1NcbiAgICAqL1xuICAgICogZ2V0RGVsZXRlU2V0ICgpIHtcbiAgICAgIHZhciBkcyA9IHt9XG4gICAgICB5aWVsZCogdGhpcy5kcy5pdGVyYXRlKHRoaXMsIG51bGwsIG51bGwsIGZ1bmN0aW9uICogKG4pIHtcbiAgICAgICAgdmFyIHVzZXIgPSBuLmlkWzBdXG4gICAgICAgIHZhciBjb3VudGVyID0gbi5pZFsxXVxuICAgICAgICB2YXIgbGVuID0gbi5sZW5cbiAgICAgICAgdmFyIGdjID0gbi5nY1xuICAgICAgICB2YXIgZHYgPSBkc1t1c2VyXVxuICAgICAgICBpZiAoZHYgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGR2ID0gW11cbiAgICAgICAgICBkc1t1c2VyXSA9IGR2XG4gICAgICAgIH1cbiAgICAgICAgZHYucHVzaChbY291bnRlciwgbGVuLCBnY10pXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGRzXG4gICAgfVxuICAgICogaXNEZWxldGVkIChpZCkge1xuICAgICAgdmFyIG4gPSB5aWVsZCogdGhpcy5kcy5maW5kV2l0aFVwcGVyQm91bmQoaWQpXG4gICAgICByZXR1cm4gbiAhPSBudWxsICYmIG4uaWRbMF0gPT09IGlkWzBdICYmIGlkWzFdIDwgbi5pZFsxXSArIG4ubGVuXG4gICAgfVxuICAgICogc2V0T3BlcmF0aW9uIChvcCkge1xuICAgICAgeWllbGQqIHRoaXMub3MucHV0KG9wKVxuICAgICAgcmV0dXJuIG9wXG4gICAgfVxuICAgICogYWRkT3BlcmF0aW9uIChvcCkge1xuICAgICAgeWllbGQqIHRoaXMub3MucHV0KG9wKVxuICAgICAgaWYgKCF0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmlzRGlzY29ubmVjdGVkKCkgJiYgdGhpcy5zdG9yZS5mb3J3YXJkQXBwbGllZE9wZXJhdGlvbnMgJiYgdHlwZW9mIG9wLmlkWzFdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBpcyBjb25uZWN0ZWQsIGFuZCB0aGlzIGlzIG5vdCBnb2luZyB0byBiZSBzZW5kIGluIGFkZE9wZXJhdGlvblxuICAgICAgICB0aGlzLnN0b3JlLnkuY29ubmVjdG9yLmJyb2FkY2FzdE9wcyhbb3BdKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBpbnNlcnRpb24sIHRyeSB0byBjb21iaW5lIHdpdGggbGVmdCBpbnNlcnRpb24gKGlmIGJvdGggaGF2ZSBjb250ZW50IHByb3BlcnR5KVxuICAgICogdHJ5Q29tYmluZVdpdGhMZWZ0IChvcCkge1xuICAgICAgaWYgKFxuICAgICAgICBvcCAhPSBudWxsICYmXG4gICAgICAgIG9wLmxlZnQgIT0gbnVsbCAmJlxuICAgICAgICBvcC5jb250ZW50ICE9IG51bGwgJiZcbiAgICAgICAgb3AubGVmdFswXSA9PT0gb3AuaWRbMF0gJiZcbiAgICAgICAgWS51dGlscy5jb21wYXJlSWRzKG9wLmxlZnQsIG9wLm9yaWdpbilcbiAgICAgICkge1xuICAgICAgICB2YXIgbGVmdCA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihvcC5sZWZ0KVxuICAgICAgICBpZiAobGVmdC5jb250ZW50ICE9IG51bGwgJiZcbiAgICAgICAgICAgIGxlZnQuaWRbMV0gKyBsZWZ0LmNvbnRlbnQubGVuZ3RoID09PSBvcC5pZFsxXSAmJlxuICAgICAgICAgICAgbGVmdC5vcmlnaW5PZi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICFsZWZ0LmdjICYmICFsZWZ0LmRlbGV0ZWQgJiZcbiAgICAgICAgICAgICFvcC5nYyAmJiAhb3AuZGVsZXRlZFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBjb21iaW5lIVxuICAgICAgICAgIGlmIChvcC5vcmlnaW5PZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZWZ0Lm9yaWdpbk9mID0gb3Aub3JpZ2luT2ZcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGxlZnQub3JpZ2luT2ZcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVmdC5jb250ZW50ID0gbGVmdC5jb250ZW50LmNvbmNhdChvcC5jb250ZW50KVxuICAgICAgICAgIGxlZnQucmlnaHQgPSBvcC5yaWdodFxuICAgICAgICAgIHlpZWxkKiB0aGlzLm9zLmRlbGV0ZShvcC5pZClcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24obGVmdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAqIGdldEluc2VydGlvbiAoaWQpIHtcbiAgICAgIHZhciBpbnMgPSB5aWVsZCogdGhpcy5vcy5maW5kV2l0aFVwcGVyQm91bmQoaWQpXG4gICAgICBpZiAoaW5zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW4gPSBpbnMuY29udGVudCAhPSBudWxsID8gaW5zLmNvbnRlbnQubGVuZ3RoIDogMSAvLyBpbiBjYXNlIG9mIG9wQ29udGVudFxuICAgICAgICBpZiAoaWRbMF0gPT09IGlucy5pZFswXSAmJiBpZFsxXSA8IGlucy5pZFsxXSArIGxlbikge1xuICAgICAgICAgIHJldHVybiBpbnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICogZ2V0SW5zZXJ0aW9uQ2xlYW5TdGFydEVuZCAoaWQpIHtcbiAgICAgIHlpZWxkKiB0aGlzLmdldEluc2VydGlvbkNsZWFuU3RhcnQoaWQpXG4gICAgICByZXR1cm4geWllbGQqIHRoaXMuZ2V0SW5zZXJ0aW9uQ2xlYW5FbmQoaWQpXG4gICAgfVxuICAgIC8vIFJldHVybiBhbiBpbnNlcnRpb24gc3VjaCB0aGF0IGlkIGlzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGNvbnRlbnRcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIG1hbmlwdWxhdGVzIGFuIG9wZXJhdGlvbiwgaWYgbmVjZXNzYXJ5XG4gICAgKiBnZXRJbnNlcnRpb25DbGVhblN0YXJ0IChpZCkge1xuICAgICAgdmFyIGlucyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihpZClcbiAgICAgIGlmIChpbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5zLmlkWzFdID09PSBpZFsxXSkge1xuICAgICAgICAgIHJldHVybiBpbnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IFkudXRpbHMuY29weU9iamVjdChpbnMpXG4gICAgICAgICAgaW5zLmNvbnRlbnQgPSBsZWZ0LmNvbnRlbnQuc3BsaWNlKGlkWzFdIC0gaW5zLmlkWzFdKVxuICAgICAgICAgIGlucy5pZCA9IGlkXG4gICAgICAgICAgdmFyIGxlZnRMaWQgPSBZLnV0aWxzLmdldExhc3RJZChsZWZ0KVxuICAgICAgICAgIGlucy5vcmlnaW4gPSBsZWZ0TGlkXG4gICAgICAgICAgbGVmdC5vcmlnaW5PZiA9IFtpbnMuaWRdXG4gICAgICAgICAgbGVmdC5yaWdodCA9IGlucy5pZFxuICAgICAgICAgIGlucy5sZWZ0ID0gbGVmdExpZFxuICAgICAgICAgIC8vIGRlYnVnZ2VyIC8vIGNoZWNrXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGxlZnQpXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKGlucylcbiAgICAgICAgICBpZiAobGVmdC5nYykge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5xdWV1ZUdhcmJhZ2VDb2xsZWN0b3IoaW5zLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5zXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybiBhbiBpbnNlcnRpb24gc3VjaCB0aGF0IGlkIGlzIHRoZSBsYXN0IGVsZW1lbnQgb2YgY29udGVudFxuICAgIC8vIFRoaXMgZnVuY3Rpb24gbWFuaXB1bGF0ZXMgYW4gb3BlcmF0aW9uLCBpZiBuZWNlc3NhcnlcbiAgICAqIGdldEluc2VydGlvbkNsZWFuRW5kIChpZCkge1xuICAgICAgdmFyIGlucyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihpZClcbiAgICAgIGlmIChpbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5zLmNvbnRlbnQgPT0gbnVsbCB8fCAoaW5zLmlkWzFdICsgaW5zLmNvbnRlbnQubGVuZ3RoIC0gMSA9PT0gaWRbMV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGluc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByaWdodCA9IFkudXRpbHMuY29weU9iamVjdChpbnMpXG4gICAgICAgICAgcmlnaHQuY29udGVudCA9IGlucy5jb250ZW50LnNwbGljZShpZFsxXSAtIGlucy5pZFsxXSArIDEpIC8vIGN1dCBvZmYgcmVtYWluZGVyXG4gICAgICAgICAgcmlnaHQuaWQgPSBbaWRbMF0sIGlkWzFdICsgMV1cbiAgICAgICAgICB2YXIgaW5zTGlkID0gWS51dGlscy5nZXRMYXN0SWQoaW5zKVxuICAgICAgICAgIHJpZ2h0Lm9yaWdpbiA9IGluc0xpZFxuICAgICAgICAgIGlucy5vcmlnaW5PZiA9IFtyaWdodC5pZF1cbiAgICAgICAgICBpbnMucmlnaHQgPSByaWdodC5pZFxuICAgICAgICAgIHJpZ2h0LmxlZnQgPSBpbnNMaWRcbiAgICAgICAgICAvLyBkZWJ1Z2dlciAvLyBjaGVja1xuICAgICAgICAgIHlpZWxkKiB0aGlzLnNldE9wZXJhdGlvbihyaWdodClcbiAgICAgICAgICB5aWVsZCogdGhpcy5zZXRPcGVyYXRpb24oaW5zKVxuICAgICAgICAgIGlmIChpbnMuZ2MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUucXVldWVHYXJiYWdlQ29sbGVjdG9yKHJpZ2h0LmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5zXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgICogZ2V0T3BlcmF0aW9uIChpZC8qIDphbnkgKi8pLyogOlRyYW5zYWN0aW9uPGFueT4gKi8ge1xuICAgICAgdmFyIG8gPSB5aWVsZCogdGhpcy5vcy5maW5kKGlkKVxuICAgICAgaWYgKGlkWzBdICE9PSAnXycgfHwgbyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvXG4gICAgICB9IGVsc2UgeyAvLyB0eXBlIGlzIHN0cmluZ1xuICAgICAgICAvLyBnZW5lcmF0ZSB0aGlzIG9wZXJhdGlvbj9cbiAgICAgICAgdmFyIGNvbXAgPSBpZFsxXS5zcGxpdCgnXycpXG4gICAgICAgIGlmIChjb21wLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgc3RydWN0ID0gY29tcFswXVxuICAgICAgICAgIHZhciBvcCA9IFkuU3RydWN0W3N0cnVjdF0uY3JlYXRlKGlkKVxuICAgICAgICAgIG9wLnR5cGUgPSBjb21wWzFdXG4gICAgICAgICAgeWllbGQqIHRoaXMuc2V0T3BlcmF0aW9uKG9wKVxuICAgICAgICAgIHJldHVybiBvcFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdvbid0IGJlIGNhbGxlZC4gYnV0IGp1c3QgaW4gY2FzZS4uXG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBjYXNlLiBIb3cgY2FuIHRoaXMgaGFwcGVuPycpXG4gICAgICAgICAgZGVidWdnZXIgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgKiByZW1vdmVPcGVyYXRpb24gKGlkKSB7XG4gICAgICB5aWVsZCogdGhpcy5vcy5kZWxldGUoaWQpXG4gICAgfVxuICAgICogc2V0U3RhdGUgKHN0YXRlKSB7XG4gICAgICB2YXIgdmFsID0ge1xuICAgICAgICBpZDogW3N0YXRlLnVzZXJdLFxuICAgICAgICBjbG9jazogc3RhdGUuY2xvY2tcbiAgICAgIH1cbiAgICAgIHlpZWxkKiB0aGlzLnNzLnB1dCh2YWwpXG4gICAgfVxuICAgICogZ2V0U3RhdGUgKHVzZXIpIHtcbiAgICAgIHZhciBuID0geWllbGQqIHRoaXMuc3MuZmluZChbdXNlcl0pXG4gICAgICB2YXIgY2xvY2sgPSBuID09IG51bGwgPyBudWxsIDogbi5jbG9ja1xuICAgICAgaWYgKGNsb2NrID09IG51bGwpIHtcbiAgICAgICAgY2xvY2sgPSAwXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1c2VyOiB1c2VyLFxuICAgICAgICBjbG9jazogY2xvY2tcbiAgICAgIH1cbiAgICB9XG4gICAgKiBnZXRTdGF0ZVZlY3RvciAoKSB7XG4gICAgICB2YXIgc3RhdGVWZWN0b3IgPSBbXVxuICAgICAgeWllbGQqIHRoaXMuc3MuaXRlcmF0ZSh0aGlzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAqIChuKSB7XG4gICAgICAgIHN0YXRlVmVjdG9yLnB1c2goe1xuICAgICAgICAgIHVzZXI6IG4uaWRbMF0sXG4gICAgICAgICAgY2xvY2s6IG4uY2xvY2tcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gc3RhdGVWZWN0b3JcbiAgICB9XG4gICAgKiBnZXRTdGF0ZVNldCAoKSB7XG4gICAgICB2YXIgc3MgPSB7fVxuICAgICAgeWllbGQqIHRoaXMuc3MuaXRlcmF0ZSh0aGlzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAqIChuKSB7XG4gICAgICAgIHNzW24uaWRbMF1dID0gbi5jbG9ja1xuICAgICAgfSlcbiAgICAgIHJldHVybiBzc1xuICAgIH1cbiAgICAvKlxuICAgICAgSGVyZSwgd2UgbWFrZSBhbGwgbWlzc2luZyBvcGVyYXRpb25zIGV4ZWN1dGFibGUgZm9yIHRoZSByZWNlaXZpbmcgdXNlci5cblxuICAgICAgTm90ZXM6XG4gICAgICAgIHN0YXJ0U1M6IGRlbm90ZXMgdG8gdGhlIFNWIHRoYXQgdGhlIHJlbW90ZSB1c2VyIHNlbnRcbiAgICAgICAgY3VyclNTOiAgZGVub3RlcyB0byB0aGUgc3RhdGUgdmVjdG9yIHRoYXQgdGhlIHVzZXIgc2hvdWxkIGhhdmUgaWYgaGVcbiAgICAgICAgICAgICAgICAgYXBwbGllcyBhbGwgYWxyZWFkeSBzZW50IG9wZXJhdGlvbnMgKGluY3JlYXNlcyBpcyBlYWNoIHN0ZXApXG5cbiAgICAgIFdlIGZhY2Ugc2V2ZXJhbCBwcm9ibGVtczpcbiAgICAgICogRXhlY3V0ZSBvcCBhcyBpcyB3b24ndCB3b3JrIGJlY2F1c2Ugb3BzIGRlcGVuZCBvbiBlYWNoIG90aGVyXG4gICAgICAgLT4gZmluZCBhIHdheSBzbyB0aGF0IHRoZXkgZG8gbm90IGFueW1vcmVcbiAgICAgICogV2hlbiBjaGFuZ2luZyBsZWZ0LCBtdXN0IG5vdCBnbyBtb3JlIHRvIHRoZSBsZWZ0IHRoYW4gdGhlIG9yaWdpblxuICAgICAgKiBXaGVuIGNoYW5naW5nIHJpZ2h0LCB5b3UgaGF2ZSB0byBjb25zaWRlciB0aGF0IG90aGVyIG9wcyBtYXkgaGF2ZSBvcFxuICAgICAgICBhcyB0aGVpciBvcmlnaW4sIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdCBub3Qgc2V0IG9uZSBvZiB0aGVzZSBvcHNcbiAgICAgICAgYXMgdGhlIG5ldyByaWdodCAoaW50ZXJkZXBlbmRlbmNpZXMgb2Ygb3BzKVxuICAgICAgKiBjYW4ndCBqdXN0IGdvIHRvIHRoZSByaWdodCB1bnRpbCB5b3UgZmluZCB0aGUgZmlyc3Qga25vd24gb3BlcmF0aW9uLFxuICAgICAgICBXaXRoIGN1cnJTU1xuICAgICAgICAgIC0+IGludGVyZGVwZW5kZW5jeSBvZiBvcHMgaXMgYSBwcm9ibGVtXG4gICAgICAgIFdpdGggc3RhcnRTU1xuICAgICAgICAgIC0+IGxlYWRzIHRvIGluY29uc2lzdGVuY2llcyB3aGVuIHR3byB1c2VycyBqb2luIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAgVGhlbiB0aGUgcG9zaXRpb24gZGVwZW5kcyBvbiB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uIC0+IGVycm9yIVxuXG4gICAgICAgIFNvbHV0aW9uOlxuICAgICAgICAtPiByZS1jcmVhdGUgb3JpZ2luaWFsIHNpdHVhdGlvblxuICAgICAgICAgIC0+IHNldCBvcC5sZWZ0ID0gb3Aub3JpZ2luICh3aGljaCBuZXZlciBjaGFuZ2VzKVxuICAgICAgICAgIC0+IHNldCBvcC5yaWdodFxuICAgICAgICAgICAgICAgdG8gdGhlIGZpcnN0IG9wZXJhdGlvbiB0aGF0IGlzIGtub3duIChhY2NvcmRpbmcgdG8gc3RhcnRTUylcbiAgICAgICAgICAgICAgIG9yIHRvIHRoZSBmaXJzdCBvcGVyYXRpb24gdGhhdCBoYXMgYW4gb3JpZ2luIHRoYXQgaXMgbm90IHRvIHRoZVxuICAgICAgICAgICAgICAgcmlnaHQgb2Ygb3AuXG4gICAgICAgICAgLT4gRW5mb3JjZXMgdW5pcXVlIGV4ZWN1dGlvbiBvcmRlciAtPiBoYXBweSB1c2VyXG5cbiAgICAgICAgSW1wcm92ZW1lbnRzOiBUT0RPXG4gICAgICAgICAgKiBDb3VsZCBzZXQgbGVmdCB0byBvcmlnaW4sIG9yIHRoZSBmaXJzdCBrbm93biBvcGVyYXRpb25cbiAgICAgICAgICAgIChzdGFydFNTIG9yIGN1cnJTUy4uID8pXG4gICAgICAgICAgICAtPiBDb3VsZCBiZSBuZWNlc3Nhcnkgd2hlbiBJIHR1cm4gR0MgYWdhaW4uXG4gICAgICAgICAgICAtPiBJcyBhIGJhZChpc2gpIGlkZWEgYmVjYXVzZSBpdCByZXF1aXJlcyBtb3JlIGNvbXB1dGF0aW9uXG5cbiAgICAgIFdoYXQgd2UgZG86XG4gICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgbWlzc2luZyBvcGVyYXRpb25zLlxuICAgICAgKiBXaGVuIHRoZXJlIGlzIGFuIG9wZXJhdGlvbiwgd2hlcmUgdGhlIHJpZ2h0IG9wIGlzIGtub3duLCBzZW5kIHRoaXMgb3AgYWxsIG1pc3Npbmcgb3BzIHRvIHRoZSBsZWZ0IHRvIHRoZSB1c2VyXG4gICAgICAqIEkgZXhwbGFpbmVkIGFib3ZlIHdoYXQgd2UgaGF2ZSB0byBkbyB3aXRoIGVhY2ggb3BlcmF0aW9uLiBIZXJlIGlzIGhvdyB3ZSBkbyBpdCBlZmZpY2llbnRseTpcbiAgICAgICAgMS4gR28gdG8gdGhlIGxlZnQgdW50aWwgeW91IGZpbmQgZWl0aGVyIG9wLm9yaWdpbiwgb3IgYSBrbm93biBvcGVyYXRpb24gKGxldCBvIGRlbm90ZSBjdXJyZW50IG9wZXJhdGlvbiBpbiB0aGUgaXRlcmF0aW9uKVxuICAgICAgICAyLiBGb3VuZCBhIGtub3duIG9wZXJhdGlvbiAtPiBzZXQgb3AubGVmdCA9IG8sIGFuZCBzZW5kIGl0IHRvIHRoZSB1c2VyLiBzdG9wXG4gICAgICAgIDMuIEZvdW5kIG8gPSBvcC5vcmlnaW4gLT4gc2V0IG9wLmxlZnQgPSBvcC5vcmlnaW4sIGFuZCBzZW5kIGl0IHRvIHRoZSB1c2VyLiBzdGFydCBhZ2FpbiBmcm9tIDEuIChzZXQgb3AgPSBvKVxuICAgICAgICA0LiBGb3VuZCBzb21lIG8gLT4gc2V0IG8ucmlnaHQgPSBvcCwgby5sZWZ0ID0gby5vcmlnaW4sIHNlbmQgaXQgdG8gdGhlIHVzZXIsIGNvbnRpbnVlXG4gICAgKi9cbiAgICAqIGdldE9wZXJhdGlvbnMgKHN0YXJ0U1MpIHtcbiAgICAgIC8vIFRPRE86IHVzZSBib3VuZHMgaGVyZSFcbiAgICAgIGlmIChzdGFydFNTID09IG51bGwpIHtcbiAgICAgICAgc3RhcnRTUyA9IHt9XG4gICAgICB9XG4gICAgICB2YXIgc2VuZCA9IFtdXG5cbiAgICAgIHZhciBlbmRTViA9IHlpZWxkKiB0aGlzLmdldFN0YXRlVmVjdG9yKClcbiAgICAgIGZvciAodmFyIGVuZFN0YXRlIG9mIGVuZFNWKSB7XG4gICAgICAgIHZhciB1c2VyID0gZW5kU3RhdGUudXNlclxuICAgICAgICBpZiAodXNlciA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRQb3MgPSBzdGFydFNTW3VzZXJdIHx8IDBcbiAgICAgICAgaWYgKHN0YXJ0UG9zID4gMCkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGEgY2hhbmdlIHRoYXQgW3VzZXIsIHN0YXJ0UG9zXSBpcyBpbiBhIGNvbXBvc2VkIEluc2VydGlvbiAod2l0aCBhIHNtYWxsZXIgY291bnRlcilcbiAgICAgICAgICAvLyBmaW5kIG91dCBpZiB0aGF0IGlzIHRoZSBjYXNlXG4gICAgICAgICAgdmFyIGZpcnN0TWlzc2luZyA9IHlpZWxkKiB0aGlzLmdldEluc2VydGlvbihbdXNlciwgc3RhcnRQb3NdKVxuICAgICAgICAgIGlmIChmaXJzdE1pc3NpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXJ0UG9zXG4gICAgICAgICAgICBzdGFydFBvcyA9IGZpcnN0TWlzc2luZy5pZFsxXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5vcy5pdGVyYXRlKHRoaXMsIFt1c2VyLCBzdGFydFBvc10sIFt1c2VyLCBOdW1iZXIuTUFYX1ZBTFVFXSwgZnVuY3Rpb24gKiAob3ApIHtcbiAgICAgICAgICBvcCA9IFkuU3RydWN0W29wLnN0cnVjdF0uZW5jb2RlKG9wKVxuICAgICAgICAgIGlmIChvcC5zdHJ1Y3QgIT09ICdJbnNlcnQnKSB7XG4gICAgICAgICAgICBzZW5kLnB1c2gob3ApXG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5yaWdodCA9PSBudWxsIHx8IG9wLnJpZ2h0WzFdIDwgKHN0YXJ0U1Nbb3AucmlnaHRbMF1dIHx8IDApKSB7XG4gICAgICAgICAgICAvLyBjYXNlIDEuIG9wLnJpZ2h0IGlzIGtub3duXG4gICAgICAgICAgICB2YXIgbyA9IG9wXG4gICAgICAgICAgICAvLyBSZW1lbWJlcjogP1xuICAgICAgICAgICAgLy8gLT4gc2V0IG9wLnJpZ2h0XG4gICAgICAgICAgICAvLyAgICAxLiB0byB0aGUgZmlyc3Qgb3BlcmF0aW9uIHRoYXQgaXMga25vd24gKGFjY29yZGluZyB0byBzdGFydFNTKVxuICAgICAgICAgICAgLy8gICAgMi4gb3IgdG8gdGhlIGZpcnN0IG9wZXJhdGlvbiB0aGF0IGhhcyBhbiBvcmlnaW4gdGhhdCBpcyBub3QgdG8gdGhlXG4gICAgICAgICAgICAvLyAgICAgIHJpZ2h0IG9mIG9wLlxuICAgICAgICAgICAgLy8gRm9yIHRoaXMgd2UgbWFpbnRhaW4gYSBsaXN0IG9mIG9wcyB3aGljaCBvcmlnaW5zIGFyZSBub3QgZm91bmQgeWV0LlxuICAgICAgICAgICAgdmFyIG1pc3Npbmdfb3JpZ2lucyA9IFtvcF1cbiAgICAgICAgICAgIHZhciBuZXdyaWdodCA9IG9wLnJpZ2h0XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAoby5sZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcC5sZWZ0ID0gbnVsbFxuICAgICAgICAgICAgICAgIHNlbmQucHVzaChvcClcbiAgICAgICAgICAgICAgICBpZiAoIVkudXRpbHMuY29tcGFyZUlkcyhvLmlkLCBvcC5pZCkpIHtcbiAgICAgICAgICAgICAgICAgIG8gPSBZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvKVxuICAgICAgICAgICAgICAgICAgby5yaWdodCA9IG1pc3Npbmdfb3JpZ2luc1ttaXNzaW5nX29yaWdpbnMubGVuZ3RoIC0gMV0uaWRcbiAgICAgICAgICAgICAgICAgIHNlbmQucHVzaChvKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG8gPSB5aWVsZCogdGhpcy5nZXRJbnNlcnRpb24oby5sZWZ0KVxuICAgICAgICAgICAgICAvLyB3ZSBzZXQgYW5vdGhlciBvLCBjaGVjayBpZiB3ZSBjYW4gcmVkdWNlICRtaXNzaW5nX29yaWdpbnNcbiAgICAgICAgICAgICAgd2hpbGUgKG1pc3Npbmdfb3JpZ2lucy5sZW5ndGggPiAwICYmIFkudXRpbHMubWF0Y2hlc0lkKG8sIG1pc3Npbmdfb3JpZ2luc1ttaXNzaW5nX29yaWdpbnMubGVuZ3RoIC0gMV0ub3JpZ2luKSkge1xuICAgICAgICAgICAgICAgIG1pc3Npbmdfb3JpZ2lucy5wb3AoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvLmlkWzFdIDwgKHN0YXJ0U1Nbby5pZFswXV0gfHwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDIuIG8gaXMga25vd25cbiAgICAgICAgICAgICAgICBvcC5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQobylcbiAgICAgICAgICAgICAgICBzZW5kLnB1c2gob3ApXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChZLnV0aWxzLm1hdGNoZXNJZChvLCBvcC5vcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSAzLiBvIGlzIG9wLm9yaWdpblxuICAgICAgICAgICAgICAgIG9wLmxlZnQgPSBvcC5vcmlnaW5cbiAgICAgICAgICAgICAgICBzZW5kLnB1c2gob3ApXG4gICAgICAgICAgICAgICAgb3AgPSBZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvKVxuICAgICAgICAgICAgICAgIG9wLnJpZ2h0ID0gbmV3cmlnaHRcbiAgICAgICAgICAgICAgICBpZiAobWlzc2luZ19vcmlnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuIC4uIDooIHBsZWFzZSByZXBvcnQgdGhpcycpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pc3Npbmdfb3JpZ2lucyA9IFtvcF1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDQuIHNlbmQgbywgY29udGludWUgdG8gZmluZCBvcC5vcmlnaW5cbiAgICAgICAgICAgICAgICB2YXIgcyA9IFkuU3RydWN0W29wLnN0cnVjdF0uZW5jb2RlKG8pXG4gICAgICAgICAgICAgICAgcy5yaWdodCA9IG1pc3Npbmdfb3JpZ2luc1ttaXNzaW5nX29yaWdpbnMubGVuZ3RoIC0gMV0uaWRcbiAgICAgICAgICAgICAgICBzLmxlZnQgPSBzLm9yaWdpblxuICAgICAgICAgICAgICAgIHNlbmQucHVzaChzKVxuICAgICAgICAgICAgICAgIG1pc3Npbmdfb3JpZ2lucy5wdXNoKG8pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VuZC5yZXZlcnNlKClcbiAgICB9XG4gICAgLyogdGhpcyBpcyB3aGF0IHdlIHVzZWQgYmVmb3JlLi4gdXNlIHRoaXMgYXMgYSByZWZlcmVuY2UuLlxuICAgICogbWFrZU9wZXJhdGlvblJlYWR5IChzdGFydFNTLCBvcCkge1xuICAgICAgb3AgPSBZLlN0cnVjdFtvcC5zdHJ1Y3RdLmVuY29kZShvcClcbiAgICAgIG9wID0gWS51dGlscy5jb3B5T2JqZWN0KG9wKSAtLSB1c2UgY29weW9wZXJhdGlvbiBpbnN0ZWFkIG5vdyFcbiAgICAgIHZhciBvID0gb3BcbiAgICAgIHZhciBpZHMgPSBbb3AuaWRdXG4gICAgICAvLyBzZWFyY2ggZm9yIHRoZSBuZXcgb3AucmlnaHRcbiAgICAgIC8vIGl0IGlzIGVpdGhlciB0aGUgZmlyc3Qga25vd24gb3AgKGFjY29yZGluZyB0byBzdGFydFNTKVxuICAgICAgLy8gb3IgdGhlIG8gdGhhdCBoYXMgbm8gb3JpZ2luIHRvIHRoZSByaWdodCBvZiBvcFxuICAgICAgLy8gKHRoaXMgaXMgd2h5IHdlIHVzZSB0aGUgaWRzIGFycmF5KVxuICAgICAgd2hpbGUgKG8ucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgcmlnaHQgPSB5aWVsZCogdGhpcy5nZXRPcGVyYXRpb24oby5yaWdodClcbiAgICAgICAgaWYgKG8ucmlnaHRbMV0gPCAoc3RhcnRTU1tvLnJpZ2h0WzBdXSB8fCAwKSB8fCAhaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIFkudXRpbHMuY29tcGFyZUlkcyhpZCwgcmlnaHQub3JpZ2luKVxuICAgICAgICB9KSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWRzLnB1c2goby5yaWdodClcbiAgICAgICAgbyA9IHJpZ2h0XG4gICAgICB9XG4gICAgICBvcC5yaWdodCA9IG8ucmlnaHRcbiAgICAgIG9wLmxlZnQgPSBvcC5vcmlnaW5cbiAgICAgIHJldHVybiBvcFxuICAgIH1cbiAgICAqL1xuICAgICogZmx1c2ggKCkge1xuICAgICAgeWllbGQqIHRoaXMub3MuZmx1c2goKVxuICAgICAgeWllbGQqIHRoaXMuc3MuZmx1c2goKVxuICAgICAgeWllbGQqIHRoaXMuZHMuZmx1c2goKVxuICAgIH1cbiAgfVxuICBZLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb25JbnRlcmZhY2Vcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxuLypcbiAgRXZlbnRIYW5kbGVyIGlzIGFuIGhlbHBlciBjbGFzcyBmb3IgY29uc3RydWN0aW5nIGN1c3RvbSB0eXBlcy5cblxuICBXaHk6IFdoZW4gY29uc3RydWN0aW5nIGN1c3RvbSB0eXBlcywgeW91IHNvbWV0aW1lcyB3YW50IHlvdXIgdHlwZXMgdG8gd29ya1xuICBzeW5jaHJvbm91czogRS5nLlxuICBgYGAgU3luY2hyb25vdXNcbiAgICBteXR5cGUuc2V0U29tZXRoaW5nKFwieWF5XCIpXG4gICAgbXl0eXBlLmdldFNvbWV0aGluZygpID09PSBcInlheVwiXG4gIGBgYFxuICB2ZXJzdXNcbiAgYGBgIEFzeW5jaHJvbm91c1xuICAgIG15dHlwZS5zZXRTb21ldGhpbmcoXCJ5YXlcIilcbiAgICBteXR5cGUuZ2V0U29tZXRoaW5nKCkgPT09IHVuZGVmaW5lZFxuICAgIG15dHlwZS53YWl0Rm9yU29tZXRoaW5nKCkudGhlbihmdW5jdGlvbigpe1xuICAgICAgbXl0eXBlLmdldFNvbWV0aGluZygpID09PSBcInlheVwiXG4gICAgfSlcbiAgYGBgXG5cbiAgVGhlIHN0cnVjdHVyZXMgdXN1YWxseSB3b3JrIGFzeW5jaHJvbm91c2x5ICh5b3UgaGF2ZSB0byB3YWl0IGZvciB0aGVcbiAgZGF0YWJhc2UgcmVxdWVzdCB0byBmaW5pc2gpLiBFdmVudEhhbmRsZXIgaGVscHMgeW91IHRvIG1ha2UgeW91ciB0eXBlXG4gIHN5bmNocm9ub3VzLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFkgLyogOiBhbnkqLykge1xuICBZLnV0aWxzID0ge31cblxuICBjbGFzcyBFdmVudExpc3RlbmVySGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdXG4gICAgfVxuICAgIGRlc3Ryb3kgKCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG51bGxcbiAgICB9XG4gICAgIC8qXG4gICAgICBCYXNpYyBldmVudCBsaXN0ZW5lciBib2lsZXJwbGF0ZS4uLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lciAoZikge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKGYpXG4gICAgfVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIgKGYpIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gZiAhPT0gZ1xuICAgICAgfSlcbiAgICB9XG4gICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgKCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdXG4gICAgfVxuICAgIGNhbGxFdmVudExpc3RlbmVycyAoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbaV0oZXZlbnQpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVc2VyIGV2ZW50cyBtdXN0IG5vdCB0aHJvdyBFcnJvcnMhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBZLnV0aWxzLkV2ZW50TGlzdGVuZXJIYW5kbGVyID0gRXZlbnRMaXN0ZW5lckhhbmRsZXJcblxuICBjbGFzcyBFdmVudEhhbmRsZXIgZXh0ZW5kcyBFdmVudExpc3RlbmVySGFuZGxlciB7XG4gICAgLyogOjpcbiAgICB3YWl0aW5nOiBBcnJheTxJbnNlcnRpb24gfCBEZWxldGlvbj47XG4gICAgYXdhaXRpbmc6IG51bWJlcjtcbiAgICBvbmV2ZW50OiBGdW5jdGlvbjtcbiAgICBldmVudExpc3RlbmVyczogQXJyYXk8RnVuY3Rpb24+O1xuICAgICovXG4gICAgLypcbiAgICAgIG9uZXZlbnQ6IGlzIGNhbGxlZCB3aGVuIHRoZSBzdHJ1Y3R1cmUgY2hhbmdlcy5cblxuICAgICAgTm90ZTogXCJhd2FpdGluZyBvcGVydGF0aW9uc1wiIGlzIHVzZWQgdG8gZGVub3RlIG9wZXJhdGlvbnMgdGhhdCB3ZXJlXG4gICAgICBwcmVtYXR1cmVseSBjYWxsZWQuIEV2ZW50cyBmb3IgcmVjZWl2ZWQgb3BlcmF0aW9ucyBjYW4gbm90IGJlIGV4ZWN1dGVkIHVudGlsXG4gICAgICBhbGwgcHJlbWF0dXJlbHkgY2FsbGVkIG9wZXJhdGlvbnMgd2VyZSBleGVjdXRlZCAoXCJ3YWl0aW5nIG9wZXJhdGlvbnNcIilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChvbmV2ZW50IC8qIDogRnVuY3Rpb24gKi8pIHtcbiAgICAgIHN1cGVyKClcbiAgICAgIHRoaXMud2FpdGluZyA9IFtdXG4gICAgICB0aGlzLmF3YWl0aW5nID0gMFxuICAgICAgdGhpcy5vbmV2ZW50ID0gb25ldmVudFxuICAgIH1cbiAgICBkZXN0cm95ICgpIHtcbiAgICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgICAgdGhpcy53YWl0aW5nID0gbnVsbFxuICAgICAgdGhpcy5hd2FpdGluZyA9IG51bGxcbiAgICAgIHRoaXMub25ldmVudCA9IG51bGxcbiAgICB9XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyB3aGVuIGEgbmV3IG9wZXJhdGlvbiBhcnJpdmVzLiBJdCB3aWxsIGJlIGV4ZWN1dGVkIHJpZ2h0IGF3YXkgaWZcbiAgICAgIHRoZXJlIGFyZSBubyB3YWl0aW5nIG9wZXJhdGlvbnMsIHRoYXQgeW91IHByZW1hdHVyZWx5IGV4ZWN1dGVkXG4gICAgKi9cbiAgICByZWNlaXZlZE9wIChvcCkge1xuICAgICAgaWYgKHRoaXMuYXdhaXRpbmcgPD0gMCkge1xuICAgICAgICB0aGlzLm9uZXZlbnQob3ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhaXRpbmcucHVzaChvcClcbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgIFlvdSBjcmVhdGVkIHNvbWUgb3BlcmF0aW9ucywgYW5kIHlvdSB3YW50IHRoZSBgb25ldmVudGAgZnVuY3Rpb24gdG8gYmVcbiAgICAgIGNhbGxlZCByaWdodCBhd2F5LiBSZWNlaXZlZCBvcGVyYXRpb25zIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHVudGlsbCBhbGxcbiAgICAgIHByZW1hdHVyZWx5IGNhbGxlZCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZFxuICAgICovXG4gICAgYXdhaXRBbmRQcmVtYXR1cmVseUNhbGwgKG9wcykge1xuICAgICAgdGhpcy5hd2FpdGluZysrXG4gICAgICBvcHMubWFwKFkudXRpbHMuY29weU9wZXJhdGlvbikuZm9yRWFjaCh0aGlzLm9uZXZlbnQpXG4gICAgfVxuICAgICogYXdhaXRPcHMgKHRyYW5zYWN0aW9uLCBmLCBhcmdzKSB7XG4gICAgICBmdW5jdGlvbiBub3RTb1NtYXJ0U29ydCAoYXJyYXkpIHtcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBzb3J0cyBpbnNlcnRpb25zIGluIGEgZXhlY3V0YWJsZSBvcmRlclxuICAgICAgICB2YXIgcmVzdWx0ID0gW11cbiAgICAgICAgd2hpbGUgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXBlbmRlbnQgPSB0cnVlXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChZLnV0aWxzLm1hdGNoZXNJZChhcnJheVtqXSwgYXJyYXlbaV0ubGVmdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBhcnJheVtpXSBkZXBlbmRzIG9uIGFycmF5W2pdXG4gICAgICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJheS5zcGxpY2UoaSwgMSlbMF0pXG4gICAgICAgICAgICAgIGktLVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICB2YXIgYmVmb3JlID0gdGhpcy53YWl0aW5nLmxlbmd0aFxuICAgICAgLy8gc29tZWhvdyBjcmVhdGUgbmV3IG9wZXJhdGlvbnNcbiAgICAgIHlpZWxkKiBmLmFwcGx5KHRyYW5zYWN0aW9uLCBhcmdzKVxuICAgICAgLy8gcmVtb3ZlIGFsbCBhcHBlbmRlZCBvcHMgLyBhd2FpdGVkIG9wc1xuICAgICAgdGhpcy53YWl0aW5nLnNwbGljZShiZWZvcmUpXG4gICAgICBpZiAodGhpcy5hd2FpdGluZyA+IDApIHRoaXMuYXdhaXRpbmctLVxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGF3YWl0ZWQgb3BzIGFueW1vcmUsIHdlIGNhbiB1cGRhdGUgYWxsIHdhaXRpbmcgb3BzLCBhbmQgc2VuZCBleGVjdXRlIHRoZW0gKGlmIHRoZXJlIGFyZSBzdGlsbCBubyBhd2FpdGVkIG9wcylcbiAgICAgIGlmICh0aGlzLmF3YWl0aW5nID09PSAwICYmIHRoaXMud2FpdGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBhbGwgd2FpdGluZyBvcHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndhaXRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMud2FpdGluZ1tpXVxuICAgICAgICAgIGlmIChvLnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICAgIHZhciBfbyA9IHlpZWxkKiB0cmFuc2FjdGlvbi5nZXRJbnNlcnRpb24oby5pZClcbiAgICAgICAgICAgIGlmICghWS51dGlscy5jb21wYXJlSWRzKF9vLmlkLCBvLmlkKSkge1xuICAgICAgICAgICAgICAvLyBvIGdvdCBleHRlbmRlZFxuICAgICAgICAgICAgICBvLmxlZnQgPSBbby5pZFswXSwgby5pZFsxXSAtIDFdXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9vLmxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBvLmxlZnQgPSBudWxsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmaW5kIG5leHQgdW5kZWxldGVkIG9wXG4gICAgICAgICAgICAgIHZhciBsZWZ0ID0geWllbGQqIHRyYW5zYWN0aW9uLmdldEluc2VydGlvbihfby5sZWZ0KVxuICAgICAgICAgICAgICB3aGlsZSAobGVmdC5kZWxldGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGxlZnQgPSB5aWVsZCogdHJhbnNhY3Rpb24uZ2V0SW5zZXJ0aW9uKGxlZnQubGVmdClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbGVmdCA9IG51bGxcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG8ubGVmdCA9IGxlZnQgIT0gbnVsbCA/IFkudXRpbHMuZ2V0TGFzdElkKGxlZnQpIDogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc3R1ZmYgd2FzIGFzeW5jLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIGFnYWluIVxuICAgICAgICAvLyBXZSBhbHNvIHB1bGwgY2hhbmdlcyBmcm9tIHRoZSBiaW5kaW5ncywgaWYgdGhlcmUgZXhpc3RzIHN1Y2ggYSBtZXRob2QsIHRoaXMgY291bGQgaW5jcmVhc2UgYXdhaXRpbmcgdG9vXG4gICAgICAgIGlmICh0aGlzLl9wdWxsQ2hhbmdlcyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcHVsbENoYW5nZXMoKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF3YWl0aW5nID09PSAwKSB7XG4gICAgICAgICAgLy8gc29ydCBieSB0eXBlLCBleGVjdXRlIGluc2VydHMgZmlyc3RcbiAgICAgICAgICB2YXIgaW5zID0gW11cbiAgICAgICAgICB2YXIgZGVscyA9IFtdXG4gICAgICAgICAgdGhpcy53YWl0aW5nLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGlmIChvLnN0cnVjdCA9PT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgZGVscy5wdXNoKG8pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnMucHVzaChvKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gcHV0IGluIGV4ZWN1dGFibGUgb3JkZXJcbiAgICAgICAgICBpbnMgPSBub3RTb1NtYXJ0U29ydChpbnMpXG4gICAgICAgICAgaW5zLmZvckVhY2godGhpcy5vbmV2ZW50KVxuICAgICAgICAgIGRlbHMuZm9yRWFjaCh0aGlzLm9uZXZlbnQpXG4gICAgICAgICAgdGhpcy53YWl0aW5nID0gW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgYXdhaXRlZEluc2VydHMgYW5kIGF3YWl0ZWREZWxldGVzIGluIGZhdm9yIG9mIGF3YWl0ZWRPcHMsIGFzIHRoZXkgYXJlIGRlcHJlY2F0ZWQgYW5kIGRvIG5vdCBhbHdheXMgd29ya1xuICAgIC8vIERvIHRoaXMgaW4gb25lIG9mIHRoZSBjb21pbmcgcmVsZWFzZXMgdGhhdCBhcmUgYnJlYWtpbmcgYW55d2F5XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyB3aGVuIHlvdSBzdWNjZXNzZnVsbHkgYXdhaXRlZCB0aGUgZXhlY3V0aW9uIG9mIG4gSW5zZXJ0IG9wZXJhdGlvbnNcbiAgICAqL1xuICAgIGF3YWl0ZWRJbnNlcnRzIChuKSB7XG4gICAgICB2YXIgb3BzID0gdGhpcy53YWl0aW5nLnNwbGljZSh0aGlzLndhaXRpbmcubGVuZ3RoIC0gbilcbiAgICAgIGZvciAodmFyIG9pZCA9IDA7IG9pZCA8IG9wcy5sZW5ndGg7IG9pZCsrKSB7XG4gICAgICAgIHZhciBvcCA9IG9wc1tvaWRdXG4gICAgICAgIGlmIChvcC5zdHJ1Y3QgPT09ICdJbnNlcnQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMud2FpdGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHcgPSB0aGlzLndhaXRpbmdbaV1cbiAgICAgICAgICAgIC8vIFRPRE86IGRvIEkgaGFuZGxlIHNwbGl0IG9wZXJhdGlvbnMgY29ycmVjdGx5IGhlcmU/IFN1cGVyIHVubGlrZWx5LCBidXQgeWVhaC4uXG4gICAgICAgICAgICAvLyBBbHNvOiBjYW4gdGhpcyBjYXNlIGhhcHBlbj8gQ2FuIG9wIGJlIGluc2VydGVkIGluIHRoZSBtaWRkbGUgb2YgYSBsYXJnZXIgb3AgdGhhdCBpcyBpbiAkd2FpdGluZz9cbiAgICAgICAgICAgIGlmICh3LnN0cnVjdCA9PT0gJ0luc2VydCcpIHtcbiAgICAgICAgICAgICAgaWYgKFkudXRpbHMubWF0Y2hlc0lkKHcsIG9wLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGUgZWZmZWN0IG9mIG9wIGluIHdcbiAgICAgICAgICAgICAgICB3LnJpZ2h0ID0gb3AuaWRcbiAgICAgICAgICAgICAgICAvLyBleGNsdWRlIHRoZSBlZmZlY3Qgb2YgdyBpbiBvcFxuICAgICAgICAgICAgICAgIG9wLmxlZnQgPSB3LmxlZnRcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChZLnV0aWxzLmNvbXBhcmVJZHMody5pZCwgb3AucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2ltaWxhci4uXG4gICAgICAgICAgICAgICAgdy5sZWZ0ID0gWS51dGlscy5nZXRMYXN0SWQob3ApXG4gICAgICAgICAgICAgICAgb3AucmlnaHQgPSB3LnJpZ2h0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBJbnNlcnQgT3BlcmF0aW9uIScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyeUNhbGxFdmVudHMobilcbiAgICB9XG4gICAgLypcbiAgICAgIENhbGwgdGhpcyB3aGVuIHlvdSBzdWNjZXNzZnVsbHkgYXdhaXRlZCB0aGUgZXhlY3V0aW9uIG9mIG4gRGVsZXRlIG9wZXJhdGlvbnNcbiAgICAqL1xuICAgIGF3YWl0ZWREZWxldGVzIChuLCBuZXdMZWZ0KSB7XG4gICAgICB2YXIgb3BzID0gdGhpcy53YWl0aW5nLnNwbGljZSh0aGlzLndhaXRpbmcubGVuZ3RoIC0gbilcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBkZWwgPSBvcHNbal1cbiAgICAgICAgaWYgKGRlbC5zdHJ1Y3QgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgaWYgKG5ld0xlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndhaXRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IHcgPSB0aGlzLndhaXRpbmdbaV1cbiAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBqdXN0IGNhcmUgYWJvdXQgdy5sZWZ0XG4gICAgICAgICAgICAgIGlmICh3LnN0cnVjdCA9PT0gJ0luc2VydCcgJiYgWS51dGlscy5jb21wYXJlSWRzKGRlbC50YXJnZXQsIHcubGVmdCkpIHtcbiAgICAgICAgICAgICAgICB3LmxlZnQgPSBuZXdMZWZ0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBEZWxldGUgT3BlcmF0aW9uIScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyeUNhbGxFdmVudHMobilcbiAgICB9XG4gICAgLyogKHByaXZhdGUpXG4gICAgICBUcnkgdG8gZXhlY3V0ZSB0aGUgZXZlbnRzIGZvciB0aGUgd2FpdGluZyBvcGVyYXRpb25zXG4gICAgKi9cbiAgICBfdHJ5Q2FsbEV2ZW50cyAoKSB7XG4gICAgICBmdW5jdGlvbiBub3RTb1NtYXJ0U29ydCAoYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgICAgIHdoaWxlIChhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGVwZW5kZW50ID0gdHJ1ZVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoWS51dGlscy5tYXRjaGVzSWQoYXJyYXlbal0sIGFycmF5W2ldLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gYXJyYXlbaV0gZGVwZW5kcyBvbiBhcnJheVtqXVxuICAgICAgICAgICAgICAgIGluZGVwZW5kZW50ID0gZmFsc2VcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXBlbmRlbnQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKVxuICAgICAgICAgICAgICBpLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXdhaXRpbmcgPiAwKSB0aGlzLmF3YWl0aW5nLS1cbiAgICAgIGlmICh0aGlzLmF3YWl0aW5nID09PSAwICYmIHRoaXMud2FpdGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBpbnMgPSBbXVxuICAgICAgICB2YXIgZGVscyA9IFtdXG4gICAgICAgIHRoaXMud2FpdGluZy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgaWYgKG8uc3RydWN0ID09PSAnRGVsZXRlJykge1xuICAgICAgICAgICAgZGVscy5wdXNoKG8pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucy5wdXNoKG8pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBpbnMgPSBub3RTb1NtYXJ0U29ydChpbnMpXG4gICAgICAgIGlucy5mb3JFYWNoKHRoaXMub25ldmVudClcbiAgICAgICAgZGVscy5mb3JFYWNoKHRoaXMub25ldmVudClcbiAgICAgICAgdGhpcy53YWl0aW5nID0gW11cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgWS51dGlscy5FdmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXJcblxuICAvKlxuICAgIEEgd3JhcHBlciBmb3IgdGhlIGRlZmluaXRpb24gb2YgYSBjdXN0b20gdHlwZS5cbiAgICBFdmVyeSBjdXN0b20gdHlwZSBtdXN0IGhhdmUgdGhyZWUgcHJvcGVydGllczpcblxuICAgICogc3RydWN0XG4gICAgICAtIFN0cnVjdG5hbWUgb2YgdGhpcyB0eXBlXG4gICAgKiBpbml0VHlwZVxuICAgICAgLSBHaXZlbiBhIG1vZGVsLCBjcmVhdGVzIGEgY3VzdG9tIHR5cGVcbiAgICAqIGNsYXNzXG4gICAgICAtIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY3VzdG9tIHR5cGUgKGUuZy4gaW4gb3JkZXIgdG8gaW5oZXJpdCBmcm9tIGEgdHlwZSlcbiAgKi9cbiAgY2xhc3MgQ3VzdG9tVHlwZSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAvKiA6OlxuICAgIHN0cnVjdDogYW55O1xuICAgIGluaXRUeXBlOiBhbnk7XG4gICAgY2xhc3M6IEZ1bmN0aW9uO1xuICAgIG5hbWU6IFN0cmluZztcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChkZWYpIHtcbiAgICAgIGlmIChkZWYuc3RydWN0ID09IG51bGwgfHxcbiAgICAgICAgZGVmLmluaXRUeXBlID09IG51bGwgfHxcbiAgICAgICAgZGVmLmNsYXNzID09IG51bGwgfHxcbiAgICAgICAgZGVmLm5hbWUgPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIHR5cGUgd2FzIG5vdCBpbml0aWFsaXplZCBjb3JyZWN0bHkhJylcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RydWN0ID0gZGVmLnN0cnVjdFxuICAgICAgdGhpcy5pbml0VHlwZSA9IGRlZi5pbml0VHlwZVxuICAgICAgdGhpcy5jbGFzcyA9IGRlZi5jbGFzc1xuICAgICAgdGhpcy5uYW1lID0gZGVmLm5hbWVcbiAgICAgIGlmIChkZWYuYXBwZW5kQWRkaXRpb25hbEluZm8gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFwcGVuZEFkZGl0aW9uYWxJbmZvID0gZGVmLmFwcGVuZEFkZGl0aW9uYWxJbmZvXG4gICAgICB9XG4gICAgICB0aGlzLnBhcnNlQXJndW1lbnRzID0gKGRlZi5wYXJzZUFyZ3VtZW50cyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpc11cbiAgICAgIH0pLmJpbmQodGhpcylcbiAgICAgIHRoaXMucGFyc2VBcmd1bWVudHMudHlwZURlZmluaXRpb24gPSB0aGlzXG4gICAgfVxuICB9XG4gIFkudXRpbHMuQ3VzdG9tVHlwZSA9IEN1c3RvbVR5cGVcblxuICBZLnV0aWxzLmlzVHlwZURlZmluaXRpb24gPSBmdW5jdGlvbiBpc1R5cGVEZWZpbml0aW9uICh2KSB7XG4gICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBZLnV0aWxzLkN1c3RvbVR5cGUpIHJldHVybiBbdl1cbiAgICAgIGVsc2UgaWYgKHYuY29uc3RydWN0b3IgPT09IEFycmF5ICYmIHZbMF0gaW5zdGFuY2VvZiBZLnV0aWxzLkN1c3RvbVR5cGUpIHJldHVybiB2XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgdi50eXBlRGVmaW5pdGlvbiBpbnN0YW5jZW9mIFkudXRpbHMuQ3VzdG9tVHlwZSkgcmV0dXJuIFt2LnR5cGVEZWZpbml0aW9uXVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qXG4gICAgTWFrZSBhIGZsYXQgY29weSBvZiBhbiBvYmplY3RcbiAgICAoanVzdCBjb3B5IHByb3BlcnRpZXMpXG4gICovXG4gIGZ1bmN0aW9uIGNvcHlPYmplY3QgKG8pIHtcbiAgICB2YXIgYyA9IHt9XG4gICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgIGNba2V5XSA9IG9ba2V5XVxuICAgIH1cbiAgICByZXR1cm4gY1xuICB9XG4gIFkudXRpbHMuY29weU9iamVjdCA9IGNvcHlPYmplY3RcblxuICAvKlxuICAgIENvcHkgYW4gb3BlcmF0aW9uLCBzbyB0aGF0IGl0IGNhbiBiZSBtYW5pcHVsYXRlZC5cbiAgICBOb3RlOiBZb3UgbXVzdCBub3QgY2hhbmdlIHN1YnByb3BlcnRpZXMgKGV4Y2VwdCBvLmNvbnRlbnQpIVxuICAqL1xuICBmdW5jdGlvbiBjb3B5T3BlcmF0aW9uIChvKSB7XG4gICAgbyA9IGNvcHlPYmplY3QobylcbiAgICBpZiAoby5jb250ZW50ICE9IG51bGwpIHtcbiAgICAgIG8uY29udGVudCA9IG8uY29udGVudC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgfSlcbiAgICB9XG4gICAgcmV0dXJuIG9cbiAgfVxuXG4gIFkudXRpbHMuY29weU9wZXJhdGlvbiA9IGNvcHlPcGVyYXRpb25cblxuICAvKlxuICAgIERlZmluZXMgYSBzbWFsbGVyIHJlbGF0aW9uIG9uIElkJ3NcbiAgKi9cbiAgZnVuY3Rpb24gc21hbGxlciAoYSwgYikge1xuICAgIHJldHVybiBhWzBdIDwgYlswXSB8fCAoYVswXSA9PT0gYlswXSAmJiAoYVsxXSA8IGJbMV0gfHwgdHlwZW9mIGFbMV0gPCB0eXBlb2YgYlsxXSkpXG4gIH1cbiAgWS51dGlscy5zbWFsbGVyID0gc21hbGxlclxuXG4gIGZ1bmN0aW9uIGluRGVsZXRpb25SYW5nZSAoZGVsLCBpbnMpIHtcbiAgICByZXR1cm4gZGVsLnRhcmdldFswXSA9PT0gaW5zWzBdICYmIGRlbC50YXJnZXRbMV0gPD0gaW5zWzFdICYmIGluc1sxXSA8IGRlbC50YXJnZXRbMV0gKyAoZGVsLmxlbmd0aCB8fCAxKVxuICB9XG4gIFkudXRpbHMuaW5EZWxldGlvblJhbmdlID0gaW5EZWxldGlvblJhbmdlXG5cbiAgZnVuY3Rpb24gY29tcGFyZUlkcyAoaWQxLCBpZDIpIHtcbiAgICBpZiAoaWQxID09IG51bGwgfHwgaWQyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpZDEgPT09IGlkMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaWQxWzBdID09PSBpZDJbMF0gJiYgaWQxWzFdID09PSBpZDJbMV1cbiAgICB9XG4gIH1cbiAgWS51dGlscy5jb21wYXJlSWRzID0gY29tcGFyZUlkc1xuXG4gIGZ1bmN0aW9uIG1hdGNoZXNJZCAob3AsIGlkKSB7XG4gICAgaWYgKGlkID09IG51bGwgfHwgb3AgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlkID09PSBvcFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaWRbMF0gPT09IG9wLmlkWzBdKSB7XG4gICAgICAgIGlmIChvcC5jb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaWRbMV0gPT09IG9wLmlkWzFdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlkWzFdID49IG9wLmlkWzFdICYmIGlkWzFdIDwgb3AuaWRbMV0gKyBvcC5jb250ZW50Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFkudXRpbHMubWF0Y2hlc0lkID0gbWF0Y2hlc0lkXG5cbiAgZnVuY3Rpb24gZ2V0TGFzdElkIChvcCkge1xuICAgIGlmIChvcC5jb250ZW50ID09IG51bGwgfHwgb3AuY29udGVudC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBvcC5pZFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW29wLmlkWzBdLCBvcC5pZFsxXSArIG9wLmNvbnRlbnQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbiAgWS51dGlscy5nZXRMYXN0SWQgPSBnZXRMYXN0SWRcblxuICBmdW5jdGlvbiBjcmVhdGVFbXB0eU9wc0FycmF5IChuKSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkobilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFbaV0gPSB7XG4gICAgICAgIGlkOiBbbnVsbCwgbnVsbF1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNtYWxsTG9va3VwQnVmZmVyIChTdG9yZSkge1xuICAgIC8qXG4gICAgICBUaGlzIGJ1ZmZlciBpbXBsZW1lbnRzIGEgdmVyeSBzbWFsbCBidWZmZXIgdGhhdCB0ZW1wb3JhcmlseSBzdG9yZXMgb3BlcmF0aW9uc1xuICAgICAgYWZ0ZXIgdGhleSBhcmUgcmVhZCAvIGJlZm9yZSB0aGV5IGFyZSB3cml0dGVuLlxuICAgICAgVGhlIGJ1ZmZlciBiYXNpY2FsbHkgaW1wbGVtZW50cyBGSUZPLiBPZnRlbiByZXF1ZXN0ZWQgbG9va3VwcyB3aWxsIGJlIHJlLXF1ZXVlZCBldmVyeSB0aW1lIHRoZXkgYXJlIGxvb2tlZCB1cCAvIHdyaXR0ZW4uXG5cbiAgICAgIEl0IGNhbiBzcGVlZCB1cCBsb29rdXBzIG9uIE9wZXJhdGlvbiBTdG9yZXMgYW5kIFN0YXRlIFN0b3Jlcy4gQnV0IGl0IGRvZXMgbm90IHJlcXVpcmUgbm90YWJsZSB1c2Ugb2YgbWVtb3J5IG9yIHByb2Nlc3NpbmcgcG93ZXIuXG5cbiAgICAgIEdvb2QgZm9yIG9zIGFuZCBzcywgYm90IG5vdCBmb3IgZHMgKGJlY2F1c2UgaXQgb2Z0ZW4gdXNlcyBtZXRob2RzIHRoYXQgcmVxdWlyZSBhIGZsdXNoKVxuXG4gICAgICBJIHRyaWVkIHRvIG9wdGltaXplIHRoaXMgZm9yIHBlcmZvcm1hbmNlLCB0aGVyZWZvcmUgbm8gaGlnaGxldmVsIG9wZXJhdGlvbnMuXG4gICAgKi9cbiAgICBjbGFzcyBTbWFsbExvb2t1cEJ1ZmZlciBleHRlbmRzIFN0b3JlIHtcbiAgICAgIGNvbnN0cnVjdG9yIChhcmcxLCBhcmcyKSB7XG4gICAgICAgIC8vIHN1cGVyKC4uLmFyZ3VtZW50cykgLS0gZG8gdGhpcyB3aGVuIHRoaXMgaXMgc3VwcG9ydGVkIGJ5IHN0YWJsZSBub2RlanNcbiAgICAgICAgc3VwZXIoYXJnMSwgYXJnMilcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IGNyZWF0ZUVtcHR5T3BzQXJyYXkoNSlcbiAgICAgICAgdGhpcy5yZWFkQnVmZmVyID0gY3JlYXRlRW1wdHlPcHNBcnJheSgxMClcbiAgICAgIH1cbiAgICAgICogZmluZCAoaWQsIG5vU3VwZXJDYWxsKSB7XG4gICAgICAgIHZhciBpLCByXG4gICAgICAgIGZvciAoaSA9IHRoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHIgPSB0aGlzLnJlYWRCdWZmZXJbaV1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIHVzZSBjb21wYXJlaWRzLCBiZWNhdXNlIGlkIGlzIGFsd2F5cyBkZWZpbmVkIVxuICAgICAgICAgIGlmIChyLmlkWzFdID09PSBpZFsxXSAmJiByLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICAgICAgLy8gZm91bmQgclxuICAgICAgICAgICAgLy8gbW92ZSByIHRvIHRoZSBlbmQgb2YgcmVhZEJ1ZmZlclxuICAgICAgICAgICAgZm9yICg7IGkgPCB0aGlzLnJlYWRCdWZmZXIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlcltpXSA9IHRoaXMucmVhZEJ1ZmZlcltpICsgMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlclt0aGlzLnJlYWRCdWZmZXIubGVuZ3RoIC0gMV0gPSByXG4gICAgICAgICAgICByZXR1cm4gclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb1xuICAgICAgICBmb3IgKGkgPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgciA9IHRoaXMud3JpdGVCdWZmZXJbaV1cbiAgICAgICAgICBpZiAoci5pZFsxXSA9PT0gaWRbMV0gJiYgci5pZFswXSA9PT0gaWRbMF0pIHtcbiAgICAgICAgICAgIG8gPSByXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDAgJiYgbm9TdXBlckNhbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGRpZCBub3QgcmVhY2ggYnJlYWsgaW4gbGFzdCBsb29wXG4gICAgICAgICAgLy8gcmVhZCBpZCBhbmQgcHV0IGl0IHRvIHRoZSBlbmQgb2YgcmVhZEJ1ZmZlclxuICAgICAgICAgIG8gPSB5aWVsZCogc3VwZXIuZmluZChpZClcbiAgICAgICAgfVxuICAgICAgICBpZiAobyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlcltpXSA9IHRoaXMucmVhZEJ1ZmZlcltpICsgMV1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWFkQnVmZmVyW3RoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxXSA9IG9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb1xuICAgICAgfVxuICAgICAgKiBwdXQgKG8pIHtcbiAgICAgICAgdmFyIGlkID0gby5pZFxuICAgICAgICB2YXIgaSwgciAvLyBoZWxwZXIgdmFyaWFibGVzXG4gICAgICAgIGZvciAoaSA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICByID0gdGhpcy53cml0ZUJ1ZmZlcltpXVxuICAgICAgICAgIGlmIChyLmlkWzFdID09PSBpZFsxXSAmJiByLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICAgICAgLy8gaXMgYWxyZWFkeSBpbiBidWZmZXJcbiAgICAgICAgICAgIC8vIGZvcmdldCByLCBhbmQgbW92ZSBvIHRvIHRoZSBlbmQgb2Ygd3JpdGVCdWZmZXJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcltpXSA9IHRoaXMud3JpdGVCdWZmZXJbaSArIDFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyW3RoaXMud3JpdGVCdWZmZXIubGVuZ3RoIC0gMV0gPSBvXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAvLyBkaWQgbm90IHJlYWNoIGJyZWFrIGluIGxhc3QgbG9vcFxuICAgICAgICAgIC8vIHdyaXRlIHdyaXRlQnVmZmVyWzBdXG4gICAgICAgICAgdmFyIHdyaXRlID0gdGhpcy53cml0ZUJ1ZmZlclswXVxuICAgICAgICAgIGlmICh3cml0ZS5pZFswXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgeWllbGQqIHN1cGVyLnB1dCh3cml0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcHV0IG8gdG8gdGhlIGVuZCBvZiB3cml0ZUJ1ZmZlclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcltpXSA9IHRoaXMud3JpdGVCdWZmZXJbaSArIDFdXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXJbdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggLSAxXSA9IG9cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayByZWFkQnVmZmVyIGZvciBldmVyeSBvY2N1cmVuY2Ugb2Ygby5pZCwgb3ZlcndyaXRlIGlmIGZvdW5kXG4gICAgICAgIC8vIHdoZXRoZXIgZm91bmQgb3Igbm90LCB3ZSdsbCBhcHBlbmQgbyB0byB0aGUgcmVhZGJ1ZmZlclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWFkQnVmZmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHIgPSB0aGlzLnJlYWRCdWZmZXJbaSArIDFdXG4gICAgICAgICAgaWYgKHIuaWRbMV0gPT09IGlkWzFdICYmIHIuaWRbMF0gPT09IGlkWzBdKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRCdWZmZXJbaV0gPSBvXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZEJ1ZmZlcltpXSA9IHJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkQnVmZmVyW3RoaXMucmVhZEJ1ZmZlci5sZW5ndGggLSAxXSA9IG9cbiAgICAgIH1cbiAgICAgICogZGVsZXRlIChpZCkge1xuICAgICAgICB2YXIgaSwgclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWFkQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgciA9IHRoaXMucmVhZEJ1ZmZlcltpXVxuICAgICAgICAgIGlmIChyLmlkWzFdID09PSBpZFsxXSAmJiByLmlkWzBdID09PSBpZFswXSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkQnVmZmVyW2ldID0ge1xuICAgICAgICAgICAgICBpZDogW251bGwsIG51bGxdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgeWllbGQqIHN1cGVyLmRlbGV0ZShpZClcbiAgICAgIH1cbiAgICAgICogZmluZFdpdGhMb3dlckJvdW5kIChpZCkge1xuICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmZpbmQoaWQsIHRydWUpXG4gICAgICAgIGlmIChvICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgICByZXR1cm4geWllbGQqIHN1cGVyLmZpbmRXaXRoTG93ZXJCb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICogZmluZFdpdGhVcHBlckJvdW5kIChpZCkge1xuICAgICAgICB2YXIgbyA9IHlpZWxkKiB0aGlzLmZpbmQoaWQsIHRydWUpXG4gICAgICAgIGlmIChvICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgICByZXR1cm4geWllbGQqIHN1cGVyLmZpbmRXaXRoVXBwZXJCb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICogZmluZE5leHQgKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5mbHVzaCgpXG4gICAgICAgIHJldHVybiB5aWVsZCogc3VwZXIuZmluZE5leHQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgKiBmaW5kUHJldiAoKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmZsdXNoKClcbiAgICAgICAgcmV0dXJuIHlpZWxkKiBzdXBlci5maW5kUHJldi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgICAqIGl0ZXJhdGUgKCkge1xuICAgICAgICB5aWVsZCogdGhpcy5mbHVzaCgpXG4gICAgICAgIHlpZWxkKiBzdXBlci5pdGVyYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgICogZmx1c2ggKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgd3JpdGUgPSB0aGlzLndyaXRlQnVmZmVyW2ldXG4gICAgICAgICAgaWYgKHdyaXRlLmlkWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCogc3VwZXIucHV0KHdyaXRlKVxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcltpXSA9IHtcbiAgICAgICAgICAgICAgaWQ6IFtudWxsLCBudWxsXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU21hbGxMb29rdXBCdWZmZXJcbiAgfVxuICBZLnV0aWxzLmNyZWF0ZVNtYWxsTG9va3VwQnVmZmVyID0gY3JlYXRlU21hbGxMb29rdXBCdWZmZXJcbn1cbiIsIi8qIEBmbG93ICovXG4ndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi9Db25uZWN0b3IuanMnKShZKVxucmVxdWlyZSgnLi9EYXRhYmFzZS5qcycpKFkpXG5yZXF1aXJlKCcuL1RyYW5zYWN0aW9uLmpzJykoWSlcbnJlcXVpcmUoJy4vU3RydWN0LmpzJykoWSlcbnJlcXVpcmUoJy4vVXRpbHMuanMnKShZKVxucmVxdWlyZSgnLi9Db25uZWN0b3JzL1Rlc3QuanMnKShZKVxuXG52YXIgcmVxdWlyaW5nTW9kdWxlcyA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gWVxuWS5yZXF1aXJpbmdNb2R1bGVzID0gcmVxdWlyaW5nTW9kdWxlc1xuXG5ZLmV4dGVuZCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBZLnV0aWxzLkN1c3RvbVR5cGUpIHtcbiAgICBZW25hbWVdID0gdmFsdWUucGFyc2VBcmd1bWVudHNcbiAgfSBlbHNlIHtcbiAgICBZW25hbWVdID0gdmFsdWVcbiAgfVxuICBpZiAocmVxdWlyaW5nTW9kdWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgcmVxdWlyaW5nTW9kdWxlc1tuYW1lXS5yZXNvbHZlKClcbiAgICBkZWxldGUgcmVxdWlyaW5nTW9kdWxlc1tuYW1lXVxuICB9XG59XG5cblkucmVxdWVzdE1vZHVsZXMgPSByZXF1ZXN0TW9kdWxlc1xuZnVuY3Rpb24gcmVxdWVzdE1vZHVsZXMgKG1vZHVsZXMpIHtcbiAgLy8gZGV0ZXJtaW5lIGlmIHRoaXMgbW9kdWxlIHdhcyBjb21waWxlZCBmb3IgZXM1IG9yIGVzNiAoeS5qcyB2cy4geS5lczYpXG4gIC8vIGlmIEluc2VydC5leGVjdXRlIGlzIGEgRnVuY3Rpb24sIHRoZW4gaXQgaXNudCBhIGdlbmVyYXRvci4uXG4gIC8vIHRoZW4gbG9hZCB0aGUgZXM1KC5qcykgZmlsZXMuLlxuICB2YXIgZXh0ZW50aW9uID0gdHlwZW9mIHJlZ2VuZXJhdG9yUnVudGltZSAhPT0gJ3VuZGVmaW5lZCcgPyAnLmpzJyA6ICcuZXM2J1xuICB2YXIgcHJvbWlzZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1tpXS5zcGxpdCgnKCcpWzBdXG4gICAgdmFyIG1vZHVsZW5hbWUgPSAneS0nICsgbW9kdWxlLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoWVttb2R1bGVdID09IG51bGwpIHtcbiAgICAgIGlmIChyZXF1aXJpbmdNb2R1bGVzW21vZHVsZV0gPT0gbnVsbCkge1xuICAgICAgICAvLyBtb2R1bGUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ZICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciBpbXBvcnRlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAgICAgaW1wb3J0ZWQuc3JjID0gWS5zb3VyY2VEaXIgKyAnLycgKyBtb2R1bGVuYW1lICsgJy8nICsgbW9kdWxlbmFtZSArIGV4dGVudGlvblxuICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoaW1wb3J0ZWQpXG5cbiAgICAgICAgICBsZXQgcmVxdWlyZU1vZHVsZSA9IHt9XG4gICAgICAgICAgcmVxdWlyaW5nTW9kdWxlc1ttb2R1bGVdID0gcmVxdWlyZU1vZHVsZVxuICAgICAgICAgIHJlcXVpcmVNb2R1bGUucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXF1aXJlTW9kdWxlLnJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHJlcXVpcmVNb2R1bGUucHJvbWlzZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJ1lKUzogUGxlYXNlIGRvIG5vdCBkZXBlbmQgb24gYXV0b21hdGljIHJlcXVpcmluZyBvZiBtb2R1bGVzIGFueW1vcmUhIEV4dGVuZCBtb2R1bGVzIGFzIGZvbGxvd3MgYHJlcXVpcmUoXFwneS1tb2R1bGVuYW1lXFwnKShZKWAnKVxuICAgICAgICAgIHJlcXVpcmUobW9kdWxlbmFtZSkoWSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChyZXF1aXJpbmdNb2R1bGVzW21vZHVsZXNbaV1dLnByb21pc2UpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbn1cblxuLyogOjpcbnR5cGUgTWVtb3J5T3B0aW9ucyA9IHtcbiAgbmFtZTogJ21lbW9yeSdcbn1cbnR5cGUgSW5kZXhlZERCT3B0aW9ucyA9IHtcbiAgbmFtZTogJ2luZGV4ZWRkYicsXG4gIG5hbWVzcGFjZTogc3RyaW5nXG59XG50eXBlIERiT3B0aW9ucyA9IE1lbW9yeU9wdGlvbnMgfCBJbmRleGVkREJPcHRpb25zXG5cbnR5cGUgV2ViUlRDT3B0aW9ucyA9IHtcbiAgbmFtZTogJ3dlYnJ0YycsXG4gIHJvb206IHN0cmluZ1xufVxudHlwZSBXZWJzb2NrZXRzQ2xpZW50T3B0aW9ucyA9IHtcbiAgbmFtZTogJ3dlYnNvY2tldHMtY2xpZW50JyxcbiAgcm9vbTogc3RyaW5nXG59XG50eXBlIENvbm5lY3Rpb25PcHRpb25zID0gV2ViUlRDT3B0aW9ucyB8IFdlYnNvY2tldHNDbGllbnRPcHRpb25zXG5cbnR5cGUgWU9wdGlvbnMgPSB7XG4gIGNvbm5lY3RvcjogQ29ubmVjdGlvbk9wdGlvbnMsXG4gIGRiOiBEYk9wdGlvbnMsXG4gIHR5cGVzOiBBcnJheTxUeXBlTmFtZT4sXG4gIHNvdXJjZURpcjogc3RyaW5nLFxuICBzaGFyZToge1trZXk6IHN0cmluZ106IFR5cGVOYW1lfVxufVxuKi9cblxuZnVuY3Rpb24gWSAob3B0cy8qIDpZT3B0aW9ucyAqLykgLyogOlByb21pc2U8WUNvbmZpZz4gKi8ge1xuICBvcHRzLnR5cGVzID0gb3B0cy50eXBlcyAhPSBudWxsID8gb3B0cy50eXBlcyA6IFtdXG4gIHZhciBtb2R1bGVzID0gW29wdHMuZGIubmFtZSwgb3B0cy5jb25uZWN0b3IubmFtZV0uY29uY2F0KG9wdHMudHlwZXMpXG4gIGZvciAodmFyIG5hbWUgaW4gb3B0cy5zaGFyZSkge1xuICAgIG1vZHVsZXMucHVzaChvcHRzLnNoYXJlW25hbWVdKVxuICB9XG4gIFkuc291cmNlRGlyID0gb3B0cy5zb3VyY2VEaXJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFkucmVxdWVzdE1vZHVsZXMobW9kdWxlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRzID09IG51bGwpIHJlamVjdCgnQW4gb3B0aW9ucyBvYmplY3QgaXMgZXhwZWN0ZWQhICcpXG4gICAgICAgIGVsc2UgaWYgKG9wdHMuY29ubmVjdG9yID09IG51bGwpIHJlamVjdCgnWW91IG11c3Qgc3BlY2lmeSBhIGNvbm5lY3RvciEgKG1pc3NpbmcgY29ubmVjdG9yIHByb3BlcnR5KScpXG4gICAgICAgIGVsc2UgaWYgKG9wdHMuY29ubmVjdG9yLm5hbWUgPT0gbnVsbCkgcmVqZWN0KCdZb3UgbXVzdCBzcGVjaWZ5IGNvbm5lY3RvciBuYW1lISAobWlzc2luZyBjb25uZWN0b3IubmFtZSBwcm9wZXJ0eSknKVxuICAgICAgICBlbHNlIGlmIChvcHRzLmRiID09IG51bGwpIHJlamVjdCgnWW91IG11c3Qgc3BlY2lmeSBhIGRhdGFiYXNlISAobWlzc2luZyBkYiBwcm9wZXJ0eSknKVxuICAgICAgICBlbHNlIGlmIChvcHRzLmNvbm5lY3Rvci5uYW1lID09IG51bGwpIHJlamVjdCgnWW91IG11c3Qgc3BlY2lmeSBkYiBuYW1lISAobWlzc2luZyBkYi5uYW1lIHByb3BlcnR5KScpXG4gICAgICAgIGVsc2UgaWYgKG9wdHMuc2hhcmUgPT0gbnVsbCkgcmVqZWN0KCdZb3UgbXVzdCBzcGVjaWZ5IGEgc2V0IG9mIHNoYXJlZCB0eXBlcyEnKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgeWNvbmZpZyA9IG5ldyBZQ29uZmlnKG9wdHMpXG4gICAgICAgICAgeWNvbmZpZy5kYi53aGVuVXNlcklkU2V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHljb25maWcuaW5pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoeWNvbmZpZylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2gocmVqZWN0KVxuICAgIH0sIDApXG4gIH0pXG59XG5cbmNsYXNzIFlDb25maWcge1xuICAvKiA6OlxuICBkYjogWS5BYnN0cmFjdERhdGFiYXNlO1xuICBjb25uZWN0b3I6IFkuQWJzdHJhY3RDb25uZWN0b3I7XG4gIHNoYXJlOiB7W2tleTogc3RyaW5nXTogYW55fTtcbiAgb3B0aW9uczogT2JqZWN0O1xuICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRzXG4gICAgdGhpcy5kYiA9IG5ldyBZW29wdHMuZGIubmFtZV0odGhpcywgb3B0cy5kYilcbiAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBZW29wdHMuY29ubmVjdG9yLm5hbWVdKHRoaXMsIG9wdHMuY29ubmVjdG9yKVxuICB9XG4gIGluaXQgKGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnNcbiAgICB2YXIgc2hhcmUgPSB7fVxuICAgIHRoaXMuc2hhcmUgPSBzaGFyZVxuICAgIHRoaXMuZGIucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogcmVxdWVzdFRyYW5zYWN0aW9uICgpIHtcbiAgICAgIC8vIGNyZWF0ZSBzaGFyZWQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eW5hbWUgaW4gb3B0cy5zaGFyZSkge1xuICAgICAgICB2YXIgdHlwZUNvbnN0cnVjdG9yID0gb3B0cy5zaGFyZVtwcm9wZXJ0eW5hbWVdLnNwbGl0KCcoJylcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdHlwZUNvbnN0cnVjdG9yLnNwbGljZSgwLCAxKVxuICAgICAgICB2YXIgYXJncyA9IFtdXG4gICAgICAgIGlmICh0eXBlQ29uc3RydWN0b3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFyZ3MgPSBKU09OLnBhcnNlKCdbJyArIHR5cGVDb25zdHJ1Y3RvclswXS5zcGxpdCgnKScpWzBdICsgJ10nKVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FzIG5vdCBhYmxlIHRvIHBhcnNlIHR5cGUgZGVmaW5pdGlvbiEgKHNoYXJlLicgKyBwcm9wZXJ0eW5hbWUgKyAnKScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gWVt0eXBlTmFtZV1cbiAgICAgICAgdmFyIHR5cGVkZWYgPSB0eXBlLnR5cGVEZWZpbml0aW9uXG4gICAgICAgIHZhciBpZCA9IFsnXycsIHR5cGVkZWYuc3RydWN0ICsgJ18nICsgdHlwZU5hbWUgKyAnXycgKyBwcm9wZXJ0eW5hbWUgKyAnXycgKyB0eXBlQ29uc3RydWN0b3JdXG4gICAgICAgIHNoYXJlW3Byb3BlcnR5bmFtZV0gPSB5aWVsZCogdGhpcy5jcmVhdGVUeXBlKHR5cGUuYXBwbHkodHlwZWRlZiwgYXJncyksIGlkKVxuICAgICAgfVxuICAgICAgdGhpcy5zdG9yZS53aGVuVHJhbnNhY3Rpb25zRmluaXNoZWQoKVxuICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICB9KVxuICB9XG4gIGlzQ29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IuaXNTeW5jZWRcbiAgfVxuICBkaXNjb25uZWN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpXG4gIH1cbiAgcmVjb25uZWN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IucmVjb25uZWN0KClcbiAgfVxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0b3IuZGVzdHJveSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rvci5kZXN0cm95KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpXG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMuZGIucmVxdWVzdFRyYW5zYWN0aW9uKGZ1bmN0aW9uICogKCkge1xuICAgICAgeWllbGQqIHNlbGYuZGIuZGVzdHJveSgpXG4gICAgICBzZWxmLmNvbm5lY3RvciA9IG51bGxcbiAgICAgIHNlbGYuZGIgPSBudWxsXG4gICAgfSlcbiAgfVxufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93LlkgPSBZXG59XG4iLCIvKipcbiAqIEdpdmVuIGEgbnVtYmVyLCByZXR1cm4gYSB6ZXJvLWZpbGxlZCBzdHJpbmcuXG4gKiBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI2NzI4My9cbiAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gbnVtYmVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gemVyb0ZpbGwgKHdpZHRoLCBudW1iZXIsIHBhZCkge1xuICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG51bWJlciwgcGFkKSB7XG4gICAgICByZXR1cm4gemVyb0ZpbGwod2lkdGgsIG51bWJlciwgcGFkKVxuICAgIH1cbiAgfVxuICBpZiAocGFkID09PSB1bmRlZmluZWQpIHBhZCA9ICcwJ1xuICB3aWR0aCAtPSBudW1iZXIudG9TdHJpbmcoKS5sZW5ndGhcbiAgaWYgKHdpZHRoID4gMCkgcmV0dXJuIG5ldyBBcnJheSh3aWR0aCArICgvXFwuLy50ZXN0KG51bWJlcikgPyAyIDogMSkpLmpvaW4ocGFkKSArIG51bWJlclxuICByZXR1cm4gbnVtYmVyICsgJydcbn1cbiJdfQ==
