{"version":3,"sources":["../yjs/node_modules/browser-pack/_prelude.js","src/Memory.js","src/RedBlackTree.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"y-memory.es6","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\r\n'use strict'\r\n\r\nfunction extend (Y) {\r\n  require('./RedBlackTree.js')(Y)\r\n  class Transaction extends Y.Transaction {\r\n    constructor (store) {\r\n      super(store)\r\n      this.store = store\r\n      this.ss = store.ss\r\n      this.os = store.os\r\n      this.ds = store.ds\r\n    }\r\n  }\r\n  var Store = Y.utils.RBTree\r\n  var BufferedStore = Y.utils.createSmallLookupBuffer(Store)\r\n\r\n  class Database extends Y.AbstractDatabase {\r\n    constructor (y, opts) {\r\n      super(y, opts)\r\n      this.os = new BufferedStore()\r\n      this.ds = new Store()\r\n      this.ss = new BufferedStore()\r\n    }\r\n    logTable () {\r\n      var self = this\r\n      self.requestTransaction(function * () {\r\n        console.log('User: ', this.store.y.connector.userId, \"==============================\") // eslint-disable-line\r\n        console.log(\"State Set (SS):\", yield* this.getStateSet()) // eslint-disable-line\r\n        console.log(\"Operation Store (OS):\") // eslint-disable-line\r\n        yield* this.os.logTable() // eslint-disable-line\r\n        console.log(\"Deletion Store (DS):\") //eslint-disable-line\r\n        yield* this.ds.logTable() // eslint-disable-line\r\n        if (this.store.gc1.length > 0 || this.store.gc2.length > 0) {\r\n          console.warn('GC1|2 not empty!', this.store.gc1, this.store.gc2)\r\n        }\r\n        if (JSON.stringify(this.store.listenersById) !== '{}') {\r\n          console.warn('listenersById not empty!')\r\n        }\r\n        if (JSON.stringify(this.store.listenersByIdExecuteNow) !== '[]') {\r\n          console.warn('listenersByIdExecuteNow not empty!')\r\n        }\r\n        if (this.store.transactionInProgress) {\r\n          console.warn('Transaction still in progress!')\r\n        }\r\n      }, true)\r\n    }\r\n    transact (makeGen) {\r\n      var t = new Transaction(this)\r\n      while (makeGen !== null) {\r\n        var gen = makeGen.call(t)\r\n        var res = gen.next()\r\n        while (!res.done) {\r\n          res = gen.next(res.value)\r\n        }\r\n        makeGen = this.getNextRequest()\r\n      }\r\n    }\r\n    * destroy () {\r\n      yield* super.destroy()\r\n      delete this.os\r\n      delete this.ss\r\n      delete this.ds\r\n    }\r\n  }\r\n  Y.extend('memory', Database)\r\n}\r\n\r\nmodule.exports = extend\r\nif (typeof Y !== 'undefined') {\r\n  extend(Y)\r\n}\r\n","'use strict'\r\n\r\n/*\r\n  This file contains a not so fancy implemantion of a Red Black Tree.\r\n*/\r\nmodule.exports = function (Y) {\r\n  class N {\r\n    // A created node is always red!\r\n    constructor (val) {\r\n      this.val = val\r\n      this.color = true\r\n      this._left = null\r\n      this._right = null\r\n      this._parent = null\r\n      if (val.id === null) {\r\n        throw new Error('You must define id!')\r\n      }\r\n    }\r\n    isRed () { return this.color }\r\n    isBlack () { return !this.color }\r\n    redden () { this.color = true; return this }\r\n    blacken () { this.color = false; return this }\r\n    get grandparent () {\r\n      return this.parent.parent\r\n    }\r\n    get parent () {\r\n      return this._parent\r\n    }\r\n    get sibling () {\r\n      return (this === this.parent.left)\r\n        ? this.parent.right : this.parent.left\r\n    }\r\n    get left () {\r\n      return this._left\r\n    }\r\n    get right () {\r\n      return this._right\r\n    }\r\n    set left (n) {\r\n      if (n !== null) {\r\n        n._parent = this\r\n      }\r\n      this._left = n\r\n    }\r\n    set right (n) {\r\n      if (n !== null) {\r\n        n._parent = this\r\n      }\r\n      this._right = n\r\n    }\r\n    rotateLeft (tree) {\r\n      var parent = this.parent\r\n      var newParent = this.right\r\n      var newRight = this.right.left\r\n      newParent.left = this\r\n      this.right = newRight\r\n      if (parent === null) {\r\n        tree.root = newParent\r\n        newParent._parent = null\r\n      } else if (parent.left === this) {\r\n        parent.left = newParent\r\n      } else if (parent.right === this) {\r\n        parent.right = newParent\r\n      } else {\r\n        throw new Error('The elements are wrongly connected!')\r\n      }\r\n    }\r\n    next () {\r\n      if (this.right !== null) {\r\n        // search the most left node in the right tree\r\n        var o = this.right\r\n        while (o.left !== null) {\r\n          o = o.left\r\n        }\r\n        return o\r\n      } else {\r\n        var p = this\r\n        while (p.parent !== null && p !== p.parent.left) {\r\n          p = p.parent\r\n        }\r\n        return p.parent\r\n      }\r\n    }\r\n    prev () {\r\n      if (this.left !== null) {\r\n        // search the most right node in the left tree\r\n        var o = this.left\r\n        while (o.right !== null) {\r\n          o = o.right\r\n        }\r\n        return o\r\n      } else {\r\n        var p = this\r\n        while (p.parent !== null && p !== p.parent.right) {\r\n          p = p.parent\r\n        }\r\n        return p.parent\r\n      }\r\n    }\r\n    rotateRight (tree) {\r\n      var parent = this.parent\r\n      var newParent = this.left\r\n      var newLeft = this.left.right\r\n      newParent.right = this\r\n      this.left = newLeft\r\n      if (parent === null) {\r\n        tree.root = newParent\r\n        newParent._parent = null\r\n      } else if (parent.left === this) {\r\n        parent.left = newParent\r\n      } else if (parent.right === this) {\r\n        parent.right = newParent\r\n      } else {\r\n        throw new Error('The elements are wrongly connected!')\r\n      }\r\n    }\r\n    getUncle () {\r\n      // we can assume that grandparent exists when this is called!\r\n      if (this.parent === this.parent.parent.left) {\r\n        return this.parent.parent.right\r\n      } else {\r\n        return this.parent.parent.left\r\n      }\r\n    }\r\n  }\r\n\r\n  class RBTree {\r\n    constructor () {\r\n      this.root = null\r\n      this.length = 0\r\n    }\r\n    * findNext (id) {\r\n      return yield* this.findWithLowerBound([id[0], id[1] + 1])\r\n    }\r\n    * findPrev (id) {\r\n      return yield* this.findWithUpperBound([id[0], id[1] - 1])\r\n    }\r\n    findNodeWithLowerBound (from) {\r\n      if (from === void 0) {\r\n        throw new Error('You must define from!')\r\n      }\r\n      var o = this.root\r\n      if (o === null) {\r\n        return null\r\n      } else {\r\n        while (true) {\r\n          if ((from === null || Y.utils.smaller(from, o.val.id)) && o.left !== null) {\r\n            // o is included in the bound\r\n            // try to find an element that is closer to the bound\r\n            o = o.left\r\n          } else if (from !== null && Y.utils.smaller(o.val.id, from)) {\r\n            // o is not within the bound, maybe one of the right elements is..\r\n            if (o.right !== null) {\r\n              o = o.right\r\n            } else {\r\n              // there is no right element. Search for the next bigger element,\r\n              // this should be within the bounds\r\n              return o.next()\r\n            }\r\n          } else {\r\n            return o\r\n          }\r\n        }\r\n      }\r\n    }\r\n    findNodeWithUpperBound (to) {\r\n      if (to === void 0) {\r\n        throw new Error('You must define from!')\r\n      }\r\n      var o = this.root\r\n      if (o === null) {\r\n        return null\r\n      } else {\r\n        while (true) {\r\n          if ((to === null || Y.utils.smaller(o.val.id, to)) && o.right !== null) {\r\n            // o is included in the bound\r\n            // try to find an element that is closer to the bound\r\n            o = o.right\r\n          } else if (to !== null && Y.utils.smaller(to, o.val.id)) {\r\n            // o is not within the bound, maybe one of the left elements is..\r\n            if (o.left !== null) {\r\n              o = o.left\r\n            } else {\r\n              // there is no left element. Search for the prev smaller element,\r\n              // this should be within the bounds\r\n              return o.prev()\r\n            }\r\n          } else {\r\n            return o\r\n          }\r\n        }\r\n      }\r\n    }\r\n    findSmallestNode () {\r\n      var o = this.root\r\n      while (o != null && o.left != null) {\r\n        o = o.left\r\n      }\r\n      return o\r\n    }\r\n    * findWithLowerBound (from) {\r\n      var n = this.findNodeWithLowerBound(from)\r\n      return n == null ? null : n.val\r\n    }\r\n    * findWithUpperBound (to) {\r\n      var n = this.findNodeWithUpperBound(to)\r\n      return n == null ? null : n.val\r\n    }\r\n    * iterate (t, from, to, f) {\r\n      var o\r\n      if (from === null) {\r\n        o = this.findSmallestNode()\r\n      } else {\r\n        o = this.findNodeWithLowerBound(from)\r\n      }\r\n      while (o !== null && (to === null || Y.utils.smaller(o.val.id, to) || Y.utils.compareIds(o.val.id, to))) {\r\n        yield* f.call(t, o.val)\r\n        o = o.next()\r\n      }\r\n      return true\r\n    }\r\n    * logTable (from, to, filter) {\r\n      if (filter == null) {\r\n        filter = function () {\r\n          return true\r\n        }\r\n      }\r\n      if (from == null) { from = null }\r\n      if (to == null) { to = null }\r\n      var os = []\r\n      yield* this.iterate(this, from, to, function * (o) {\r\n        if (filter(o)) {\r\n          var o_ = {}\r\n          for (var key in o) {\r\n            if (typeof o[key] === 'object') {\r\n              o_[key] = JSON.stringify(o[key])\r\n            } else {\r\n              o_[key] = o[key]\r\n            }\r\n          }\r\n          os.push(o_)\r\n        }\r\n      })\r\n      if (console.table != null) {\r\n        console.table(os)\r\n      }\r\n    }\r\n    * find (id) {\r\n      var n\r\n      return (n = this.findNode(id)) ? n.val : null\r\n    }\r\n    findNode (id) {\r\n      if (id == null || id.constructor !== Array) {\r\n        throw new Error('Expect id to be an array!')\r\n      }\r\n      var o = this.root\r\n      if (o === null) {\r\n        return false\r\n      } else {\r\n        while (true) {\r\n          if (o === null) {\r\n            return false\r\n          }\r\n          if (Y.utils.smaller(id, o.val.id)) {\r\n            o = o.left\r\n          } else if (Y.utils.smaller(o.val.id, id)) {\r\n            o = o.right\r\n          } else {\r\n            return o\r\n          }\r\n        }\r\n      }\r\n    }\r\n    * delete (id) {\r\n      if (id == null || id.constructor !== Array) {\r\n        throw new Error('id is expected to be an Array!')\r\n      }\r\n      var d = this.findNode(id)\r\n      if (d == null) {\r\n        // throw new Error('Element does not exist!')\r\n        return\r\n      }\r\n      this.length--\r\n      if (d.left !== null && d.right !== null) {\r\n        // switch d with the greates element in the left subtree.\r\n        // o should have at most one child.\r\n        var o = d.left\r\n        // find\r\n        while (o.right !== null) {\r\n          o = o.right\r\n        }\r\n        // switch\r\n        d.val = o.val\r\n        d = o\r\n      }\r\n      // d has at most one child\r\n      // let n be the node that replaces d\r\n      var isFakeChild\r\n      var child = d.left || d.right\r\n      if (child === null) {\r\n        isFakeChild = true\r\n        child = new N({id: 0})\r\n        child.blacken()\r\n        d.right = child\r\n      } else {\r\n        isFakeChild = false\r\n      }\r\n\r\n      if (d.parent === null) {\r\n        if (!isFakeChild) {\r\n          this.root = child\r\n          child.blacken()\r\n          child._parent = null\r\n        } else {\r\n          this.root = null\r\n        }\r\n        return\r\n      } else if (d.parent.left === d) {\r\n        d.parent.left = child\r\n      } else if (d.parent.right === d) {\r\n        d.parent.right = child\r\n      } else {\r\n        throw new Error('Impossible!')\r\n      }\r\n      if (d.isBlack()) {\r\n        if (child.isRed()) {\r\n          child.blacken()\r\n        } else {\r\n          this._fixDelete(child)\r\n        }\r\n      }\r\n      this.root.blacken()\r\n      if (isFakeChild) {\r\n        if (child.parent.left === child) {\r\n          child.parent.left = null\r\n        } else if (child.parent.right === child) {\r\n          child.parent.right = null\r\n        } else {\r\n          throw new Error('Impossible #3')\r\n        }\r\n      }\r\n    }\r\n    _fixDelete (n) {\r\n      function isBlack (node) {\r\n        return node !== null ? node.isBlack() : true\r\n      }\r\n      function isRed (node) {\r\n        return node !== null ? node.isRed() : false\r\n      }\r\n      if (n.parent === null) {\r\n        // this can only be called after the first iteration of fixDelete.\r\n        return\r\n      }\r\n      // d was already replaced by the child\r\n      // d is not the root\r\n      // d and child are black\r\n      var sibling = n.sibling\r\n      if (isRed(sibling)) {\r\n        // make sibling the grandfather\r\n        n.parent.redden()\r\n        sibling.blacken()\r\n        if (n === n.parent.left) {\r\n          n.parent.rotateLeft(this)\r\n        } else if (n === n.parent.right) {\r\n          n.parent.rotateRight(this)\r\n        } else {\r\n          throw new Error('Impossible #2')\r\n        }\r\n        sibling = n.sibling\r\n      }\r\n      // parent, sibling, and children of n are black\r\n      if (n.parent.isBlack() &&\r\n        sibling.isBlack() &&\r\n        isBlack(sibling.left) &&\r\n        isBlack(sibling.right)\r\n      ) {\r\n        sibling.redden()\r\n        this._fixDelete(n.parent)\r\n      } else if (n.parent.isRed() &&\r\n        sibling.isBlack() &&\r\n        isBlack(sibling.left) &&\r\n        isBlack(sibling.right)\r\n      ) {\r\n        sibling.redden()\r\n        n.parent.blacken()\r\n      } else {\r\n        if (n === n.parent.left &&\r\n          sibling.isBlack() &&\r\n          isRed(sibling.left) &&\r\n          isBlack(sibling.right)\r\n        ) {\r\n          sibling.redden()\r\n          sibling.left.blacken()\r\n          sibling.rotateRight(this)\r\n          sibling = n.sibling\r\n        } else if (n === n.parent.right &&\r\n          sibling.isBlack() &&\r\n          isRed(sibling.right) &&\r\n          isBlack(sibling.left)\r\n        ) {\r\n          sibling.redden()\r\n          sibling.right.blacken()\r\n          sibling.rotateLeft(this)\r\n          sibling = n.sibling\r\n        }\r\n        sibling.color = n.parent.color\r\n        n.parent.blacken()\r\n        if (n === n.parent.left) {\r\n          sibling.right.blacken()\r\n          n.parent.rotateLeft(this)\r\n        } else {\r\n          sibling.left.blacken()\r\n          n.parent.rotateRight(this)\r\n        }\r\n      }\r\n    }\r\n    * put (v) {\r\n      if (v == null || v.id == null || v.id.constructor !== Array) {\r\n        throw new Error('v is expected to have an id property which is an Array!')\r\n      }\r\n      var node = new N(v)\r\n      if (this.root !== null) {\r\n        var p = this.root // p abbrev. parent\r\n        while (true) {\r\n          if (Y.utils.smaller(node.val.id, p.val.id)) {\r\n            if (p.left === null) {\r\n              p.left = node\r\n              break\r\n            } else {\r\n              p = p.left\r\n            }\r\n          } else if (Y.utils.smaller(p.val.id, node.val.id)) {\r\n            if (p.right === null) {\r\n              p.right = node\r\n              break\r\n            } else {\r\n              p = p.right\r\n            }\r\n          } else {\r\n            p.val = node.val\r\n            return p\r\n          }\r\n        }\r\n        this._fixInsert(node)\r\n      } else {\r\n        this.root = node\r\n      }\r\n      this.length++\r\n      this.root.blacken()\r\n      return node\r\n    }\r\n    _fixInsert (n) {\r\n      if (n.parent === null) {\r\n        n.blacken()\r\n        return\r\n      } else if (n.parent.isBlack()) {\r\n        return\r\n      }\r\n      var uncle = n.getUncle()\r\n      if (uncle !== null && uncle.isRed()) {\r\n        // Note: parent: red, uncle: red\r\n        n.parent.blacken()\r\n        uncle.blacken()\r\n        n.grandparent.redden()\r\n        this._fixInsert(n.grandparent)\r\n      } else {\r\n        // Note: parent: red, uncle: black or null\r\n        // Now we transform the tree in such a way that\r\n        // either of these holds:\r\n        //   1) grandparent.left.isRed\r\n        //     and grandparent.left.left.isRed\r\n        //   2) grandparent.right.isRed\r\n        //     and grandparent.right.right.isRed\r\n        if (n === n.parent.right && n.parent === n.grandparent.left) {\r\n          n.parent.rotateLeft(this)\r\n          // Since we rotated and want to use the previous\r\n          // cases, we need to set n in such a way that\r\n          // n.parent.isRed again\r\n          n = n.left\r\n        } else if (n === n.parent.left && n.parent === n.grandparent.right) {\r\n          n.parent.rotateRight(this)\r\n          // see above\r\n          n = n.right\r\n        }\r\n        // Case 1) or 2) hold from here on.\r\n        // Now traverse grandparent, make parent a black node\r\n        // on the highest level which holds two red nodes.\r\n        n.parent.blacken()\r\n        n.grandparent.redden()\r\n        if (n === n.parent.left) {\r\n          // Case 1\r\n          n.grandparent.rotateRight(this)\r\n        } else {\r\n          // Case 2\r\n          n.grandparent.rotateLeft(this)\r\n        }\r\n      }\r\n    }\r\n    * flush () {}\r\n  }\r\n\r\n  Y.utils.RBTree = RBTree\r\n}\r\n"]}